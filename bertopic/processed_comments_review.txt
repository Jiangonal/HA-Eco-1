Tests are missing. Waiting on an intents bump before the test can be added. Tests added in
This are glob pattern not regexes, so the {6} doesn't work afaik. The [0-9] appears to be fine though. May be parametrize some hostnames to make sure all regex expressions are tested. I don't understand? I mean we are not evaluating the glob patterns here anyways, so we are just passing through the strings here. It's not a bad idea though (added it)
Please reduce to one platform home-assistant-core Everything has been merged to an intermediary branch and already has been reviewed thoroughly :) Oh! Forget I said anything then :) Thanks for staying sharp Joost! Is this going in for this beta? I've a washer to test, in case! :) That is the plan yes :) Joost! Is this going in for this beta? I've a washer to test, in case! :) Thank u for the washer. I hope it works :)
I think a few of these are bugfixes that should probably be moved to separate prs I have made prel PR's for the two cases. I think the test fixes can be left in this PR. This block should be replaced by result await config entry.start reauth flow(hass) (preferably in a preliminary PR) As we have seen in weird implementations, I think this might be a breaking change for reauth flows triggered without a config entry. We may need to ensure that entry id is available. Fair point even though I think it should be mandatory to provide an entry id for both reauth and reconfigure flows. Anyhow maybe that check should go elsewhere and do some logging (deprecation) first. I agree - a deprecation is needed in the "init". But I think the check is still needed here - at least until the deprecation ends. Unfortunately yes, anyway will add it once I rebase over that's pending
This can now be moved to a constant at the top of the file. This is used only in this one place. What is the reason to move it all the way up, where it's far away from where it is actually being used? It's a general recommendation - we try to keep schemas as constants Same here, this can be converted to a constant now. Since you are now implementing reconfigure, does it make sense to still allow updating the previous entry outside of reconfigure? Single-use variable Why do we have an option for input sources (besides there was this option in YAML)? That was already here before this PR. It was added with the config flow. The reason we have it is so that users can select which input sources are present on their receiver. Doesn't the device tell us what are present? No, it does not. There is a discovery mechanism for that, but it is not implemented by older receivers, and even for newer ones it is still not supported by the library we are using. Ok.
Can we let this function return a list instead of a single item? Yes, we can. You can change it in this PR Done in PR It seems a bit unwanted to add the WebRTC specific validation here and a WebRTC specific object to hass.config. Maybe a webrtc integration, which just holds the configuration, would be more appropriate? Discussed offline, with the conclusion it's OK to add this to the core config This class is the same as RTCConfiguration . We could use that one instead

We normally only want to import from the integration package module and not from submodules. Should I change the export of the camera package? Should it be done within this PR? This import will be removed once 129032 is merged This fixture is legacy. The new way is to use the cloud fixture and set cloud prefs fixture. Did I do it in a way you meant now? Update the cloud fixture instead. We shouldn't create the cloud client in the test. That will happen when we set up the cloud integration. Set up the integration either in the test or in a fixture. The mock cloud will be set on the client by the integration when it's setup. Add the ice servers mock to the cloud fixture mock in conftest.py . If we need to set preferences we can use the set cloud prefs fixture. See other tests that use these fixtures for examples. I couldn't use set cloud prefs as I wanted because it did not get executed in the proper order, so I modified the test flow a bit and also defined Alexa and Google configs as they were needed because I could not set prefs before initialization. This should be a separate PR. Yep, it's for testing now. I was hoping someone will do it before me; if not, I will do it myself. I will also create a separate PR for hass-nabucasa .
let's make the domain music assistant Hah, I already discussed this with both Marcel and Jozef :P Working on it as we speak Not needed, it's just the name in the manifest. removed in latest commit We only allow catching bare exceptions in the config flow, we should be more specific here Please use entry.runtime data to store runtimedata Why don't we do this before forwarding the setups? You mean move the entry.runtime data call from above to after this block? Scratch that, I see what you mean Let's not do this yet Let's move reconfigure for a followup Not sure why we have this extra step, can be combined This should not be the case I personally like to inverse the if statement, to make it if user input is not None and then just have one call to async show form Only have stuff in the try block that can raise unused Looks like this is also doing reconfigure? Let's split this logic back into the user and zeroconf step Can be set outside of the constructor I personally always prefer to have this logic in the platforms instead you can use the self.player property here We can use the new notation for this Instead of showing the user an error a dev can understand, I would rather see user facing errors like "Could not add to queue" or something along those lines (they can even be translated)
Are both of these exceptions realistic? When should they occur in real life? (Maybe I will be seeing why when I am scrolling down here) The first one is for typing: so we could cast instead, but that's why its here. The second one also shouldn't happen. I think a couple years ago there were a large number of possible states for nest configurations to be in (yaml, multiple auth types, imported subscriptions, manually created subscriptions, etc) that I was probably being paranoid and wanting a clear error message. I've updated this to assume the key exists. Ah by changing this i introduced a KeyError since the code will run anyway to check the old format. Sending a PR to fix. Sent and added a test case that was missing from this PR to exercise the bug. I don't believe there is a difference Only have stuff in the try block that can raise Removing this instead, didn't meant to include this in the PR. I am not 100 sure on this, but you can pass a translation key to a selectselector. maybe we can use that to translate the create new. But I am not sure if all keys that are in the options need to be in string.json, because ideally it shows the raw strings if its not found. Not a blocker, just curious Yeah, I was thinking the same thing that it would be ideal to translate create new, but then still have it work for th other options. My assumption was that given some of the work to enforce translation keys existing, that we wouldn't want to do this. I will follow up and get a definitive answer though. is Topic a brand name or is it just a normal word, otherwise we should lowercase that word Lowercasing. idem for subscription name Lowercasing.
Is this a real value? You probably use Twitch more than me, but I know that they have tier 1, 2 and 3 right? Yes, the tier values are 1000, 2000, and 3000. I have no idea why. See check-user-subscription oh lol This was unused (and doesn't exist in the API) so I removed it in passing. But, shouldn't we show 1 2 3 here? I don't think we should change the value at all. The end user would want to get it as the API provides it, I would think. We only show the 1000, 2000, and 3000 as-is. Yes, but users don't talk to an API, users go on Twitch and have a Tier 1 sub, so they expect their tier to be 1 . If I don't have knowledge of the API, seeing myself being a tier 1000 sub just feels off Fair enough. I'll look at it. The test is incorrect, that should just stay the same This value should be what the sensor attribute ends up as though, shouldn't it? Or does it go through that part of TwitchCoordinator ? the subscription tier is now what we put into the fixtures right? The fixture data (corrected a few minutes ago) is what gets returned from the API, so it's a string there. The attribute subscription tier , which is what gets displayed to the user, would be an integer. yes, then the test should be just sensor state.attributes["subscription tier"] 1 ?
Please use the migrate function for this async migrate entry Tried that, can't make it work. I need to access the coordinator to be able to pick up the firmware version. Ooh right. Hmm. Would it be possible to create a new connection during migration? Unless... I store it as part of the config-entry , would that work? I mean, you need a few parameters to create a connection to the plugwise device right? Can't you create a new client during migration, get the info you need and close it. I think we consider things like config flow and migration to be independent from the normal workflow, as in, when you set up the config flow, we also don't store the client used to verify to use later I will try to get the required version from the device registry.sw version , that should be the simplest method. But wait (this is the moment I actually realize what we are doing here). Why don't we fetch this on runtime? Because you can change the update interval of a coordinator on runtime, why do we need to store the version in the entry? Ok, the PR has been reworked. I do like snapshots, but in this case I would rather see a test that tests if the entry is changed to what we expect. Snapshot tests are nice to fixate data objects, but they don't tell us the meaning behind the change nor what we expect it to test OK, I took inspiration from a wrong integration then Changed as requested. This change is not related to the goal of this PR and should not be in this PR for that reason. As a side-note, essentially, the title can be fully removed. We fall back to the integration title, which a user explicitly starts the addition process for. I really think this is not integration logic. The fact we pass down a timeout (which is also device depended) from Home Assistant down to the library is odd. Why not handle all of that in the library? Home Assistant connects with a device... without passing a timeout, and it gets a timeout raised when... well whenever Yes, that's how we did it before but then we're stuck with an initial timeout of 30 secs for all devices. So if a user makes a typo she he has to wait for 90 sec before she he can correct and try again. The nice thing of the HA discovery is that we can use the discovered information to set the timeout as early as possible, from within HA, to 10 sec for most of the user having non-legacy devices. That was my thinking behind this PR. There should be no reason for this to be part of the configuration data.
Please use SnapshotAssertion in diagnostic tests Done! Why do we have this? We want to test the code redacting itself right? Yup right, took from below link at my first attempt to write the test. L27L29
Hi there vingerha We do not allow integrations to configure a update interval. Instead, we provide a sane default out of the box. If a user wants a custom schedule or interval, one can use the home assistant.update entity action. .. Frenck Clear but this integration does not allow that as it always defaults to 300s, so its present status it is already not adhering. I will have a look if this can be made more in-line Correction, it works now... had not looked at it for almost 2y so either it changed or I missed things back then. If I would have known this to work then I would not have spent time on a PR :(
Why didn't we implement the water heater platform for this? HA water heater platform support only 0.5 step. But our devices only support step 1. That's why we didn't implement the water header platform. You can overwrite the precision right? L194-L201 Let us discuss about that. As we tested in HomeAssistant, frontend only supporty 0.5 step with ,- buttons. That is because water heater entity does not have 'attr target temp step'. We need 0.5 step in frontend. If I am wrong please let me know. Frontend has support but backend not ( target temp step is not implemented in WaterHeaterEntity ). Otherwise for Fahrenheit it will be step 1, for celsius 0.5. 'core' only supports 1step, but 'frontend' supports 0.5. User could get it wrong. In conclusion, WaterHeaterEntity does not work as we want. So we need this. I think we can agree with that so I close this conversation as resolved.
No other data that we send to the frontend is using the consumers casing format. We just output our data in the Python's used snake casing format and the frontend (or any other consumer) can translate it to their casing. Should we add the cache decorator since we only need to calculate this once? We need to recalculate it if the WebRTC provider changes, but we will look into it tomorrow. Nick told me we should use cache only on a class or static functions. Otherwise, self will be added to the cache and, therefore, never garbage collected. Also, we can only invalidate the whole cache, not only for one instance. I converted the function to a property so I can use under cached property as dict is the function name that we use. Why is this needed? In the WebRTC commands we didn't catch the HomeAssistantError coming from get camera from entity id since it will be handled by the common exception handler. I think we should be consistent. Can this raise HomeAssistantError? Nope good finding
Does this only support 1 room? Yes, it is the room where the thermostat is placed. Dutch screenshot from the portal: ![image](
Maybe add an enum for these strings and use that in the parameter schema with vol.Coerce ? good idea Should we make this websocket command a bit more generally useful ? Maybe we can just return all URLs for all situations as a dict? I wonder if we shouldn't just include this data in the existing network command? We can return adapters, configured adapters and the resolved URLs? I considered this but urls are handled in a different component in the frontend and it would make loading the data even more complicated no need to move this into the network helper. Let's keep it around the WS command. Is there a reason to have this as a constant list instead of a string enum?
Single-use variable
".HA RESTORE" is only here while testing, this will be removed. The idea is to expand this to also support passwords in a follow-up PR, so while this is not needed as a dict now, it makes future enhancement simpler. I'd make this a dataclass instead. Workaround to deal with the fact that the target directory will not be empty. Was included in Try to use pathlib.Path as much as possible instead of os.path and other related os module APIs. The former is higher level and often easier nicer to use. corresponding-tools Does this work? pathlib.Path.iterdir It did Generally, it's safer to try and open or read from the file and catch FileNotFoundError than checking first. The file can be removed after the check so checking doesn't completely safeguard the case that is checked. Patch a Path.read text operation instead and set a side effect FileNotFoundError . So while the .HA RESTORE file can be manually added, I dont think that is something we should document. So the documentation requirement of this feature, IMO should not be triggered until this is implemented in the UI, or a service call is added. I'd change the test parameters instead to be the return value and side effect or just the side effect, to avoid encoding logic to the parameter.
Please don't use the update entity service for this, rather let the entity naturally update, for example with either freezing and skipping time or by calling a callback function fetched from a mock Time skipping it is, thanks for the hint! Please apply this to the whole file :)
use entry.runtime data instead Thanks, addressed in the new revision. not needed if switching to runtime data Thanks, addressed in the new revision. better to do that in init instead Not sure I get that. Can I await an async call in init ? I'll look into it. Sorry, meant init .py in setup entry Got it. Addressed in the new revision. can we maybe instead try: here? This should throw some errors probably Thanks, addressed in the new revision. remove empty keys Thanks, addressed in the new revision. belongs in the lib Thanks, addressed in the new revision. is default Thanks, addressed in the new revision. can't this throw? I'd suggest to use the CONF prefixed versions from central const instead Thanks, addressed in the new revision. avoid get here Thanks, addressed in the new revision. same make sure it's removed I removed the listener in the new revision. Using properties directly instead. can we move that code to the available property Addressed in the new revision. I think I'd prefer the properties here as well for readability Addressed in the new revision. Why would it be an invalid host?
The end date should be exclusive ( calendarevent) and must be after start, so 1 day here, and below too. CalendarEvent already handles this and adds 1 day so i thought it might be unnecessary It's there just to fix input bugs, and is shared with the input handling code for creating events from the service. You can just use dt util.now() here and it will give you a local datetime in the current timezone as described here get-events But that's exactly what i need, a tz-aware datetime representation of today (starttime 0:00) for rrule to return also events for today. Is that dt util.start of local day() ? lol, that method does the exact same thing (now that I know this exists, I'd preferably use that instead) This doesn't seem quite right to me since it is potentially hiding additional upcoming events? Current the rules are this returns either the current or next upcoming CalendarEvent. I believe a simple way to implement "active after" is to iterate over the sorted event list and find the first event where the start time or end time are greater than the "now" time like here L371 (used by local calendar) I would recommend implementing this logic for the upcoming event and the event date range search once, and just make each type of event supply a sorted list of CalendarEvent and hand the rest with shared code. Having the variance between them may introduce some bugs if we don't find all the subtle differences here so its easier to just get them right once and do them the same way. (The logic can be the same whether or not its an all day event just by converting the dates to a timezone aware date when doing the range comparison) I think i still need some tweeking for the reminders calendar, I'm considering adding them in a follow-up PR It's not implementing the spec correctly. I see, you removed from the pr. There are two changes needed here i think to meet the spec described here get-events (1) the end date is exclusive. (2) This need to check if the event end date is between requested start and end dates. The events don't have enddates, so it is not necessary to check if the enddate is in between. All calendar events have an end date. I understand the habitica tasks events don't, but i'm talking about how its represented as a home assistant event. They set an end date ("start timedelta(hours 1)".) This is not implementing the get events spec correctly "The start date is the lower bound and applied to the event's end (exclusive)." I removed the reminders for now as there are still some other things i have to figure out about how they work in Habitica, the to-dos and dailies are all-day events so i think this doesn't apply to them. Will this prevent future occurrences from showing up here? As I was saying before for the other event type, a single timeline view will ensure we don't have inconsistent behavior. the future occurrences should still show up, just for the current day they should not show up after beeing completed I must admit, that was a ve
Device class restart, then you can also omit the translation key :) Great catch, I should've remembered that! Fixed now. This [is the test]( L170-L176) I was referring to in the comment on the same point in discussion r1791827763. We could potentially drop this check but it's quite handy to have a test to ensure we haven't forgotten any translations. Perhaps it could be extended to see if a unique device class is present if the translation key is not there.
I don't really like this c p from entity component::motion as I'd like to trust binary sensor maintainers' to avoid out-of-sync here, but hassfest doesn't seem to like indirection so.. You don't need this. If has entity name true and there is no related translation string found, it will fallback to the device class translations. So you can remove this and it will use the default translations We took a decision to enforce translation strings for all of our entities to avoid missing translation keys that sometimes were able to use a device class or perhaps not. There is a test for this in the test framework to ensure that they exist. But can't you also assert that a device class is set or the name is equal to None? This is now fixed with 128022. Maybe the rest of the steps could also be done in a playbook style, but I just wanted to add these necessary steps to simplify the process for whomever wants to add the next new entity :-) I think this should be event platform. Potentially, yeah. But the event platform has its issues also, so I'd rather expose this as-is (if it works) and we can discuss about deprecating it later on. I was just reading the community forums and noticed that many people were asking why there's no sensor for the motion detected, and there was a screenshot not showing the detected state. IIRC, one of the problems with events is that you won't get this either, but you must know that you are looking for a specific event. Event triggers should probably solve that issue, but it's much more work than simply exposing this binary sensor for anyone who's looking for an easy solution. I think I'll get a test device "soonish" to experiment a bit how it behaves to see what would be the best approach. If the motion sensor has a duration, binary sensor is OK. If the motion sensor is an momentary sensor than the event platform should be used. Since we are polling for this, I think binary sensor is probably what we want Honestly, this doesn't belong here at all. These are mostly generic instruction on how to use the HA devs environment, besides a fixture adjustment. Agreed, I simplified it a bit to include only the fixture edit snapshot update, I hope that's fine? The idea is to make the update process as straightforward as possible for future developers. I removed all README.md updates from this PR, so this is resolved now.
You never actually initialized hass.data[DOMAIN] afaiw, so doesn't this raise a Key error? Also, could we use HassKey for typing hass.data? I haven't seen the key error during testing, but the default should be set. Are we sure media player doesn't already guard for this? This code was taken from a different integration, the media player integration doesn't guard against this.
this is incorrect Fixed, it's just a mistake on my side this is incorrect Fixed Can you tell me a bit what this does ? Is this a new feature ? It's a fallback translation key. It will be only used when we have primary attribute on multiple endpoints (when we suffix the name by the endpoint id). It's used here diff-b6c426ab993a9279a458078576e5fa2a2a8746b1f97ee3ae583877b2fae9cb57R87-R88 the name got me a bit confused at first. I'm fine with keeping it this way but another suggestion wold be to rename this to " platform translation key" or " base platform translation key" ? I agree the current wording it not good. I renamed to platform translation key .
Please make sure the code is not longer than 88 characters. I think this message can be a bit to the point. I would maybe suggest keeping this list in a more central place rather than the light setup, since in the future you might have more devices that have their own speciality like idk, a physical switch or a binary sensor for detection. I would add the link to the place where they should report this. "We found device "x" which is not supported by the integration. Please create an issue at x" I have the same setup in switch.py as well. Should I move the supported devices list into const like so? The reason I have it like this is because some devices may support light but not switch, and vice versa, so I have it inside the platform and not in const . I think it would make sense to centralize this list yes. And I think it depends on how much devices you expect to support. If you expect 100 devices, I would go for a dict with platform as key. and then you can also create a set with all the device types that you know, since all devices that you support at least 1 platform. If you only expect to support a few devices or device lines, I would suggest doing it by model - platform There's only about 6 device types according to the app: ![image]( ![image]( Should I implement what I suggested then? Or am I misinterpreting what you're saying? That's fine, I don't have a strong preference, but I just wanted to say that I would have it depend on the amount of devices
Should viewers be plural to stay consistent with "followers"?
We should rather check if they are used in automations and scripts and raise if they are Could you please give me a hint how to do that? Would you also briefly explain to me, what's wrong about raising the issue at the moment when the entities are set up? Raising the issue should not only occur if the entities are used in automations and scripts but generally if they are used (even from the frontend)? We usually get more false positives for users and we want issues to be actionable, not a "hey, did you know that ...". In the past we deprecated the harmony switch entities, I think that's quite a clean example. (It's already removed from the codebase, but the PRs are still there) I can link when I finally booted my pc Thanks! I guess I found it here: I'll implement it in the same way. Let's not create an issue per item
Please deduplicate this, there are 16 almost identical copies of this list comprehension I want to definitely get the code complexity down of this function, but I didn't think this PR was the place to do that. Also because all the data we get is now typed, we can't just make it more generic without a lot of hassle Why is this assert here? Hide it behind TYPE CHECKING if it's a hint for mypy Don't we have better control over exceptions with the new library? We have, but I wanted to add the extra exceptions in a follow up, since they also add extra tests Please hide behind if TYPE CHECKING if this is a hint for mypy Does the new library change the times? Why does it do that? The signature of media duration is int None , and we now round to adhere to the typing Apparently it was only my IDE complaining, not mypy This is kind of stupid, why don't we make async ensure token valid return the token, then this would just be simplified to: return session.async ensure token valid() (For a different PR though) async ensure token valid already has a lock, you added it yourself joostlek in Why do we need another lock? I actually don't know lol, when I made this I did add it with a reason, but I can't remember which one it was now make a decorator which returns None if item is None and passes item to the function if it isn't, something like
Just a hint - on reconfigure, the reason must be explicitely stated. Not sure, but if this will be done over all integrations, maybe it makes sense to use self.init step or self.source as default for async update reload and abort ? Is this what you had in mind? 127756 has been merged, so the reason can be dropped (but still needs to be added to strings.json ) Yes, thank you! Will adjust this evening. Please update strings.json accordingly The data is already available in reauth flows (but not in reconfigure flows) What happens if the user changes the region or the username inside the reauth reconfigure flow? It seems to me that the entry data would no longer match the unique id... this is an example where I think the unique id helper suggested in 127565 would be useful Yes, this makes absolute sense. As the helper is not available right now, I got inspired by this PR and implemented it directly in the config flow. If this changes at some point, I'm happy to adjust. I missed this earlier: could you please in a follow-up PR avoid using raise, and drop the redundant check? Will do in the next days!
peteS-UK pan we but these default values as a const named value. entry.runtime data.options.volume step entry.options.get(CONF VOLUME STEP, 1000) - entry.runtime data.options.volume step entry.options.get(CONF VOLUME STEP, 5)? Yes, can do. These are really just if something's gone awry, since the values are defaulted and required in the configflow, but as you say, t makes sense. 1 should be an acceptable value, right?
is this an expensive operation? Can we postpone the generation? It shouldn't be too expensive, so you're right we could postpone it until an error occurs. Delayed the creation of this list until needed, and also skipping config hidden entities. We call normalize name a lot. I don't know if it's worth doing some caching ? I wonder is using this normalization function would work: L27 It ignores all whitespace, though. There are two aspects here. First is the question why it ignores whitespace in the first place. I was actually going to create a PR changing it, because it does not make much sense to me. Second is that entity registry is not a normalized name registry anyway, so we don't have normalized name available there, so it does not really help us with the caching issue. I can see ignoring whitespace in some very specific scenarios, such as "overhead light" vs. "over head light". But it should probably not be the default. Why are we comparing it to the entity id in the first place? Users should call their entities by their name, not id. This allows intent recognizers to target specific entities when there would otherwise be ambiguity. For example, I map "TV" to a specific entity id in a pipeline. Does that actually happen anywhere though? It would have to happen already at the sentences level and I don't think we have any sentences with a name slot hard-coded with an entity id . Unless I'm misunderstanding what you mean by: For example, I map "TV" to a specific entity id in a pipeline. The default intents no longer to this, you're correct (they did originally). I want to leave it in for now, though, as other intent recognizers may use it. I'm not concerned about overlap, as entity ids are very distinct from human names. A potential problem is with area floor ids, though. If you have an area named "kitchen" but it's area id is "bedroom" (for some reason), you could match the wrong one. I don't like this logic, and all the ones following it. If some unexposed entity happens to match required features, it does not mean that the problem is that it is unexposed. You would first need to establish that it has a matching name in the first place. So what you want to do instead is to have a second set of candidates, consisting only of unexposed entities and do the same operations on them as on normal candidates. If at some point normal candidates don't match and unexposed do match, then that is where you return MatchFailedReason.ASSISTANT . Thanks for the suggestion! I've reworked the logic so that unexposed candidates are kept until the very end. I'm curious what you think. I'm not sure I understand how this works. Just because you have constraint.name does not mean that this is where the matching failed. It could have failed later. Or earlier. What is the selection logic behind this code? If we're here, the match succeeded all of the other checks and failed the final exposure check (with the reworked logic). The goal is to give as much information to 
I think we should also apply this to the off state. Also, can you checkout cv.ensure list ? I think this will make sure it's always a list and thus you don't have to do instance checks on the config but you can just assume it's always a list Done For a followup PR, it would be nice if we could replace the switch , turn off and entity id with SWITCH DOMAIN , (I forgot the turn off one) and ATTR ENTITY ID we'll do..
This change does not seem to be related to the re-discovery functionality introduced by the PR? Can it please be moved to a separate PR? It is related, it was a sub class before, now it is a fixture. Moved removing the entry into the test As this is extended the TestFlow class is now a fixture
It would be better to have a base class with the common functionality and two subclasses, similar to: L80 So you would end up with - SwitcherBaseCoverEntity - SwitcherSingleCoverEntity - SwitcherDualCoverEntity The subclass will only implement changed parts It is done.. I tried to separate init as well but it did make issues.. Please submit the separate init and we will fix the issues in the PR review. It is done. You can see current issue. Update method should be moved from the base class to here as it is not common for both classes: L104-L110 It is done. If you add it to the base class it will resolve the warning It is done. Add empty method: It is done. Please move this to SwitcherSingleLightEntity class It is done. It is done. This was just an example not something you should commit (should be something like return super().is on() or ... , however looking at the final result I think it would be better to remove this from the base class and add it in the subclasses. It is done. It is done. Please look at the logic used in the cover, you don't need to translate the light for a single entity. It is done, but now the light will get the device name which is not what is shown in the Switcher App. (Just like the cover in the S11 device) Now it will be like this: Runner S11: cover.switcher runner 6cf5 (Actual name: Switcher Runner 6CF5) light.switcher runner 6cf5 light 1 (Actual name: Light 1) light.switcher runner 6cf5 light 2 (Actual name: Light 2) Runner S12: cover.switcher run plus a9be cover 1 (Actual name: Cover 1) cover.switcher run plus a9be cover 2 (Actual name: Cover 2) light.switcher run plus a9be (Actual name: Switcher Runner 6CF5) It is done. It is done. It is done. It is done. It is done.
How did device class work here again? I think they were derived with unitGetter L64-L70
Hmm, This is a strange name but I can't come up with something better here Yea, was also not overly joyed about it, but could not think of a better name. Please use the fixture to enable entities by default instead I did not know there was a fixture for this. Very nice, thanks!

If its possible to have multiple entities added here we should call async add entities only once since it creates a task under the hood and we only want one task. Alternatively if its not possible we could change this to an if elif elif elif block to show its only one But maybe we keep it Cct because RGB is Rgb The class name is RpcShellyCctLight , I think you're looking at an older commit. I was thinking CCT should be caps but Rgb isn t so at least it s consistent I used Rgb for since to make it more readable ( RgbLight ), I don't mind we align all if you think CCT RGB is better The re could be pre-compiled as a constant instead of compiling every loop since it never changes I think this only needs to be an Iterable , than you can avoid making copies You could likely avoid the keys call as well
We're not allowed to access another integration's hass.data items directly. We can use this helper to get all platforms of the template integration: L1063-L1066 The EntityPlatform has a dict with all its entities in the entities attribute. Combine these two conditions with and . I can't use and since apparently the walrus does not make the assigned variable available right away in the same expression, but I have combined them in a single if It works by using a parenthesis. But the current way works too. I know this is crap, but I need to figure out how to avoid vol messing up a custom class dict Actually, I've refactored so that these are no longer needed, but forgot to remove them. I'll do so in a following commit. This line is not covered with tests as the RELOAD handler is [locally defined]( L84) in async setup Should I take it out as a separate method and patch it to test this as well? Since the reload helper should be tested separately, I think it's enough to test that this callback calls the service. We can do that by mocking the service with that test helper, using the same service domain and name. L346-L355 Thank you! As it stands, you can't use Jinja templates in triggers. It would be great to be able to do so, but i think that would mean moving the logic for registering triggers much later. Is that OK? Here's an example: trigger variables might be needed, but the question is when should they be evaluated? Is it safe to do so at config validation? Or should the trigger registration be postponed to much later, when it's safe to evaluate trigger variables as regular tempaltes? This isn't specific to blueprints, right? If it's not specific to blueprints I suggest discussing it separately in a new architecture discussion. I'd say that template blueprints expose the missing feature. In automations, you can use trigger variables specifically for allowing the templating of entity id in blueprints, which had not existed for templates until now. The second variant is setting variables that are available when attaching a trigger when the trigger can contain templated values. These are defined using the trigger variables key at an automation level. These variables can only contain [limited templates]( limited-templates). The triggers will not re-apply if the value of the template changes. Trigger variables are a feature meant to support using blueprint inputs in triggers. ([source]( trigger-variables)) I'm a but stumped about what to do here. If you think this discussion is outside the scope of this feature, I'll start a new architecture discussion, but again... template blueprints uncovered this issue, so i'd say it's related. I don't think it's related since it's about triggers and not blueprints. We don't need to solve all problems at once. Roger that. I'll leave the PR as it is. Maybe call it reference entity since that's what we call it in the description? Or update the description to say original entity? Maybe define the function in this modu
Shouldn't this be UnitOfConcentration? Yes - but I forgot to push my commit !!! Good morning! Yes - but I forgot to push my commit !!! It's there now: ff2ccd90fcd75c04ddc80589c5650d73110347bf Note: I've used UnitOfVolumeConcentration The consensus from the core team meeting was not to make it concentration by as suggested in the architecture issue: glucose. But they are units of concentration. Which means we can't create a concentration device class because molecular weight, but we can have a glucose device class using units of concentration But they are units of concentration. Which means we can't create a concentration device class because molecular weight, but we can have a glucose device class using units of concentration My thinking too... - Have all concentration units as UnitOfConcentration - Have a device class for BLOOD SUGAR LEVEL which only allows two units from the enum - Have a unit converter for BloodSugarLevelConverter which only allows those two units But they are units of concentration. Which means we can't create a concentration device class because molecular weight, but we can have a glucose device class using units of concentration You where in that meeting and was in that process. This exact idea suggestion was raised and decided against. I am ok with you raising this again, however, in that case I will revert the decision so we can re-evaluate that it the next core architecture meeting. A PR is not the place to have this discussion. .. Frenck But they are units of concentration. Which means we can't create a concentration device class because molecular weight, but we can have a glucose device class using units of concentration My thinking too... - Have all concentration units as UnitOfConcentration - Have a device class for BLOOD SUGAR LEVEL which only allows two units from the enum - Have a unit converter for BloodSugarLevelConverter which only allows those two units That is not what your architecture proposal described. Do you want to revisit the proposal? Have a device class for BLOOD SUGAR LEVEL which only allows two units from the enum This very specific case has been discussed a few times. Most recently with the addition of the calories unit added to energy. We think such limitations are unneeded. If we can provide conversation between certain units, we are fine with giving the user the ability to select it. For example, a user can (as of 2024.10.0) set energy sensor that measures their home energy meter, to calories. I won't recommend it... but .. Frenck Added a comment on discussioncomment-10771739
This seems an unrelated change to what is being described in this PR? frenck User feedback: hope this time interval is shorter I will make a note in the description Let's do this in a separate PR. I have a hard time believing that this is not possible without service call. My suspicion would be that the machine they are running this on is doing too much at the same time and can't keep up with the 5 seconds. Because 5 seconds is very very low for HA standards Let's do this in a separate PR. I have a hard time believing that this is not possible without service call. My suspicion would be that the machine they are running this on is doing too much at the same time and can't keep up with the 5 seconds. Because 5 seconds is very very low for HA standards Ok, I'll delete it. Our device supports 5-second requests (the app also requests devices at 5-second intervals) Users have previously reported this situation. In the case of 5 seconds, I verified with my own computer that HA can work normally. Thanks! Let's do this in a separate PR. I have a hard time believing that this is not possible without service call. My suspicion would be that the machine they are running this on is doing too much at the same time and can't keep up with the 5 seconds. Because 5 seconds is very very low for HA standards Can I submit a separate PR for this modification point You're always free to open a PR, but I think that 5 seconds is very very low and not useful for the majority of users I am now looking at this, and this list is exactly the same as the em06 one. I'd rather see that deduplicated
I'd suggest to, in an initial PR, add [event entities]( where each button is one event entity which can fire different events. I'm not sure if device triggers are needed as well, maybe not? Also, should the beo remotes be their own devices? I guess I could add the Beoremote One as a device, I'll take a look at that. I didn't even know event Entities were a thing, so I'll take a look at that as well. I'll convert this PR to a draft for now. OK, I've pushed an initial commit containing event entities for the physical buttons as well as Beoremote One keys and a device for the Beoremote One. There are 10 Event entities for the physical buttons and 58 for Beoremote One keys. This seems to be a bit excessive, but still seems to be a better way to handle events. What are your thoughts? I agree it's not great. Maybe to add tens of entities which are not very likely to be used. Maybe make the event entities disabled, then users who want to use them can enable them? Yeah that sounds reasonable. It seems there is no reason to support device triggers at this point, so I'll just close this PR and open some new ones. If you decide to still support device triggers, I'd suggest to have one type for each kind of keypress, and a subtype for each button. That should avoid overwhelming the user with a huge list of triggers. Example: L43-L75
I think it would be nice if we wrap the lambdas in parenthesis because now the second part is on the same level as the rest of the properties Can we use icon translations? sure - feel free to propose some nice icons Does this mean that the battery is low? In that case you can omit the translation key and it will fallback to using the device class name and translation Well, yes, but this is separate from the battery sensor - so I think they mean the (9v) backup battery here that is often found in a smoke sensor. With other words: We need the it to be named "Battery Alert" or "Batter Low Alert". The device also has a battery sensor attached on the powersource cluster (in case of a battery powered device): ![Scherm afbeelding 2024-09-24 om 14 47 40]( The power source cluster is not mandatory for smoke sensor, that is why we put battery alert attribute in smoke cluster as well. User must replace a new batter once the battery alert is set. Both of Heiman smoke sensor and CO sensor are supported power source cluster and the batter alert attribute in Smoke cluster. Let's translate these values any reason we explicitly set it to None? no, leftover I guess Whats the granularity of the data? Because we also have timestamp. (not that it makes that big of a difference, but maybe if we also take the time into account, we better line up with a manufacturer for example sending a push notification that it expired) its seconds since epoch so this may also be a datetime from my perspective Is this smoke or CO? because I think we have a device class for CO typo
What's the reason we don't add host logs follow here? thanks, I think I missed it when copied from admin paths And here? Please use snake case variable names.
Was the changed text from PR 120858 lost in rebase? Probably, I'll fix this. The full error message from the automation is something like: Got error 'Expected HH:MM, HH:MM:SS or Entity ID with domain 'input datetime' or 'sensor'' when setting up triggers for automation I think the exception text needs to mention it's a time trigger's "at" template that rendered to a value we could not understand?
Can be a normal callback
I would like to be able to pass arguments for a command, but AFAICT send command doesn't support this. Any ideas? For example, when sending DisplayMessage which accepts the Header and Text arguments. The only thing that comes to mind is encoding the data in the command string, but that's not ideal. You can use action calls for these kind of calls Yeah, I wanted to use the provided remote command actions if at all possible but if not, likely need to create a "send general command" action. We don't like these as these don't provide context. (That's also why remote is a bit meh, but it works). So we would rather see a display message action than a general catch all. With the specific services you can ask more contextual questions and parameters, increasing the user experience Sure, I was mostly just going with what I know (I use the Apple TV remote entity frequently). But if there's no way to send context to remote commands, then I agree that actions would be better. I'll add actions for the commands that take arguments. I'm not super familiar with how HA handles actions, is this the right approach (f3b325238ff731ec10ee915034b6f76a26d43be8)? If so, I'll add the rest of the commands with arguments as actions. ![image]( Where is the unique id set? In the JellyfinEntity base class, to {server id}- {session id} : L27 Can you elaborate what this entity does? As in, afaik a remote is usually a physical device, and Jellyfin is software, so is the remote virtual or did they introduce a new feature? Correct, this is a virtual remote for sending commands to clients. Does the linked doc PR clarify this? If not, let me know if there's anything there that can be improved. I'm implementing this as someone that's fairly familiar with Jellyfin so I might leave out information that I assume everyone knows (but doesn't). How many remotes can a server have? Or does this create a remote for every client? Correct, one per client. Do we already have a device per client? Yes, this uses the same logic as the media player entity for that. Would it make sense to maybe do a step backwards first and create a new base enttiy for the JellyfinClient? because now the base entity is for the server and we overwrite practically everything to make it a client entity. WDYT? I was considering that, I just went with minimal changes to other areas for the initial implementation. But I agree, I'll add that. We can introduce it in a preliminary PR I think it's simple enough to include here, see 5018ebef3ce5b6820e9fe1191c03e1cfa6af0184. I did only just now learn that remote.send command has more properties, but does every integration have to implement it themselves? You're referring to the ATTR NUM REPEATS and ATTR DELAY SECS , right? My understanding is yes. I skimmed the code seeing how other remote integrations (Apple TV, Android TV, etc.) implement it and it all seems to be via this approach. So when can this be None ? We always get session data from the constructor right? Good question,
Can you also add off grid unintentional, as I've had a user report it's also a valid state. Fixed in [a682d25]( True is the default value so you can just remove this line. Fixed in [a682d25]( Just a question, but shouldn t that be for island status? Yep, in my rush I did it on the wrong line. Good catch. Fixed in [8ef08a5]( From the name it sounds like it should be a binary sensor e.g. status is True or False ? Yeah, it does certainly looks binary L16 JEMcats how about you remove it from this PR, as I am going to drop it in Teslemetry and Tessie at the same time in I have removed the Storm Watch active sensor. [6eb19f6]( Missing translations are probably causing this to result in an update of the snapshot files Same here Should this really be translated same as the one above? I don't think it should be, I'd suggest adding the intentional unintentional aspect to the translation. are you talking about off grid and off grid unintentional? If the key name contains unintentional I guess it would be logic to add that as a word to the translation. Resolved [d492c28]( I storm mode active still in this PR? It was going to be a binary right? If its not in this PR you need to remove it from strings.json
duplicate statement Not sure if I like github links as manufacturer Tricky bit is that Squeezelite is a software only player and that's the only home page there is for it. It's also the most common software player by far nowadays in the squeezelite ecosystem, so listing something makes sense. It's the link which is referenced on the Lyrion home pages. Or, we could use the Lyrion page which links to it - if that's preferable? I think we should set it to the manufacturer, as in, whenever I see a manufacturer of a device, I see the manufacturer or the developer, not an URL OK - so you're suggesting we should just have Ralph Irving as the manufacturer then? If so, that's fine to change as well. I think that's fine and have made that change. Set to None if not set OK - was just trying to avoid "undefined" in the device list which is a bit messy. Is your preference "Undefined" then rather than just a blank? I think None is the default? returning None leaves the manufacturer as unknown . I've changed it to None - number of unknown devices is going to be very small anyway. Be beware that device infoes don't overwrite. So try to readd the integration and check again Yes, deleted and re-added. None returns unknown , but that's OK - that'll only be a very small number of devices (Squeezebox, Squeezelite, Squeezeplay will cover the vast majority). This one can be merged with the other one Merged FYI, this says Squeezelite while we check for SqueezeLite , what should it be? Yes - SqueezeLite is correct. Test didn't seem to change, but have updated.
What entity did we got you to revert in teslemetry or tessie that wasn't a lock? Speed Limit. I made sure not to sneak it in here.
You could also consider adding a listener to the coordinator and check for this at runtime instead of at reload. I have something similar in airgradient where I check if the communication method is updated and if it's cloud , it deletes all control entities I could do it at runtime, however I don't think its a setting that is going to change that frequently. At least it seems unlikely that a user would be switching back and forth between coordinator and router modes often. on second thoughts, having the entity created dynamically at runtime will make more sense, once we add the ability to switch Zigbee radio modes from within HA. I have implemented this now. We should not have if statements in test code ok, I guess for now will run all button tests as router, since it has all buttons available. Might change in the future though if other conditional buttons get added.
It is done. Move this to shorthand attribute. self. attr name ... It is done. Let's add a translation key and use translation placeholders to add the light id. We should however add a space in between the light and the id I guess this can be resolved now :) This test can be removed by parametrizing the test light test: It is done.

switched order makes this slightly more readable Those can be combined to a single if . Do we need explicit check for self. attr fan modes ? I think if it was None , self. device.current fan speed would also be None so this check would never be reached. yes, but mypy doesn't know it and complains about it. Is it fine to leave mypy warnings? Then just leave it in for type safety, that's fine. We can't ignore mypy warnings as it would not pass CI, but we can either add a check or add type: ignore[...] Have not seen this in UI yet, but should there be a space between the value and the -sign? img width "182" alt "Screenshot 2024-09-22 at 8 54 04" src "" Looks good to me without the space. If you want to go the CONF FAN PERCENTAGES MODES route, I think it should be vol.exclusive with CONF FAN MAX STEP . prevent empty lists this could be unindented. If you want to add the space before int(fan mode.split()[0]) could be used (imho slightly better readable). It would be possible to receive a value from bus, that isn't configured as fan mode. So eg. fan modes are [33, 66, 100] and some other device sets the fan to 50 we would have a mode that isn't available in fan modes . Is this valid? If not, we could coerce it to the next mode by doing something like I think you want the last value here, no? anyway, I fixed the code to find the closest and added a test for that. Nice idea One suggestion though: I'd remove 0 from self. fan modes percentages in the fan modes property. That way if modes are [0, 33, 66, 100] and the controller returns 15 (or lower 0), it would show FAN LOW instead of FAN OFF and the user would have the ability to turn the fan off completely as the OFF item wouln't already be preselected. - discussion r1770825256 Another way would be to not have the 0 item in self. fan modes percentages and handle FAN OFF explicitly in async set fan mode(self, fan mode: str) . However you prefer. removing zero makes sense, because the other use of fan modes percentages, also omit the first element. Would have to add 1 when apply to the mode index. actually, missing around with the index is confusing, I would go what you suggested above. Fixed, I also added a test for the case. Looking at other integrations, it seems common to use a dict for that lookup and an inverted dict for the reverse-lookup instead of using lists with index. But for plain percent (no low-quiet-mode etc.) I guess index is fine. Import FAN OFF and FAN AUTO from the climate component (alternatively move this enum to knx.climate). We can then replace climate.py with In the schema this could even be used like StrEnum should be preferred over plain Enum in HA integrations. Those plain Enums we have are more or less pre-py-3.11 leftovers (although HA had a StrEnum backport before). fixed
Please wrap the multiline lambdas to make them stand out from the rest of the parameters we should collect all entities and add them once. Also, would it be logical to create logic to compare the state of the user on runtime? We could register a listener at the coordinator and check the class of the user and compare that with the class we added entities for, and if they differ delete the entities for that other class. This would also enable us to auto add on reaching level 10. Not a blocker, but maybe a nice way to give the intergation that extra Would love to do that but don't know how, you surely know an integration to get some inspiration from airgradient You can only have 1 setup at a time right? ? You only have one class right? yes, checking for the players class and selection which skills get loaded happens in the callback But why do we create the full list then? Can't we compare against the chosen class and store for what entities the class has been added? Isn't this the default implementation? Also, everything starts with ASSETSURL, might as well move that here so you can remove that prefix Is that better now?
Extra logging Removed Stale docstring? My commit was lost in a rebase again. Personally not a fan of dispatchers anymore, as it's unclear who will be using the signal. Not sure what the official stance from core is on this. An alternative is to share a dict with events between the HTTP view and the WebSocket command. I don't agree. Searching for the signal name will immediately reveal who is involved in the signal. Why reinvent the wheel? The problem is the lack of typing on the dispatcher. The things are too loosely coupled. Ah, that's indeed a good point Can't we add the same type mechanism for that as for hass.data ? I wonder if this should be a subscription or that actually a normal call could be enough?
So what do we put in here? What's possible? It is the absolute time (ex. 00:00 23:59) The reason we didn't use 'time' entity is that we can't cancel with 'None' I am also wondering if time entities have you to deal with timezones. I think I'll discuss this with others since I don't think a text entity is a right way to display this (its too free form), you'll hear from me I am waiting for updates from you about this. :) Okay so I discussed this and we think that a text entity is a bad idea since its too free form and a time entity works better for this. But we have a question to make sure that that is the right choice: Is it able to set only one of the two entities? Or do they both need to be set? It is able to set only one. I have a question. Do we have a way to set None to time entity? Or if there is a any new recommendation to cancel the timer, please let me know. LG-ThinQ-Integration I think you can also use a sensor with device class: duration , which supports units like d , h , min , and s , or alternatively, use device class: timestamp (like [Home Connect]( L57-L68) do). LG-ThinQ-Integration I think you can also use a sensor with device class: duration , which supports units like d , h , min , and s , or alternatively, use device class: timestamp (like [Home Connect]( L57-L68) do). We use this to set the timer. But we can't set with sensor which is read-only. But we can't set with sensor which is read-only. My bad. Then the time platform is probably the best option. I think that resetting the timer in this case can only be done with a separate button . joostlek Do you agree with this idea? Then we are going to add button entity and time entity. In my guess, this would take some time and would not be included in the first release. Please let me know your suggestion. But we can't set with sensor which is read-only. My bad. Then the time platform is probably the best option. I think that resetting the timer in this case can only be done with a separate button . btw, Thank you for the suggestion.
We should not add unknown , we should return None if that's the case. That will render the entity as unknown , otherwise there are 2 unknown states to pick from and that's bad This "unknown" is for the case: - the device receives a new software version and transmits new values that are not this option list - all new values are displayed by this sensor as "unknown", showing that the Lektrico integration needs to be updated too. How should we handle this case? Thank you. it should return None instead of the string unknown I removed unknown and used None , thank you.
Since it was only 2 states I ended up [switching these]( discussion r1754085889) to the binary sensor platform in PR 125490 . It makes sense. Given that the API docs specifies that door states use an enum data type, I believe enum sensors are a better choice. Here s why: if any of these entities, which we currently assume that they have only 2 states, suddenly support an additional state (like a locked state for doors, or any new possible state), we need to ensure compatibility. This would mean deprecating the binary door sensor and introducing a new enum sensor, along with handling any collateral effects. To me the main reason to use EntityDescription data classes was to have a [unified class]( L373-L406) for the Platform to make it easier for entities to be added in the future since a developer or user would only need to add an item to the appropriate tuple instead of duplicating a class and changing its logic. Separate classes also make it similar to the current method of adding entities which, as you've probably seen in the switch entity, can make adding additional entities complicated and add more duplicate code than necessary. I understand your idea, however, I think that simplifying so much the sensor entity class results in more complicated entity descriptions that contains duplicated code. Also, this PR was about door enum entities, code quailty improvements and simplifications comes in another PR I'm preparing these days. Is this one still needed here
Not needed afaia rather make this a normal if statement. I would suggest moving that time creation to a separate function to give it extra context about what this function is doing Not needed as blocking True Can we also try covering these lines while we are at it? What do you mean? Add tests for this line. It seems to be the last line that needs coverage, so it would be nice if we could cover everything so we don't regress on it in the future as I assume that the integration will have quite some changes in the future I would move this to a function as well for the context Let's move this out of the class Do you mean to a helper file in Home Connect module? Or maybe to a more general module such homeassistant.helpers ? you can just create the function on the root level of this file
Got a blocking call error here: None is the default so you can probably remove that. Also missing unit of measurement . For native step , this is what I get back from the API for my fridge: Awesome! stepsize wasn't documented on the API docs, this is a great addition! Yeah, and the simulator doesn't return stepsize either so I don't think there would be any way to know. Aren't these in homeassistant.const ? Nope, but they are in homeassistant.components.number , maybe we can use those If we use those values, would it be okay if I use "max" and "min" in the test to ensure that if the constants' values change in the future, we'll know that we need other constants? stale docstring Why do we run this here? Do we expect it to change on runtime or is this just for the first time running? Otherwise I would suggest adding the function to async added to hass Is just for the first time running (or the following times if home assistant is not able to fetch it) What the hell has 3 wine compartments This is present in all the tests for Home Connect, among other integrations such as Azure Data Explorer, Bang Olufsen, and Tibber. uuuuugh, we can use is here since its an enum Sure! What I meant in the previous message is that we should also consider changing those in the future. (and even maybe leave the ones from this PR for that change also)
Why is every scene its own device? It doesn't need to be. Scenes are not a device in the real world, so we could skip this part. But I am interested in how they work since they are linked to a room On the automatically created dashboard it puts them into the corresponding room: img width "595" alt "image" src "" It works the same as with other entities which have device information: img width "1088" alt "image" src "" yeye, I get that, but how does Scenes work in the world of WMS It is basically just a one-off trigger of saved target states. You configure them like this: ![image]( You can add any WMS device destination there and set a desired target state. Scenes in WMS are basically the same thing as in [HA]( "A scene entity is an entity that can reproduce a wanted state for a group of entities. A scene entity can activate the scene towards a group of devices but remains stateless ..." Check. Yea I remember that Hue also has scenes, but they are coupled to the group they affect Okay, so should I remove or keep the device info? I just checked: The following integrations also provide DeviceInfo for Scene implementations: - fibaro - hue - litejet - lutron caseta - tuya I did some more research and found out the following: Fibaro links the scenes to the hub device: L51-L54 Hue actually links the scenes to the room zone device: L103-L107 Litejet links the scenes to the hub (mcp?) device: L51-L56 Lutron Caseta links the scenes to the hub (bridge) device: L41-L43 Only Tuya links the scene to its own (scene id) device: L37 L44-L50 So, we have Hue linking to rooms, 3 others linking to their hub and just Tuya creating per scene devices. Based on these findings, any suggestion on how to move forward? Rather call it something else than Pascal Case That is too similar to the new class WebControlProScene implemented here. Also, the WMS prefix with CamelCase is used for other imported constants from pywmspro . Personal preference, have the bigger objects first We had this exchange before regarding the base entity class and destinations. Since I cannot base the Scenes on the base entity class (but other device types will follow doing that, don't worry), I would like to keep the parameter order at least aligned with that: L20 We should rather have a device per area Implemented, thanks for the feedback. Model name based on Hue integration.
Please bump in a separate PR Can we refactor this to return a EntityDescription? for sure, will do I think this part should be like and the thing down below can use .replace to add the UoM and device class WDYT? will do with .replace you meant like that? entity description.native unit of measurement UnitOfEnergy.WATT HOUR dataclasses.replace you only have to parenthesize lambdas if they span more than one line will remove What will the unique id be? unique id is assembled in entity.py using device serial and entity description key. entity description key is ATTR RESETTABLE COUNTER or ATTR NON RESETTABLE COUNTER with added counter index In line 177 in sensor.py (get counter entity description) i use .format to add index i hope this is OK. Can the counter change? We want to avoid setting up and having the data point that previously represented counter 1 to be counter 2 and vice versa they cannot those counters are directly from the energy meter's registers, always in same order
Should we just fallback to the device class provided translations? That would mean the name would become battery . We already have a sensor called battery showing the state of charge in . I found that too confusing, that's why I named this type of binary sensor as battery state . I don't mind changing to the device class provided translations, but maybe it's an idea to improve the naming for these particular battery binary sensor and sensor ? But that would break stuff In that case I would like to keep the name as is
So why do we observe states? We can inline this Still relevant the host is a bad unique id since it could change. If there is nothing unique to be used, use async abort entries match They are required and have defaults, why do you still use .get() in init .py ? unused why do we store this twice? (Or three times if you could the state of the library?) I would suggest to remove the self.devices and co. Either make this return None and just update the client and read the state in the entities via self.coordinator.client . OR make a dataclass with the data you want to store in the state and replace this dict with creating that dataclass and access it typesafe via self.coordinator.data Raise UpdateFailed Still relevant Overwrite the config entry typing in the coordinator This doesn't sound like a sensor. States have a max length and this sounds like it could reach it. Either create entities for those devices and make them proper devices (via via device you can link devices to other devices so you can see it as "connected via") or make this an action call (separate PR) Not a good unique id. Rather use entry id . Please use the common translation keys here and use data description to add context Use common keys The host is a bad unique id as it can change You need to pass in data IIRC Please add a return type Please add the type of the async update data as generic type Not needed Do we have something more unique for the device other than the device name? Please wrap the lambda in parenthesis What are the possible states? Are they custom? Please run async add entities once, so extend the for loop in the async add entities to include the for device ... Please don't log in a constructor

Have you considered just creating the object in init.py and passing it to the coordinators separately hmm, no I didnt, that would be simpler for sure! Why does it extend? I think was due to type errors, but not quite right, will fix Why do you change this type? If you share a lot of logic I think creating a base coordinator is better. Withings has some of these ok I see, yes base coordinator here is cleaner. you should overwrite the coordinator which is used, just like how the entity description type is overwritten oh yes, of course..

If you have this everywhere, consider moving it to AirzoneEntity
Please use the DeviceClass.RESTART I added DeviceClass.RESTART, thank you. Please don't raise integraton here I removed it, thank you. Stale docstring I updated it, thank you. I removed translation key "reboot", thank you. I am missing the strings.json changes (and maybe icons.json if you want custom icons for htese entities) I added buttons in strings.json, thank you. I removed the reboot button from strings.json, thank you.
Is this true? Do we know what the current option is? Shouldn't it be set to None , causing the entity to show unknown? yes, good call. fixed.
Let's add the name and description to strings.json . That way they can be translated into other languages. Same These are already defined in strings.json
joostlek reviewed The class is always created right? Should we make it not nullable? My comment What if mqtt is not working, but the other cloud functions are working well temporarily? Do we have to stop other functions? If we want to keep the functions to work, we should allow None for 'mqtt client'. can a message not have a deviceId? Updated as below device id message["deviceId"]
If the source entity gets the wind speed device class this can be omitted Since same key for location exist, I want to maintain the "wind volume". Why exactly? You can just remove this one and save translations for our contributors Please revert this one Please revert the change of the references Reverted. This can be removed if the entity gets device class battery
This should not be needed if you move the entity description class and definitions above the RingNumber class which is where they should be anyway (n.b. some other ring entities still need to have this cleaned up) Oh yeah, I didn't realize that. The whole structure was copy paste from switch.py I think :thinking: Fixed in 4da13d3e28 This can be done in one step: ad988f8218 If gets merged before this PR you should drop the no updates until logic in favour of replacing exception wrap with refresh after . This is an old pattern that is not covered by tests and the refresh after is more deterministic. EDIT: Actually having now tested this with my ring devices I think you should probably wait until is merged and then pick up the refresh after because when I set the volume, the volume sensor remains on the old value until the next refresh which can be up to a minute. EDIT: has now been merged so you can pull in the changes and use refresh after . You will need to configure the mock [like in this example]( diff-b487e8bddceac9e066a21d6090120f137d32187383b9a18ae4f2a0abe0f531f1R157-R163) so that the new state will be returned after the refresh. Awesome, that's good timing that 125775 just got merged. Here are my changes: cf98410b18. I hope I didn't miss anything. FWIW, tests are passing and setting volume still seems to work. This comment is not relevant to this platform as it doesn't use the history. 096dccd9b1 We shouldn't need the null check value fn may return None , at least according to the type definitions: Since float(None) raises an exception, I think the check should stay. As above cf98410b18 As above cf98410b18 The setters take a float and do the conversion EDIT: Actually I've just realised this looks like a mistake. This should be doing await self.entity description.async setter(self. device, value) instead of getattr on the device. Yup, good catch! I noticed the same when I saw your review yesterday :) Forgot to adapt this part after refactoring. Fixed in 23deff562e This can be combined with the RingChime volume entity description above as per the sensor implementation. I have separated them because they don't have the same max. volume, at least according to the python-ring-doorbell : That being said, I think that CHIME VOL MAX is wrong. It should be 11 as well. Since happen to be the maintainer of that library, you may consider this an informal bug report :smile: It would be great if you'd submit a PR to the library as I don't have a chime myself to test with (and it'll be tiny). It might also encourage you to add more amazing features to the lib Can you also add the same icons for the other volume entities under sensor 5f6260f8ba 1df09e7b65 And please do this tweak for the other tests below. 3af64af837 1df09e7b65 A better way to do this would be to use the snapshots. See L32 for an example. To generate the snapshot run pytest tests components ring test number.py::test states --snapshot-update Prefer the constants which are here: except for A
Should we just create a new MockConfigEntry just so the test will keep working in the future, independent of what happens with the entry fixture? Done Should we use data description to give more context to the user about what this means for them? I added the data description to those two options. We only use v1 1 here right? Should we just create it here instead of using a fixture? I find it kinda strange to use a fixture for a test and directly run async update entry to modify it I removed the fixture and added a parameter to create config entry to set the version.
When a flow is aborted, we update discovery data if there's an existing ignored entry with matching unique id . We keep more than one item of discovery data to handle cases such as: - cast where a single config entry manages all Google Cast devices - integrations which support more than one kind of discovery If zeroconf is an instance attribute we don't need to pass it around to instance methods. You're right, but the zeroconf instance is passed to us by the zeroconf callback, I didn't want to change the existing pattern. I can clean it up though? Follow up is ok too. What other result types do we expect here? async finish flow is called on FlowResultType.ABOIRT and FlowResultType.CREATE ENTRY . I agree it's not clear, a separate PR could add that to the docstring of async finish flow , in FlowManager and in derived classes? Done in PR I don't completely follow how storing a single key here plays with updating many known keys with a discovery key above when finishing the flow. There will only be a single active discovery flow per device, also when the integration has multiple discovery sources for the same device. async step ignore is called when the user ignores a discovered device or service, we then store the key for the flow being ignored. Once the ignore config entry is created, the code above will make sure the discovery key is kept up to date since it may not be stable unlike the unique id. If this explanation makes sense, should I add it to the docstring? That makes sense. Please add it to the docstring. : 1: Should we trigger rediscovery also when non-ignored config entries are removed for a more consistent experience, i.e. removing any discoverable config entry will make it show up again as discovered? Sounds good. Should we use the fixture that does this instead? yeah, definitely. Tests added in the PR should use the fixture, and existing tests improved in a separate PR. Separate PR for existing tests: The reason for the MappingProxyType(dict(key)) is to avoid multiple layers of mappingproxy when updating the config entry. Maybe it would be better to use a helper function which inspects each item and only wraps mappingproxy when needed? Looks like this line is not covered
Modified The class is always created right? Should we make it not nullable? What if mqtt is not working, but the other cloud functions are working well temporarily? Do we have to stop other functions? If we want to keep the functions to work, we should allow None for 'mqtt client'. Why do we set it to this high value? I don't expect a majority running their HA for 180 days straight Changed to 1. Can we catch more specific exceptions? We only allow the config flow to catch bare Exceptions Modified idem idem idem idem This will log the stacktrace as well Can this raise? We should only have stuff in the try block that can raise Modified
Should we add a device class? This same as temperature in sensor. We don't use device class to support Fahrenheit dynamically. ex When a user change UoM in the mobile app, the cloud send the temperature to the integration with UoM. Keep it as is. But we also want to allow the users to set the UoM via HA. The device class helps with categorizing entities to what their data point means The device class converts the Celsius's min max when config's unit is Fahrenheit. But native step is not converted by config's different unit so the same issue as async set native value occurs. - climate: discussion r1765990233 We don't want to use devices class(NumberDeviceClass.TEMPERATURE) except for climate. unit of measurement? It is level value. Fan speed : 0 2 Brightness : 0 4 I might think that having this as a select entity would be more useful, but I don't think it's a blocker Because their type is range(has min max step) we want to use number entity.
Who do we have 2 Turbo? Because we have device variations, some devices use 'power' for 'Turbo' and other devices use 'turbo' for 'Turbo'. These all sound like they should be switches instead If we move them to the siwtch, 'header toggle' switch to control all together is enabled automatically. Can we disable it? Or we want to keep these here. What's header toggle? If there are more than one switch, a switch that control everything is enabled. It is a header toggle. So how is that enabled then? We choose what entities we want for what device right? Of course, we can control each. But those switches are not irrelevant. So it is quite awkward to control them with a 'header toggle' at once. We don't want that UX. I think I'm not completely understanding. These selects are now used for toggling features of a device. You're talking about a switch that can turn off everything? Where does that header toggle come from? (Where does the name come from? I'm assuming it's a toggle in a header, but nothing comes to mind when thinking of that, so if you have a screenshot of the problem, yes please) Problem ![Screenshot 20240927 155615 Home Assistant]( Our intention ![Screenshot 20240927 155559 Home Assistant]( The related front -end code is as below. L120 I also discussed this one and we came to the following conclusions: 1. A humidifier is better represented by a [humidifier entity]( 2. You can set the entity category of those entities to EntityCategory.CONFIG and it will not show up on the default dashboard 3. This is mostly a frontend thing. We should not change choices in the backend because the frontend handles it differently. Does this help? I also discussed this one and we came to the following conclusions: 1. A humidifier is better represented by a [humidifier entity]( 2. You can set the entity category of those entities to EntityCategory.CONFIG and it will not show up on the default dashboard 3. This is mostly a frontend thing. We should not change choices in the backend because the frontend handles it differently. Does this help? 1. As we tested, humidifier entity doesn't support steps, and our devices only support 5 steps. It causes errors whenever a user set humidifier target value. That's why we didn't use humidifier entity. If I am not right, please let me know. 2. If we set the 'entity category' of those entities to 'CONFIG', those entities are not added automatically when a user finishes config steps. Then I guess it could be some kind of burden to a user a little bit. Btw, I agree that this might be one of the best solutions to remove 'header toggle' In conclusion, if you don't want us to use 'select' instead of 'switch', we need to discuss your suggestion(no. 2) internally. Yep, please discuss this internally. I think it's good to know not a lot of users are using the default dashboard, so it probably won't affect that much users. Also, a new updated default dashboard is on the roadmap, so eventually it will be better (I don't think that they
This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository. changing-the-entity-model Oops, I missed those docs! Done:
Please leave the dependency bump out of this PR. There is a PR that bumps the library: Once that is merged, I'll rebase this PR and fix that last error. no device class? added Please don't duplicate the same fixture in different modules. Put it in the conftest.py module instead. Those fixtures can be accessed by the whole test package.
from homeassistant.components.button import DOMAIN as BUTTON DOMAIN done in and idem done in
I think we have a device class for this If we use the device class, we can't use the name and icons that we want. We want power on off icons, but device class provides plug on off icons. Please let me know if not. You can overwrite the icons in the icons.json. but adding a device class helps with contextualising datapoints Translation key is not used Removed
You overwrite later on line 142, so no need to set it like this Removed I think this does the same It generates ruff syntax error. 'Assignment expression target must be an identifier' 'cannot use assignment expressions with attribute [syntax]' Keep it as is The values we initialize with None can be moved outside of the constructor. The attr temperature unit can also be moved outside of the constructor attr temperature unit has to be initialized in constructor() because runtime error can be caused in super(). init (). Keep it as is. super. init () doesn't contain any references to this right? Since we haven't defined for temperature unit's property , we need this statement for initialization. Otherwise, the following error occurs. 2024-09-19 10:17:21.937 ERROR (MainThread) [homeassistant.components.climate] Error adding entity None for domain climate with platform lg thinq Traceback (most recent call last): File " usr src homeassistant homeassistant helpers entity platform.py", line 598, in async add entities await coro File " usr src homeassistant homeassistant helpers entity platform.py", line 816, in async add entity capabilities entity.capability attributes, File " usr src homeassistant homeassistant components climate init .py", line 323, in getattribute return super(). getattribute ( name) File " usr src homeassistant homeassistant components climate init .py", line 489, in capability attributes temperature unit self.temperature unit File " usr src homeassistant homeassistant components climate init .py", line 323, in getattribute return super(). getattribute ( name) File " usr local lib python3.12 functools.py", line 995, in get val self.func(instance) File " usr src homeassistant homeassistant components climate init .py", line 579, in temperature unit return self. attr temperature unit File " usr src homeassistant homeassistant components climate init .py", line 323, in getattribute return super(). getattribute ( name) File " usr src homeassistant homeassistant components climate init .py", line 323, in getattribute return super(). getattribute ( name) AttributeError: 'ThinQClimateEntity' object has no attribute ' attr temperature unit'. Did you mean: ' attr temperature unit'? Why is the step affected by the temperature unit? For example, when step is 0.5 and unit is F, it causes the calculation error. Keep it as is. Causes calculation error where? When device's step is 0.5 and HA's config's unit is Fahrenheit, then async set temperature has same output value by , - climate's button. For example 65.0 and 65.5 has same output converting to Celsius by round by step. 1. 65.0F - 18.333333333333332 - 18.5 2. 65.5F - 18.61111111111111 - 18.5 So, if it is less than 1, it needs to be corrected to 1. I think if the temperature is in the kwargs its always a float Modified. unused Removed
What other platforms will you add? You might want to move the attr name None to the media player, since the other platforms you will add probably won't have the device name as the entity name Yep, good catch. I'll be adding an update entity and a few switch button entities. the client is only used in local contexts and not transferred to another step You never abort like this I am missing the zeroconf test where we try to discover an already added device, and the zeroconf test where the device doesn't respond
We want lowercase UoMs, but I do see that the rest doesn't have this, so that would be a nice followup
Why not use a future ? It allows error and result. I assumed you wanted me to use a listener instead :smile: Kept the future Where do we test unsubscribing? Added a test

Therese changes should not be in the same PR as the esphome changes. Tests are also missing. Created a new PR for this:
No need to overwrite as it's already set in self. attr supported features Can be set outside of the constructor why would it be none? Why don't we use close valve ? I think you can also remove those Don't do this, rather just import what you need I don't think you need to add the job thing for it to work. i have to, otherwise i get this error: RuntimeError: Detected that integration 'ads' calls async write ha state from a thread other than the event loop, which may cause Home Assistant to crash or data to corrupt. For more information, see async write ha state at homeassistant components ads valve.py, line 83: self.async write ha state(). No I mean, when you close a valve, it will automatically request a state update afterwards, and that will run in update in the entity.py true. tested it, thank you!
Duck type safety Duck type safety except here we know the exact type of the event, so should already be type safe? I have applied your other suggestions, Thanks! Entirely fair! Was mainly thinking along the lines of how we may know the type of event, but not the type of event.settings itself (hence the need for the None check at all) Instead, just fetch the function the library received via the mock call arguments. This is implemented in knocki ok I see. have implemented something similar.
We should remove the if statement, so rather just put the serial numbers as parameter.I think We should remove the if statement, so rather just put the serial numbers as parameter.I think These are now removed.
you can overwrite the config entry: ConfigEntry type outside the constructor here and then you can remove this assert done. Doing this removes the need for this local type overwrite Done. You can use snapshots here Done I personally don't like the name test coordinator as it assumes an internal feature to be used. I think these are runtime tests and fit in test init Done.
It should at least be unique in the platform. That's what I was thinking of doing too, but I wasn't sure about the naming convention.
I don't quite follow why we need to look at samples here, rather than simply pass (state change, entity available, last updated time seconds) to remove labelsets ? Thank you for pointing out my confusion. The other comment helped a lot too. Could we skip based on the key in self. metrics ? It's supposed to be the metric name anyway. Yes, this makes things much better. Thanks! The comment says "all metrics" which is no longer accurate, could you please adjust it? I don't quite understand the reasons for resetting the registry and re-initializing the component here. I tried to [remove it]( and the tests were still passing. Perhaps this was necessary when new behavior was behind a configuration flag, but it's not anymore? Yes, it was some kind of leftover code. I've removed it. Thanks!
Please wrap multiline lambdas in parenthesis If we only have 2 options, shouldn't this be a binary sensor? I had as an ENUM state since the API returns an ENUM type, though since only two values are ever returned and there's a DOOR device class , making it a binary sensor makes more sense. Please use lowercase names, you can use translations to uppercase them I am missing all entity translations in strings.json Mistake on my part not checking in strings.json and icons.json So according to icons.json, these have 2 states. Let's make this an ENUM device class sensor and add the possible states in snake case in a list in options . This allows HA to know the possible values and help out with automating the state [3 states]( L47) actually, the default state is off . Also, SensorDeviceClass.ENUM is the [default]( L45) device class for this child class. What's confirmed? From the [API]( event-present-state-enumeration): Description: The event has been confirmed by the user. Basically an acknowledgement of the alert by the user. It can be done at the appliance or in the Home Connect app. I plan on making a button entity for thin in HA. For documentation purposes - Alarm off (Default): img width "323" alt "Screenshot 2024-09-11 at 9 12 57 AM" src "" Alarm State: img width "322" alt "Screenshot 2024-09-11 at 9 22 45 AM" src "" Alarm Acknowledged: img width "319" alt "Screenshot 2024-09-11 at 9 23 03 AM" src "" We should add translations for the states We should add translations for the states I think I understand now. So missing translations is why they present and confirmed state are lower case? I'll add the string translations, thanks! Yes, and we should move the placeholders to be translations themselves joostlek, I'm seeing the translations for both the icons and states in the UI, though I'm wondering if this was not according to your recommendation. I can refactor it if you see an improvement that can be made. Thank You. We should not put the full name as placeholder, rather just make this a normal translation stale docstring I would imagine that this is only for the alarm entities, and the class name now implies its for every sensor Yeah, my goal was to get a single [description]( diff-04bb25b821c929e1f88647c802d692fdb154cc832f5570590c7c2f48feecf442R83-R96) and [entity parent class]( diff-04bb25b821c929e1f88647c802d692fdb154cc832f5570590c7c2f48feecf442R360-R364) for each sensor. Though because of the current implementation that does not utilize entity descriptions , I didn't want to make any breaking changes before migrating entities over. FYI, there's another PR for that rework in the works by someone else, it's linked to this PR It would be nice if we can refactor the integration to at some point use translations like normal so we can make the intergation more accessible for non native english people But in a followup I'll have to research this, would you know of a similar integration that does translations well?
Please extend config entry typing and store the coordinator in entry.runtime data Please use cannot connect Can't we do this after we got the credentials? You are allowed to login via either username or email . I did this with the intent of blocking setup if either was the same, but didn't also grab the username from the auth response. That has been corrected. Now if you try to setup an entry using username , then another using email it should abort. I added a test for this use case as well. There's always a config entry, please overwrite the typing for this co rdinator Please remove empty fields I think we can remove this and the forward part internal user id sounds quite unique to me tbh This is how the data comes back in their auth API response. I've got no control over naming here No I mean, this sounds like a plausible unique id to use Oh, so instead of the data check, you are suggesting to use: correct? I think so, yes consider doing it like airgradient where you can autospec the mock why don't we continue the flow we already started Do you really need the RequestInfo ? Can't instantiate a ClientResponseError without it. In august tests I see ClientResponseError(None, None, status 401) Ideally parametrize this test
Have you considered just using translations as they are meant to be? They're called "translations" for a reason :P. Please add the names to strings.json Only have stuff in the try block that can raise the problem is that it will be more code and more tests if I separate the stuff that can raise and return def native value(self) - float None: """Return the state of the sensor.""" try: value self.entity description.value fn(self.coordinator.data) except AttributeError: return None if value is None: return None try: return float(value) except ValueError: return None We would need tests for all cases anyway. I am mostly wondering why we float() joostlek changed the code to this. But can't make the attributeError test work. would assume this would work: async def test current temperature attribute error( hass: HomeAssistant, mock bsblan: AsyncMock, mock config entry: MockConfigEntry, freezer: FrozenDateTimeFactory, ): """Test current temperature when an AttributeError is raised.""" await setup with selected platforms(hass, mock config entry, [Platform.SENSOR]) Set up the mock to raise an AttributeError mock bsblan.sensor.return value.current temperature AsyncMock(side effect AttributeError) Trigger an update freezer.tick(timedelta(minutes 1)) async fire time changed(hass) await hass.async block till done() Check the state state hass.states.get(ENTITY CURRENT TEMP) assert state.state STATE UNKNOWN It should be a float value? (if sensor is not working on heater the return would be '---' and this is not a float. so we should check for float value? or should I change the python lib to return none when it receives '---'? Never mind. I figured it out. This is already captured in the test sensor.ambr snapshot Let's not do this :)
Looking at the Rest API for available commands, I wonder if adding the S1, S1 Plus, K10 and K10 Pro can be done using the same code. Yes, I think so but I have only the K10 . We add them without testing? I made the change If the API says it us compatible, let us try! Can we make these snake cased names? Like quiet ? This way we can translate them properly and the values still make sense when templating Yes, it's possible. I'll make the change Ok, I made the change What can the state be? Shouldn't it be mapped to the HA vacuum states? I don't know. The state sendes by switchbot : - StandBy - Clearing - Paused - GotoChargeBase - Charging - ChargeDone - Dormant - InTrouble - InRemoteControl - InDustCollecting states So, ok, thinks for the link :-) But, can we discuss for mapping switchbot state and HA state ? - StandBy - STATE IDLE ? - Clearing - STATE CLEANING - Paused - STATE PAUSED - GotoChargeBase - STATE RETURNING - Charging - STATE DOCKED but this state indicate also the charging - ChargeDone - STATE DOCKED - Dormant - STATE IDLE ? - InTrouble - STATE ERROR - InRemoteControl - STATE CLEANING but with manual control ? - InDustCollecting - STATE DOCKED ? I don't have such device, but from what it looks like it sounds good Ok, I made the change Let's put the list outside of the class We can add these fan speeds to the translations Hum, ok, but how to do it? Maybe in const.py? Or in other file? And I suppose, same things for mapping state switchbot to HA? What's the best? - attr fan speed list: list[str] [VACUUM FAN SPEED QUIET, VACUUM FAN SPEED STANDARD, etc.] - or attr fan speed list: list[str] VACUUM FAN SPEED LIST And last question, I'm not sure how put translation. Could you give me a example or an other file with an usage, please? Thanks in advance So, I use constant for each terme "quiet", "standard", "strong" and "max" and put it in const.py file I use a dict for mapping speed to speed waiting by switchbot For translation, I don't know how do it so, I wait for your response Let's remove the comment ok, I'll do it done! Idem done! This way if there's a state not in the list, it will show up as unknown
Please bump in a separate PR Hi, the new library is necessary for Covers to work, and just making a separate PR that only bumps the lib version seems unnecessary and extra work also for the reviewers No, that's what we want to happen because then we extract what is needed for that library bump to work I'm sorry, I'm not following you on this one. What would change if I made a separate PR before that? Whatever you could do "then" to "extract what is needed for that library bump to work" wouldn't also work in this PR? I'm confused by what you are saying. Anyway, if you really want me to make a separate PR, fine by me since this is what you want to happen. Just asking to be sure, so it should go like that: 1. I create a new PR that ONLY changes the requirements (so the one line here, and the files in the requirements) 2. Draft this PR 3. Wait for the lib bump PR to be merged 4. Sync with dev 5. Open this PR Is that correct? Or do you need to do anything else before that? Yep that sounds perfect Here's the new PR: Switch the CoverEntity and the CoordinatorEntity Could you please elaborate? Why would that be the case? In our previous PR in which we had a switch we followed this order and there were no issues about that Consider a preliminary PR where you create a shared base entity Hi, what do you mean exactly? You'd like an extra abstraction that both the IottySwitch and the IottyShutter inherit from? I think that's an interesting approach, but since the guidelines on the docs are not really clear about what should and what should not be done I preferred going for the simple approach It's not something in the docs but in the code, check AirGradient for an example Looks clear enough to me based on the example you are proposing. Is it mandatory to do it before this PR? I'd rather do it afterwards, especially because with two entities it would be easier to refactor later and find the correct common denominator for the base class, otherwise if I did it starting from the current dev version I would just add a layer of abstraction that references itself only. You can do it in this PR or a separate one upfront I did it here! This looks really inefficient. can't you keep a list in the cover platform with all the known shutters and just watch out for them? Hi, it's not clear to me what you mean with keep a list in the cover platform with all the known shutters and just watch out for them Moreover, this approach is already used in the Switch entity as well, and we didn't have any problems with it. I understand there might be a bit of extra calculations going on here, but there doesn't seem to be any concern in efficiency for the size of the lists involved here Would it make sense to already transform the coordinator data to a key-value dict of all devices? It will remove the need for all these lookups The API returns a list of devices, so every time it gets called we'd need to map it into a key-value dict, which would move a bit of the computation there, but d

Isn't self.hass already set after adding? This server code should definitely be moved to a library. Socket details should be abstracted in a library. The UDP audio will be deprecated eventually, so this code will go away. Ok.
Why don't we make this an update entity? So the information provide by LMS is very simple and unstructured making it an update entity didn't really add any value so I kept it simple stupid. Can you elaborate? Sure all you get is a simple unstructured string with some embedder html that changes dependant on install type. if its not present no upgrade. Sample text:- A new version of Logitech Media Server is available (8.5.2 - 0). a href "updateinfo.html?installerFile var lib squeezeboxserver cache updates logitechmediaserver 8.5.2 amd64.deb" target "update" Click here for further information a . Yes but that doesn't answer the question why an update entity doesn't fit? pssc, you likely know this already but, you can get the latest server version from h and This of course just gives you the current version for each track and you'd have to check the currently selected track (actually not sure how to do that) and the current platform and version to know if an upgrade is required. I guess that's what the server does itself to throw up the text that you're checking (and to already have downloaded the new version in the background) and so it's likely checking the presence of the text as a flag for "upgrade required" may well be the simplest. Yes and requires a separate poll, parse and all that jazz so I have taken what we have in server status and can make an update entity work I would suggest overwriting the native value property instead Oh yeah much better Please use Sentence case Are current entities affected by this? No only some of the new entities Better idea? In that case this works Please use icon translations Should we add a suggested unit of measurement It seems to be scaling nicely Test Server has a smallish collections and Prod one is large. I get that, but knowing the duration in seconds is a bit, strange, hours seems a more logical unit Unit of measurement? What does this return? string I think I could put this int an update entity. What does this return 0 total count of players But don't we see all the players as devices? Total Players yes, Other Players no (other servers), You thinking Diagnostic? we get them for free as part of the status poll. Why do we recast? source dict is Any. Does mypy complain? yup
please use the constant fixed. Can we add more types in a follow up PR? what do you mean? if ADS TYPES, all are here except string. That doesn't makes sense (to me). :) No I mean, python typing, so adding name: str to make the code and linters know that name is of type str added them as you requested. Does it make sense to add the conversion in the place where we fetch the data instead of here? Because we know if the datatype is a date right? i moved the conversion to the async update , which is a better place for it indeed. Oh that isn't the best place as its now a polling sensor. I mean, the previous PR you used logic to make string a string, bool a bool, etc, can't we move this to there? tried it, but can't really get my head around it.... removing it for now (not the most useful types anyways. will add if i have more time.) I think there are two ways to look at this... Option 1 (as previously implemented): - in def device notification callback , keep the raw integer value - in def native value , use the SensorDeviceClass to convert the value to correct datetime - ignore the ADSTYPE Option 2 (I think this is what joostlek has in mind) - in def device notification callback , use ADSTYPE to convert to date time datetime timestamp - in def native value , return the existing datetime value from the state dict - probably need to add some checks in setup platform to confirm that DeviceClass is compatible with ADSTYPE Will try to achieve option 2 in a future PR. Now, i have a few more ADS devices to add, and would like to focus on those. Side note: I'm not sure that unit of measurement should have a default value... it's been known to cause issues in some integrations. I'm also very surprised to see a default device class being set to ENUM. Again should it not default to None? Finally, should state class be added? L362-L363 removed unit of measurement for now, to simplify things for now. Enum was there because i was testing and it just left there as is. Added State class and refactored the device class. The unit of measurement needs to be kept. It's just the default "" that needs to be removed I think. Like this: vol.Optional(CONF UNIT OF MEASUREMENT): cv.string, added back in. resolved. resolved. I wonder can this really be missing from hass.data ? I would expect that if it is not present, then setup platform is never reached. You could maybe simply replace with ads hub: ads.AdsHub hass.data[ads.DATA ADS] L136-L147 It would be good for maintenance if this change could be applied to all other platforms in a follow-up PR. Similarly it would be good for maintenance if type hints for init could be applied to all platforms in a follow-up PR.
I think we should use the library built api for command classes, ie endpoint.command classes and CommandClassInfo and build a dict from scratch, or alternatively add a to dict method to CommandClassInfo in the library. We've moved away from using .data elsewhere in the integration. Requires I think we said that the frontend wanted snake case keys, at least for is secure cause the frontend was already handling that. We need to adjust that here.
I think we should discuss the consequences of removing the default disabled here. It means that all these kinds of sensors, ie notification command class and number type, will be enabled by default. So there may now show up weird sensors that we don't label as diagnostic. AlCalzone Is there a list of all possible number type notifications to get an idea of the impact? I'd rename this function since it returns an entity description and not a boolean. I actually changed it back as it was causing a side effect. The check is now separated from the entity description This isn't great since we don't want platforms to depend on each other. The approach in Matter would solve this but that's a large refactor not for now. I don't have a better suggestion at the moment so let's keep it for now. Yeah, I was a bit in doubt about this one - we could move it into a util module In the end the check is super simple but still risky to duplicate We need to add the value id to the set of discovered value ids when the for loop is finished regardless of what happend earlier. Otherwise we'll potentially discover the value again.
Instead of adding this method to the base class, maybe there should be separate base classed for live and non-live data migrators. In isolation, its probably ok to add here but I think you do need to separate anyways to handle the retry case discussion r1783092827 migrate data is wrapped in retryable database job which never gives up. I'm not sure if this is OK here, or we should instead fail after a number of attempts? I think we should be using something like database job retry wrapper which fails after 5 attempts
Using the default translations should be sufficient as this is the only entity of the device beside humidity. ![image]( Should this be a reference instead? Can be omitted as it will then take the device class translations idem
This one can be of device class ENUM, it can then also have options provided, with the possible options. But I think it would better to transalte them to weak instead of 1 All these entities with a device class which is not enum (where the name is the same as the device class), can be removed from strings.json and icons.json, as they get their name from the device class What does this do? What does this do? What does this do? What does this do? What does this do? device class? What does this do? What does this do? What does this do? device class? What does this do? What does this do? What does this do? What does this do? what's this used for What does this do? What does this do? What does this do? What does this do? What does this do? What does this do? What does this do? What does this do? What does this do? What does this do? What does this do? What does this do? What does this do?
Can we sort this alphabetically? Can be set to attr device class instead We only use this once though This can be combined by the way Can be set outside of the constructor as it's static
Let's use snake case Is it possible to add mock data to have the diagnostics have a complete picture?

Please use Sentence case for casing {location} Removed. As you mentioned at discussion r1740516115, placeholder is not passed. Modified. We don't pass any placeholders right? No, we don't. Removed.
Mac here also needs to be redacted. Maybe it can be a dict? now i learned about the [ asdict ]( dataclasses.asdict) from dataclasses :nerd face: :bulb: Add to redacted info Also redact I think
I think this is wrong (it might be wrong above too) as it's not really testing the values passed. It's just testing that A A , when it should be testing that A expected Could we use a snapshot assertion here instead? Note: I have opened 125064 for the bad existing tests. You will probable need to rebase once that is merged. This could have been a separate bugfix PR but I think it's ok to leave it in here. We should not create services that require the user to put in JSON objects. This is too error prone imo I changed both examples in the file. Also updated the documentation.
You don't need to delete it in the end consider using the snapshot platform helper, it will fixate the data objects in .ambr files. You can then run pytest . tests components met --snapshot-update I looked into it, but felt like it was on the edge where it was better to go the individual attributes route, since the forecast isn't being tested. Maybe improving the test coverage should be part of a separate PR? But the UV index isn't part of the forecast object right, so testing that would be outside of the scope anyway Hmmmm... Actually, uv index gets included in the forecast object if it's available, so it's fair to say it's in scope. There's no tests for hourly or daily forecasts right now though, and that might be a sizable chunk that'll exercise a bunch of bits I haven't touched here. Would you rather I follow-up with another PR adding tests for the forecasts and updating to the snapshot platform or bundle those changes here as well? Sounds good

This is only added as mocked device constructs modules internally from the mapping, and the siren platform will only be initialized if the Module.Alarm is in the modules. I'm not 100 sure but this might interfere with which we'll want to cherry pick into the beta so I think we should hold off merging this until 124930 is in. If there will never be more than one we don't need siren Ah, I just copied this over from the climate platform with the assumption that we should add a suffix, but yeah, there can be only a single alarm per device, so I'll remove this. That is, if the unique ids are platform-scoped, as otherwise we might clash with some legacy ids here(?) Removed get unique id . Is already set on CoordinatedTPLinkEntity Good catch, removed! This is kinda already tested by the test states test Yeah, I think it makes no sense to do explicit testing in this case, so I'll just remove this test. Thanks for the review!
Add require admin decorator This one can be a service because it s something we want to allow users to do in their automations This should be left up to the platforms. We don't know if wake word is being listened to. I believe that we should move to make pipeline entity id and the other one properties on the entity instead of passing them around. If announce media id is provided and it is a media source URL, it should also be resolved and processed. I believe that this if-statement should be rewritten to something like:
If physical devices are involved at all, we don't label it as a service. hub seems appropriate. integration-type

Usually we would bump the library in a different PR, but in this case its likely that its going to raise KeyError as soon as you set up the sensor since the mappings are otherwise missing and its small enough to do it in the same PR.
The async setup component is not needed This tests has a few things wrong. 1. I'd rather set up a real life integration setup. So it would add sensors players and you could interact with them. 2. We should avoid using if statements in the tests as it makes it unclear what its actually testing Can you share an example of an integration that does tests they way you prefer? I'm not sure I understand "real life integration setup." Sorry, one more question - I can remove the "if" that appears in the test further below, but the "ifs" in the function mocking the pysqueezebox async browse function are necessary to make the mock function respond like the real library's async browse . Those are ok, right? I think an integration like reolink , but adding tests can be a bit more work. The idea is that you patch the library to return values what we expect. Then we let HA setup the integration using those patches and then we assume that the devices that are created are created correctly. then you can call services with those devices and check the right function are called. I am not sure what is needed for media source to work, don't have that much experience with that one, but there aren't a lot of examles of good media source tests, so that's sad. But feel free to contact me on discord :) Idealy we mock the library in a separate fixture, this way you can reuse the fixture in more tests Got it, very helpful. I'll take a look at reolink . Ok, I think this is a better implementation of the tests (we set up a SqueezeBoxEntity player instance and run everything from that, just mocking the communication with pysqueezebox as needed). Long term I plan to add tests for the other parts of the integration, but that's a separate PR. What should happen when we call this? Does this raise something? Yes, it should raise BrowseError if an item isn't found. Updated test and code.
Nautical miles is two words. Please separate them with underscore in the attribute name. you're right - 126905

- [x] yale 9843e549a505513ef1029506c2e45f93bdba8060 - [x] august e05213a03ad768ad6703eecba76bb4a6070f3b88 Not sure if this already was there or that this could be auto detected in the future Outer for loop can be added to the comprehension - [x] yale 9c6fa1649633a3a416cd93c06ecff37bbae49c40 - [x] august 60d62a64c78 I think epenet just changed all of these to entry data - [x] yale b640a31fab6 - [x] august - does not apply No abort? - [x] yale 06195fcb7077c97a0ac12fa864280be58fd5ba7a - [x] august does not apply Isn't this always the same now? Yes - [x] yale e1062a0e70b - [x] august does not apply Isn't this a base entity rather than a mixin? Outer if can be moved to comprehension Mixin already has this Didn't you remove pubnub? I can remember a PR where you migrated to websockets We have new way of notating this right? How much do users notice about this migration? Is it worth trying to split these attributes off directly so we don't have to deprecate them at some point? Looks like something for const Autouse? Not needed because blocking True Snapshots? Would the freezer work here? Snapshots? Personal ick Why dont we assert the created entry? I'm missing a test where we try to add the same account twice - [x] yale 06195fcb7077c97a0ac12fa864280be58fd5ba7a - [x] august does not apply Should we use pytest.raises? Should we assert it's not loaded anymore?
Duplicate code in the function above....not sure its enough to consolidate though Yeah I wasnt sure if I could make it less even, unless the above one just calls this new function? The naming isn't great, but I guess calling the other function would work. Probably not worth worrying about it since its a single line anyways
A switch named On doesn't sound logical to me imo. I'd rather opt for using name None (causing the switch to be seen as the main feature of the device, so in this case it would be names switch.{device name} and it would be like "turn {zone} on or off" (which sounds logical, but I think you already have a climate entity per zone)) Another option would be calling the switch something like Running, but it sounds meh. Also, climate entities support TURN OFF and TURN ON actions now. The default behaviour is that it will use HVAC mode to turn on. But maybe it's nice to overwrite the turn on and off actions to make this what you need A switch named On doesn't sound logical to me imo. I'd rather opt for using name None (causing the switch to be seen as the main feature of the device, so in this case it would be names switch.{device name} and it would be like "turn {zone} on or off" (which sounds logical, but I think you already have a climate entity per zone)) Done in bb564fb4c4 Also, climate entities support TURN OFF and TURN ON actions now. The default behaviour is that it will use HVAC mode to turn on. But maybe it's nice to overwrite the turn on and off actions to make this what you need This is my attempt to add independent switches and [master zone mode selects]( diff-2695ddf2943968129bc3f9c43d26ea0f96bdcce8fb4657fba43b74312c16f883R194-R202) for changing the status on master and slave zones: Because the following discussion has stalled: That has not stalled, in fact, that has been implemented as far as I'm aware That has not stalled, in fact, that has been implemented as far as I'm aware Nope, the only thing that has been implemented is the on off feature flags: However, as long as there's an OFF HVAC mode, I won't consider that discussion as implemented: L17-L18
Not needed. Everywhere where you have entry id, you also have access to the entry data Fixed, thanks Why don't we add every module out of the box? Different modules are generally in different buildings - to me it felt presumtious to assume users would want that in a single Home Assistant instance, so it seemed sensible to allow them to be added one by one as required. Ideally for connection striaght to a device we do 1 config entry - 1 device. But for cloud accounts we rather do 1 config entry - 1 cloud account and import everything and let the user disable the things they don't need Okay, that's fine. I'll sort that out tomorrow. It simplifies the config flow a lot. Done, thank you! Please set the entry.runtime data to a variable first Done Typing Done Why don't you make zone a parameter Done - nice idea This can all be removed if you use attr preset modes instead of preset modes Nice, thanks! This is small, can be inlined I left this as is - mostly because it makes the code easier to test (well, to mock) when testing the config flow. We should not mock a function in the config flow, we should mock the library Done! Thanks for the tip! Comment first off, how does roth sell their product? Touchline SL? should we rename this with an underscore in between? Let's create the coordinators here and set them to entry.runtime data. we should also do the async config entry first refresh here We can omit the True with the coordinator since the entity is already able to get a state Let's add the coordinator name in there so the self.coordinator.data is typesafe unique id is unqiue per intergation per platform, so no need to prepend it with touchlinesl-zone- I would recommend checking out fujitsu fglair they have a nice way of doing this. Also make sure to check the available property they have, you need that as well why?
I would vote to move to warning and point the user to the documentation for manual setup I started with debug here to keep it simple, but I think it would be good to make a repair issue in a future PR This one will be difficult to cover without patching get url I think it would be good to also check ws config["enable"] in case the outbound websocket is disabled and enable it Are you thinking something like? I'm a bit conflicted on that as I think its ok to set it up if its un-configured, but if they explicitly go in an turn if off it seems like we might not want to override their preferences. While I agree there is something in your claim, I think we reach here only if it is a sleepy device, added to HA and has no entities, in this case we probably need to do our best to help the user, so I would prefer we also enable the WebSocket if it is disabled (as your diff above). The case that makes most sense not to reconfigure is if it is enabled and set to another value, since there might be a case that the user set another address due to a proxy or different networking, but I don't see a case for having a sleepy device in HA without WebSocket as it makes it non-functioning. I agree with Shay, when ws config is disabled the device simply doesn't work with Home Assistant, integration in such a case should try to fix the problem. Adjusted in a4d5f727ff97f4ead4e0388c66fd2548de1214a5
Why are we storing this in a store instead of the config entry data? Hum, I don't known. I'm new in ha development (but I'm a experienced developer in other side). So, I'm inspired in other integration like samsung smartthing but if there is a best way, lest's go Withings is a good one to check ok, I'll check it that many thanks
These are unused? Thanks! Copy paste and being tired :) I'm missing translation strings for the options. Oh good point, I didn't look at it because it didn't have entity name true but that's unrelated, so my fault I will try to get it done before beta
I don't think you need to extend the button. self.drink doesn't add any value since in the for loop at line 57, you can just put in the drink from the for loop scope instead of from the lambda This could become a list comprehension Please collect all entities you want to add in a list and add it all in once This change produces an error B023 Function definition does not bind loop variable drink because this can cause late binding In that case you need to disregard my previous comments and we do need a second extension, sorry for that, didn't know this wasn't possible I see that type: ignored is used a lot in the codebase. I'm thinking leaving it as is But that doesn't mean we should introduce more of them, the most of them got added due to new python features and typing things What does this button do? Should we use a translation key and placeholders to add more context to the name? This button prepare a drink to be poured out using the device. The problem is that the drinks are created using the device app and the user can choose a name there I can add the word "prepare" so for example for the drink called "cup of tea" the button name would be "prepare cup of tea" That sounds awesome! we still want to collect the entities in a list and call async add entities once
I believe you should be using async migrate entry . See docs [here]( config-entry-migration) Maybe I'm wrong but I don't think this is required just to replace an entry option. Migration is to be used when all config entry structure is changed. See PS4's migrate entry. Only used for country code change L91 Yes, but country code is in data , not in options , and probably are some mandatory data for integration. I have no problem in implementing this, but I managed other options migration where this was not required, so I just wait for a confirmation if this is required or not.
This should not be a service. It should be a websocket API to be used by the wizard. It should also be its very own PR. Each service should be its own PR. We should call this announce. Do not include text in the name as we will also allow media in the future. Please open a standalone PR to add the WyomingSatellite implementation. The trigger PR has to be layered on top. We shouldn't include this in a user facing service. I feel like this option shuold only be available via a websocket service.
name is not used yes, true. removed actually this is needed we have a new helper for this. mock config entry.somethingsomethingreauth (forgot the name) yes, very new. mock config entry.start reauth flow have updated to this now this should return a form It didnt make sense to return the user to authentication form, in the case of connection error. So I opted to abort the flow on connection error. Should I handle this differently somehow? I could redirect to a new step to update device host? Can we move this to a parametrize? Sure. Just raise ConfigEntryAuthFailed ok What's this for? this was to test that reauth was triggered, but maybe simpler clearer to do it inline in the test. Can we rename the fixtures to be more meaningful? I have renamed this one mock config entry host . I will make a followup PR to rename the existing fixture, and also use this new fixture in some of the config entry tests. We should instead check if there is a flow in progress after this Ok, have changed it to check flow progress instead.
In Home Assistant normally utils are tools that are not aware of Home Assistant and helpers are tools that are aware of Home Assistant. I think the client, model and utils belong in a 3rd party library in home-assistant-libs org. That is the plan when everything is ready. I just opened the PR to test the code on multiple machines. Shouldn't we talk about ice servers instead of stun servers ? Needed to add mashumaro here otherwise we will have the same issue as with the supervisor lib This needs to be updated to take the websession as well as the url value or it will error. As a thought maybe the client should have the websession as the second parameter and allow it be passed as None (and create an aiothttp.ClientSession if it's None). I know the primary reason for the library is for HA support but it's probably good practice for it to be usable outside of HA and most consumers wouldn't expect to have to pass in a web session. If someone uses the library outside of HA, they can create easily the websession with: Will add this to the Readme of the lib URLs can be either a list or a string. This should return a list of ice servers. Shouldn't it be register ice servers and use a list of RTCIceServer? Currently, there is no use case to return multiple servers. One server can have multiple URLs You can get the list of ice servers from . As discussed internally, we will merge it without it. Add the servers in a follow up I'd cache the providers in a local variable too since we need to access it twice. Can we use the DATA COMPONENT key to get a typed optional result. We can mark this in the manifest instead. I think we should explain in a comment why we have this RTSP to WebRTC coupling. Why do we set up the camera integration directly? This would be a tiny bit faster with a frozenset instead oh, nevermind its being used in a genexp with startswith diff-43b3bf64f3dd0aebbb9a33d25de61875864bf29c6fc359058a75d9bb5feca656R71
Wouldn't this always add a conversation entity, even if the config entry doesn't support it? Right, I forgot to add the check! Nevermind, it's checked in wyoming data.py Adding an entity cannot just raise. It should not add the entity unless there is something that can handle it . It should never reach here anyways, as the services are checked earlier. So I'll just remove this. Only do this if the conversation agent was previously available for backwards compatibility. I don't think this is necessary because this is the first time Wyoming exposes a conversation agent? This appears to be quite necessary, actually :smile: I had just removed the migration part. Can you explain why you think it is necessary? Creating a conversation entity is the modern way. Setting agents was the old way that we shuoldn't add to new platforms. When I removed it, the agent no longer worked. Should we be calling async set agent automatically in the entity base class? No, that should never be called anymore. It is no longer used. Users should only target the entity ID. This is not a satellite platform. Instead, it should only be handled by data.py . This is wrong. You need to do lookups based on entity IDs. Entry ID should not be used. Same. We shuldn't talk directly to the agent. Instead call conversation.async converse Otherwise you are not testing that the method is actually called correctly from the conversation agent. this is built-into the base entity. Not used
[ base trigger validator, backward compat trigger schema] means a list which passes at least one of base trigger validator, backward compat trigger schema , that's not what we want. ohhh, that makes sense Wondering if this is still relevant since the TRIGGER BASE SCHEMA already makes them exclusive I am wondering why this adds a trigger key, since we now pop it There needs to be an explanation to what is going on here. Let's cover this. We should add tests in tests helpers test config validation.py which call TRIGGER SCHEMA and or backward compat trigger schema with all the cases covered. I'm not sure restricting to dict is correct, I think we should allow any Mapping Isn't Mapping a subtype of dict? No.. This explanation is not clear, we should explain the trigger key is currently only for yaml, while the Python implementation still uses platform This copy should only happen if we mutate Please add tests for the changes to this WS command I don't think this parametrization should happen here. This should instead happen in tests components automation test init.py to make sure both the old and new keys work Since trigger is now yaml only, can we run the backward compat trigger schema before we run base trigger validator ? Revert these changes, these checks should be in the backward compat trigger schema if that runs first. I'm not sold on naming this response , how about this: Let's explain why we do this instead of fail
Since CPU is an acronym for central processing unit we should upper case it. Changed as requested The should be "CPU core 1 usage", etc. Changed as requested We can use translation placeholders here. Done Please use the freezer for changing time Could you provide an example? Ok. I replaced everywhere idem
Please make a separate PR for this change. When making that PR, please also add an icon for the number integration for this device class. We missed this when adding this device class a couple of months ago. Please remove this change.
I don't think we should change this. It would mean that the entity would never be docked if the entity only changes state due to service calls and doesn't have a state value template. Ok, I'll change that back. Should add lawn mower.mower can return . Not replace lawn mower.mower can dock as it's still there
This can be moved outside of the if statement
Done Unused Removed done Please double check if the state write is needed, it might be so that this is built in. Otherwise we're doing 2 state writes You were right, the async write ha state is not necessary. I removed it.
why the noqa Was included in the scaffold. Please keep config flow specifics out of the normal setup This is a shared function, not config flow specific. But we should not share a function with the config flow, they should live independently Okay, since you recommended to inline it anyway below, I can do this in both places. I thought it would be better to make sure both config and setup follow the same procedure to avoid unaligned behavior (also in the case of future changes enhancements of this function). Why do we add webcontrol as suggested host? Let's remove that This is the default hostname given by Warema. but webcontrol isn't a hostname? Yes, it is. It is not a FQDN, but a hostname that can be resolved locally. Can we use the helper for this instead of having it like this? You use the helper later on, so you know which one I mean :) The function is tiny, let's inline it Only have stuff in the try block that can raise It can raise. This structure comes from the integration scaffold. host user input[CONF HOST] can't :) Why don't we have a dhcp entry point? Because it is not needed. The DHCP discovered entries need to be user-confirmed anyway according to the developer documentation. And this way the same form can be re-used. Do we get anything unique from the dhcp message? Do we have something unique we can set as unique identifier? Unfortunately not, the hub API doesn't return anything, no serial or mac of the hub itself. Can you elaborate on what a Destination is? Will you add more future platforms? What happens during a refresh? Please use the extended config entry Why do we refresh here? Without a refresh here the destinations actions aka device type and capabilities would be unknown unset. Please move this to a follow up as well I need this to let users ask for more platforms or device types. I am not saying we don't want this, I am saying we don't want this in this PR :) Let's not include a class name in the unique id Let's move this to self. attr device info in the constructor
This is not needed for this to work Just the field in the entity description is enough Oh interesting. How does the entity description work then? Is it just a container for all of these values that is used to populate the attributes like self.entity registry enabled default ? The above suggestion causes ruff to fail, no idea why that wasn't a problem previously
The code in this method is almost same as the code in async step start addon , could you try to deduplicate them to call a common helper? It is only one return statement, but we need the separate methods as there are different steps. Why does the start task raise AbortFlow which does not abort the flow? Corrected. Now AddonError is raised instead. Take a look at this class: L76 It moved the waiting to the add-on manager which simplifies the caller's logic. Can that class be used here too? matter and zwave js should probably also use that class. I have looked at this class. And it can help a little to install the addon. But not for the progress code. To start the add on the class does not check if the discovery info is available and if the broker can be connected with the discovery data. It will take some more time after starting the addon befoe the discovery info comes available. So I'd rather not the WaitingAddonManager class at this state, as it does not really help, and seems to make things more complicated. It can happen that the user already have the add-on installed. We should either check that before showing the menu, or make this text more vague. Checking before showing the menu is probably better, the option would then either be to connect to the broker provided by the add-on, or to install and configure (what you already implemented) Made the text some what more vague about set up of the addon. This data was not used OK, then we clean that up in a separate PR. This should be in addon.py Separate PR please Let's not create a 7th copy of these fixtures. Instead: - The existing fixture implementations should be refactored to helper functions which are moved from to tests components hassio conftest.py to tests components hassio common.py - Fixtures added to tests components conftest.py In this PR, hassio and mqtt should make use of the shared fixtures provided by hassio In follow-up PRs, homeassistant hardware , homeassistant sky connect , homeassistant yellow , matter and otbr should be updated to use the shared fixtures. Right so for this PR, is it okay to add the new hassio fixtures to tests components conftest.py ? I moved the shared fixtures to tests components conftest.py . In a follow up PR the redundant fixtures can be cleanup, and refactored if needed. In most cases they are copied now. The functions in this file are not pytest fixtures, they are helpers which mock hassio functionality. Rename them accordingly, for example with this pattern: discovery info fixture - mock discovery info Renamed them all

rather than limit to 100? Hi pssc We don't know the count at that point - until after we run the command to get the favorites. I just picked an arbitrary number larger than I thought people would have. To get the count first, I could do a "favorites items" which just returns the count, but that's just an extra call I think. I could change the number to 1000 (i.e. basically just all of them). Thoughts BROWSE LIMIT ? Yes if we're going to set it to 1000, we might as well use browse limit, but that's more to limit the number of tracks etc. where the number could be very large. Certainly no harm in using it here as well though. Think it's likely a sensible change - or at least there's no harm doing it IMHO. Rather than crafting our own command and calling the API directly with async query, I will add favorites support to [pysqueezebox]( Another place where the functionality should be in pysqueezebox . Does this search work for you? I've implemented this a different way in pysqueezebox because when I run a search like this, I get only count of matching albums, not the matches themselves. Yes, works fine for me - works fine when I test it in HA as well ![image]( returns ![image]( Interesting, what version of LMS are you using? Ah, I figured it out. Was missing the upper limit on results, which apparently makes LMS just return count. Yes, the upper limit is officially "itemsPerResponse", so I guess it interprets nothing as 0, and just gives you the top level stuff back,
The docstring is misleading, the test has nothing to do with templates IMHO, it's about special treatment of a payload which is b"..." . Should we also check the string starts with b' or b" , since that's all we care about to not waste time trying to evaluate the data? Can we assert in a test we don't call literal eval when the string does not start with b' or b" ? Test was expanded
If there is only 1 item in the data object, there is no reason to wrap it in a data class to begin with. Just store the device map directly into the runtime data in that case. This, right now, is adding an unneeded layer. No need to warn for that, as a matter of fact, no need to log it at all. It is already logged. And how can a user resolve this in that case? As per previous PR review comments. Please remove all services from the initial PR. Shouldn't this be part of the library? This doesn't look Home Assistant integration specific at all. Why is the type cast here? Isn't the upstream library typed? Same comment as before: r1711423028 I could not find the public open-source repository providing this package. pypi doesn't have any public repository linked, and couldn't find it with a search on GitHub either. String type is already inferred Shouldn't the library raise an error exception in these cases? Seems a bit odd. As I cannot find the sources of the library, I'm not sure why this is the way it is here. This makes our translation keys coupled with an upstream library. We should be doing that. Please decouple it. Please do not ask for an config entry name in the configuration flow. There is no need to assign this to a variable first. CONF ACCESS TOKEN is always in the user input... the schema required it. Are there any possible side-effect from this? Not fully understanding why the device registry is retrieved in this location. Probably better to move this into the places it is actually used (since you pass along hass anyways, you can do it locally). body? What is that? Why is an ininstance check needed here? This check shouldn't be needed, according to the method signature above, this is always a list. This is already typed upstream? - These could be moved to be class variables? - Not sure why access token has a default? - Entry name can potentially be removed considering the other comment of not asking for a name in the configuration flow. We always have an access token, it is part of the schema as required?
Don't log on info Not needed
Bound might not be necessary here, could just put in RussoundBaseEntity as a type in function directly. Don't know the python semantics regarding this. There are new typevars for this, I'm not sure about the usage of them. I think technove has one Yep, they are just using the shorthand. I'm swapping over to that. The self. device identifier instance attribute only seems to be used in this method. Then it doesn't need to be an instance attribute but can just be a local variable. Alternatively since it's only used once, just inline the expression where it's needed. Same comment for self. controller as for self. device identifier .
Better not put default init on a class. You can set this attribute also at top level since it's static ? Wouldn't that cause the SatelliteConfig object to be shared among all instances then? I thought it's a frozen object that each implementation would override as necessary This whole function needs to be defined inside the assist satellite base class and called by the VoIP satellite entity. Moved into the base class Only import things for typing. All function calls on the assist pipeline integration need to be done inside the assist satellite base entity class. I think everything except the pipeline event callback can be moved into the base class. The VoIP code needs to know the pipeline stage in order to play the tones, send the TTS audio, etc. I think that the device registry entry was already on the entity class. This otherwise is fine. Is this necessary if we have a property already? Let's require classes to override on pipeline event ? (And call super) or maybe make it an abstract method platform entities need to implement. They all have it. And then call that method from on pipeline event. This is reverse logic. The state is determined by the base class by asking if this property is true. It should be abstract and implemented by platform entities Should muting be a supported feature since VoIP doesn't use it at all ? This should not have an implementation. It should be abstract. The platform entity will need to ensure the microphone is muted when the method returns. Then when we update state, it checks is microphone muted property to determine state. No need to have an intermediary property. Just always write to attr state No need to translate this. Should be handled in UI natively. Instead of implementing it like this and computing it on the fly, set attr supported features above init instead. For a future PR, the assist satellite base class needs to handle this feels a bit like a generic util function ? queue to generator with optional timeout ? Somewhat, though it is specific to bytes as queue items. I guess that could be made generic. Moved to util.async This is only used in tests, move this out of prod code. I'm using this in the make protocol function in voip.py Can we have entity register its start stream function with VoipDevice inside async added to hass ? We don't want to expose raw entity objects to other code. If start stage is wake word, it would be something else. Should we enforce only a couple of start stages to keep code simple today? I don't think we should because of the way I plan to implement remote pipeline triggering: the satellite will call back through this function. I just need to set the state more carefully with the pipeline events. This is the default and can be removed It's not registered as a service , described in services.yaml or used in VoIP. Let's leave it out for now Also shouldn't be abstract as it's guarded behind a supported feature. Let's drop it for this PR Are any of these used ? I don't think so. 
Can be removed as there is no difference between them, so we can use directly the base class Wasn't sure if that would be a breaking change Can you please move it back, where it was before I will revert this whole file. That block moved so I could reference the classes in the list of description objections The string mapping should be in strings.json so it's translatable. motionblinds ble has a good example: L61-L70 Thanks! Do we need a custom description class? It's not adding anything is it? I can remove it. The other components in Schlage used this pattern Make sure this supports auto-removal of the entry. See L49-L61 for how this is done with other entities. Sure The state test can use snapshots ( snapshot-testing). But you should also add a test for changing the state, ensuring it calls the Schlage API properly. I will look into this. For some reason when I run pytest tests components schlage test init.py --snapshot-update the snapshot doesn't update even though I've added a new key value pair for auto lock time In the meantime I've updated the test to set the option based on demo test select.py Please keep lines under 88 characters The link is over 88 characters. What do you recommend? You can always remove it, when people try to remove it and test it out they will find out it doesn't work I guess Sure. Updated the comment Would it be more natural to use minutes for some or all of these? I can update it to match the first-party Schlage app UI Why do we unload the config entry at the end of the test? Let's see if the tests pass without it. Other Schlage tests ([example]( L62)) do it Seems to work without it so I removed it Should we validate and log if we get an unexpected value, or is that not needed? I have not seen that pattern before It was meant as a question: Do we trust that the Schlage library will never return a value which is not one of the select entity's options? If we do, no need to validate. If we don't we should check.
Instead of hardcoding this list here, could we use VALID STATES from alarm control panel ? L33-L41 I'm using VALID STATES now. I had to add three states that were missing from this. The alarm control panel refers to these as "states" rather than "modes", so I'd suggest to use the work "mode" here and below. Changed. Please don't change the entity integration in the same PR as another integration is changed. Changing an entity model needs prior approval in a discussion in our architecture repository. changing-the-entity-model Removed the change, and submitted Sorry, I've realized that my previous comment about this was confusing. What we are reporting here seem to be referred to as "state" rather than "mode" by the alarm control panel component, so I would suggest to avoid using the term "mode". Here's a suggestion (you'd need to adjust tests accordingly): VALID STATES shouldn't be used outside of the alarm control panel reproduce state module. It's just a set of states that can be reproduced and not meant for outside use. Oops, it seems like [I provided]( discussion r1714829427) DeathCamel58 a misguided recommendation earlier about this. Sorry! MartinHjelmare, is there a generic way for the Prometheus component to consume a list of all valid states from another component in cases like this? I see us use a few different approaches now: for cover , we hard-code a list of possible states: L442 for climate , we read a StrEnum exported by that component: L539 for humidifer , we read a list of modes from a separate attribute: L608 What would be a good approach here? Until there's an enum for all alarm control panel states I suggest we hardcode the states here in Prometheus. States are now hardcoded.
Why is the command optional and then asserted to be not None below? It should not be optional, I think. Use kw only True also. ah, yes, that will also fix the above question (I made it optional due to the missing kw only)
We don't need a translation key since we set a device class that provides a default translation. We can remove this. Please update the docstring.
Is this name as well as entity id and original name related to the device class? I would have expect this to be DHW temperature ? Looks like this is not generated correctly for me locally, but it is in [workflow]( I could fix this manually but would like to know why this is happening. joostlek any idea why this produced wrong results locally? Missing translation? Did you generate translations? No, just the string.json , the entity id contains the translated name? python3 -m script.translations develop --all HA takes the strings from translations en.json
Why do you need to change this test? I added it when I fixed controlling entities with ' in their name, e.g. Alice's room. The param2 is defined in its schema as vol.Any(int, float) so a string value doesn't pass validation. We already have an ' in param1 , but if it is not enough, I can add another string parameter
Please don't use previous config flow implementation in Switcher as an example for config flow. It is not allowed (and not needed) to store data in hass.data during config flow. So can you show me a good example? Any platinum integration can be used as an example, why do you need to store the devices in self.hass.data ? they are not used outside of this class I revert that part back.. I dont know how to progress from here.. The async discover devices() was the right direction, just don't store the discovered devices inside self.hass.data , you can store them in a temp variable ( discovered devices ) if they are only used inside this method, if you need them in another method you can store them as a class variable ( self. discovered devices ) This is already async, why does it run in a task? I just copied it over from the previous iteration of this file.. You copied parts which are not related and mixed them, can you remove the async create task ? I revert that part back.. I dont know how to progress from here.. Please first check if one of the discovered devices needs a token before asking the user to add a token I do that here: diff-3e4eacfcf78f613ccf0f87e8409a1e040758f7e7ec9bcb802becd3de9458b96cR57-R61 I am calling reauth to get username and token only if device that needs a token found This needs to happen in 2 places: 1. Same place you already added, this will handle devices that are detected during runtime that needs a token. 2. When user add the integration, if a device that needs a token is detect you need to switch to asking for credentials before continuing to create an entry. Exampe: L171-L172 This needs to happen in 2 places: 1. Same place you already added, this will handle devices that are detected during runtime that needs a token. 2. When user add the integration, if a device that needs a token is detect you need to switch to asking for credentials before continuing to create an entry. Exampe: L171-L172 Maybe I am missing something but when I tested this part I got the "reauth" when I initially set the integration for the first time and when I had this already set up and I pressed reload on the integration (And when I didn't have the device there and restart HA).. Plus this is the only part where the bridge is detecting the devices so I can determine if this is a token-based device no? I put the missing step and did a little refactoring. Please revisit. Is it going to be used anywhere in this PR? if it is for future device add it when you add the support for that device I need the COVER1 ID but removed the COVER2 ID The implementation of the get circuit number here does not make sense, however since it is not used in this PR (it will simply return 0 ) please remove it and remove the index parameter, you can add it in a future PR when you add support for dual cover. Removed get circuit number and index Please refer to a new section in the docs instead of the URL and example thecode I don't understand what doc is you talking about? t
This needs to interateable. It seems there are unnecessary spaces here: can we mention the dep bump in the PR description please ? I've just added it to the list. We will release 6.5.0 of the library soon. Then we can do a PR to bump the lib version and after that rebase this PR OK
I don't think that's needed here, you can just do str I think it's more user friendly to have a dropdown selector here. Also having a free text string is more human error WDYT? oh, the UI is done with services.yaml, this is only for validation, but then its already validated Ok. Done idem Done please use string references I'm not sure what you mean [ key:components::seventeentrak::..... Done use constnats Done I mean for Config entry id and package tracking number btw
My understanding of this method is that it's what the assist satellite implements itself for persisting the config. Something like this: In other cases we always hardcode them to the desired value. we never return unavailable , instead, we return False from the available property. For a future PR: When it's being processed, especially by LLMs, we should be able to pass some extra context for the conversation agent to understand the response of the user that comes in (ie, extra context would be the entity ID of the garage door that was left open) When these services are added back in a future PR, these shouldn't be top-level functions but instead be functions on the Assist Satellite base class and then pass the string of that function to the register enttiy service function
typing done typing done Not sure what you use at the other platforms, if it's a - , just keep it like that, otherwise I'd recommend this as it's a good practice because if you ever have to migrate in the future you can just do .split(" ") and have both sides intact In the other platforms I also already use self. attr unique id f"{blind.mac}-battery" in multiple places in a simular way. Although a nice suggestion, i don't think it is wise to deviate from the pattern for the motion blinds integrations. Will keep this in mind for future integrations. typing done typing done
Use the config entry Theoretically you can move this to init and then have a But it's opinionated, we don't have strict rules where this should live but I personally prefer the init Can we finalize the dict type? Finalize - add the type hints of the keys and values That looks like a g too much That's what it has at the bottom of the about page here The extra g signifies a non-profit company under German law according to a quick Google. Ooh, never heard of that, but that makes sense Nit This already happens in the super class I'd almost wager to just duplicate the keys in the entity description, you could then just remove the whole constructor of this class. But this is again opinionated :) Need the init for setting the entity description to type the value fn so leaving this as is, copies Mealie. You have to overwrite the type of the entity description Let me look again at this then. Ah, it was the different parameter name in entity that threw me, resolved this now. Is this what mastodon calls it? Changing to posts for both the key and translation name. The API calls them statuses, but the JoinMastodon home page says "Mastodon supports audio, video and picture posts..." They moved away from Toots in 2022. Please delete the file and regenerate them, you have some leftovers from when you didn't generate translations yet You don't need this one as it's defined here Oh whoops forgot that I made this comment when I approved it, could you please fix this one in a followup? Will do Fixed in
Is this how the device is reported? If not let's use the model number without the variant attached to follow how the other models are done. cdnninja, sorry, missed this earlier this week! My two EverestAirs report as LAP-EL551S-AUS. I based the addition to const.py on the EverestAir models listed in [pyvesync's vesyncfan.py]( For the const.py file, I tried to match the existing style of the Core Vital models (such as line 58), by listing "EverestAir": "EverestAir" first. Happy to revise you'd prefer that not be there. Oops I missed this. You are correct.
Why is this something stored here and not fetched during runtime? If we would fetch it at runtime when the integration gets loaded and the inverter is offline, it would lead to the integration not starting, right? And since the value won't ever change, I thought it'd be smart to obtain it at setup. I mean if the device is offiline we should not start the integration anyway. Storing it makes it look like its user configurable which its not No, that's wrong. The integration should start as the inverter is offline during the night If a device is offline we should not start as we can't get data etc. That's how it should work Okay, then I'll change it to checking it on startup. Why do we store this in self.api? Shouldn't we store this at the coordinator Because the api needs this as well, as it checks against that as well and why storing it in the api and the coordinator when the api needs it regardless of the coordinator? It sounds strange that the API requires it tbh, why do we receive the value to set it afterwards, why don't we call a function for the api to just set it themselves. Also, can this raise? We should raise UpdateFailed in that case The reason is that the API shouldn't run any IO in the init function so that it can be initialized when the inverter is offline
You shouldn't be deleting this file? Home Assistant is licensed under the Apache2 license. We cannot accept proprietary licensing within our codebase. Above all, it is very clear that parts of the code produced in this PR are copied and used from other parts of our codebase that are already published under our license. It would not be possible to claim that proprietary. Please note that you all have signed our Contributor License Agreement at this point as well (see the above interaction you all had with our bot), which conflicts with this. Remove all custom services from the initial PR. They can be added in separate PRs later; we want to keep PRs to the bare minimum. Please remove diagnostics platform from the initial PR, it can be added in a follow up PR later. Please remove all device triggers from the initial PR, it can be added in follow up PRs at a later stage. Please remove the notify platform; initial PRs should have a single platform. This can be added at a later stage in a follow up PR. Missing codeowner I could not find the public open-source repository providing this package. Pypi doesn't have any linked, and couldn't find it with a search on GitHub either. nmap? Is this a weird assumption? What if one is using a different subnet or address range? This is a client implementation, which should be extracted into a package, open-sourced and published on PyPi. This is effectively putting 3 different integrations into a single integration; riddling the integration codebase with checks for each one of them. This is not correct. Home Assistant supports multiple integrations being exposed under a single brand. Meaning we can make the LG brand and expose multiple integrations under it. This is what should be done here as well. The pattern you are using here, is something we used in the very past and are no longer using or allowing. This file is a nice example; it is fully copied from an integration that Home Assistant already has in its codebase. You cannot claim copyright on this code. I'm not sure why this file is here, it is part of the webostv integration and should be part of this integration at all? Please don't use hass.data for this anymore. Instead, store the runtime data in the config entry. For more information see:
Only add attributes here that are mandatory in the spec why is this ? I mixed it with the file used as an example: cover.py this needs to be in the calculate features no need to set this in each atrribute callback, move it to the ValveEntityDescription If this is dynamic, move it to the "calculate features" logic. We can also extend the discovery schema logic to move it there We're missing tests for a device that supports set position. We're missing tests for state updates. tests added
How accurate is the run time? Is it changing a lot? If so, consider using [ ignore variance ]( L169-L172) Good question. Im not sure. Will look at your suggestion I've pinged users with the device for this information. Maybe its ok to merge this as is and I will put up a future PR to tweak this based on feedback? Looking at logs provided in it does not update very often. The logs span 15 minutes and the value has not changed during that period Done Should we add suggested unit of measurement? A sensor in seconds doesn't sound pleasant Done
I would suggest that we generate a new unique URL instead of passing the URL around. (ie based on ulid() ). Where are these changes coming from ? Must be new type checking rules. I couldn't finish the commit without the changes (even though I didn't touch those lines). After rebasing, the complaints went away! Should we return the proxy URL from async allow proxy url ? that's also the place that defines it. If we are returning the URL, rename it:
Please rename this to CONF ENUM SENSOR OPTIONS so it's clear what it is Please add a comment explaining this is options for enum sensors done
Using a CameraEntityFeature doesn't sound like the thing we want to use here. I have too little experience to know what to do use though I think you can scope the target device with model . I think I once reviewed this for yolink I know, I would have like to just use a number flag like 1024 but then I cant get the services.yaml target- entity- supported features to work. How can I define a specific feature flag so I can filter out a specific entity for the action target? I have removed the filtering of the entity ids (using a entity id which does not belong to a chime will result in a understandable error). Although I would have liked to have filtering on the enity target as well. Why is the target domain a select entity? Wouldn't it be more logical to have a device target? Because I absolutely hate using a device as a target because that will use some random device id in the call. When I then want to swap the device later on (because it is broke and I have a replacement, I bricked the firmware, I upgraded to a simular model with more features etc.) I just remove the old device and set the entity ids of the new device to the same as the old device. I get back all the history of the old device in the new device enitities, but most importantly all my automations will continue to work as usual since the entity id is used as target. Otherwise I would have to go trough my 195 automations and 102 scripts to check all the places where I used that device and re-target them to the new device. (ending up with searching trough YAML files for the old device id, which is not user friendly). Right, but that is a concern that is not specific to reolink. So I don't think that replacing a device should be a reason not to pick this tbh I kind of dislike custom actions services altogether, hence why I implemented the select entity in the previous PR. because: - they are harder to find in my opinion (don't show in the device page) - targeting is not nice (as explained above) - they require a lot more code to implement than just another entity description in the list of entities. It has been reworked and now works both with device and with entities as targets (and a mix of multiple together). It is become a hell of a lot of code for something which could have been just a simple select entity..... Why do we still allow entities to be selected? Is the device alone not enough? You can always select entities when using the target, I am merely filtering. And I did make it work through entities or devices, both work. That keeps me happy since I can use the entity id :) And you can also use device id is you prefer. It's not up to each integration to add other ids than the required id, just for the sake of ease. That should be handled centrally by Home Assistant if we want to do that. Please remove the entity id selector. Sure I will remove it, but it does not make any sense to me. Then you get a target select in the UI in which the user can select devices or entities (or ar
Why don't we add all inverters by default? Depending on the setup there may be quite some devices with no or little added value for the user. Me for example, I do have four devices: one inverter (with values of solar yield, that I already get from base setup), one gauge for energy consumption (also already integrated in base setup), one gauge for my heat pump (this one I need) and one relais (can be triggered by solar energy surplus). Based on the SolarLog manual there could be loads more devices be connected. Hence I do not think all devices should be added by default. I thought about adding it in the configuration, but in my view the OptionFlow was a better fit (despite being more complicated to implement). We usually want to go with an approach where we add everything, and people can disable devices if they want I definitely would not like this from a user perspective, but if this is the rule... Would it be an option to copy the step to the initial ConfigFlow, so that the user can decide in the initial setup? It's an old one but it explains the decision well Thnx. In the reference it is said this applies for data retrieved in one API call. In the case at hand, for every device at least 3 calls are needed (name, consumption, power). The library does only make the calls for enabled devices. Does this still apply? In practice this rule is also applied to integrations getting data from more endpoints. Enphase for example just creates a device for every physical device and that's seen as normal. I can bring this to the core meeting for you and check what they think of this if you want Perhaps this would make sense. I think the alternative to give the user the possibility to choose during the initial setup would also be user-friendly. But I would rather not like to spam the user with loads of unnecessary devices. What does device name return? A user-defined name of the device (can be set in SolarLog configuration) Then we should not have that in the unique id I double-checked in the manual ( and on my SolarLog device and have to correct my above statement. The device name is automatically detected and according to my understanding cannot be changed by the user. It's possible that it could be changed during the initial detection, but I also have not found a reference for this possibility in the manual either. The device name therefore is immutable. Should we split this class in a SolarLogcontrollerentity and a base entity? This way you don't have to duplicate the attr has entity name thing (and it looks a bit nicer) Does every inverter have the same data as the controller? No, inverter provide less data points (at the moment solarlog-cli has only implemented yearly consumption(i.e. energy) and power). Some additional data points may follow. Should we duplicate the list to make that difference? Because currently both could contain any key and it would create an entity According to my understanding L238 makes sure, that only those sensors are created f
I see no need to pre-parse any of this info for diagnostics. It just make it harder to debug things so output the full list. repr is non machine readable. Would have been cool if it would have been a to json() function that repr internally used. But this output is not for machine consumption so a stringified data is fine.
How about making a mapping up next to COP LEVELS ? It would also be nice to driver attr min temp and attr max temp using the LOW or HIGH constants to improve readability. (As a reader it took me a few moments to understand the idea that there are these notions of levels, and they have specific numbers, and they have specific labels from the API etc so having it all together could help) Implemented all of this. Perhaps there is a way to phrase this in a way that the user might understand the implications of this? I'm not sure i follow what i'm supposed to understand from this. It's a complex issue that's also covered in the documentation. Essentially some vehicles require an extra layer of security that this integration doesn't currently support using. Explaining that in the error seems too long. Could refer to the documentation maybe as I agree with Allen it's very technical error Command signing is required, please see integration documentation. Does this work? I think this check should be moved into async setup entry to avoid adding the entity. If none of the commands are supported or not allowed then let's not add the climate entity. My impression is there are already sensors for a read-only view. (Also I don't think we need logic later to check raise for scope and raise for signing and to raise on a command given here we've already said the feature is not supported. My assumption is that the tests would still pass if those checks were removed given the climate integration won't call the service if the features are not enabled?) There are not sensors for a read only view because they would duplicate the values exposed by the climate entity. The intent is to use the correct platform so that a user can later decide to add the required scopes and the entity won't have to change. The approach used here is consistent with Tessie and Teslemetry. There's climate state inside temp which seemed like the important bit. Either way, my other point was there is complexity with these checks later in the entity and I don't think it is needed. My impression is that if the features aren't set the code in the entity for double checking these things won't run because of the missing featuers. My assumption is the tests exercising those aren't actually covering those code paths (could confirm looking at code coverage or the error messages raised). Some of the climate attributes are exposed as sensors yes (forgot about that), but this isnt true for the other platforms for example the lock platform is the only way to see if the vehicle is locked. I dont believe hiding the climate entities is the right outcome, because I know for sure I'll have users raising issues that the climate entity is missing. These cases are covered in tests test climate noscope and test climate command signing . I dont think I understand your core point because there is no "double checking". If there is a reason the integration knows a service call will fail it checks for that before trying 
Should we just do an icon here instead of the channel icon? I think it can look strange if you add more sensors that they all have the same picture. Wdyt? That's true, although it doesn't bother me. Not sure if there is an appropriate icon for both of them. I think subscribers is fine as is, but let's add one for the views, not sure if there is a viable icon for that. Please use the icon translations to add one I'm wondering, what makes the views any different from the subscribers ?
Not needed Oh, why don't we store this in entry.runtime data? You can use a dataclass to store both Please use constants Idem Idem Please leave reauth for a follow up Don't create mutable objects on class level, rather create them on instance level in the constructor Idem Can we type info Why don't we add everything we find? We want to make the set up as easy as possible This should belong in the sensor platform Why the dict Please use translation keys and entity translations and icon translations What's a COP? Can we type the update coordinator with the return value of async update data? Let's do this outside of the constructor tbh Typing Typing Typing Let's move this to a constructor with attr device info Why do we set it if it's empty Remove empty fields Not really needed imo, because this can change in the future and it would run stale Typing Use an f string Why don't you just go for overwriting the native value property?
You only have to inherit ApSystemsEntity If I do not inherit the BinarySensorEntity here, the tests fail and I get an unavailable state for all binary sensors. I think Joost referred to the CoordinatorEntity being unnecessary, because afaik ApSystemsEntity already inherits that No, ApSystemsEntity inherits only Entity from homeassistant.helpers.entity . If CoordinatorEntity is omitted, the binary sensors also cannot be set up successfully either. Okay, then my bad Ooh you're right mawoka-myblock A nice follow up would be to maybe create a second CoordinatedApSystemsEntity base entity so you can avoid the double inheritance I think this is already in ApSystemsEntity Make it a dataclass instead These aren't booleans right? Yes, the Apsystems python lib returns an IntEnum Status class here: L164 Do you have a link to the Status intenum? Shure: L8 I'm not sure why this is an enum and not just a boolean tbf That's right. But that's something only mawoka-myblock can say something about. (it also wasn't a comment for you, just thinking out loud) Not really sure here, but I got the python api file from a beginner and started improving it from there while sticking as close to the api as possible. So that's how you sometimes miss things like that, right? But I'd say that it's not a huge problem, is it? No it's not, but it would be nice to eventually change this, this way you could remove the bool from binary sensor.py . Because when you see an enum you automatically get the idea there are more options, but if its only true or false, a boolean makes more sense.
Lambdas should not be multi line, if it doesn't fit on one line make it a function instead. This should be for network clients right? Not for infrastructure It is infrastructure. Uplink MAC for my UDP is my modem MAC. Uplink MAC for my Switch 24 is my UDP MAC, etc. Make the two devices unique and combine them to one list and skip the if not has uplink as we should refrain from using if-statements in tests This string is wrong
Rather create a separate coordinator, I've been told Throttle isn't very optimized Would it be possible to add a test for it too? Instead of mocking the aioclient, shouldn't we mock the github library? I tried but i couldnt't get it to work. The github integration uses the same library and does the same, it mocks the aioclient. i figured it out :D Would it make sense to have this set in async setup and added to hass.data just like in wled ? I know that it's more likely to have multiple wled devices than multiple irons, but I like to think that its nice to see it as a good practice. WDYT? (not seeing this as a blocker btw, just thinking out loud) You mean one single coordinator for all instead of per entry? Hmm, I think that makes sense but if it is not a blocker, I would prefer to do this in a follow-up PR Fine by me would it make sense to do this in init.py and make it a parameter to avoid to call it twice? Isn't async setup only called once during initialization? Oh, right, it is called once per coordinator initialization. Good point! Thinking about it, now that firmware version is relevant for the update entity, it maybe be necessary to refresh the device info from time to time, in case it has been updated in the meantime, not only on integration setup Then you should move it to the update function Ok, never mind, just remembered the device info is cached in the library, so calling it twice would not result in fetching the characteristics from the device again.
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service, and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shifts in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: OK that's interesting to know (after two months of waiting and hoping). So that means this great integration will stay in current shape until someone starts to migrate it to a config flow version? Unfortunately, that's for sure way out of my skill level. Too bad, I thought spending some hours solving a problem I have and making the improvement usable for everyone would be a rather quick and helpful thing. Unfortunately with all the needed rework I won't be able to work on this any further. Probably this integration will die (no maintainer, no huge user base, zero changes for years... one breaking change in core and goodbye VoiceRSS ). Anyway, it was interesting to see and learn a bit how things work in the developers building. I'll move back to the users building, enough PR experience for a long time.
We should not use any calculation on the expected value as this could hide a conversation error. I use an online converter to get the expected value, and then the tests ensure that our converter works the same way.
Not sure if I can fix this easily. Error was: homeassistant components homematicip cloud sensor.py:93:11: C901 async setup entry is too complex (29 25) In a separate PR, I think the function should be refactored. Maybe make a map between classes and entity objects? Not sure why this is failing in the tests. When can this be false? I think you can remove the hasattr check for valveState, because this is always provided by the class of the upstream lib. I think what helps with simplifying is to make this a single list comprehension barryvdh You could use that comprehension (which also uses all Falmots): Done in HI barryvdh can you please add imports AsyncFloorTerminalBlock6, AsyncFloorTerminalBlock10 and AsyncWiredFloorTerminalBlock12 to imports. All are nearly the same but with different amount of channels. This is done in hasattr check can be removed, because the attribute is always available If I removed it, I get this error: FAILED tests components homematicip cloud test sensor.py::test hmip floor terminal block mechanic channel 1 valve position - AttributeError: 'HeatDemandChannel' object has no attribute 'valveState' I was really confused why that error happened. The HeatDemandChannel could not be a HomematicipFloorTerminalBlockMechanicChannelValve Instance, because we defined in the async setup entry which channels are allowed. Currently at a few points in the code (not just yours) the functionalChannels Array is accessed via the index (functionalChannels[channelIndex] which gets not necessarily the right functional channel, if there are more then 10 channels. So the array index differs to the channel.Index value. I hope I was able to explain the point. The best way until I fixed it is It's untested, but you can use that everywhere, where you are calling self. device.functionalChannels[self. channel] at the moment. So like this? pullrequestreview-2370369548 Do you need that? Its not referenced somewhere (at least I couldn't find it) Correct, removed
This should be a service instead, as it is a one-time action, and we don't care about the state. Also, if I want to play the same tone twice I need to set to a different option first otherwise the the option is already set and so HA will call the method to change it. Adding the service should be done in a follow-up PR so this one can be merged and included in the 2024.8 release Using a select gives a much nicer user interface where a user can just select the chime to play. (I could have used button entities, but then you get 9 button entities instead of 1 select). The value is set to None always and when selecting a option, it will play the ringtone and also emedialtly go back to stay on the None state (async write ha state). I have tested this and you can select the same ringtone again to play it a second time. Also you can use the select.select option to play the same ringtone muliple times after eachother (you need a delay of the time it takes to finish the ringtone, otherwise it keeps starting the beginning of the ringtone). Besides the key "play quick reply message", entity works exactly in the same way and is already present in this integration. I think I agree with edenhaus. Like, yes it's a nice way to give the user a quick way to play a chime, but what is the use case? I would assume most people only visit the device page when they are setting up or checking something, not for actually doing actions. I would argue that select entities would only be the best pick when it has a state. Otherwise a select entity could also be used as a remote, where all the buttons are put as options. While it works, its not ideal. So yea, I'd argue that playing a sound (and playing that quick text message) is an action and thus should be a service call (or buttons, but I think a service call is more flexible here when reolink adds more sounds or messages, otherwise you might have to add even more entities in the future) For the "quick replay play" I just added that entity below my camera stream so I can play a voice message when someone is at the door, no need to create something with services, just add the select entity. Indeed for the play ringtone off the chime it is less likely a user wants to trigger it, but more likely to be used in automations and scripts, but if you use the select.select option or a custom service really does not matter much. Besides having it as an entity on the device page makes it a lot easier to find for users (in my opinion). I agree buttons would be a even better fit, but you end up with way too many buttons.... I do like the select entity better, but if you ensist I will remove this entity and implement a service in a future PR. I removed it. Why can the coordinator be None? Because when it is None, the default coordinator will be used (almost all reolink entities use that coordinator). See L53-L54 You can remove the list creation and use a generator expression Thanks for the suggestion, I removed the list for all platforms o
We should extend the typing of the config entry to make it type safe Is the email unique? I believe so yeah, I could call .lower() or .upper() on it if you'd like The moment you have the extended config entry type, this isn't needed anymore Let's still try to use the normal rules and only add the cover in this PR why isnt the constant stored as vol.Schema? I'd invert it This way you don't need multiple forms Let's leave reauth for a followup This function can be inlined imo So if I understand correctly the whole setup function is only for setting up for the first time? Use async setup that's a new feature we added this release Do they encode json into json? Yeah, it's weird Followup
Please make the default propane to preserve existing use cases Please use a different constant or bare string for the step since these are not the same Please bump dep in a separate pr so I should not change the integration manifest dependency in this PR? The integration changes require the new package version to build and once I change the manifest will not check in without the manifest due to the build script blocking the commit. Sorry, I'm new to this show so I'm not clear if you don't want me to update the manifest or your just asking for a separate PR to identify the requirement to bump. never mind i think i understand, will do. example bdraco Can you plesae clarify. Previously data {DATA MEDIUM TYPE: user input[USER INPUT MEDIUM TYPE]}, had the same keys. In your review you said they were not the same so I changed them to be different. It appears your new comment suggest a name change but to make them the same. Personally, I kind of feel these are just keys and if they happen to be the same in both dictionaries that's OK but I'm happy to go either way. thanks For clarity, my concern was about mixing the step names and the data. There is no concern about using the same keys for the user data and the config entry data since they are ultimately the same data. This needs a bit more work though since entry.data.get(CONF MEDIUM TYPE) will be None for existing entries so it should probably be This looks unused Setup the entry here to make sure the entry reload listener works Please revert the typing change on this line you may have an older version, mine shows ConfigEntry Cleared browser cache and it s still there. Will double check it by pulling manually when I m back at my desk no my bad, i thought i had changed that but guess i didn't rebase. Please use the integration specific config entry type here This was the concern about mixing step id with the data key. Please use a bare string or a named constant for the step id. This schema could be a constant since it never changes. We want to use the integration specific type for all instances where the config entry is a mokepa config entry
Do this in a separate PR and link to the changelog Reverted the version bump, PR for that here: Nit: missing new line at the end of file Nit: missing new line at the end of file
2 things 1. Translations (both entity name and icon translations) (i think this got migrated to had entity name so that would work) 2. Should this be disabled by default? Solved by: 1. ef1275f87371ecb765b3c8a9cb4a0c3b62ca77ae 2. f96363ae41395a9bd501a6d3284f34d62d46ad37
Is there an easier way to reset the call args, but preserve the current mock state? This seems unnecessarily repetitive. If you just want to test the service call you can just remove the receive of the event. Is that what you mean? The sent commands depend on the current state (brightness color) of the light, so having the correct state before calling the service is necessary. These assertions depend on how many calls were done before, which introduces coupling between the sub-tests so I'm looking for a way to reset the call history, but not the entire mock state. You can use reset mock on the mock attribute that you want to reset. Ok so just client.async send command.call args list.reset mock() ? No, client.async send command.reset mock() . Ohhh, I think the issue is actually not related to that. I am using this call already, but I thought it was resetting the Z-Wave values aswell. However the test sets the targetColor , but there's no machinery in place to update the currentColor afterwards. Side note: We should replace the standard light entity attributes and properties with self. attr color mode etc in the future, where appropriate. I had to do this because scale is considered float None , even after the definitive assignment here. The suggestion causes an error on the line where scale is multiplied. Maybe there's a different trick I'm not aware of, like TypeScript's non-null assertion? Ok. Please use keywords when passing a None value so it's easier to read what parameters we're using. Do we need to get this value a new on every call to turn off or can we store the value as an instance attribute? I guess we can cache it in calculate color values , but I was under the impression that this is just a simple lookup. If it's the same instance there's no point in looking it up more than once. I'm missing an assertion of the entity state after this event. Otherwise we can remove this call. This will error if the list is empty. If we know that this light always supports red, green and blue colors, ie we don't have to worry about an empty list here, it's weird that we check self. supports color in this class. The modified discovery scheme creates an instance of this class for a) devices that only have a current color, but no switching capabilities b) devices that have a binary switch and a current color So there should always be at least one color component, otherwise the scheme wouldn't match. it's weird that we check self. supports color in this class. Due to the discovery scheme, it might be that we end up with a white-spectrum light that cannot be dimmed, but turned on and off. I'm not sure how to match lights that have exactly RGB support, but nothing else, since the discovery scheme seems to match when ANY of the specified values are there, not ALL. Should the initial if in async turn on and brightness should defer to the parent class if there is no RGB support? That way we should avoid this problem altogether. max value can't be None with the 
Not needed as already tested with test number entities For volume, the test test volume maximum was created as the maximum value can be changed dynamically by an event from the bot (as different bots support, unfortunately, different ranges). But in your case it is fixed and therefore not needed Thanks for the feedback on that one - have removed in the latest push
If this doesn't need to wait for the the callback to finish, loop.call soon threadsafe is much more efficent If this doesn't need to wait for the the callback to finish, loop.call soon threadsafe is much more efficent missing coverage Added test to cover this line Is it safe to create a session here?
As mentioned in the previous PR, it is not relevant or meaningful to add all parameters to the entry. In fact, looking at your example, there should be a validation error and a testcase that disallow CONF PERCENTILE without STAT PERCENTILE ... You're free to address that in an another PR but the initial implementation was based on the yaml-schema which has these as defaults hence it's added regardless if the user provides some input or not. This PR is about adding preview. The second part was rather a point for myself. The percentile characteristic was introduced by me and I didn't consider this as a noteworthy anti-pattern back then. My fault, not your concern :) No worries. Would be happy to see a follow-up PR if you think it's worth fixing it (user experience)
Can we keep the old one around and deprecate that one properly? Reolink did a PR a few days back where it had to deprecate one, so maybe that's a good inspiration I think uptime is still a valid and common name for the start up timestamp Hmm, something in me things uptime is viable for both, but I'm not sure what is best here I'm happy with both, so I can change it to use uptime for both if you prefer that. The only downside is that they'll both be called uptime so one will be appended 2 The only downside is that they'll both be called uptime so one will be appended 2 Ah, you're right, and we won't be able to tell them appart for uptime seconds deprecated ... I've asked for a second opinion on this. But also keep in mind, people could've renamed both the name and entity id, so it could but even be recognizable

Is this PR missing a strings.json entry? Good find! :)
You could invert this to avoid having 2 async show forms I think this way is more readable because we return early, isn't it? I like the other way more because it's a bit smaller and you don't repeat the show form. (Some integrations have it so that they have it 3 times, so this integration isn't the worst) Updated Config flow has a self.add suggested values function that would help Updated Is default for primary objects Don't we get anything interesting from the API to use as unique id? No, the API is very basic. Also, we may use several config entries for the same key (but different prompt, etc) Unused? Yes :) No need for this as this was only for old style integrations. THis one will only use the new entities. Removed You should make a copy or else the trace of older interactions with the same conversation ID will have the same list, including future messages. This is only used once, does it make sense to have it in an inline-function? Should we move it outside of this function instead? Moved outside.
Use runtime data instead No import? Why is this limited to a single entry? There were too much moving parts currently, I think this requires a bigger refactor at the moment Should move to async setup ? Broker is not available back there
We have the same thing here as in We have a list of possible values. Would be nice if they was generated on the fly. But I'm not sure how we can do it, as the device need to provide data before we can make them. How do you mean generated on the fly? In all cases we wait for data before creating entities That is what I mean. It would be nice not to define those cases like CPU , Local and PHY here. I think we also briefly talked about it in 116737 that we could make those entities based on the data coming in. But I'm not sure where and how to start. If you know the structure you could iterate on the content of them and use the keys as name I guess? If I understand you correctly. Thinking again about it, as this is about generating the descriptions we can't be reliant on any runtime data as this needs to be setup before reading any data from UniFi See the changes to the sensor platform here I think I've applied similar changes now Copy paste issue. I still think we can change device temperature method in such a way that we don't need this TYPE CHECKING step I still think we can change device temperature method in such a way that we don't need this TYPE CHECKING step Still not 100 sure I understand what you mean here? Do you mean that device temperature cannot return None ? If you can make it always return the expected container fo example If we do that, then the supported fn need to verify that the container have a value I tried to return {} but that is not possible. Is there another way we can achieve this? You could change the device temperature to return the value or None instead, then instead of type checking we could do return temperature if temperature is not None else 0 or something along those lines If we do that async device temperatures supported fn will always return true. I think that is worse? Added something in b11c2b49a474599a40d0336fd74dfdb2ca7e9141 I was thinking something like this return 0 is not reachable here as supported fn will make sure to not update the value see entity.UnifiEntity.async signalling callback Maybe something like this Still no coverage here Lets make sure the deterministic part is first
If it's a light, shouldnt it also be a light platform? It is a wall switch whose usage is for simple light : I am perhaps wrong thinking the correct platform is a switch for this type of device ? Oh then it is a switch Corrected. Corrected. Stale Corrected This should follow the logger in the library btw Done Done
Can be set outside of the constructor Make the step the parameter There's a helper for this, don't know the name but I think discovergy uses it yep async update reload and abort Self.entry is always none when its not a reconfigure You can auto update iirc for what purpose? I don't want to abort if the IP changes but the mac is the same But you do want to update the IP address in that case and not create a second entry okay I think I did what you are saying but not really clear because its undocumented if the IP changes during reconfigure, it will always update the entry if its a new mac, it will update the unique ID I am not sure what else abort if unique id configured should be doing since it only matters during a new configuration Rather split these tests up We should not mock this imo I think this can be removed since if we have a self.entry we are in a reconfigure flow for sure
Make unit tests, put this in there. Profit. Unresolved Comments are gone and I dont have the understanding yet to do unit tests and will run of of time very shortlly Remove the comments Only have stuff in the try block that can raise Don't catch bare exceptions outside of the config flow Please use an f string Honestly, just create the device info in here instead of creating it in init and passing it to every object We can remove this imo Might as well just implement the is on property. You can then remove the constructor all together I think i still need to do this for self.async write ha state() as auto update is off? That's the default implementation of handle coordinator update Why isn't this in the library? We can remove a lot of the comments and make it much simpler Surely the data presentation should be down to the integration? , The library does I would expect in this case and gives me the results of my query. But you could also argue that this is part of the protocol and the way the response should be perceived, and this belongs in the library You could , and you could argue this is good defensive programming and response should be perceived by the presentation layer not hidden by an intervening api as we might be able to use that subtlety to better present the data. I have been bitten by the curse of the API hiding that to many times. comprise take it out of the async update data cand all something to do from there it in the class in say prepare data uncluttering the Update and an being clear on the data manipulation for presentation? I mean, i dont mind it being here, but we should not make it too complicated with alle comments and stuff. We should rather introduce unit tests to make sure the data is perceived correctly I think this code would still need to be there even with unit tests but I can take out the comments about the status Items I haven't used or manipulated for presentation, they were more an Aid for later. Please don't do this, use translations Why don't we create the device here? Means taking stuff into the entity and it was how airgradient did it ;-) Oh, but that's because we don't have all the info in all the entities because we have 2 coordinators. But I think you can just complete the device info here Yes think I might well end up there too, with more entity types, but having thought about It quite a lot last night this seem to be the cleanest approach as it contains all the server setup stuff(inc device) to init and then I can just link pass on to that. ? I dont think the context is needed here Recommendation Let's make these more human readable
This can be combined with a generator expression I'm not overly familiar with python but from what I understand, your suggestion won't work as-is. Can you elaborate on what you want me to change? updated What's this for? Probably not needed. I'll remove and re-test. Name is required. Fails to initialize if I remove it. Do we use it in the base class? (If so, could you please post the link because I'm on mobile) It's used in the callbacks of this class. L81-L84 Oh can we rename this to zone name ? name kinda indicates that's it's the entity name done What's a damper exactly? The [damper]( is how each zone controls how much air is allowed through it. It can be fully open, fully closed, or anywhere in between. AirTouch5 is a multi-zone AC. There is a central AC unit with ducts going out to each zone (usually a room), each of these ducts has a damper inline, the damper controls the rate of flow of air in to that area. [Damper example image]( Too fast Honestly, maybe a valve would also fit here. But I'll leave that up to you two Oh never mind, apparently we have a device class specific to damper, so cover is the best I would assume It is okay (although not recommended) to manually control the damper for zones that have temperature sensors. I think we remove this test and always allow it, we should update the documentation to say this isn't recommended because the AirTouch5 unit should be controlling them (assuming you have AT5 temperature sensors, which you really should have!) I'm happy to do that. I haven't made the doco PR yet but it's on my list of things to do. Now you can combine those Is static, thus can be set outside of the constructor Let's use a translation key Good point! I'm missing a translation key in the class Also let's call it something better I reused what was in the base class. L12-L17 L3 Happy to change it if you still want me too. Updated translation to "damper" but left the climate translations as they were.
Stale? Stale? And typo
resolved resolved Why do we remove the binary sensor one? because that translation key is not being used in the binary sensor (and it was me that added it recently) Also please overwrite the type outside of the constructor Hmmm.....I'm unsure what you mean by the type outside the constructor . I can't really see which other types would need to be updated? You mean like this: entity description: HiveSensorEntityDescription ? We don't want to make these strings, because not all values are strings Please also add the on and off ones, they should be references completed completed
There's not much I can do here, is there? The format is specified by ruff. I think it's short enough to be on one line, but the comma at the end makes ruff go to the second line. But it's also possible that ruff adds the comma, in that case this can be ignored Stale Replace state with attr is on Only have stuff in the try block that can raise I think the update is run by default Not sure why we call async refresh The API doesn't have an async refresh function. Lol Oops, sorry. All this async stuff is still partly "magic" for me and it's not always clear to me when a function implies a certain functionality just by its function name and when what is executed where. Basically I just wanted to update the coordinator to get the current switch state after switching the switch. However, after thinking about it again, I think I don't need to do this at all, as the update process is handled automatically via the is on function. If I annoy you with my trial and error commits, feel free to ignore the merge request for now. I will remove it from the draft status later. If it still causes too much noise, I will gladly close it again to reopen it later. Best regards and thanks for your feedback. Why in the async add executor job? I've never seen that, so just asking It's for running sync functions that do blocking IO Okay, then it's wrong, as the api is completely async, including this function. That doesn't work like that, as the self. api.get device power status() returns a coroutine, which doesn't contain the value or anything, so you' have to add an await before that. In addition, this shouldn't be needed, as it's handled already And no IO here as well, as it's a property Firstly, here's the same with the coroutine, secondly, as mentioned in the docs, this function mustn't run any requests and must only return from memory, thus making this obsolete. the update should be implemented in an async update function instead. Idk, but running await self.async update() may be needed here, but I'm not sure, another one will have to verify I have tested it locally in connection with my inverter. And it looks like it works without an additional await self.async update() at this point. Yes, the other integrations also don't call the update function Same with running update here (maybe) Finally runs always, so you'd be making the sensor available always Isn't needed, implemented automatically Implemented automatically as well ohh, that is nice. thx for the hint
Moved if old major version 1: out
Should we keep these alive for 6 months and raise an issue when added used? We can remove them if someone disabled them We can remove them if someone disabled them I don't think that will work: the swich entity will not be set-up anymore, so it will always be unavailable. If we do set-up the switch enity, removing it here does not work because it will be re-added in the next step when the platforms are set-up. We could keep both entities around for 6 months, but it is a bit confusing to have 2 entities doing the same thing for new users. Besides, because my code uses the same class for all switch entities it is a bit of a pain to implement deprication code (raising the issue) specific for 1 entity. I guess I could make a seperate list of depricated entities and during setup check if it is enabled or not and only set it up if it is enabled and then raise a repair-issue. That would be the nicest, but also the most work to code..... hahaha You can set up both entities, but only if the switch has been added before as it is not disabled yet. I will write some code joostlek alright, finished, could you take a look if this looks good to you? Still need to test when I get back home tonight, so do not merge yet. But you can already approve if you think this is alright. It is deprecated and will be removed changed, thanks You already have HDR in the switch so you can reference done Can't we just search for the entity directly? I don't know how.... We know the complete unique id right? We can find the entity by the unique id iirc The start of the unique id has 6 diffrent possibilities depending on how the camera is connected and what firmware the camera is running (if the serial number is available). Aah check, in that case its probably suboptimal to check 6 times Thanks, I adjusted the spelling error throught the PR. Can we avoid adding more if statements to the tests? yea, sorry missed this. Removed it now. I have a personal ick for the const.DOMAIN , but that's personal preference I also find it very confusing that in entity registry.async get or create( the domain is supposed to be "switch" and the platform supposed to be "reolink". In my head this is the wrong since I always though the domain is Reolink and platforms are switch, select etc.... But anyway. Lets leave this for some other PR. It also confused me many times lol We shouldn't create an issue just because the entity is enabled. We don't know that the user is using the entity for anything. Praxis is to create an issue if an entity service is called or if the entity is referenced in an automation or script. I will keep this in mind for next time. However in this case this entity is disabled by default, so when a user enables it, I think it is safe to assume the enity is also beein used. Maybe they activated it and forgot about it?
Stale Do these all have an action directly? Or is it just a step in a series of steps to perform an action? all of these are direct actions But like, one is open settings, so does that open the settings menu and then you have to get the remote to do the rest? it opens the settings and the user can send the commands to navigate menus themselves via HA Yea but it's not an action on its own. I'd see this as a thing in a remote entity, not a button entity imo okay np I removed the menu stuff Use the device class reboot and remove the translation key to use the device class name stale stale stale Please overwrite the type outside of the constructor These can be removed now right Do this in a separate test
Can you give examples of what the state would look like? Does this help: ![image]( If there are only 2 states (on off), they should be binary sensors. I know we had this problem in the previous PR, but instead of trying to get into the same discussion, can we try getting into the constructive discussion on how we can get the integration on a point where we can add those? Feel free to message me on Discord? I'm happy to help out and support where needed. The reason I chose a generic sensor over a binary sensor is as follows: The data returned from Hive contains a number of elements, which include sensor data and binary sensor data. Hive clearly makes a distinction between the two. All the sensors that I added appear in the sensor data element (not binary sensor ). Therefore, I suspect that the values may not be binary. Even if they are binary at the moment, there's a risk that this could change in the future. But we add entities to what they are today, and not on what they could be in the future. If in the future it returns, idk 5 different modes instead of "ON", we have to make a breaking change and adapt the integration OK. I've converted the binary sensor candidates, but they always display 'On' regardless of the true state of the underlying entity. (I haven't pushed my changes.) That sounds incorrect. I was also quite surprised how the native value is acquired from the device in the sensor, can you maybe explain a bit how Hive works? I really have no idea on how Hive works internally. I'm just a simple home user that's trying to get some missing functionality working in the HA Hive integration. Do you have discord by any chance? yes, just joined. I see 2 ribbals in the HA discord, can you send me a message? These should be BinarySensorEntityDescriptions Completed Please collect all entities in a list before adding them Completed It should still inherit BinarySensorEntity Completed Please add typing Completed Completed What were the possible states for these? ON, OFF, SCHEDULE Can we make them lowercase and make these an enum sensor so you know what the values can be beforehand? Converted these to enums Temporarily removed the changes to this file, so that the rest of the PR can be progressed. This one is already done by the device class thus can be removed removed Please remove the icon as they are still translation keys Can we move the services to the bottom?
This doesn't work. The scan interval can already be changed in the platform schema as pointed out in the discussion above.
Slightly pedantic but maybe this should be called async update last restart to match the other update methods that are named after the associated sensor type. That's indeed a good idea. FYI: there's a new way to notate generics, so maybe that's interesting for you
Thanks! Are you willing to commit contribute to the development and maintenance of the Overkiz integration or would this be a one-off contribution? My idea is to actively contribute to the Overkiz integration, at least to add support for some devices that I have which are not supported yet. I would also be glad to contribute and help maintain the repository. However, if you prefer that I am not listed as a code owner yet, that's not a problem. I added myself because I thought it was mandatory. Please use the same style as the other line items. We leverage the UIWidget as an override, thus good to add which UIClass your device normally has. Can you move it up as well in the list? We sort this list alphabetically. Why not leverage the list here? Absolutely This one was not resolved yet :) It seems my comment got lost, but why do you need this? Especially since you are only executing a single command? I ve seen that there is a use of it in other atlantic devices. If I don t put it I see a strange behaviour when switching between modes: the device turns unavailable for a moment and then come back to be available again. With that wait, it works like a charm.
Only have stuff in the try block that can raise Let's use config entry typing is there an example you can point me to please? When I was writing the review I was still on my phone so couldn't give an example, thanks for asking I like, this is pretty neat, something I didn't know about until now, thank you :) Please update the name Please use invalid auth as that's a common name in the codebase Why do we warn here, we already know what the cause is right? Can you elaborate on what a device id is? device id is a unique identifier that identifies the connecting device on anglian water's side, usually its a form of the device fingerprint that runs the android app. Leaving this alone will auto generate one in the background. Its needed to retrieve water data. So why does someone needs to set it? an optional step to use an existing device already registered to the account. A lot of this was copied over from my custom integration so in my case while I was testing it removed the need to perform a number of API requests to register the "device". I can remove for this though I have removed this, but it is still required otherwise we might overload AW's API with fake device registration requests. Would it help if you remove the device if the user removes the integration? Please add the return type of .data The default function doesn't have that parameter so let's not do that You don't have a reauth flow, so raise ConfigEntryError for now instead Please add the coordinator type in the entity typing Why does it have 2 loggers One is for the module that the integration uses, the other is for the integration itself. The module has a seperate logging namespace. You don't need to add one for the integration itself, just the libraries Please use icon and entity name translations here No need to add anglian water to the unique id Please use constant UoMs for this Should we also add a state class? To use entity descriptions proper, let's extend the sensor entity description with a value fn
Old config entries will not have the port field. You need to use a get() with a default. I suggest you dont set a default value here since then it matches old entries better. Thank you for considering my PR. Modified the code accordingly, should be compatible with old entries that don't have a port field. This should be a constant variable Should be a constant variable as mentioned earlier. Idk how important that is, but maybe set the 2nd attempt to another port, so we can see that it accepts changes after crashes. We are not testing library here. So that type of test should go into lib
Ideally, this would live in the library so other consumers of the lib have this data too. Also, just an option, hass.config.language can be used to offer translated names. Works for me! Can pick that up in a follow-up!
Please assert the mock call arguments too.

It seems unrelated to this PR. Yes, I am honestly puzzled here. I did not add this, however when rebasing on dev due to merge conflicts, these were a couple of them. I remembered that something with device assignments to template entities has been added in the last release and assumed that this was the change. Need to double-check that I guess. It seems unrelated to this PR. See above
Buttons are zero indexed, but humans want 1 indexed names It can use device class translations f8b77bd1e9d1de87c4d9c7b0558d3debd8a47505
I think if you change this to token: str oauth session.token[CONF ACCESS TOKEN] you can remove the type checking below Thanks! I think we can remove the "obvious" comments. Can we do this bump in a preliminary PR first so this PR only is for tesla fleet ? Please rebase now after bump is merged Done
We cant move this to ShellyRpcAttributeEntity because: - for sensor platform the type of attr options is list[str] None - for select platform the type of attr options is list[str] We cant move this to ShellyRpcAttributeEntity because: - for sensor platform the type of attr options is list[str] None - for select platform the type of attr options is list[str]
I fixed the types as they where not correct, I wonder why mypy did not catch the issue... Why do we need a service to list all the devices? We already have them in Home Assistant right? There are 2 reasons: - we do not have all the device types that the SwitchBot API provides (like Vacuum cleaner or curtains) - I did not find a way to get the attr unique id from the device or entity when providing a selector for that in the service screen we do not have all the device types that the SwitchBot API provides You mean implemented in HA? Yeah, not yet implemented in HA We should not create a send command service as that leaves the user without context. It's a waaay better user experience if we can contextualize the calls. So for example if you would use this service to activate something, rather create a service to do that activation via that. Or use entities to accomodate that action I am sorry, I am not sure I understood. Are you suggesting to add a service to for instance a plug to add additional commands ? I made the command service to be able to control devices difficult to adapt to Home Assistant like a TV (the interfaces were sto different that made me puzzled) and other non supported devices. I agree, making entities would be easier to use though. Yep, looking at this list, these could all be entities, yielding a way better user experience
Please remove all things that are not gathered device data. We should not include the execution state of the objects in the library, like what callbacks are connected. That the code logic works should be tested in the library. We don't need that in diagnostics. Diagnostics is meant for data that we can't test, like user specific data in the config entry or stored device state, that will vary between users and we need to be able to handle all kinds of user data. Please explain more if you still think that this data is needed. So only keep device['states'] and the entry? Type, name, timezone, rssi sound ok too. I don't know what connection type means, but could be ok, if different devices support different connection types. Ie, data that is specific for the device is ok to include, but don't include data that just means something for the library and its logic. Done
Can we combine the call? Async add entities is quite expensive iirc Done in f9c4dbb0f0b52442c7ef78ddb54e077c6cc62383 Please use the freezer as well Done in 4b66f3589be4cc44ef5298cb7c07c7f84c6a3b37 Can this be added on runtime? Or is this something that is there by default? You could also make separate listeners for these and if the webserver is already set up, we don't attach the listener Actually you're right, so on a second thought I've removed the webserver and water heater from the listeners since those can't be dynamically added.
This integration has quite a good test coverage, can we add test coverage for these lines as well? .. Frenck This integration has quite a good test coverage, can we add test coverage for these lines as well? The coordinator is completely untested and I'm a bit stuck here since I'm not a pytest expert. Maybe someone can point me in a direction?
I think these will never change so cached property can be used instead of property Would be nice if 176 177 was a named constant from the lib or a function to tell its a ceiling light Yes, it would. I've asked LIFX to add this to their official products.json file, but in the meantime, there is no other programmatic way to determine what is (or is not) a Ceiling device besides the product ID. I could put this in aiolifx , I guess while I continue to push LIFX to improve their product definitions. I could put this in aiolifx , I guess while I continue to push LIFX to improve their product definitions. That would be a great solution for this case It would be a great solution for Home Assistant, but I'm not sure it's a great solution for aiolifx , to be honest. I don't want yet another technical debt because we've hacked something in before LIFX makes it part of the official spec, then I can't roll it back. I'd rather just do it here as a workaround so that other dependents of aiolifx don't use it. It looks like update products is already adding converting keys in L31 Maybe ceiling or similar could be added in L131 It's not adding or changing any keys. It's just creating a single more easily usable dictionary from the upstream production definitions: Would be nicer to build local vars for the args that do not change inside the loop instead of doing the same get each loop To speed this up, wrap it in create eager task Does this need to be sped up? not required but will reduce latency There are a bunch of other places where this would be far more effective noticable, I think. I'm not too worried about how long it takes to trigger a firmware effect in this instance, even across multiple devices. When I start doing some code quality improvement PRs, I'll pick it up then. The default will already be filled in the UI if no value is entered since its defined in services.yaml The default will already be filled in the UI if no value is entered since its defined in services.yaml The default will already be filled in the UI if no value is entered since its defined in services.yaml
Just a thought, we could just combine these steps into one, because the schema of the second step doesn't change Yeah that does make it a bit less complex. I've made the change.
Newer model seem to support up to 128K, might be a good idea to change max to an even higher number (unless I'm misunderstanding something). Perhaps. Mind suggesting a diff patch in this PR? I would happily increase it. The default size in ollama is 2048. So when DEFAULT NUM CTX is set to 4096 here it doesn't actually set a num ctx so the 4096 is ignored and it still uses 2048. One option is: - Don't set DEFAULT NUM CTX at all so that the default is None and only pass the context size when its not None - If you're trying to also increase the default context size, then this needs a different approach
For discussion, not a request: Should the name be "Last Observation Time[stamp]", "Latest Observation Time[stamp]" or something like this? There was a report from the very beginning of this integration that some stations provide incremental observations, e.g. temperature every 15 minutes but wind speed is only reported in the update every hour (I can't remember the exact details, but something like this). To solve this problem, pynws uses the most recent data from the requested time interval, and thus in this integration. But I'm also afraid this distinction is too hard to convey, so also can see the argument for your version of the name. As an aside, this is one of the reasons why I'm reluctant, but not outright opposed, to let users configure the integration asking for 24 hrs of data from the API, even when this sensor is available. I'm not wedded to any particular name. Out of the ones you suggested, I like "Latest Observation Time," since "Last" sounds a bit final. I only chose the name as a literal concatenation of the API endpoint and key name for consistency. I know some observations are more granular in time resolution, but I don't think we have to worry about that. If there is a desire to display all of the intervals within the larger timeframe, we can worry about that later (we'd have to modify how pynws returns information, anyways right?). we'd have to modify how pynws returns information, anyways right?). My comment was mostly about naming. I don't think we should add more complexity here. I like "Latest Observation Time". This comment was addressed. For some reason I cannot "resolve" this comment on GitHub.
Do we want to move forward with this dispite lacking ATTR DATA support? Not sure how that is used. As we should keep the old service for the deprecation period we could deprecate the use of it? It has quite a lot of features in data: So i dont think we can deprecate the old service untill we replicate some of that. Maybe the data could ve namespaced by some domain key. That way it would work with group too. So i dont think we can deprecate the old service untill we replicate some of that. Right, in that case it seems not we can deprecate the old service. We could consider to implement both, the entity and legacy service? We could deprecate the old service as soon as the new entity service is ready to replace it. Another option might be that the new entity based service implements templated notifiy entities that can be set up via a config flow. In that way the user can still send the message to the entity, but the formatting might be no longer part of the send message service call. We likely need config sub entries in place for that, since the data to add would be quite custom. But the idea seems quite sound. That said, i have never ever used any of these advanced features so not sure how they are used :)
This moved code, and is legacy from yaml when custom urls were supported. It should be deprecated at some point.
We do we implement 2 methods here as we do not seem to use the empty label. Sorry i think i don't fully understand you. So we have 2 methods here, one to add just a label and one to add the label with a locale. Because the supported modes attribute does only accept a label with a locale a placeholder is set as locale. Later when the supported modes field is added to the capabilities object the placeholder is replaced by the default locale en-US. See line 244 in resources.py. I did this because then there is only one place that uses the default locale. If you think that is confusing i can just replace the placeholder with the default locale. Same here
We should increase the minor version instead, as we were adding a new field. Please adopt the rest of the code Can we add better typing for this function? So wait, in the config flow you add the option for users to select HTTP or Serial and in the migration we set it to http ? Let's make the config flow also provide lower case names and use translations to make it look nice for the user. No need for this. You can just check the mock entry . It will use the same object Please use the constant
You should probably reuse the reference from seat heater since I don't think there needs to be a new translation for Low, Medium, High Thanks for the quick review. I've updated the strings.json per your advice.
We already have this in the device info, no need for separate sensor We can add a frequency here It reports it as frame rate not refresh rate - 23.976p I can convert it, but seems hacky IMO because 23.976p has a specific connotation besides refresh rate (its a progressive signal) What are the possible values in order 1. 422, 444, 420, RGB 2. 10bit, 12bit, 8bit 3. 601 PAL 709 DCI 2020 4. PC TV If these are all pre known we should use enum sensors to allow users to be able to preselect them in the automation editor and know what the possible values are if native value is None it is rendered as unknown and that is a good thing imo. Please remove all the names to make use of the translations In this case, might as well just create one big data update and call this before the snapshot and make the snapshot snapshot all the updated states In the previous test I liked the old name better since it was more readable. GPU temperature looks better imo Please use the snapshot platform helper in this case This change is unrelated its not related but makes the code a lot easier to work with But it should go in a separate PR as its outside of the scope of the sensor platform reverted Can we bump in a separate PR? no its required to fix how one of the sensors works No but please bump this in a PR before this PR why do we float(str(? fixed Just a thought, would it be maybe more useful to return width and height in a separate sensor? Like I am thinking of use cases for this entity, and I can only thing about a display use case or when the values are separated this value is commonly used to match to a know set of resolutions so it would not be useful if separate
You can assign the coordinator to entry.runtime data This can be reduced to only returning the await Move this to the else block Do we know if it responds differently with invalid credentials? Then it will raise AutarcoAuthenticationError Let's also catch that and show a proper error for that the public key does not change at runtime, so might as well just asign it to a self.public key to avoid a dict lookup every cycle use the typed config entry from . get it from the config entry can be merged and the list can be removed as the async add entities can get a generator expression not needed Let's make HA create its own entity id so the behaviour is consistent with other integrations You could also do And make both the entity description and this class Solar specific. This will help when you add the inverters Should we use the public key as unique identifier here? Name can be static can we use data description to add more context to the fields? if we only have one we don't really need to parametrize this
What is the reason name is removed here? This file is generated. I don't think I manually removed it. I added it back but it was auto removed by script.hassfest I know it is generated, which makes it even weirder that it happened. Maybe the integration name change was what temporarily caused it. Why is it called twice? My bad. Removed. Can we use the self.add suggested values to schema helper? Don't log on info Personally think we should keep reauth and reconfigure out of the picture for now These can both be set outside of the constructor Don't log on info Can be omitted Is this an entity? Yes Then we should not set self.name directly Wait, are you sure? I thought Provider is not an entity. Sorry this is the legacy provider. The one above is the entity. Why do we set the state to a default? We should patch this where we use this Personal ick Consider creating this a fixture as you do this quite a lot here We should make sure the tests end in either an abort or create entry to test the flow is able to recover On errors I don't abort but rather show the form with the error without moving to the next step: ![image]( Since this is the very first form and there is no state I don't think it's worth complicating the test setup and continuing the flow which will essentially retest test user flow success Why the state? why do we do this?
Please run hassfest again, it should also add the tests as codeowned done Is there a way we can detect the protocol by the host? How does the user know which one to pick? We can't detect the connection method, but it depends on how the user is connecting Iskra's devices. If they use a smart gateway (WiFi to RS485 IR Modbus) to connect energy meters to Ethernet, they should use the REST API. However, if they use a Modbus RTU- TCP gateway or any Iskra measuring device that supports Ethernet connectivity, they should use Modbus TCP. In summary: - REST API: meters connected to Smart gateway - Modbus TCP: meters connected to Modbus RTU- TCP gateway or Ethernet-enabled device But can we probe and try the other one if it fails? joostlek I can do something for sure but i'm not sure it would be okay. I can probe if the device responds to the REST API. If not, I can assume it is using Modbus TCP and prompt the user to enter the Modbus address and port. If that's acceptable, I can proceed with that approach. However, we can't be certain it should use Modbus TCP in that case, as the user might just enter the wrong IP address. We also support UDP broadcast discovery(not standard), which could later be added as a zeroconf method. This would work for all devices, except if the user sets the smart gateway to require authentication. In such cases, the user would need to enter credentials. Zeroconf works with mDNS instead of UDP I'll have a think about the rest any updates? changed Let's at least pick snake cased names changed to snake cased names This cant happen removed iskra aqara? Removed. What entities does the gateway have? currently only number of connected devices, but i'will add more in follow up pull requests. It also has pulse counter and temperature sensor user can use, tariff calculation and other status data. Can't we see the amount of connected devices via the HA? true we can, will delete this entity as it's unnecesary Let's move this to entity.py moved Let's move the creation of coordinators to init .py fixed This looks very complex, can we maybe move this to a follow up so we can focus on the normal devices first? I agree, but this is a crucial aspect of our measuring devices. It is a bit complicated, so let me explain it further. All our devices, including energy meters and power quality analyzers, have energy counters that measure electrical energy. These devices contain a few non-resettable energy counters, which users cannot reset, and a few resettable ones. This is why there are two for loops in the code. Resettable Counters - Customizable by User : Users can configure each resettable counter to measure: - Imported or exported energy - Active, reactive, or apparent energy - Total energy or energy for a specific phase of the meter - Example Use Case : This customization can be particularly handy. For instance, a user can set a load such as a central heat pump on one phase and a sanitary heat pump on another phase. They can then see the consump
Lambdas shouldn't be multiline It's a single function call. Do you suggest I make the variable names shorter so it can fit on a single line? It gets formatted this way automatically. Im not exactly sure about the motivations here. But for me when I could t fit a lambda ok one line i needed to either short it or define a method separately I replaced the lambda with a function def, enable charging and disable charging Lambdas should be on a single line Done.
Could just use the same TIME TRIGGER SCHEMA and don't need to make a new one without the check for a template? I tried that at first, but when it renders after the template, it should only allow time and the entity domains. It was allowing integers, and other types because cv.template allows those to pass validation. I wasn't sure how to get past this fault without separating the 2. I'm not 100 familiar with vol.Schema, is it possible to make a schema and extend it while adding a message to it? I couldn't find a way to do that. Looking at the code L235 , msg is a property. I could extend and change the message, however I still think I need the 2 validators. Thoughts? I just looked into this more, it's not possible to extend the schema or use the same one. I'd need to insert cv.template into the vol.Any object and it's not possible. I'm going to leave this as-is. This would never be used right? So we could just set the dict directly on the render complex call? I only added the access at the top of the method because everything else was accessing the trigger info there. I can access it in place. I just followed the path of trigger info, looks safe to just access it in place without the or {}. Template.async render accounts for None. Will move. Seems forgotten to be removed
Let's keep this alphabetical What do we have Ruff for? Done For a lot of the checks. We also have a pylint rule that checks if PLATFORMS variables are alphabetical. But this is a dict, not a list, and it's called DOMAINS AND TYPED hence there is no check for this. But I personally do really like when these lists are neatly ordered to be consistent with the rest I added it as the datetime platform and later just renamed it. Shame on me Shouldn't the entity be unavailable in that moment? Or are there other moments when this can happen I had the direct service call in mind. And at least during testing the device when Homeassistant first connected to the device (after bootup) it was available but no time was displayed, meaning the coordinator had to data yet. Something I want to investigate and possible fix in a separate PR But why is that the case? you're now raising an issue that the device is not connected, but from your response I also guess that it already was connected, so what should the user do to get the data? Removed if you ever need to migrate you can just do .split("-") Done Let's name this entity BroadlinkHysenTime, as it is specific to the Hysen class, and we may want to add other types in the future. Do you think other device types would have a fundamentally different time platform? The data used is retrieved via the broadlink api get full status Yes, although we currently only have this device with day of the week and time in the API today, this structure could vary depending on the type of device in the future. Some devices might include day, month, and year, while others might include timezone information. Do we know of a device which is available today or will be available in the future? Or is this an assumption? It's always an assumption when it comes to Broadlink. When we don't know what is going to happen, we better keep it flexible. But I am totally okay if you want to leave it as is and change it later if we need to. Let's add some flow control to ensure that if the entity is of type 'HYS', then we add BroadlinkHysenTime entities. Otherwise, we do nothing. While I get the idea I think this would be different then how filtering is done for other platforms. E.g. L95-L104 Even if we do a good job creating a unified interface in the library, we could still have at least two types of time devices: weekday time and date time. Moreover we do already filter the platforms by device type: diff-de5887f91e2b6b4559fe8fe3c68b104fbbcc5048feb84a0db325be16527d87f0R39 Why should we do it again? It's about making the code more robust. This function accepts a ConfigEntry in its signature. It should be able to handle any ConfigEntry , without depending on filtering or validation by a higher level module.
Please import this one Use entity descriptions. That means you have 1 generic sensor entity, and then change what they return based on the entity description injected. You can also reap a lot of beneifts of creating a base entity, which is just the CoordinatorEntity, which you can use as base entity for all your other entities, so you don't have to set device info and has entity name everywhere Can be removed Why the bool I think we can assume coordinator.data and coordinator.client are always there will fail if its removed Traceback (most recent call last): File " workspaces core homeassistant helpers entity platform.py", line 598, in async add entities await coro File " workspaces core homeassistant helpers entity platform.py", line 912, in async add entity await entity.add to platform finish() File " workspaces core homeassistant helpers entity.py", line 1366, in add to platform finish self.async write ha state() File " workspaces core homeassistant helpers entity.py", line 1005, in async write ha state self. async write ha state() File " workspaces core homeassistant helpers entity.py", line 1130, in async write ha state self. async calculate state() File " workspaces core homeassistant helpers entity.py", line 1067, in async calculate state state self. stringify state(available) File " workspaces core homeassistant helpers entity.py", line 1011, in stringify state if (state : self.state) is None: File " workspaces core homeassistant components binary sensor init .py", line 293, in state if (is on : self.is on) is None: File " workspaces core homeassistant components madvr binary sensor.py", line 97, in is on return self.entity description.value fn(self.coordinator) File " workspaces core homeassistant components madvr binary sensor.py", line 60, in lambda coordinator.data.get("outgoing hdr flag", False) AttributeError: 'NoneType' object has no attribute 'get' When is coordinator.data None? pushed fix You can remove all the "on" clauses Please remove not needed I think Sentence case please Don't access the coordinator, please get the data push function via the mocks.
The option name and its definition are very unclear. Purely from an English or non-user perspective: Render True will render it? So templates do not work when render is false? Wat does "render" even mean? Have any other suggestions? I'm not too keen on the verbiage either. It was the best I could come up with at the time. always evaluate , when changes , on new value , always trigger ? extend , verbose , expand , etc? Wat does "render" even mean? Decided to go with trigger on new value
Let's keep this change for a separate PR This change seems unrelated to this PR. Please don't stack multiple changes in a single PR. I suggest to split this out in its own PR. Addressed in Unrelated change? This integration uses a coordinator, shouldn't that be used instead? Commented out code Addressed in I think we can eliminate the use of this method completely? If we store the device ID in the class, we always direct reference the values stored in the coordinator That is the default Removed in You might be able to leverage entity descriptions for your all sensors instead. Addressed in Why is a float conversion needed here? Omitting it causes mypy to report an error: Let me know if there's a nicer way to work around that. If your library is completely typed you should consider adding a py.typed file because then mypy can actually read the types from the library Unrelated change If we reference the name provided by the device class anyways, we can just as well drop the translation key and let the entity fall back to the device class translation automatically. Addressed in Should this be a test fixture instead? This seems an odd place to do this, this affects all tests. Addressed in Missing return type Addressed in The laundrify sensor fixture could be typed to make it complete Addressed in Same comments as above Addressed in Same comments as above Addressed in
Shouldn't you test that it's now excluded ? added a few more cases in bb960634d1c512286c674afac9721f4fb5944a15
Instead of using hass.data for this, use the new config entry runtime data: Updated to use the new config entry runtime data. This doesn't seem to actually do anything to test the connection? You're right. I removed it. What is the purpose of the online property if it always returns True ? It had no purpose. I removed it. Same as above, what's the purpose of the is on property if it always returns True ? It had no purpose. I removed it. The hub test connection function just waits 1 second and returns True so this will never raise CannotConnect You're right. I removed it. Please use the Platform enum instead L39 We can use the hub directly Can we somehow validate the token by doing a request? Currently we are only checking if it's any jwt token, but not if the token is a TriggerCmd jwt token I added an API request to validate the token. Not used I removed self. hass and self. name but I kept self. token for the token property. Please return a DeviceInfo instead Please explain where you use the callbacks? You are only adding and removing them, but the callback is never be called Good call. I removed them. For new integrations, we require the following: - Support for [the new entity naming]( has entity name-true-mandatory-for-new-integrations) - Entities and their attributes should be [translatable]( Please adopt your code to add support for it. I think I resolved the new entity naming issue. I'm not sure what to do about making the entities translatable because their names are based on TRIGGERcmd user data. I need to do something, I'll try to figure it out, but I'd appreciate any clues you can give me. Already set by attr name As this is assumed state please set assumed state to True or implement a call to get it from the api I'm not familiar with triggercmd but from the variable names I think we should create a device per computer
When returning datetime strings in Home Assistant, they must be ISO 9601 formatted. Ref: datetime.datetime.isoformat including timezone information. For example: 2024-01-01T10:10:10 01:00 Test has been updated. Not sure how that ever passed... Same comment as previously, I would have expected a iso formatted string here I had written it that way to match the existing assertion later in the file for following since . diff-b1ac5ab4e5ed3195f189b8d6a33d5b336fbc4de941bc5e2989ef1dbbd6bcc90fR93 Is there a style guide for dates times I should be referring to? Aah check that makes it consistent I guess .. Frenck
Let's store it in the config entry runtime data Unused Removed. If we are not doing anything special here, let's combine the two flows as we usually do. so: The intention was to have async step pairing() as a common call for both the user step and import step to reduce duplicate code. My other two solutions would be: 1) Duplicating connection logic (or making separate connection logic, which is what the pairing step represents) between the user and import steps. 2) Combining user and pairing step into one, and calling user step from data passed from import step. I thought this might be visually confusing, so went with the former. Oh I missed that this was also used in the import step. I personally always like to duplicate it, because it will be removed eventually, and you have to abort the flow in the case of an import flow instead of returning errors with the form. Yep, I did the abort to be able to combine the logic. If returning the errors is the expected behavior for the user step, I'll separate the logic. Logic has been separated. I think we can support multiple integrations from the start tbh Let's do this in a followup Same for these changes Please extend the typing of ConfigEntry as seen in [the blog post]( Please type this no need for the extra When do we expect to get this? We will get a NoPrimaryControllerException when there is a connected controller that does not have an ID of one. To provide context: The Russound MCA-C5 can be daisy chained (using their proprietary serial connection) up to six total units. On the rear of each unit, there is a dip switch to select the ID of the unit (1-6). Per the unit and API's instructions, only the first logical unit (Unit 1) can be interfaced over IP. In our use case, we treat all the daisy chained controllers to the primary one single device since that's how it's intended by the manufacturer. It's possible for someone to have a single unit on ID 2 that is hooked up to HA over IP. The API doesn't function properly (as expected) in this case so this is caught here to ensure that all controller stack-ups have at least the primary controller present. This exception may become irrelevant when I pull the logic out of the try-except-else since I was using it as a way to reach the except block. Cleaned this up so that NoPrimaryControllerException is raised directly by the find primary controller metadata method. Leaving this open for discussion clarifications if there are any. Let's try to keep everything out of the try block that can't raise. If I am correct you can connect, enumerate controllers and close and move everything else to the else: Moved the set unique ID out of the method. You are correct on those three methods. I also made the find primary controller metadata method return the exception directly so that is able to remain put. Let's not do this, because if I still have the YAML and I deleted the imported config entry, and created a new one, because I got a new IP address (its a bit tricky,
we need to guard for invalid data here as we have seen devices in the wild with malformed data in the hardwareAddress field. So my proposal is to convert this entire block into a small helper util which guards for invalid mac addresses (or the convert mac address util erroring) Thanks for the review. I'll look into it shortly. Hey, I looked into it and maybe there is more to it Maybe you can elaborate on those malformed addresses and what the concern is here. Since the matter lib will always return bytes for the hardwareAddress , a malformed mac address is not a problem, and you only have to check for excessive size. But that leads me to another thing, namely: What is a valid mac address? Looking at: L420-L437 It assumes a 48bit address. But IEEE 802.15.4 (or any other new standard) uses EUI-64, 64bit addresses, which is CONNECTION ZIGBEE "zigbee" in HA, although this is not exclusive to ZigBee and a device should either have a EUI-48 (traditional MAC) or a EUI-64. So there isn't really a need to differentiate between the two. There is also the CONNECTION BLUETOOTH "bluetooth" connection type, which is also a EUI-48 from the same pool of addresses. --- Back to the topic of malformed hardware addresses. A problem would arise (that HA currently doesn't seem to account for, and it's not specific to the matter integration) if the device reports a mac address that's not a valid identifier for an individual device. A NULL address, such as 00:00:00:00:00:00 , has the potential to match a bunch of devices. Also, at least half the mac addresses are multicast addresses, also unsuitable for device identification. Since this is not matter specific, this should ideally be handled by the "core" HA code. These checks should be made by the device registry. This is a bit overkill and doesn't belong here in an individual integration. From an architectural perspective I would propose this at the core level. I agree, that's why I added the comment to your earlier review. discussion r1668494242 Can you tell me where such discussions about architecture best belong? It doesn't feel like a bug report or a feature request. In the end, it's not that important to me, I just noticed it and am bad at ignoring it. (As evident by the over-engineered code ) Well, you could just make a draft PR against HA core and get feedback (or a merge that way) but if it needs a bit discussion first, its probably best to raise a discussion here: This was all I meant with my review feedback - just a try..except around the code that reads the mac address into a mac address string (as that can be an empty string or malformed junk) to not blow up setting up a device GeneralDiagnostics.Structs.NetworkInterface.hardwareAddress are (possibly empty) bytes . I guard against None and empty here. convert mac address takes these bytes, formats and concatenates them. The result is a string in the format ( "xx:xx:xx:..." ). I check that the string has an appropriate length for EUI-48 or EUI-64 addresses a
I think callback is not allowed on awaitable functions ( async def ). Yeah ok, should I run the existing method as a Hass job then? For example: It works, I'll just need to update tests. This is still relevant Just remove the decorator. The dispatch helper knows how to call coroutine functions as well as async callbacks. Please use constants Got it. I'll open a PR for the rest of the tests. How does an ID look like? For the Beosound Level, the built-in sound modes have ID 1, 2, 3 and 4 and user-made IDs start at 100. This would make the Optimal sound mode's label Optimal (1) . So no huge numbers. I think we should catch KeyError and wrap in ServiceValidationError since the base entity does not protect against trying to set a sound mode which does not exist: L392-L397 I've added a check for if the sound mode is in the integration's sound modes. Please add a test which exercises this path Ah sorry. A test has been added now. We can remove .keys() . Copying a dict to a list copies the keys by default. Got it. I've created a PR to fix this
Why do we enforce this? Why don't we allow if someone uses 2 deako bridges? Good question. We only need one device for a successful integration. A second bridge won't be beneficial or net any other devices. I tested removing this constraint and on larger installations, the discovered devices menu is flooded with all the devices that could be the bridge. There's one instance I can see for two bridges and that would be separate installations on the same network. So you would have two sets of devices, but there's no way to distinguish what devices are a part of what installation from the advertisement data and even with the local API, there's no way to determine if a device is part of installation A or installation B without comparing the device list of multiple devices. Can you elaborate on this? the discovered devices menu is flooded with all the devices that could be the bridge. Yeah so I have access to a larger installation of Deako devices ( 100) and due to their behavior with getting online to check in, there are always more than 10 online at a time roughly. By removing the constraint that there can only be one active config flow via the DOMAIN, the discovered section in the integrations menu will now have all the devices listed as separate Deako integrations. We only need one to act as the bridge, so having all those listed there is misleading. And why should we connect to a bridge if we can also talk to the device directly? Not every device is guaranteed to be on the network and often most devices are not. The bridge device gives us two things: 1. the list of all known devices, whether on the network or not 2. access to the encrypted BLE mesh network for control requests How can we detect if the device is a bridge? Good question! Any device that's on the network can be the bridge device. The device that is selected as the bridge device (aka connected to with a socket) will no longer advertise I believe. I would have to confirm with the firmware team. No but how do you know if the zeroconf message is the one sent by the bridge? All of the zeroconf advertisements are sent from devices that aren't the bridge, just ones that could be the bridge. This flow is essentially bridge selection where the first device that advertises is the bridge. Mind sharing the zeroconf debug logs? Like I think I start to know what you're getting at, but I want to be sure. So I talked to firmware team, device continues to advertise when it's connected to as the bridge, but I think that's fine for the integration's use cases. I'll get you some zeroconf logs on the larger installation that I have access to. Here are the logs: [2024-07-17 11:06:18.log]( Can you do homeassistant.components.zeroconf: debug instead? You bet! Much easier to read. [2024-07-17 12:51:08.log]( Let's use the entry.runtime data , there's a dev blog post about that a month or 2 ago, I'm on mobile so I dont have a link Ooooo I like that. Thanks! Certainly cleans things up a bit. Can be merged Let's
We shouldn't use the event bus for internal communication in the integration. Future PR is planned to get rid of the custom events. I haven t come up with a good replacement for the camera urls or logbook yet. Camera urls should be easy to move over. The event entities and logbook need some more work with logbook in general as there is no way to describe them currently. That s not a DoorBird specific issue though. Everything in this integration has historically used events to communicate . It s quite old I could replace all the internal communication with the dispatcher in the mean time but it seemed a bit much to fire an event and also use the dispatcher. Its going to take longer than I had hoped to figure out the logbook so I'm going to open a PR to add the dispatcher. We will fire the event and dispatch until I can come up with a way to get rid of the custom events. We might have to bit the bullet on that one and do a breaking change to remove them in a few months after the event entities have been around for a while if they work out as planned
Changing the key, means also changing the unique id (see diff-58dcc591bbd6b0e56a5d7f1b6b1a4d38486cba28db575070dac071668ba9919aR220) therefore we need a migration for it. If you still want to change the key, you should please do it in a separate PR That is why the [ update unique id() ]( diff-d9ed91adf5c8ce40001603047a42a975ed0f7640a63d6af98b93d00784f56322) got extended (and the migration tests adjusted). We cannot do this in a separate PR as migrating the keys before changing [ handle coordinator update() ]( diff-58dcc591bbd6b0e56a5d7f1b6b1a4d38486cba28db575070dac071668ba9919aL210-R233) will cause failures. edenhaus just thought about it again, would you prefer 1 PR for migrating the keys and the update function and a second PR for adding the tire sensors? Created 121380 and will rebase this as soon as the other one is merged. Rebased after unique ids are migrated with another PR.
Don't you need slugify(coordinator.duid) here, you use it everywhere else? Yes you are right! Next time I'm back at my computer I'll make the change. It's unfortunately not too easy to do on my phone Added! This code appears quite a bit Maybe make coordinator.duid slug Also since it never changes you could make it a cached property so it doesn't have to execute every time Please split ternaries that span multiple lines into a normal if else Use .items() to avoid looking up the key every loop Missing coverage Looks like a useless delegation This is a bit more compact, but personal preference, not strictly required
Why is this needed? This is needed because i read the locale from the configuration. Since we should stick to the english locale in this PR (as you said in the next comment) this will be removed. I reverted the commit which adds this line. Let's stick to the English locale, in this PR. I reverted the commit which uses the locale from the config. Now every mode is using the default locale 'en-US'. A TV does not reflect a remote. The existing media player entity would be a better match. Alexa supports media player entities to control your TV: media-player You are right. There even exists a remote display category for alexa ( display-categories). I added the remote display category and used it for the RemoteCapabilities. I think we should not use the mode controller to turn the remote on The turn on is also implemented for the power controller. This code here sets the new activity. To use the remote's turn on service was the only way i found to set a new activity. Is there a better way? Even though it looks a little bit strange i do think that it makes total sense to turn on the device of the remote when setting a new activity. I opened a discussion for this: Personally I do not think we should call service TURN ON here. You need some tests for the handler code as well I have just added that. I am not sure about the mode controller. It does not seem to be picked up. (But I may be wrong), I am not sure if i understand correctly what you mean. It is definitely being used for the remote domain. I tested it, both with postman and Alexa itself and it is working just fine. I think this part should be implemented with an InputControlller instead (like we do for media player ). Yes you mentioned that before but i still think that this will not work. The problem when using an input controller is that you can not specify 'generic' inputs, only predefined values by alexa (TV, HDMI, DVD, etc.). The input controller already tries to match the given source list to the allowed values but this does not work for the activities of the remote, because those activities can be anything. The mode controller on the other hand supports any kind of names for an activity. If you really insist on using the input controller instead of the mode controller we should think about a way on how to match an activity name with an allowed alexa input controller value. My first idea for that would be to let the user do that themselves. The user could create a mapping in the configuration that maps an activity to an alexa value. The downside is that the user has to know which values are allowed and that it does not work out of the box. remote.ATTR PRESET MODE does not exist. May be add a comment why we use a mode controller in stead of an input controller here. Please also add a test case so this code covered. To add a test for this code i would have to add a test for the discovery response. I think this does not yet exists. Should i add this in this PR or create another one to add it? I
Let's try to be more specific about the added option than a combined entry specifying an Entity ID and an offset If we're anyway changing the comment, can we make it less misleading? We're not tracking all entities. unpacking a tuple like this makes the code difficult to read Could we use a named tuple instead, and something like:
We don't have this list in the lib probably? Unfortunately not. They are only mentioned in a comment at L424-L478 and L323C9-L328 We don't need to suffix the platform domain to the unique id. The entity registry is aware of both the integration domain and the platform domain of the entity. I copied this from other STT entities such as L56 If you are certain it would be fine and you prefer it without the suffix, let me know to remove it before the next release. Yes I'm certain. What we do need is to deduplicate each entity within the same platform type. Eg if two different config entries are used that creates two different STT entities, we need to have an id for that to deduplicate them (config entry id). If one platform creates two entities for every config entry we need to have another id for that. Addressing it in 126585 Missing return value typing. It doesn't seem to be missing. It returns AsyncGenerator[speech v1.StreamingRecognizeRequest] BTW, I've enabled strict typing for this integration and there are no complains. Sorry, I misread.
Could you maybe update the description of the PR to explain what this feature does and how it affects the integration? Thanks! .. Frenck Currently the component regularly polls the IGD (router) by calling several so called Actions (Action in UPnP terms, an RPC), such as GetTotalBytesReceived . In this case, these Actions simply return a State Variable (another UPnP term, speaks for itself I guess.) UPnP also specifies that State Variables can be evented. This means that a client can subscribe to a Service (which holds Actions and State Variables) and gets callbacks to when a State Variable changes. This prevents regularly calling Actions, saving some processing on the client side (in this case, the Home Assistant side.) Please do note that not all State Variables are all evented. The example of Action GetTotalBytesReceived , which returns State Variable TotalBytesReceived is not evented. The State Variable(s) we are interested in are ExternalIpAddress , ConnectionStatus , and PortMappingNumberOfEntries . However, some UPnP devices have a UPnP buggy implementation. Hence, we want the users to be able to fall back to polling for the mentioned State Variables. Generally I don't like options because they increase complexity. Given the wide range of devices this integration is supporting with various levels of quality, and different implementations of the spec, I think its unavoidable in this case.

identifiers is not needed if connections is set unless you need to use via device Please use sentence case Move this to the base Should this be in finally? Not even required, the library does this already When is this not known? Was supposed to cache the value and only fetch on first refresh but is not needed, the library already returns a cached value But what if we can't find it? We raise why the context? Leftover from settings entities, will remove it for now and re-implement it again later in another PR when I need it for the settings entities. Overwrite the config entry type in the coordinator. I would maybe suggest to do the same for device, but I think there is a reason you dont have this yet Let's try to omit the Unit of measurement here as someone could also set it to microvolts what unit of measurement? Voltage is a unit. but if the user sets it to microvolts, the name is incorrect. so maybe try to incorporate potential . Looks like a nitpick, it is, but its just a thing we have with naming But voltage is not a unit of measeurement, that's how it's called in english and what this sensor measures. And the unit of measurement for voltage is volt (or kVolt, mVolt, uVolt...). That is true now I think about it Please use Sentence case We have a common key for this one Why the super? Not sure, was autocompleted by vscode and i just left it like that I think it's unset by default it will just return None, so it's unnecessary anyway Instead of snapshotting, just compare the status against STATE UNAVAILABLE as now it's unclear what you're testing
Moving CONF HATER to init .py is necessary to avoid circular import between init .py and climate.py . If you wish, I can create another PR to move all constants shared between init .py , climate.py and confg flow.py to a const.py file. Yes i think that would make sense. 120789
please use more descriptive names (new-record and result say nothing about the content) In general, not a fan of a seperate helper file, I think the functions can be reduced in size and moved to the coordinator Actually I had it on the coordinator first, but decided to make a helper (I'm more fan of smaller files). However, you're the code owner, so I will do the change what is this by default? always UTC? or depends on wallbox config? hesitant about whether this should be something we do in HomeAssistant (or more upstream (or not))? Wallbox API returns always UTC time. I thought this quite a while as well, but I decided to covert the time to local for easier use in HA end. If you see it's better the other way around, it can be changed of course hmmmmmmm, let me think on finding a cleaner way I would like to skip the extra functions this can be a 1-liner I think, same for the other if's Most probably yes. I'm not very experienced with python. Mind sharing an example how to do this as one-liner? I think that you don't need to do anything if you just use the original dict right? but otherwise: converted["max energy" item.get("max energy") (this deals with missing values) why are we creating a new dict? we have a dict as input right? Same as above, not very experienced with Python (yet) :-) In Python the input data is always mutable? a dict is, just change the attributes by setting them dict['attrib'] new value One more thing about this: I'm creating a new dict since the service is not providing the full data received from the API. I'm mapping the get services output and set services input as same 'model'. Currently API returns some extra data that is not required accepted by the set schedules API. Meaning that you get easily get the schedules from the service, modify time and pass the same or slightly modified data to the set schedules. So, if I would re-use the provided dict (item) it would keep the obsolete data keys as well :-) If you think this is the wrong approach, please let me know and let's think a better way of doing this just remove the key that has to go, item.pop('key to remove', None). I think you can do this in the coordinator function. see comments above see comment above, should we do this in hass? not sure I think you can do this in a few lines without using a seperate helper file use better names again I think you can do this in a few lines without using a seperate helper file can this be async? i think you can skip this local time var, I think you are creating 2 idential datetime objects here. Suggestion: time obj datetime sys.strptime(time, " H: M") return dt util.as utc(time obj).strftime(" H M") And then just move it to the main function i think you can skip this local time var, I think you are creating 2 idential datetime objects here. Suggestion: time obj datetime sys.strptime(time, " H: M") return dt util.as local(time obj).strftime(" H M") And then just move it to the main function Went as that first, but bumped into an i
Use capitalisation consistently with the other sensors Yeah, sorry, my bad. Fixed!
Is this complicated config necessary? Why not use the default config from e.g. line 65? It doesn't harm either Well, it does not make sense. The mean circular characteristic is super special, does not take percentile as an input and sampling size provided as a float won't break anything but sets a confusing example. :) I can simplify it, I just used a random case. I changed it to use average, but the config entry requires everything else... Function name and docstring do not make sense. Also, shouldn't these be split up into two-three test cases? Edit: I can see that the first half of this testcase is a replica of the test case defined in the other file. Was that necessary? Also, shouldn't these be split up into two-three test cases? Can you specify which three you suggest? Was that necessary? What do you suggest? Deduplication? IMHO, that isn't needed for 2 occurrences. No I wouldn't spend that time. Many of the test cases start with similar initialization code. dougiteixeira I would appreciate a minimal config and a better docstring. After that the addition lgtm!! The sensor test only checks whether the device id of the source entity was linked to the helper entity. The init test, on the other hand, cleans up links between devices other than the source entity (the user can rename entities and impact the integration). That's why the initial part is the same, as I need to link a valid device as done in the sensor test and some stale devices. I improved the docstring. As I need to configure the integration to trigger cleaning, I don't see a way to reduce this.
This is odd... considering... (see next comment) This is a fixed method. If more entity description are added, this will not work. So IMHO, we should either: - not use entity descriptions just yet - or, add this call to the entity description I think this will be the only button looking at the Plugwise webserver. So no entity description then. That service call is already blocking Can we also remove the translation key? It would name it restart duo to the device class translations which makes it more in line with other integrations Plugwise calls is a reboot button. And I see other Integrations use "reboot" as well. We introduced this later, joostlek is right, we can just remove it and let the device class handle the translations (which means everything will be translated immediately as well, as it re-uses an existing key).
I think that it works best if "Responding to user" is also a tool call. That way it only has to call tools. This means that all response text needs to be json-encoded (i.e. all quotes escaped, all line breaks replaced with n , etc). And I don't entirely trust LLMs to do that correctly every time. When using a respond to user tool, how does the tool loop know when to stop? hard coded special case for the respond to user tool? (Are the other conversation agents doing this?) No, we are not doing it for other conversation agents, we let them to respond to the user natively. Anyway, the TOOLS PROMPT was a workaround that we don't need anymore as the ollama library supports the tool calls. We'll keep the type: ignore[typeddict-item] until is merged
Should this be awaited? This doesn't need to be a coroutine function since there's no await inside. Make it an async callback.
We have a fixture for this already. L45-L52
Currently the work area id is not exposed to the user in HA, so it'snot possible to enter it. Here are three solutions, I'm not sure, what would be best: 1. Generate a service, which lists the work area ids and the human readable names: eg: 123: Front lawn 2. Add extra state attributes to the work areas sensor: L338-L345 , which show the work area ids and the human readable names: eg: 123: Front lawn 3. Request to enter der human readable name here, and then search for the work area id. Problem: The names might not be unique. Edit: 4. Register all the work areas as Areas in Home Assistant and use the area selector. Help welcome. Option 2 is fine in this case. Please exclude the list from the recorder Services should always be registered to prevent from unexcepted errors like service not found in automations and co
This is not common so I think its best to keep this in the docs okay thank you for the prompt review, will fix these Comments dont add much Why the noqa Please use constants CONF Please use entry.runtimedata Please refresh the coordinator before assigning to entry.runtimedata uneeeded Only keep things int he try block that can raise why this doesnt this display the error in the UI? no the self.context why? The config flow is the userfriendliest way to tell the user they fucked up and thus something is wrong This specific part was added because it may be the case the device is not connected yet or set up but the integrator knows the connection info already, or maybe the device isn't plugged in, etc. I want to give the user freedom to move on and add anyway as they can modify the options after adding it We should confirm we can connect with the device before the user is able to setup. This way we can ensure everything works like expected. Why does init .py take into account that these values are optional as they always get a value from the looks of it Follow up You can then access self.config entry afterwards Stale euh? I had a HA error unless I added it but could have been caused by something else. I will try to remove Please type the coordinator to the type of data Let's not use the event bus here, what are we doing here The point of this is to send events when these values change. This is what the docs say to do. Is there a better way to handle this? I am asking a more global question, what does this do and how does the integration communicate with the device and vice versa It opens a persistent connection to the device and the device pushes data to the integration. The integration processes that data in realtime and updates its internal state. So the integration reflects the real time state of the device This code would fire events on the bus so users can create automations based on specific states of the device in realtime if they would like an event based system. I supposed they can also use sensor data (had to remove it because the bot wont let me add more than 1 platform but will add later) so I guess I will remove this for simplicity We should not add this. the user can set it up themselves This library is used to wake the device which otherwise is impossible to wake up. Is there a built in for this? Its unreasonable for a user to set up wakeonlan first then install this integration. Alternatively, I can bake this into my library and call it from the integration The user should use wake on lan for this. The library should not do this
I'm surprised by this combined with should poll not being overridden in the update entity class. Is the matter integration polled? No, the Matter integration is not polled. But checking for updates is. The device don't have a bulit-in update checking mechanism, so we don't get a notification pushed when there is an update. We could do the polling on Matter Server side. But it feels more naturally to use Core's polling capability. With this, one can also use the homeassistant.update entity service to force an update check. For the records: This turned out to be a bit odd in Matter in general: Matter entities generally get updated through subscriptions push from the Matter Server. Yet, polling was enabled by default (since that is the Core default). With Matter entities now don't poll by default. I've rebased this PR to dev again, and enabled polling on the MatterUpdate class explicitly (see diff-ac1ac949f539d395d65427ac886c148bf954020185229945fb6f1a87779ad811R73). Why does this method not just call self. update from device ? update from device gets called on every attribute update as pushed by the device. We don't want to trigger a update check whenever a random attribute changes on the device. What sets the entity picture in other matter entities? It is not being set in other places. This is more about overwriting the default behavior of the Update entity. Ok, then please rewrite the docstring to make that clearer. Maybe like this remove the comment: Why is this needed? If the entity is polled, an update should be scheduled after service calls It usually takes 2-3s for the device to get the first update progress state changes. Pushing the progress state change here, really improves user expirience: With that, the frontend immeaditly switches into a "in progress" animation. Without it, the frontend doesn't update, and it feels like the "Install" button is broken. OK, please add a comment explaining we immediately update the state to not have to wait for the real update state change. This is not needed Does this send a message to the Matter devices too or is it just a local update check? If the update button on the "Updates" page or the "Check for updates" menu button on the HA settings page is clicked, async update is called for all update entities. If an "image notify" message is sent to each device (e.g. via Thread) here, this could cause the network to be spammed for a short amount of time. So, if this sends a message to the device, maybe set PARALLEL UPDATES to 1 or another reasonable number for the Matter update entity platform? Does this send a message to the Matter devices too or is it just a local update check? This causes no communication with devices. It uses cached vendor product ID and version information to check for updates. The update check is polling the http get requests to the CSA DCL REST API. Maybe explain why the update entity is polled Added. Thanks for the review! Why is this needed? This is not needed, I'll remove it.
These strings are provided by the humidifier entity component itself. Got it, thanks! You can remove them completely as you have set the device class and it will use the name from the entity component automatically. I'm sorry if I wasn't precise. jpbede I tried that first and it did not pick up the name from the entity component automatically. Ok, my bad, this is not supported by the humidifier entity component. Just a nitpick for later, maybe we could avoid those magic numbers and use some speaking consts for it :) Ya definitely a fair point. These are unfortunately somewhat magic numbers in the documentation itself, but perhaps I could think of a way to better describe them.
I am not 100 sure what this attribute usually represents, but "fan mode" and "preset mode" sound like they are different kind of modes, so I'd suggest to call the label mode as well. Sounds good to me; I changed it
Should this be added as default? Why is there a force poll option added in this PR ?
We generally don't allow storing entity objects in a shared container It looks like you only need to know the .key so you could do it as self. features by entity id: defaultdict[str, set[str]] defaultdict(set) than subscribe in async added to hass with self. features by entity id[key].add(entity id) and return a callable that does self. features by entity id[key].remove(entity id) than drop the key from the dict when all are removed than replace entity description keys with something that returns the dict of subscribed keys Note that the entity id is stable for the lifetime of the entity object and if it does change, it will be removed and readded (new object) How should this be changed? Perhaps hass.data is a better place. It fine to store it here, and its fine to store the entity id . The concern is storing the entity object itself in the shared container especially when it might still exist after its removed from Home Assistant. I think this is solved now. Please review. If possible, I'd split the options flow into a new PR and let this PR handle the registering of the specific keys to update Dropped the options flow. Is this what you meant, or did you mean to completely remove the force poll related parts, such as diff-bf146bfe416cf0296a6c04f61fa6b8c1a9acb073dab44aab697d7f1eddc519d0R86 ? I think you do. Let me split it up a bit further. Done. It would be a bit lower risk of breaking in the future if you pass entity id and key so the there are no accesses to the entity object properties outside of itself. Fixed. We should avoid accessing runtime data in the tests, instead patch async subscribe services or if its already mocked somewhere else, assert using that mock. We are still accessing entry.runtime data here Fixed1 Missed this one the first pass, but keys() can be dropped here since its the default Missed this one as well , but commented code
This pattern is repeated in other platforms, consider making a AirGradientDescriptionEntity that subclasses AirGradientEntity and sets the unique id and description. Than you can drop init from some of the other platforms Will look into this when I merged all the platforms in for which I have a PR open :)
Oops this should fix indentation the types don't match either so i just reverted it Is 0 a good indicator for this case? Is it allowed ok to use something like "unknown"? Or even "unavailable"? I just used that as a defensive mechanism for the typing, it's technically always an int but the MetricValue type is an union of int float None not sure what's a pythonesque way to do it, in typescript i'd just do ...get(...) as T So could we return None here instead? Or maybe joostlek can provide some guidance in this regard. My concern is mostly that for the "normal" profile there is no concept of "profile duration", it will be active until one manually changes the profile, and it is the profile that is switched to once the duration expires for fireplace, boost or extra. So letting the sensor show 0 for the normal profile feels a bit misleading to me. so None for "unexpected" value AND default value? so that the value is None when none of the timed profiles are on? Yeah, I think that could make sense. Maybe a specific early return for the normal profile, and then we could even log something on debug for unexpected values, or WDYT? In any case, I really like this new sensor The thought that the Vallox unit could provide it never crossed my mind, even though I almost implemented something like it using template sensors in Home Assistant at some point Hold on. I am moving this block to the lib. Use new method from Could be an idea to bump the library version in a separate PR I guess. yes, lib version update needs to go in a separate PR. created 120395 for it
So I am wondering, would this be able to be split up to a select entity and a number entity? I think the select entity would work, but I won't be sure if the logic around it could be reflected correctly, wdyt? set profile method in the library supports setting duration. It works only for fireplace , boost and extra profiles. So I think a single set profile service would be fine accepting profile name string and optional duration. Creating int mappings feels to be wrong. I mean its not about int mapping, its more about moving to a service or to entities, as entities are more user friendly and accesible, the only question is, is this a good idea for these not that familiar with python, is there a simple way of having the parameter be coerced into the matching int enum of Profile from the lib? or how would the mapping be done? e.g. from "Boost" to Profile(3) Oh but that's not the thing I am worried about, you can indeed do Profile(3) . I am more wondering if it fits and if it can be done directly. two parallel conversations happening I think :) I'm not sure about either, my end goal is just to have a service to call from nodered to enable the programmable "extra" profile when my range hood turns on. But the vallox websocket api makes interactions a bit easier by hiding some of the lower level stuff. Separating this into two entities might mean splitting some of the existing stuff to use the lower level modbus registers. Like all the modes that allow timing, have separate registers for timing, and also a register for enabling or disabling the timers. And when setting a profile, it clears the existing timers for other profiles. Out of the box there is a priority order the device runs down. I would keep everything close to the api which is less likely to change. Don't use ints as profile. Pass in a string that you would map to a profile. any ideas why originally the Extra profile was not 'settable'? It's not included in VALLOX PROFILE TO PRESET MODE SETTABLE , but I could add it there and cut down on the definitions in const.py and use it to map the param. It is some firmware limitation. Vallox's Web UI does not allow to set Extra profile in 2.0.16 (which I currently use). does the HA side support some sort of conditionals based on the firmware version, it works fine on my .24 version if someone can verify how it works on .20 i could branch it to either .20 or .24 Why do you need that Extra profile? Isn t fireplace and boost sufficient for all the use cases? It's a separate configurable profile that can be used via digital inputs on the board or via modbus or the websocket api. I'd use Fireplace for the fireplace, and a differently configured extra profile to compensate for my kitchen air extraction. ![image]( This way i can avoid pulling a low voltage cable from the kitchen to the air handler, and just trigger the extra profile via a sensor on the kitchen range hood open close relay. edit: my kitchen air extraction is not via the vallox unit, so it ne
This code is very inefficient integration entities is frequently at the top of template profiles I see from users. I think we should avoid repeating that pattern
Pull this into a standalone if-statement and then conditionally add the FLOW CONTROLLER SENSORS and ZONE SENSORS. Since the conditional isn't something related to what you're iterating over, it's weird having it in the list comprehension. Good call. Fixed.
We should raise ServiceValidationError instead, and preferably we also add a translation key to make all the errors translatable :) Is this something that is always available? Can we read the dehumidify value? This could also be a button maybe Thinking out loud here, so feel free to leave your idea of it as well Can we gett the state? Would this be a select entity? Not needed yet Fixed Automatic can use a reference key to the other automatic in the file, (I'm on mobile, so I can't type one out for you) Wouldn't that then require referencing a different entity? You would essentially be referencing from fresh air mode to the air cleaning mode entity. Seems confusing. I would rather keep it as is personally. Yes, and that is no problem because it decreases the amount of unique translation keys You can make inverse mappings Updated What do we do with the unique id? Do we append something with it? It is used to generate the attr unique id on the base entity. This was how it was decided to be done in the initial implementation of the integration. Looking from the code it looks like every select kinda has the same logic, but I don't want to burden you again with "let's simplify it", so I'll try tinkering myself first before I jump to conclusions Refactored. It's a little awkward because each of them is dependent on two properties, but only one of them is actually updated. Hope the logic makes sense If we only have on or off, what about a switch? It's not really an on off. It's off or automatic. Automatic isn't really on , it's more of a "let the system decide what to do". I think a switch would be confusing. It would also over complicate the code because it would be one of 4 of the same type of entity to be different. I'd like to keep it as is. I see so this is the ventilation mode (aka fresh air control) - which is not the same as the fan mode exposed in the climate entity. This is different than a "ventilate now" switch that some hvacs have. While I proposed a switch in my initial comment, I do think a select is clearer. The list(set(..)) was because in the sensor there were a lot of duplicate options, but in this case everythin is unique, so no need to do this now Updated when the item isn't found, does that always mean the mode is off? Or can it be unknown because its not supported? Technically it's not possible. Per the documentation, anything outside of the values we have is "reserved", which means that it theoretically is a value supported by the protocol, but doesn't actually ever happen. The "off" is really just a failsafe. Stale Stale Maybe just create the inverse maps as a constant outside the class as well That would require adding a new parameter as well. Is there any real benefit to having the inverse maps as constants that then get passed in, as opposed to just generating the inverse map in the init? Can be combined
We create a task if its going to be awaited? Hm not sure why I awaited it. I use a background task since apply options calls set permanent connection, which connects to the motor If the intent is to wait for it, than it should be awaited directly. If you don't want to wait for it than its fine as-is except please use entry.async create background task Sure. I don't think it makes sense to make the setup of the entry wait for the connection of the blind in case a permanent connection is enabled, which is why I use a background task The permanent connection option makes sense given its BLE. For the disconnect time, why would the user need to change this? How does the user know what a good value is here? For the disconnect time, why would the user need to change this? How does the user know what a good value is here? It defaults to 15 seconds which I would say is a reasonable time for normal-sized blinds, and it gets refreshed every time an action is performed (like opening, closing of the blind etc). However, I can imagine some users would like it to be a little higher, maybe because their blinds are bigger thus requiring more time to open close fully. Also, it is an option , and I would say it is never bad to have the option to change it to your liking See this related issue: Please add some some descriptive text explaining why you would want to increase the value. Something like: The default disconnect time is 15 seconds. If your shades take longer to perform an operation, increase the disconnect time by counting how many seconds it takes for a full open-to-close operation to be performed and adding 5 seconds. Where and how can I add that? Is it possible to add a description to each of the options? Usually thats accomplished by extending the description field or for less important options, its added to the docs (but users don't usually see those) diff-67d46204179e211a11e8bffe64c02f3799c7f8bbcf8a1248013bf6b232f3691cR27 What about adding it to the description of vol.Optional , or won't it be translated in that case? Updated the description field to: The default disconnect time is 15 seconds, adjustable using the slider below. You may want to adjust this if you have larger blinds or other specific needs. You can also enable a permanent connection to the motor, which disables the disconnect time and automatically reconnects when the motor is disconnected for any reason. WARNING : Changing any of the below options may significantly reduce battery life of your motor!
The logic to connect to the device should be encapsulated in a package published on PyPi. The logic to connect to the device should be encapsulated in a package published on PyPi. Can I simply remove the requirements from manifest.json and use the aiohttp 3.10.0b1 version that is already a dependency in Home Assistant? No, you need to create your own library with all the calls to the device service and publish that to Pypi and use that Not needed Why the comment Not needed Please use entry.runtime data. Check airgradient for an example. You should extend the ConfigEntry type with the type for the runtime data. Use constants Not needed for now EV? Please add typing can be combined if both are required, why do you always use .get() ? Use constants instead We should check if the data is valid. The config flow is the best way to tell the user they did something wrong, so we should try to connect with the device to verify the data Please keep this for a follow up PR ? The coordinator should not be in charge of creating and removing entities. That is the task of async setup entry in the platform files. Check Withings for an example, the best example in there are the measurement sensors This sounds like some library specific things, can we move this to the library? Only have stuff in the try block that can raise The library is not licensed properly, please add a valid OSI approved license Remove empty fields Why is localizing a thing? Don't use state This is device specific, please move to the library This is an abstraction, we want to provide the device to HA as raw as possible Don't add extra state attributes Euh, why? Please check other integrations for how they do their config flow tests
Would be nice if this came from the lib in a future update Yeah, we discussed about this in private and agreed that it'd be fine to access the feature by its ID (which are now de facto a part of our stable API) to fetch the information from it. Changing this is not necessary for getting this in as there are no other fan devices, so this is just something we should improve on in the future releases. opened and assigned to 0.7.1 Makes it consistent with the base class which accepts only device coordinator as positional args. That's done This shouldn't be anymore required, as the parent class implements async added to hass ? Removed That's done although I'm still not convinced about dropping these prefixes as it's inconsistent with all the other names like descriptions, coordinators and config entries and now we get name collisions with the kasa module names. We can change that in a single PR for the whole integration, if needed. Consistency is the key, but we can rename all of these if needed. Would this approach also fix 114752? The issue that aimed to solve was "partially" provisioned power strips where the individual sockets were not named, leaving the children with an empty name. Yes it would fix that Move the comment above the line, this will make the code itself a oneliner. Done This reads odd, when the super() is called with parent directly after the statement, indicating that this should probably be done on the base class. Fixed, wasn't needed This could use a comment why it's necessary to pass wait background tasks . I typically always do this in tests as I've experienced intermittent issues without it and I think it's good practice. I can add a comment referencing the 112726. Comment added to setup platform for device in init. I need to remove this
I just picked values here that I thought made sense, but the API allows for up to 100 days of activity, so these can be adjusted if we think more or less is better. This is pretty conservative as well, with 2 base stations I m only hitting around 1100 API calls day, but I don t see any reason to go less than 15 min intervals. You can use itemgetter here instead of a lambda operator.itemgetter If its always one preference here, but I'd probably write it like this At some point, in a different PR, this integration should migrate to use runtime data Avoid fetching time twice by saving dt util.now() and than adding the timedelta to it. Also can utcnow() be used here or does it need to be in local time? Good question. I don't know that it couldn't be UTC, but I guess I'd prefer it be local for events that fall on the edge of the time frames that might be omitted otherwise. For example an event 7 days ago where the current UTC time has moved to the next day would be left out, if I'm thinking about that correctly.
This should be EntityCategory.CONFIG since it's an entity that allows changing something about the feature. Then maybe the notification idle buttons should be changed too? Yes, good. : 1:

Why don't we remove these devices automatically during config entry setup? We don't know during setup the status of the device. Devices are added during runtime when we get a broadcast from them Ok.
could be a set to avoid a linear search but won't matter unless this list grows quite a bit
The unit and formula for calculating value are modifiable by the user during runtime, so we do not add a unit and state class for this sensor. Should this be diagnostic ?
Could we add a testcase for this? I take it, it's not possible to set holiday or summer via the integration? In that case we should maybe raise an error here instead to tell the user they need to turn off holiday summer via the app (or whatever) as it's not possible here. exactly - holiday and summer mode are configured via the device hub, but not the integration. At the moment his PR includes code, which changes the list of available hvac modes and preset modes - based on the configured holiday or summer mode - to only each one available mode, so it is not possible to select any other hvac mode or preset for the user. But we could change this to not changing the list of available hvac and presets, but raise an error to tell the user, that a change is not possible ( as you suggested ) after some thoughts about it, I think we should still change the list of available hvac modes and presets based on the holiday summer mode, so the user can't select any unavailable hvac preset, but should raise an error when needed Could we use is False instead as I read it initially as the attributes was removed while they are not
those variable are only used once anyways is this the main feature of the device? If yes, set the name to None I didn't quite follow this comment. One device can support multiple systems and zones. Each (system, zone) pair maps to one ClimateEntity. If a devie publishes only one entity - the main entity - which it looks like you're doing here, we set the name to None, so it follows the device name required for new integrations no need to save them if you set the unique id here Actually, there is no self in scope here? dealt with this in the init no need to set to None use the attr instead also please the attr you didn't address this one what are you doing this for My understanding is that not all of these attributes are valid in all HVAC modes. I.e., the high and lo attrs only make sense in HEAT COOL, and target temperature is used only in HEAT and COOL. So, I'm clearing them to enforce the invariant that target temperature attrs are only set if actually being used. I'll add a comment to that effect if this makes sense to you. is default since you're only using this once, move it inline, so you also can get rid of the exceptions if I do not catch the exceptions, then the config flow tests will fail -- I had taken them from the skeleton generation tool IIRC. Thoughts? sorry, I meant do catch them, but if you move them inline, there's no need to define custom exceptions, but you can catch them directly remove any empty keys is this really a hub, or a single device I think it's a hub, but I'm happy to discuss. This is a single piece of hardware. It can connect to one or two different HVAC systems. Each system can have multiple zones. A (system, zone) maps to one ClimateEntity. It feels like a pice of hardware that exposes two different HVAC systems (say, an upstairs and downstairs furnace) would be a hub? the question is whether you setup the integration once per HVAC device, or once per system and the integration adds all climate devices at once. If at once - hub, if one device - device. You are currently only adding one climate entity per config entry, so imo it would be a device in the current implementation. please make your errors translatable, by settings translation key , moving the text to strings.json and setting translation placeholders if you want to pass values to the string you shouldn't need this just preference, to not define variables we only use once anyways can we add device info? why are you mapping "auto" to heat cool instead of "auto"? (temperature range is supported by both)
I'm not a fan of this as many users will have no idea what "EP" means and most devices will only have a single endpoint. Also hardcoding it like this will make translation impossible. Maybe there's a better way, but I put that in to avoid two same-named numeric inputs. A particular example came up while I was working with the Inovelli switch which has two lighting endpoints so you get two OnLevel attributes. See image: img width "235" alt "image" src "" Some thoughts ... - I wanted something to distinguish between the two and I thought that, at least with an EP designation, this could be explained in a user's manual for the device. - My "EP" approach also has the weakness that it doesn't clearly associate the numeric input with the specific control. Is it possible to relate the name of the numeric input to the control it relates to. I.e., if the user names the control "Living Room", is it possible for the numeric input to have that appended like ("OnLevel for Living Room"). That may be the least confusing if it was possible. - Another approach that is likely better than using the "EP" would be to do what you did with events and see if there is a matching FixedLabel and append that value if a match can be found (or use the first label in FixedLabel as a default), but only append the "EP" if no match and the device has multiple endpoints. - Longer term, I had thought there needs to be some kind of naming "helper" function as a more general naming function that does something like : See if there is a semantic value taglist and, if so, translate the semantic value to use in the entity name, or see if there is a FixedLabel and find one matching target labels [X, Y, Z], or if no target label match in FixedLabel, use the first label as the name, or if nothing else, return an endpoint number. Anyway, I agree with the point that that I put in isn't ideal, but less confusing than if there are duplicates with no way to distinguish. Opened a PR with a more generic approach to postfix the entity name, but only if the device actually has multiple endpoints: This needs to be changed to avoid a rounding issue. Should have been : measurement to ha lambda x: int(x 2.54 0.5) As is, if you entered the value of 54 percent, it would get converted to the native value 137, and that would then get reported back and coverted as Int (137 2.54) 53. Adding in the extra 0.5 results in proper rounding. we just need to use round instead of int This seems like a todo? Its a comment on all our tests, maybe we should just not replicate it everywhere Ok lets ignore for now. Lets clean it up at a later stage (all at once) if we have confirmed with Martin what's needed Please separate words with underscore, send value . We need to test the set value service of the number entity too.
use a translation key in the entity description (and strings.json) this is dead code Imo it would be better if we can make a mapping table to translation keys so the modes have a nice localized label I'm still thinking we should do better and make this generic The options (translation keys) can be added to the entity description and then we need a way to map the supported values If you want to guarantee that they all work the same, you could just define all types here and type checking will verify they remain all the same. yeah but that becomes an awful long list ok maybe it was the setting of the moon yesterday but today it works. Weird. So adjusted it with a type alias Shoould all these clusters have the same translation key ? I could expect a device to have both energy mode clusters. Yes, it's just "mode" unless a description exists Can this change be reverted? Generator should be imported from collections.abc. OK, I think that slipped through in the original PR. Lets address that in a follow up PR. epenet
I think this need to maintain same unit to allow it to be changed. See here: diff-d6bb8150a2868b6dd04145e6bfcc804b99e27e9f2abf100c8483ff60bcaf5bbfR60 Done! Should be updated to use new helpers
This will match the same as before, so no breaking change will occur here. Can we use icon translations? you can do that with the other one as well iwth .extend()
I'm worried the naming will be confusing, and will result in people using this sensor instead of the Price sensor. Can we change Actual to Previous We should not put all this information in the state attributes. Ideally the old data should be migrated to either new entities or using service responses to allow the user to view the data and do their own processing to it. I don't see how the old data should be in new entities. I'm basically just following what the integration is already doing for forecast data. idem What are you trying to say?
typing typing typing? Done
It doesn't seem this needs to be a coroutine function? This code is copied from homeassistant components automation init .py ; we should instead move the common code to the condition helper. Deduplicated in 2d9928d Type annotations are missing. What does None mean as the return value? None is returned by condition checkers when the condition is disabled. L119 L242-L249 The function returned by async conditions from config does not return None though, maybe it should not use the ConditionCheckerType Is context Any ? Well, the handle triggered with script is passed as action to trigger helper.async initialize triggers which is just typed as Callable . However, when the action is called, context is Context None : L279 L292 I guess it makes sense to do the same typing here to prepare for future typing improvements of the trigger helper. run variables is still not typed. It is now. This can't return None as far as I can tell. Good catch.
Does this match the meaning of the feature? It should indicate if the door latch is retracted. It is not if the door is physically ajar. Yes this is ok I misunderstood the state. If open state indicates a retracted latch, then I agree, it doesn't match and door open close state should be exposed with a binary sensor entity. I had to go back to the arch discussion to understand it. The dev docs where unclear :)
There's only one integration for this brand, can be removed Can be removed Use entry.runtime data instead Don't log on info level Comment doesn't add much Why current password This can be inlined Please add reauth and reconfigure in a follow up Although this is vital code, I've removed it from this PR. To be added back reviewed in the next PR. Together with the SemsoterraSensor object this feels like code that should be in the library rather than here I've simplified the code. The library uses a slightly different data model (a probe has a set of sensors, where HA uses a flat list of sensors instead), so some work needs to be done here. Please remove empty fields Please type the Coordinator entity Can be set outside the constructor Please use entity descriptions Please use the DeviceInfo object also, replace ConfigEntry with this custom one everywhere else is the default keep only code in try that can throw is only used once can we make the expiration offset a const? if you only use the validate input once, just keep it inline, makes the code clearer imo this class adds little value, except complicating the code make this an instance attribute can both of those throw? until you implement reauth can we move this to a models.py make this an Enum or IntEnum maybe use a StrEnum for the type
Can we move these constants to const.py ? The test only assert updating the state via an MQTT message, can we also test setting the target temp high and low. Probably you can use this from the climate tests. Had to remove the command topic anyway, as setting via service is (currently) not supported by the water heater component. We could set those as a config option instead. This test does only test setting the state after a water heater has updated its state.
These tests are not valid, as the state for time entities are not matching. A time entity only contains a time, and not a full timestamp. .. Frenck
I would prefer that if we want to switch to the default of Ollama, we should just not pass in the option at all and also not offer it to the user. synesthesiam since you picked this current default, thoughts? Understandable that there are many, many knobs that could be turned on Ollama and its probably better to not overwhelm the user. My thinking on this one was that different users could have pretty substantially different setups and usage patterns. I did a decent amount of testing, and at least on my hardware (1080ti, i7-4770K, SSD), the latency from loading the llama3 model into memory was surprisingly negligible. However, having 44 of my GPU RAM tied up by something only used a handful of times per day was much more limiting. I'd can imagine at least 3 classes of users: 1) High performance seekers: potentially serving many users and likely using dedicated hardware. Current value of -1 probably best fit. 2) Hobbyists recent adopters: probably deploying on a desktop computer they use for daily work computing. Having a big chunk of GPU RAM tied up probably infeasible if they ever want to play a video game or other intensive tasks. Values of 0 - X minutes probably ideal. 3) Budget homelabbers with either a raspberry pi or mini pc. Potentially deploying Ollama using CPU instead of GPU. I'm actually not sure what the performance characteristics would look like here. I'd guess values of -1 or 0 would be undesirable here but not sure. I also wanted to leave room for customization as new models come out. Even if llama3:8B loads up quick, it's possible models in the next few months get unwieldy. I can envision someone running a massive model on a device with unified memory wanting to avoid reading from disk. Leaving it up to the configuration of the Ollama instance could make sense, as this can be easily adjusted with the OLLAMA KEEP ALIVE env variable. So I am leaning to just letting users use OLLAMA KEEP ALIVE . Mike is currently out so let's wait until he is back next Thursday. I set the keep alive to -1 with the assumption that for HA users would not want to pay the cost of loading a model every time it wasn't used for 5 minutes. When used in a voice pipeline, the delay of a few seconds is a bit annoying. I'm fine making this configurable, but I'd like to keep the default at -1 even if Ollama themselves use 5 minutes. But we could let users configure Ollama with -1, instead of having this option in HA We could, but I would argue Ollama's default is not right for HA. I was confused when first building the integration because my models kept getting unloaded. Ultimately deferring to you both, my two cents is that Ollama can be used by multiple users for multiple services. The right default behavior for a Home Assistant only setup won't necessarily scale to other configurations. Having Home Assistant impose an immutable default behavior that impacts the whole system running Ollama might be a bit overkill. The other edge case is that setting -1 in the 
This type hint is likely redundant Updated This was added because: async step lock key() needs model to run verify encryption key() - model name is initialized in async step bluetooth() , a different function, hence the class variable verify encryption key() needs model to run lock.get basic info() lock.get basic info() uses different command for the two lock models I'll push a suggestion in a moment CONNECTABLE SUPPORTED MODEL TYPES probably needs an update? Already added, check homeassistant components switchbot const.py Let's make this a constant called LOCK MODELS since its used in two places Added. Called it SUPPORTED LOCK MODELS so variables in const.py looks more consistent.
Why not make the fault code None instead - ? Then the attr state becomes Unknown . But it is not. You mean: ?
Do we really need a separate flag given that we could perform the check inside the ctor? The flag is needed for the sensor platform because it's currently created without a feature being passed but it's "non-primary" and there's no way to tell inside the entity constructor without introspecting class . I've removed it for now and the emeter sensors are now on the parent but with they should go back on the children.
Let's avoid the use of Pydantic here and just use normal dataclasses instead Fixed in 761f2c8db09d4dde5ef9d666a8795ecc4c60a19f Is the rule "no Pydantic in build infrastructure and support scripts" or "no Pyndatic in general"? Code doesn't directly depend on Pydantic. No reason to rely on a dependency if it isn't needed.
Instead of just the magic number 2.00 , calculate it or add a comment explaining it at the second thought... I don't want to calculate it because it would duplicate the implementation in the unit tests. I want the tests to be calculation-free as much as possible so that they're independent of the algorithm. There's no need to comment because the test is already clear. My existing comment isn't unique to this unit test but applies to the entire component. The existing web documentation pointing to Wikipedia should suffice. Therefore, I will remove this comment in the next commit. Wdyt? Let's extend with another sample to test the behavior of the state update after a discarded sample
Why is this? Seems a bit strange as we have entities? For example, I don't, because I have a wall connector but do not not a Powerwall or Solar, so none of the entities under this device get created for me. Can you extend the comment a bit explaining that so future reviewers isn't asking the same thing? As I haven't tried myself but you tested that this works fine and you get a location selector? Yes the location selector works. Sounds to me they should be required by the schema then and unnecessary to handle separately? But it's conditionally required, you only have to specify a time if you enable that feature. I can't do that with the schema AFAIK. Ok. Let me take a look then Could we rephrase it slightly so the user understands the "condition" required. I have tried to reword this using the name from the service translation. ServiceValidationError should have translations, also below Ive decided to remove the log. errors should be HomeAssistantError . Also please use translations. This error has unknown values, so I cant translate it. You can pass it as a placeholder so the string could look something like Service returned error: {error} or something similar to make it a bit more user friendly than just the hard errors Oh yeah good idea. This seems very strange to me? We typically don't allow to mock internals and also can this even happen as I would think the integrations would not even start then? Maybe you're intending to do tests for the services if the config entry is not there at all or unloaded? The helper function that finds the specific part of the runtime data for a device id has failure cases if it can't find the specific VIN. I can avoid this type of test if I also remove that safety from the code. I think this specific test has found the device, found the config data, but cannot find the VIN in the config data. You're right that it should be impossible. Should I remove the failure case from the code so that it doesn't need to be tested?
Define integration type and iot class This file will get generated later on and receive the translations from lokalize. Does this change? If no, set attr device info in init directly. Can be omitted if you set attr unique id and attr name instead. Can be removed if you set attr oscillating directly. reuse existing function: L385-L388 Can be removed if you set attr preset mode instead. Reuse existing function: L446-L454 Use Platforms.FAN from homeassistant.const I wonder if this is better to be maintained in the library. Do static inits outside of constructor. Raise ConfigEntryNotReady integrations-using-async setup entry Can be defined as a constant Raise errors as HomeAssistantError Order imports You can use list comprehensive here What about moving the fan handling to fan.py and store devices here only? set attr percentage in update and reuse existing function L361-L366 Is it valid to set available to false if status is None ? try command can now never return false but will raise an exception, so I guess it's safe to remove the condition: Same for the other try command calls. This will not change, so set attr speed count in init and reuse existing function instead: L368-L373 This will not change, so set attr preset modes in init and reuse existing function instead: L456-L464 Set attr available in update and reuse existing function: L823-L826
Reuse existing error message This file will get generated later on and receive the translations from lokalize. When setting attr unique id you can omit unique id function, same for name Set attr device info in init directly. can be removed if you set attr oscillating directly. Can be removed if you set attr preset mode instead. Can be removed if you use attr is on instead I wonder if this is better to be maintained in the library.
why are you patching the async setup entry , is there a reason it shouldn't run? Because it's not needed for the test. This tests is only verifying that the configure flow works as expected. what's that for, you already blocked in L108 Not needed, removed. Personal opinion, I don't like snapshots in config flows because they completely abstract away the thing that you want to test. The assertion becomes something like "the result should be something along these lines", but doesn't specify the critical points which do matter like CREATE ENTRY or things like that True.. But I don't really care too much about what it returns. It's an internal feature of the of flow. I suppose i could maybe switch to props include, and just list one or two entries. I've reduced the snapshots so they are much easier to review and only include what we want to test. You're doing the exact assertion twice can we use CONF for this? I've changed it. But for me i see a reason to avoid constants in tests, since if somebody where to change the value of this constant, the test would succeed, but users installs would crash. In the template and scrape config flow, we also use the name device class iirc. Should we stay consistent? The annoying thing is that our select selectors only allow string values. So if we do that we would need to adjust the config structures. I very much dont want different structures for yaml and flow. If our selectors allowed bool values, it would have been easily solvable, but they dont just yet. I think you're missing my point, I mean, now the name of the field is "type of device" (which could be "device type" imo), but should we stay consistent with HA naming and just name it "Device class"? Ah sorry. I got mixed up with climate that uses a boolean switch. Sure lets change that. Honestly, at this point this is just the same as It's not that we assert huge data objects any more, so imo we should just not use snapshot here, but I won't block this It would be a few more checks like not none, title and stuff. Which is sort of what snapshot is for. Now the snapshot is quite readable. I would prefer to keep it like this for now. I will take your objections to it into consideration though.
This is not using an index and will be very inefficient. Shouldn't we add a secondary alias index so we can call areas.get by alias(name) ? This should be added as a a new function so we don't have unintended side effects. We should then update template method to call it. Probably also update suggested area processing in device registry to use it.
There's a helper for this, withings uses it What do you mean? Withings uses oauth2 flow handler It uses a helper for these 3 lines in the reauth Found it Why is this a placeholder? The string used is "title": "[ key:common::config flow::title::reauth ]", and the corresponding text from home assistants strings.json is "Authentication expired for {name}"
If min is 0, it will get min mireds , which might be None You are right, but it is consistent with current ColorTempSelector behavior: L430-L438 I will fix both. This should be cached. Done
Doing what? You're right, that was a big brainfart ! Note: since the library seems to hold the return value, maybe you should use the result instead.
refresh api data also updates traffic rules, no need to call this Why is this needed? Turns out it's not. My mistake. During my testing I had trouble getting updates to appear. I added this and something else and it worked; I didn't see which change fixed it. There are no old unique ids for traffic rules, this can be removed Default value, can be removed Default values, can be removed Default value, can be removed Default value, can be removed Alphabetical order :) I guess since using the data update coordinator it could be used here to force an update and reset the timer to keep it aligned from "last" call, I guess this would warrant one update coordinator per api long term How will the update coordinator behave with an update from a different cadence? Will it reset its timer for polling the data next time? Should be removed Still here Is this relevant? Without update callback the update coordinator won't start the schedule for refreshing data. We can skip the append json addition if we just validate the path If its only one iteration of the test you can hardcode the entity id inside the test Stale code Place it between fixture system information data and fixture wlan data I don't understand this one, there are no web sockets related to traffic rules, is this just stale code doing nothing? Just a copy paste. My first time in this codebase (and I'm not a python dev IRL) Just a copy paste. My first time in this codebase (and I'm not a python dev IRL) ![]( This is default, can be removed description is already a string Copy paste thing, should be named traffic rule or something As there is a name property in the test data for traffic rules, why did you go for description over name?
To avoid unused variable, I suggest that you move it to the decorator (and the same can be applied in test init) This change should not be needed for config flow tests. It seems that you are missing a path on async setup entry Look for mock setup entry in the code for a sample fixture (usually it is auto-use in the config-flow tests) You mean that i added recorder mock? The statistics import is triggered in async added to hass and does an initial statistics import, that's why the test fails if the recorder isn't initialized first. Tests for config-flow should be patched to avoid calling async added to hass altogether. Look for mock setup entry in the code for a sample fixture (usually it is auto-use in the config-flow tests) Oh, i understand now. async added to hass is in fact patched out but i found out the reason the test fails is because the recorder is defined as dependency in the manifest. If I change it to after dependencies the test runs without the recorder fixture but not quite sure if that makes any difference for the functionality of the integration. I don't see where async setup entry is patched out. Can you point it out? it's in the conftest.py - L29-L34 The fixture is declared - but it's never activated. Your are missing pytestmark pytest.mark.usefixtures("mock setup entry") or equivalent in test config flow.py Sorry - cancel everything I said - I was looking in the wrong place! why don't we overwrite the type in the coordinator? Indeed a very good question Also improved typing for device entry while i was at it.
Why do we need to have two different tuples if the check for adding them is the same? Using only one tuple will reduce duplicated code Because the entity class is diffrent: one tuple contains all entities that receive pushes and subscribe to those the new tuple contains poll only entities with a diffrent entity class (excluding the subscribe, unsubscribe and callback methods). In my opinion, we should change the name as it's not clear what an entity named "Sleeping" with the state "Active" means. It could mean that the camera is currently sleeping, but from the options below it probably should mean the opposite True, do you have a good suggestion for the entity name states? Maybe "Sleep status" as name and "awake" and "sleeping" as the two states?
Moved to Moved to Moved to This is most likely a bug. I'll open a PR to take this on out. Seems it is a side effect with the new code, it does not seem to happen when using in a manual cleanup with 2 single discovery topics (test added) It seems to be race with device based discovery. The condition will avoid removing a device that already has been cleaned up. We add device here to ensure we subscribe for discovery updates. The integration that provides the entities and migrates them, is also resposible for cleaning up. Considering the suggested protocol for upgrading existing devices to the new discovery message format, I would expect SUPPORTED COMPONENTS to be converted to a tuple, with device either first or last, and a test to ensure the order. Converted the set into a dict now. As we also use it to check if the topic is supported, a dict or set is the fasted way to do that. The wildcard discovery topics for device based configs are subscribed first now. A nit, but Why is this log added? Removed it, I think it was there to help debugging If we're anyway messing with this: Please explain in more detail in the docstring what this does Added more detail Please explain in more detail in the docstring how this works The idea is to generate component config from the device config, right? Then explain that. done Please explain this too Maybe this should be "regenerate"? Also, please improve the comment to explain when the cleanup config is generated. changed, also added more detail in the comments Why is this check added? If a device based discovery is triggered to be removed and all components removed, lets say 2 components, then this check will be done twice, as we do not await anything and the actual cleanup is processed later. From the tests it seemed this would cause issues. With single components the updates have more time to process, and this race does not occur. This was moved because the fixture was needed for some added discovery tests with device-based discovery This key is no longer added, see: diff-189ecd07b98c2a9602a647f97dfe63e919c95af2d3856701044958b230591ef1L274 The platform is is no longer added to the discovery message, see: diff-189ecd07b98c2a9602a647f97dfe63e919c95af2d3856701044958b230591ef1L274 Should we pluralise the abbreviation in case there's a need for a "component" key in the future? How come no abbreviation for the mandatory key platform is added? I think we should add one, "p": "platform", Is this change really correct? How can we know payload is a dict of strings or a string, this function is called before any validation, right?
better to use entry.runtime data nowadays ok, sure is default done if you call super().init first, the self.config entry will already be filled, so you don't need to pass it if not required otherwise, I always prefer instance attributes remove empty keys I don't know your next platforms, but since this gets a coordinator: Maybe inherit from the coordinatorentity here? Will end up with two different Coordinators (one for local device data, and another for internet based data such as available firmware updates), but can probablty inherit here and handle update sensors differently when they come. logger is defined and imported already use that idem idem idem pass in x.sensors to the value fn is there a reason why the first two key and translation keys are different? Might lead to confusion are you planning for non diagnostic sensors in the future? otherwise could move this to the description definitions 1. I think all sensors will be diagnsotics will move move this to base class base class I would move the whole uptime stuff to a separate sensor class that is independent from the standard sensors, would make the code clearer to read imo use sentence case (also for rest) compare those with is no .get necessary on those always finish the tests to terminal states, to show we can recover (create entry abort) by fixing the error and continuing I believe we'll need a fixture here to avoid all those individual patches access directly [] I don't really like snapshots in config flow tests. Imo it's better to test the data directly probably better in a fixutre as well
I wonder if you should lowercase instead, to make it future translatable? Actually, we should make this translatable from the get-go. This topic has been discussed previously for this integration. Entity names, enum sensors and option values are created from the metadata in the API. However there are huge numbers (number of supported heat pump models (20 to 600 entities) of possible entity names in the API, they are normally easy to understand for a user that is interested in using them. E.g. "Discharge (EB101-BT14)". There is no official documentation of the data points ( entities) in the API and you need access to each and every appliance model in your account to harvest all possible values. Thus, the decision up to now has been just stay with the english terms and not enable translations. I would rather continue this way in this PR, which by the way probably is that last platform needed to get a complete user experience. If we should enable translations fully in this integration it should be done in a separate PR or series of PR:s. Thus, the decision up to now has been just stay with the english terms and not enable translations. Let's document that in code using comments, so we don't have to discuss this in reviews in the future again Since this comment will be applicable to all platform modules I think it is better to make it in a separate PR. Use the already calculated options dict to reverse the doct. Like this? You always intify in the options code. Seems you should always do that here too. option map and option rev are set up when instantiating the class. That should be enough IMO. Or am I misunderstanding something? I dont see why you do the isinstance check is my point. Aha, I misread "intify" above and did not see your point. Type-checking complains if I always make int(value t). value t can have a number of different types depending on context. Here it can be int, float or None. I don't know if there is a better way to override the type checking. elupus OK, this way int() is used without any complaints from mypy. Let's combine this one with the one above. There is no need to separate these (another test will basically reset set up everything again, which is mostly a waste of CPU cycles at this point ) Alternatively, you could snapshot the state instead of asserting it. Parameterize with a single value? Why parameterize in that case? Same as the above, also, this test and the above test could be combined?
We have this helper: L1737
Something isn't properly mocked These values aren't in the diagnostics test right? based myself on existing tests and assumed to much removed The coordinator data is already present in coordinator.data right? It is, but after the failed mock (previous review comment) I realised this is a better solution - it will force a refresh which is actually more useful during debug Sure but then you are not creating a diagnostic from the current state. If something goes wrong at a given moment and you want to capture that, snapshotting would refresh the lib and you would get new data that maybe doesn't have the same issue. The important aspect is to capture the differences between the raw data and the TrydanData The coordinator also updates quite often, it will be very difficult to time a diagnostic download with an ephemeral error. But if necessary I can change back But with what is raw data filled then? raw data is literally the JSON coming out of the EVSE (the physical device) without any processing my the underlying library (pytrydan) The objective is to detect whenever the manufacturer changes the JSON and be able to easily provide an update to the integration I agree with joostlek : we prefer current coordinator data than a fresh one. Plus, if API changes you will still see it reverted Not used ? Can we bump the library in a separate PR? In a separate PR, migrate the integration to store the coordinator in entry.runtime data instead The pytrydan library guards against the raw data not necessarily being valid JSON, I think we should do that here too? Or maybe just dump the content without trying to decode it? indeed it guards the data but not the raw data will change Is the title composed of the host name? If so, should we redact it too?
Please move the function body of async send command to this function and call this function from async send command so both function behaves completely the same Can we return also for the legacy bots the response? The original sucks library does not provide the command response. I don't know if we can change the library behaviour and I don't have a Legacy bot to test it. Move this fixture to the test file This test does not test if the parameters are passed correctly to the command. I would suggest that the fixture is returning the command name and it's params as response, so we can make sure that the params handling is correct As params can be inserted as yaml we should convert the example to yaml Why did you include custom and not only send command ? The vacuum integration already has a vacuum.send command. I don't want to confuse user with two services with the same name: a specific ecovacs.send command and the original one. Command response parsing should not be done in HA but in the library. However, as your use case is very rare and returning also the parsed response, requires a big refactoring in the library. I would suggest that we return the raw response for now. We can always add later a parsed service, if the use case is bigger. For that reason I added raw Is there a specific reason for the double underscore in const? Nope only a typo :) Sorry for the typo. As Ecovacs has not only vacuum bots but also mowers and co, we should use device instead of bot Can be removed
Would be good to have multiple connections and than verify it can be replaced with no connections or a single connection Can we add a message.
Preliminary PR can this be moved to attr name ? New PR as suggested Preliminary PR can this be moved to attr native value ? Preliminary PR can name and token be typed? Why are you generating a new token if it is not provided? The yaml currently requires the token. We should not add new functionality in this PR. It can be added in a follow up PR to keep this PR as small as possible The documentation already describes the manual steps how to do this ( so i thought the config flow can do this for the user. It is just 2 lines of code but i can add this functionality in a separate PR if necessary Removed that for now and will submit it in a follow-up PR Why do we generate a QR and ask the user to add it to the authenticator app? Normally the website where you are activating asks to insert a generated code to verify the setup It is to verify the OTP generation is working as expected. If the user somehow typed in the wrong code they would not know because OTP would still generate codes, any string is a valid token to generate OTPs, so this is the only way to validate that the token is correct. removed OTP verification Seems i was wrong about this, it seems to be possible to insert an invalid code that raises en error. Added some basic validation but leaving out the verification with an OTP code Unused Please verify also that the repair issue was created added the test to test sensor.py as the issue is created in sensor.py Already tested in test init Can we automatically get the name from the token? If you scan the QR code in the authenticator app, it will automatically suggest the title The Token itself does not have a Name encoded, only the QR Code has. As you can see in this codesnippet from the first commit were I had the QR code generation, the QR code contains a provisioning uri, which is constructed from the token, a username and an issuer name. When configuring the OTP sensor from the Token, there is no additional metadata that can be extracted from it. But it could be a really cool feature, if the Config flow would access the camera to scan such a QR code and setup the sensor from it
Either cover it, or don't... don't hide it :)
I would imagine two of the same for loops are easily mergable right? I'm not sure what you mean, this creates a generator chain where each element is an awaitable that can be run simultaneously. Sure it could be a for loop with await but that would be slower. Eventually it will also have a third generator for the vehicles. What's island status? Can we have a list of options here? There is no documented list of possible values, so the risk of making it an enum is that I'll miss something that isn't seen often. Is there a way we can find out what these values are? Over time from user feedback probably, but not immediately. I dont have a Powerwall myself. What's the state? An integer which we do not have documentation for what the value means. Why do we have this? The device info could have version? I agree, I'll remove it. This is the default right? Or do we overwrite it somewhere? These entities use the base description. Have you considered creating a base coordinator? I have this in withings I did this previously in Teslemetry but it caused a bunch of typing issues and there really wasn't that much overlap. It ended up adding complexity rather than removing it. Essentially does the same, but I think this is just a better practice :) I am now thinking, these 2 classes don't really differ, except for the fact that one uses a different coordinator. But because these are 2 different classes, we also need to have 2 sensor entities, and they also look exactly the same. Would it make sense to merge these 2 and make the data.id and coordinator a parameter solve this? For the device, you can make use of dr.async get or create to just create a device with the properties, and then having self. attr device info DeviceInfo(identifiers {(DOMAIN, data.id)} would link everything together. For an example check lidarr (got merged today) or aosmith As I see it, having two classes means I am sure what type of entity it is, type checking will ensure it has the right coordinator, and the code is easier to understand because there is a clear distinction between the two similar but different data sources. Is there benefit in reducing 14 lines of code in the entity file to make all the other platform inits a touch more complex? The only other aspect from a maintainance point of this, is if I make this change here, I probably need to make it in Teslemetry too otherwise the code patterns will be unique in subtle ways that will make it harder to maintain both (since they are functionally equivilant). I can make the change if you think its the best outcome. I have just pushed a change implementing this. Please use the freezer when changin time idem Let's keep this out for now. It doesn't make sense to add an enum sensor without options, Removed This could be an Enum Can get an enum by key? TessieWallConnectorStates(0) TessieWallConnectorStates.BOOTING for the options dict in the next review comment: [state.name.lower() for state in TessieWallConnectorStates] We should provid

I think the new variable name makes it easier to understand what exactly it is doing. Since in Python3 False is a keyword for 0 and True for 1 I suggest to use a Boolean here to make it clear that only two values are allowed. As you can see below the sensor value is not a boolean, the value can be 2. True. Let me create a new suggestion. I cannot resolve this discussion so will continue here: Add an Enum like this: can then be used like the following: Can be combined with a SelectEntity for the sensor mode I think the new SelectEntity or SensorEntity should be introduced in a separate pull request. This is incorrect, as the data will not return an enum member defined in HA. You probably wanted to return the value of the enum member like If sensor is not part of the data an error will be raised as SensorMode(None) will raise the ValueError Are we sure that sensor is always included in the data? If yes, than we should change it to data["sensor"] If not we should only update the value if sensor is included As eifinger already mentioned, can we create parameterized tests out of it to reduce duplicated code? To align with the codestyle of the lines below Disagreed. I need a None check. The lines below are 0 check, so it would be false if sensor is 0. Please make sure that the correct api functions are called too
only have code in try that can fail is default move that before the try can we move that inside the else (same reasoning as before) can this throw? otherwise move out of try maybe IndexError or KeyError if something is wrong in the json response but didn't happen till now while the sensor tests are not a hard requirement, a suggest you add them regardless. It's easily done with snapshot tests, look at tedee for an example Added snapshot tests for the sensors but still need tests for the statistics import part or is there a specific reason I missed, why this should be indeed a class variable? since getUUIDs() has no IO not using that one atm I don't think there's a point in that being a dict. First refresh then assign Which reauth the one that i had to remove xD Idem Maybe this can be a separate function to make this clearer I am not sure how many times this for loop runs, but we don't want to spawn a lot of executor jobs. So we should try to put the whole for loop in the executor at once usually only 1 time, depends on how many flats you own or rent Configentryerror Enums? Personal ick Please use the snapshot platform helper does it snapshot also the device registry? Oh no, you have to make that one yourself. I usually put that one in test init.py as its platform undependent ok, will move the test to there
if you redact all of those, how would the user (with multiple devices) know which device it is? Yes, you are right. I got confused by the naming. Looking onto my own Inverter, I checked that these keys are not the keys used for registration on the ZeverCloud. So it is no security issue to show them, I have removed the complete redaction. Just for clarification: "SerialNumber" means the serial number of the inverter. "DeviceId" points to a "device", that groups up to 3 inverters. The "device" is registered into HA by its IP address.
Euh, isn't the supported features to tell what features the entity has at all times? E.g. if its not showing progress it doesn't mean the progress flag should be removed. You're correct about progress, but the install capability needs to be removed until an upgrade can be installed. There was a change recently that allows capabilities to change dynamically, I'll see if I can find the reference. Why should the install be removed then? It should only be removed if there is an update that can't be installed iirc As discussed, for the records, because it cant be installed why downloading, which can be common if the vehicle doesnt have WiFi were its parked. This was also discussed for Tessie as is identical. This isn't correct. The flags should be removed if an update can't be installed for some reason in that case. They should not be removed just because there isn't an update available. The update can only be installed when the status is available or scheduled. The only difference between the code and what you describe is that yes, INSTALL is also removed when there is no update at all. This implementation matches Tessie: L43 To be clear, there is an update when the status is anything more than a empty string. Still seems a bit odd but I guess that makes sense somehow. The comment in the code was misleading, I will adjust that to be clearer that you can only install when downloading is finished. Are we missing to assert something here at the end of the test? Yes but I couldnt figure out what to asset as nothing actually changes after running the service call, I'll snapshot and see if any attributes are useful. If progress is supported it should be in the attributes. Maybe that?
sorry - forgot to remove these, fixing now webplant? sorry that was my working title, will fix updated is the newer way this can't be here, but needs to be in a separate pypi package should all the external-calling functionality be in a separate pipy package? or should I wrap this into the coordinator instead? it's just one http call. everything that's communicating with device 3rd party API should be wrapped into a library outside of HA, so HA only uses the lib. ok, no worries, let me factor that out in a new pypi project default is there a reason why you don't have this inline? It seems to be only used once I just kept the structure as templatised, will simplify should be in the library please use SensorEntityDescriptions instead, this will make your code a lot cleaner to type the runtime data correctly, also replace the ConfigEntry with SunsyncConfigEntry in coordinator.py just preference appear unused makes it clearer for those not knowing sunsynk, because it's weird initially we have a "Plant" please remove any empty keys think this comment is incorrect required for new integrations don't set the entity id, but the unique id should be typed automatically now, when we type the class (please double check) you could extend the SensorEntityDescription (by building your own dataclass, look at e.g. lamarzocco for examples) to include a agg function key, making it a bit easier to read imo move all the names to strings.json and set translation key instead
I would also keep the "This smart home is controlled by Home Assistant" part by default I have it now as part of the API text: Call the intent tools to control Home Assistant. Just pass the name to the intent. It feels a bit weird to instruct it to know it's controlling a smart home if we don't actually expose an API. I mean, previously LLM used to know who it was (Home Assistant) and how to control HA (using the app). Now it knows how to control HA (by enabling or using tools) but does not know who it is. It is fine with me as long as it is intentional. Do you have any plans to actually use the tool input here? I would like the LLM to know myself (i.e. hass.auth.async get user(tool input.context.user id).name ) and my location (i.e. device registry.async get(hass).async get(tool input.device id).area , device registry.async get(hass).async get(tool input.device id).floor ). It would be useful for both controlling and not controlling Home Assistant. We can do this in a separate PR. I was expected your PRs to be updated to change this prompt :-) Ok, I will :)
Let's remove user id for now, since this is not really the id of the user speaking. We don't have a mechanism yet for identifying speakers. You are right, speech recognition will have no user id for now. But what about writing to the assist chat in the app or calling the conversation service some other way with right context?
If this is going into debug logging, could you please make the debug message a bit more expressive? Especially, if this will cause the "Someone logged in..." emails (which we all loathe). This message is related to updating devices. If it kicks in a re-authentication (due to expired token), it will send that email, but i don't think this is the place to log that... I think "Updating devices" is quite clear for when devices are being updated This is mostly to make sure that polling is not happening (ie: this message does not show up in logs) But maybe it would be nice to have that message (logging in) to match the emails, though debug logging is disabled after some time, in integrations, so it probably needed INFO level. I'll let one of the owners comment on that before using this PR for that Since there is duplicate coded below, this should be moved into a new function. It also looks like there is a bug here that the callable that track point in utc time returns is never saved or used to cancel the fetch if the integration is unloaded before it can fire Does 1 line of code really count as duplicated code though? I thought about doing it but then looked slightly uglier as the new function still needs to take some parameters. Related to the return value, probably better to leave it for a different MR, as I'm not confortable changing something I didn't introduce nor detect Does 1 line of code really count as duplicated code though? Yes I thought about doing it but then looked slightly uglier as the new function still needs to take some parameters. Related to the return value, probably better to leave it for a different MR, as I'm not confortable changing something I didn't introduce nor detect The bug should be fixed in a separate PR
Right now CONF STORAGE KEY refers to a specific ics path above based on STORAGE PATH . (In other words CONF STORAGE KEY is effectively already CONF ICS FILE but limited to a specific location.) Can the config flow place the file into that destination? This can also allow validation at upload time to verify the file parses when its moved into the final location. This also can let us import from a URL as well and have the same behavior. That makes sense, I think I've reworked what I had to instead move the file to where CONF STORAGE KEY points. I also see how this will allow for easier implementation of importing from a URL. i think this patch is not used needed as setup only happens once below on the second step, so this should be omitted. I think we should just keep this in the config flow file for now rather than making a separate directory. Let's use HomeAssistantError here which is more standard expected. Very nice test! Can you also exercise the case where the ICS content is invalid and fails to parse? I think this is not needed? This also needs to raise an config flow error and show an error message. This string should be capitalized.
It feels more natural if device id is first parameter. Should we call this no timer support ? (and update all variables classes errors) why would we allow a device to have 2 timer handlers? I don't think it can happen. Changed to a single All functions in TimerManager should raise if action is for an unsupported device ID. That check shouldn't happen by the caller of these methods. oh this is a test, never mind You don't need this wrapper anymore as this error handling now happens in every timer function? I'm using it to reduce the amount of repeated code. Removed Prioritise device checking. If the device can't handle timers, we shouldn't consider anything else. I can't get timer.device id if timer is None timer.device id will always be ok, otherwise it couldn't have been created. I can't get timer.device id if timer is None I can't get timer.device id if timer is None This is an internal function and doesn't need the check. We shouldn't call this method unless the device can handle it. this is a little weird. Removed
We should not expand YAML configurations. Why can't you use the VLC Telnet integration instead? This integration is only for a local Python environment, so it probably wouldn't make sense to add a config flow to it. I've been using this to test out media players, and thought I would share. It seems kind of silly to leave the integration almost non-functional without a unique id. This violates our ADRs, it should migrate to a config flow instead.
This is not the case for BooleanState, also we don't need to invert as we have to in Occupancy sensing. So I think you can just not provide a lambda to measurement to ha . Thanks for the code review. This matches the device type: I think you also need to add something like otherwise detection will conflict with the door schema higher up, since both are matching on the same attribute ( clusters.BooleanState.Attributes.StateValue ). do you have the fixture for this fake leak sensor ? At the moment I don't have any idea how to correct this test. You need to supply a diagnostics dump of a device containing this cluster attribute, without that, this PR is not complete If you have the diagnostics dump, I'm willing to finish the PR and add the test but at minimum we really want that dump Here is the dump: [matter-2a4bd9d95d966aefd2521cccecaf2a8f-Waterleak-b356679fe5052ff13e1f5ebe00498252.json]( ![image](
Please change these to kw only and drop the mixin
Please keep this file alphabetically sorted This shouldn't be controlled by the integration. login seems to be unused otherwise. - Should this raise an exception instead? - This should ideally differentiate between an network connection error and an authentication error (username password doesn't match). Different exceptions can be raised for those cases. Shouldn't we just set up all platforms instead? And let the platform decide if it should add entities for a given device? Please store runtime data inside the config entry instead. For more information see: - Since Python 3.7 dicts are ordered, the use of OrderedDict is no longer needed. - This schema is static, lets put the schema in a constant instead The code doesn't need these. Please use the single config entry manifest option instead: Additionally, why is there only a single instance allowed? I think the hashing of passwords should be a functionality that the library should do. Is it? Couldn't it be a connection error? Integrations should only provide translation strings ( strings.json file). Please remove this file. Integrations should only provide translation strings ( strings.json file). Please remove this file. Wouldn't it be more beneficial to have information like this in the Python package? So everyone using that package has this information available? This file should be renamed to entity.py Ideally, you should just pass down the device config entry. Name is set to None? But in the base entity ( DreoEntity ) the property is implemented. What is the right one? These should raise an HomeAssistantError instead. Versions are not used by built-in integrations. Who is kane?
Please revert this change and fix it in a follow-up as it has nothing to do with this PR
Could this use entry.runtime data instead?
There's a helper for this, can't remember the name, but I think someone already applied it at Withings Funnily enough, I copied that code from [Withings]( L71-L75) LOL 117727 Please bump in a preliminary PR Is that advisable and safe? The new version adds the new exception that this PR handles I mean it would cause a problem now anyway when the authentication isn't right, sooooo 117730 Isn't this already in there? I don't think so? I mean, by default. Now that I say this I check withings and we also have it there. Lovely. I am missing the new abort strings Please use the FlowResultType enum and replace with is I think I made this a fixture in conftest.py, so you can just add that to the parameters of the test I can't see an async update entry mock in tests.conftest or tests.components.conftest - it might've been something else? Maybe that's a nice one to add as well, makes it cleaner :) oh wait, I looked wrong We shouldn't patch this at all, I thought this was async setup entry What does this do? Wraps the async step reauth so that I can check it's been called without intefering with the function and causing it to raise an exception I mean, why do we need to check if its called? we can test the result of everything This was to keep the scope of the test small and specific - it doesn't really care if the reauth succeeds, only that the AuthorisationExpiredError triggers it you can then just check if there is a new flow created and that the config entry state is set to SETUP ERROR Sorry, how do I check that without a patch or mock? You can setup the integration, and when the client is mocked to raise an auth error, you can check the state of the config entry It looks like the state never actually gets changed. It's not changed by the [DataUpdateCoordinator]( L363C1-L378C64), [ start reauth ]( L992-L1008) or [ init reauth ]( L1010-L1049). Am I missing something? I think you can find this test in some test init.py instead of the test config flow.py, This was at withings because the user id an int in withings, just FYI yea so we should not patch this, we can just check if the token in polling config entry is still the old one
Please add a docstring explaining what this function does added Why the len(t.keys()) 1 check? I wasn't sure if there was hypothetically some other real trigger that could someday contain the "triggers" field in its object. This ensures this special behavior is for objects which have only the triggers key. Bad idea? Not a bad idea, I think your solution is good I gave you the wrong filename in a previous comment; I meant for this test to be added to the existing file tests helpers test config validation.py resolved Please add a case which shows we don't flatten if triggers is not the only key Wouldn't that be a validation failure, as there's no current valid trigger we can write that would have that form? Nevermind guess that isn't checked by TRIGGER SCHEMA added It's enough with len(t) 1 . Fixed by
i'm not sure if a json string should be used for a user visible sensor state in the UI I can replace the JSON with a comma separated pair of values (like x,y). A sensor state should be one value, which can directly be used and shown in the UI. In your case the state is combined with multiple values, which is not allowed What do you suggest for this specific case? A sensor with datetime as value (last update) and coordinates as attribuites can be a possible solution? This exactly describes an event entity we want to avoid any extra attributes as far as possible, especial when they should just represent the entity state We shouldn't add any custom commands to the send command service. You can use update entity service on the sensor entity instead Please revert as described above This entity should be disabled by default as most users don't need it. This entity can spam your instance as the pos event is send a lot during cleaning Can you please move the const to the event file as they are used only there Please add translations for the types too and create a const in HA for the supported types similar to lifespan Icon missing Revert changes in this file The positions in PositionsEvent are on purpose a list as someone could have multiple charges, which this entity currently does not support. Please don't make any changes to this PR until I have discussed it internally and come back to you. So we don't waste your time ;)
In my opinion the following is more readable and more strict. Agree
This is already part of the constructor of the DataUpdateCoordinator
Typo in value Fixed
Should we make "none" a constant in the LLM helper? Since it's not a value we ever pass to the LLM API, I am not sure? We wouldn't want to just have a stub API returning no tools, as that is a waste of compute. As noted in another comment, the request will fail if tool spec["parameters"]["properties"] does not exist. Solved in voluptuous-openapi 0.0.4
I changed this because when I had configured a bad model, the config entry refused to startup Why is that bad? Isn't it better to fail as soon as possible? The config entry wouldn't set up and the user couldn't change the model anymore (happened to me) Could also put tools tools or None below in the constructor call. My suggestion would be to put a limit on of attempts here, but its uglier. Pull the tool creation out of the try given i think it won't throw tool input.tool name Do the tools need to be constructed on every interaction with the conversation entity? How about constructing them in init once and maybe even share them among the multiple conversation entities? It's up to the LLM API objects to decide if they want to cache them. Here we just fetch them. const to improve readability? Update PR description to mention this new functionality. I'd remove the free in US. It's free and rated limited only if the linked cloud project doesn't have billing. It's currently the same for 1.5 but that will switch to paid starting May 30. Thanks for including this. We need to figure out how to exclude the vision models too. Those won't work with text only. Not sure if the API is translating the display name. Seems safer to check api model.name instead. Please break long strings around max 88 characters per line. Addressed feedback in Make a parameter for the data to update the options instead. Empty dict or {CONF LLM HASS API: llm.LLM API ASSIST} .
Favorites should be exposed as media sources and not as sources. Media sources are fetched on demand, so the sync service should be removed. Thanks balloob . That'll take changes to the python library as the browse methods don't support favorites at the moment and these libs don't seem to have been touched in quite a few years. rajlaud, are you open to a PR on the python library if I can figure out the changes to add favorites as a category? PS, I quite liked the favourites being on the main UI of the cards as I'd seen on a couple of other (custom) components, but understand they should really be in the media browse. Hi petes-uk, yes, PRs are welcome to the python library. OK rajlaud I'll take a look. Favorites work pretty differently to other categories I think, so from a quick glance there's going to be quite a bit of "if category "favorites" .... else ..... Anyhow, I'll take a look. You can "fake" a favorites folder in the media browsing inside Home Assistant and just list the same content as you do here. That's also how we do it for some other integrations Ah c'mon balloob , you can't tease us like that. Any pointers at which others might do it this way - seems much more sensible than burying a whole separate path in the browse. Sonos adds [an entry for favorites]( L299) in their root payload. And then when a user browses it, it will list data from [a specific endpoint]( L157) peteS-UK hows this going? Hi pssc I haven't had a chance to look at this lately - my laptop died and my old laptop isn't upto running a dev container so I've been without a dev environment. I'll try and revisit it (although I still use the sources option at present as they're then on the main UI of the media player component, but I do understand the desire for consistency as well). Hi pssc OK - I've made the changes to add a basic favorites category to the media browser rather than using source - it doesn't support folders as yet, but I don't think they're that widely used in LMS world - I'll look at that for a v2 - messy bit is there isn't a call to say "what favs are in this folder". The only issue I have atm is that the media browser doesn't display the favorites in grid view, but works fine in list view - which makes no sense to me. I've posted a question in discord for now. Once I have an answer, I'll likely close this PR and raise a new one since the baseline has moved such a lot since this original PR. peteS-UK happy to help if I can. I too would like to see this available via HA. was looking to add Favs to the underlying browse code in the supporting library, think I got as far as the unit tests. pssc Attached are the 2 files - very minor change to media player - just on the playing - then modifications to build item response and library payload in browse media. [new.zip]( Really odd that it actually works fine in list view and I've got no idea where the media browser window code lives so don't know where to look. Once I can figure out the problem, I'll submit a
The name of the method suggests the expiry date can be edited, however the method allows disabling expiry This means we bump the expiry time every time this method is called, is that intentional or should it only happen if expire at is None? Same comment as above, the name of the WS command is not aligned with the functionality I'd suggest to make the parameter positive: enable expiry instead
If user input would ever be None, the code would fail Validation is done in user step Took this over with as less changes as possible. But your simplification is much appreciated! I noticed that with the above change, the result of the test against double entries has changed: Before, in async step import the setup was aborted if the entry already exists ( return self.async abort(reason "already configured") ), now with the test only being performed in async step user , the user is shown the form to change the host name. I therefore added the host validation again with Can you please create a private function to avoid duplicate code? done Why did you change the key? As the key is used for the unique id, you can only change it if you provide also a unique id migration for the old entities Is it ok to add the migration in async migrate entry (below L49)? When searching for examples, I found several integrations performing the migration in async setup entry , which I deem less appropriate in the case at hand. edenhaus : Made a suggestion. Let me know your thoughts. You should update the config entry after the migration Done. What is the reasoning behind this? The migration will be only executed if the version doesn't match. If an error occurs during the migration, the migration will never be executed again as the config entry has already been updated. Why are you needing this variable? The coordinator set the variable last update success automatically. See the base class Can you also test the entity's migration?
No such entity? I removed these from the PR, obviously missed icons. Could be None instead to bail early instead of looking for a key in the data each time? Done that and refactored the descriptions a bit to avoid mypy issues. Not in entities? Can we type this? Idem
For integrations that connect to devices or services, we no longer accept new YAML configurations or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shifts in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
I'm not sure if this is needed. Is there a benefit to showing "Unavailable" instead of "Unknown"? I think it's just semantics for me. If someone wants to filter and not display entities that are unavailable, it makes sense to me to mark things as available or unavailable. Unknown almost seems like a temporary lack of data. But I don't know if there's a home-assistant approved way of thinking about this. generic-properties available : Indicate if Home Assistant is able to read the state and control the underlying device. Okay, reverted that commit.
Can we use a reference? Yes
Please use proper formatting. For instance: CONST FAN LEVEL 1 . Yes, it's done. My bad. Why is this order reversed and what does it do? It's because I changed the order of insertion in swing modes. I can reverse it. My bad. Can we reduce the nesting here? Can an early-return principle be used here? Yes you're right. I think I can merge it in a single if. I don't think I can use a return because I don't want to skip the call to set zone overlay for that reason. Feel free to let me know when you committed these changes and I need to review them again. It's okay. Let me know if you want some other changes.
I would not hard-code this. Snapcast could be anything, not only music. I understand where you're coming from as the stream could be a broadcast, notification, etc, But A. MediaType.MUSIC is required for artist and album metadata to be parsed. B. Snapcast doesn't currently provide a means to specify this. Of the available MediaType, MUSIC and PODCAST might be the only relevant types. We could attempt to deduce the type by checking the metadata. If an album or artist property is present set the type to MUSIC otherwise leave it empty. Good point, didn't know that. For me both solutions are fine. Maybe it is easier then to set it to Music as you suggest. Unless anyone else feels strongly I would prefer to leave this set to Music. I would not hard-code this. Snapcast clients could also run on a TV kodi. And for groups it does not apply, does it? ( Ok. I went with speaker because even if running on a TV Snapcast can still only play audio. Since that issue has not been addressed and no client type information is passed back to the server, what would you recommend? Leave it unset? I guess if there is no need to set it I would leave it unset. If there is a benefit of setting this to speaker we could also go that way, as it is the most common case. Understood. I'm in the middle of a move right now so I'm unable to determine if it's necessary or not. you could simplify to return self. get metadata("artist", [None])[0] you could simplify to return self. get metadata("albumArtist", [None])[0] Thanks for catching this
It is usually recommended that dependency bumps are done as standalone PR. Only the changes directly linked to the dependency bump (for example when a property has been renamed) should go in the dependency bump PR. Thanks epenet for taking the time to review my change. Yes I saw that in the instructions, but wasn't sure this one made sense. Curious to hear your feedback about this one and whether it's the right way to go. Moreover, adext now exposes a new API to async wait when it's done initializing. The AlarmDecoder extension now wait for the object to be created before initializing. The only way I can think to slice it would be to do the API bump and add the API async wait call in AlarmDecoder and do no other change. In isolation, that change would seem rather odd because there's currently no reason to wait for the initialization to happen given the old implementation. It only really makes sense in light that I need now information from the initialization in order to create the entity in the extension. If you believe that's still the way to go, I'd be happy to make the change accordingly, but it didn't quite obvious that it was the intention of the rule vs a simpler case of API bump where the API changes with no actual net effect on the code for example. Please advise. It's still good practise, you can indicate that the bump is "just to keep to up-to-date", or that it is "preliminary for follow-up PRs that will make use of the functionnality". Ok no problem at all. Here's the relevant PR that I submitted to handle the bump only: [ That is a lot of duplicate code. I suggest that you create a base entity in a new entity.py module. Ah yes. Fair point. Let me make that change Should be moved to the base entity Should be moved to the base entity I think you can also set entry type on the device info Not needed I think, as it comes from the base entity. You're correct. I verified that it still works with this change I think actually we don't need to make client accessible anymore, as it was only necessary for the device info . It's used for more than just the registration. I need adext functionality across child entities. As a reference, see alarm control panel which calls a couple functions on it. Indeed! We should still use the local variable directly inside attr device info: Yup that seems fair more readable. Weird ruff didn't catch this one. By changing the integration type here, it is failing hassfest CI. Please ensure that you run python3 -m script.hassfest to also update associated files. I ran it, but didn't notice the error. It came back with the following: Validating manifest...Traceback (most recent call last): File " frozen runpy ", line 198, in run module as main File " frozen runpy ", line 88, in run code File " workspaces HAcore script hassfest main .py", line 250, in module sys.exit(main()) File " workspaces HAcore script hassfest main .py", line 172, in main plugin.validate(integrations, config) File " workspaces HAcore script hassf
Is there an English word that could be used here? (I assume 'class' would be used if it wasn't a reserved word). Actually, now I see klass used in several other places in the code base, so I don't think this is an issue. Although I was expecting it, I didn't see attr latitude and attr longitude defined as cached properties in the base class for a TrackerEntity . They are in GeolocationEvent , but not in a TrackerEntity , not sure why. Either way, does that make these just plain instance variables, in which case do they need initialising, and possibly renaming to avoid being confused with cached attributes? I've removed these attributes and put them back into the properties directly. I think if you want to check for None , you need to not have the default False The default for get is None, but I am looking for a literal value of None, so I do need to set the default to literally anything other than None. Ok, so if I understand correctly: I don't understand how the value can be missing, trigger the get default of False, but you want that scenario to be reported as 'available'. Have I misunderstood something? When a value is missing, its not unavailable, its unknown. self.get(self.lat key, False) 12.3456 Tracker is available self.get(self.lat key, False) None Tracker is not available self.get(self.lat key, False) False Tracker is unknown, but avaliable, likely because the vehicle is asleep when home assistant started. Ah ok, that makes sense now. I didn't realise there was an 'unknown', 'available' state. If that's what you need, looks good to me. Are there any occasions where the return type would be str ? I just copied the parent property, but I've removed str now.
I'd simplify this message for all the service calls. We don't need to explain the implementation details of the library in the error message. Done in , I also used a decorator ( so we don't have to much duplicates. I can use the decorator in another PR for the other platforms. This will always be true. Done in "Start for" doesn't sound good. Maybe "Mow for"? Also, consider a common service which allows overriding the schedule for a certain duration, where the mode is set to mow or park. I changed it A maximum of 60480 minutes is a bit ridiculous, it's 42 days. Why not a duration selector? I didn't know, there is a duration selector. Added in Please add translations for the options of this selector, here's an example of how to do it: L44-L49 Instead of moving the exception text to a constant, move it to strings.json and inject the error via translation placeholders: done in I missed that
Would it make sense for the "age check" to live in the library instead? Seems a bit weird to parse the VIN in the coordinator. Sure, I'll add this line as a prop in the library. It's still here? Must have snuck back in during a rebase or something. Its removed. We're already setting this in init ? I need to reset it to its default value every time the coordinator runs since it can be modified. Why? The value is conditionally changed here: diff-1b78433d89fdfa4f0ff3be14baf64fa89c3e68b30bac2bd5a8bc31a95882ae84R107 But that 15 minute time period only should occur once before the interval is reset back again. What if the user turns off polling and use an automation instead to update the entities (or possibly in the future somewhere the user can change the polling frequency directly)? If the user uses an Automation they are taking responsibility for letting their vehicle sleep. If the rules change and users are allowed to change polling intervals then I'll need to address that based on how it's implemented. If you can see a better way let me know, but I need a way to stop polling for 15 minutes under certain conditions. Could I turn off entity updates myself and schedule them back on? The context that may be missing here, is the Tesla Model S and X with older computers will stay awake constantly if Home Assistant polls the vehicle API. In December 2023 an update was rolled out to fix this for every other type of vehicle, so I only need to account for these older vehicles by pausing updates for 15min when it appears the vehicle has been idle for 15min. My point is only that if a user turns off polling and does it himself by using the update entity service this disregards from whatever you're setting here internally in the integration. Therefore my thinking is if you should handle this in another form than using the update interval variable. As example maybe just look at the datetime of last refresh and then don't allow another update until time 15 minutes. I'm okay with, and would prefer the user is able to override this behavior using update entity . Before this code was implemented (in HACS version) i was advising people to use automations to handle this themselves, and there very well may be people who want to keep doing that so they can have more control over when the sleep is attempted. TLDR I want update entity to work when someone calls it regardless of this code. Should we add a new car instead of modifying the existing (so there's another set of tests specifically for "old" cars? This VIN is an old car, this also fixes the model in the device entry, so its cleaner to just use this VIN everywhere IMO. Ok. But we also have a newer car so we're testing both? There is added functionality for older cars, but everything else is the same. The only thing I could test with a newer VIN is that the pre2021 code block doesnt run, but its just a boolean IF, so that seems to have limited value. Ok
Update the comment to explain that we want to keep the legacy notify service around during the deprecation period, even though we now support notify config entry. Why do we make a copy? We don't modify the data. A future improvement could be to make a helper method that both the notify and sensor steps can use since most of the logic is the same in those steps. I'll open a follow up PR for this
Im not sure if we should consider this data for this sensor So my initial thought is that I want to know how many devices is on the network now. If I understand it correctly, when removing the number will only increase when devices join the network right ? It would presumably just take a bit longer before the number decreases. I think its better to start without this tweak and we can then add it if people are unhappy with the representation Just to be clear and I fully understand it will the number always increase and never decrease then? Remove it and test it out :) I would assume it would decrease (but maybe in a lower fashion) as well but if it doesnt we keep it in Removed ti So you tester it and it still works? Sorry for back and forth here, I saw that the same thing was done on the wlan client side, so lets keep it as it was considering the last seen as well.
Please add this in a separate PR battery power sensor only ? Both, then we can merge the fix of the intergation in a hotfix and add these 2 sensors as a new feature next release already split the version bump (fix) so this PR is only about the new properties made available by the new firmware version You can use a minor version migration for this I must have backwards compatibility with firmwares that don't provide the device ID Unneeded now What are the possible values? L23 Can we make a transformation map in the integration that translates the enum to a str (snake case) and then we can make this an enum sensor with the options provided. This allows the states to be translatable done! Thanks for a great suggestion :) Maybe these should be fixed in the lib instead Version bumped Unused This all can be replaced with creating a MockConfigEntry with the same unique id and adding it to hass Done This one can now be removed Should this be called slave status? (Or maybe use a different name for slave if possible). Since a state can be no error, while the name assumes it's an error I'm following the manufacturer documentation, changing this would be inconsistent with the manufacturer documentation But reading the states, not everything is an error, reading, writing etc isn't an error ![IMAGE 2024-05-11 22:46:42]( except for the first state, everything is an error the first 2 bytes indicate the slave brand model and are not provided via HTTP only show up in the display ![IMAGE 2024-05-11 22:48:19](
What is the unit care? Unit Care is an care counter for the whole bot. There are a few todo's in this timeslot. For Example wiping cleaning the sensors, wheels and the whole station parts.
You can use [config entry runtime]( data instead. Is this an oauth2 integration? Unfortunately it's not, it's authenticating through AWS cognito libraries same as the mobile app does. While cognito does also support OAuth2 I haven't managed to get this working. Can the user change their email address? It looks like that's not possible atm. There's no possibility to do that through the app. Let's have reauth in the follow up to keep this one small and simple Why is it always available? Please put the coordiantor first Why are these assigned to self. first? Please remove empty fields. Also, don't forget to set the loggers Please use icon translations Does aioaquacell contain enough typing? Consider adding a py.typed file to enable mypy to read the aioaquacell types right? Could use device class duration This is all stored in the device, we should not add this as sensors This is already stored in HA per state, so we should not add this one either What are the possible states? It's reporting in a string type, for example currently mine is 'high'. I haven't mapped out all possible states yet, probably something like high, mid, low. I'll add icon translations for that in a next PR. Sounds like a true false sensor, this should be a binary sensor All these can be removed We should combine the unique id with something unique from the device. if I understand someone can add more softeners, so we should add something softener specific to the unique id You can omit the battery translations since the device class handles this
Is this a breaking change? Strictly you are right, added a breaking change section. Under ideal conditions a locks state is updated by the device ( pessimistic mode).
note to self: Still need to check this Ideally we use FrozenDateTimeFactory instead of patching utcnow I was trying to keep PR semi-manageable. This was changed to accommodate the change in location, not a change in functionality. I agree that these tests needs to be updated in the future.
Why should it be a lock and not a switch entity? Also the class documentation specifies it as a switch I copied the already existing KebaLock from above (see line 31) and modified it for the user auth. That's not an answer to my question. Can you give me a reason why this should be a lock and not a switch? In my opinion this is a switch, which enables disbales something Ok, sorry. This could also be a switch.. It authorizes blocks the charging of a EV connected to the KEBA wallbox. Lock entities should only be used for real locks (like the things that block people from coming in your house), all other use cases should be a switch I can change it, but this would be a braking change for the old implementation? We should deprecate it and migrate it to a new entity then
Please use entry.runtime data instead Why are you adding ajohnston1219 as code owner and not yourself? I tried changing this, but every time I commit the pre-commit scripts change this back to ajohnston1219, which is my personal GitHub account. This has something to do with the multiple SSH keys on my computer, but I am not sure how to get the pre-commit scripts to use the work username instead of the personal one. If you are aware how to fix this, let me know and I will change it. Nevermind, I think I managed to get this to work this time. Why are these sensors being removed? Not all devices support this value, and there is no model number currently included in our partner API, therefore it requires modification of our API to support knowing whether or not to include this value. you are creating a config entry here that is not matching the data format that OAuth2 config entries follow. You can see the format in your test instance by checking the file config .storage core.config entries All config flows need to be tested. OAuth2 config flow tests are automatically generated when you use the scaffold script. You can see the template here: Okay, I was trying to fix tests from the previous integration, but those appear to be incompatible. I have used the scaffold script to create a new integration and generate the tests. The tests are now passing. This is not used. Not used How do I set the scan interval for polling? The documentation says this: You can control the polling interval for your integration by defining a SCAN INTERVAL constant in your platform. Careful with setting this too low. It will take up resources in Home Assistant, can overwhelm the device hosting the API or can get you blocked from cloud APIs. The minimum allowed value is 5 seconds. Where should I define this constant? you need to define it inside cover.py The default scan interval for covers is every 15 seconds, which is what is being used now. Can be moved into cover.py and assigend directly, no need to push into const. You can omit the data here, it doesnt add value to store it as a new dict cast(str, self. oauth session.token["access token"]) is better to use here as it doesn't create a new string One major thing I am missing is, can we set some unique user id as unique id for the config flow? This now creates the situation where someone can break their installation by logging in with the wrong account. We should prevent that. Can we move this to cover.py ? session is always used to create a AladdinConnectClient . Let's move this to init .py so we don't have to create this twice. runtime data should be used if the ConfigEntry is typed. Please type it,. We can move the door fetching to init .py to prevent it fetching the doors twice. This can be removed I am not sure what the idea is here, but currently you only add garage doors that have been added previously. This should be revistied and fixed
Why are you doing manual unit conversions if Home Assistant has support for it built in? Please adopt your code to use translatable names. More info can be found in the developers docs Hello, I don't quite understand. Are you referring to attr name? Can you explain it in detail Here, I referred to Shelly's. Adding translations for new entities is required. With translation placeholders ( it should be easy to add support for them. Here, I referred to Shelly's. The shelly integration where added before we had translation support therefore they have more time to migrate to translations thanks Numeric values should not converted to strings. The user can change how many digits are shown in the UI and therefore we should always return the value as number This should be moved inside of the value function fn of the entity description as it applies only to two specific entities
docstring sshould start at the first line. Also only add comments if they add valuable context to the code, this one only describes what is already obvious from looking at the code. Personally, I wouldn't add a comment here, but according to the checklist, the code must pass the check using the python3 -m script.hassfest command, which requires docstring on methods. In this state the test passes without any errors. Use cv.port to validate port number Please change all references to Hello World or the Awesome light example integration Imports are unsorted, by pressing Alt Shift O VS-Code will organize the imports for you. Done Return type should be ConfigFlowResult Done Rename to something like LedScConfigFlow to prevent overloading base class. no need to rewrite as you are comparing all values in user input Can be removed, your integration doesn't have options No need to move the PLATFORMS here, just leave it in init Can be removed. Setting up integrations from configuration.yaml isn't allowed anymore for new integrations. No need to outsource the setup to another function Always use the constants to access the config variables like you did in the config flow Maybe something more meaningful like LedScLightEntity that also describes that this inherits from LightEntity. Also please adjust the docstrings I think hostname and port are not allowed as unique id for integrations. You can alternatively use config.entry id as unique id Just assign the unique id to attr unique id. Also your integration should not log too much if not necessary. They might help during development but should be removed before commiting. You can log data to debug though that might be valuable for debugging errors. OK, this log informs about loaded devices that could be useful for debugging. I will change the level of this log to DEBUG . Done This is not the error message that is displayed, it is a tranlation key and the corresponding message is looked up in the strings.json file. Please add a strings.json file to your integration. Use the entity description attribute instead and use strings.json for device names instead I can use entity description for more detailed device information, but the entity name is dynamic based on the WebSC configuration. But device is not the right category. It is really a hub. The integration is connected to a single device using Websocket, but this device controls any number of lights. The individual devices are configured in the WebSC application. Advanced LedSC properties can be configured in this application. The integration connects to WebSC and loads the configured devices. So it is not necessary to configure the individual devices separately in the integration configuration.
To be future-proof changed This sets the state to unlocked and not to open. changed Please add the is open property too otherwise, the state will never be opened is open property was added now. Please add a test where the state template return open . Please test also optimistic case
This is energy returned to the grid, but with the LED-impulse version you're using the same key for its lone usage channel. Not sure if this is as intended. I have replaced it with the ESI TYPE ENERGY COUNTER USAGE HIGH TARIFF type. One, I don't think it makes sense to expose this value as it's a static configuration that's used by HmIP to convert "number of impulses" (which it doesn't expose) to volume. Without the raw impulse data there's not much we could do with this value. Two, it's not in m h but in m impulse. So removing the GasVolumePerImpulse Sensor is okay? I'd say yes. I see no use case for it. It's a user-supplied config value that tells the ESI how to interpret its raw sensor data. People set it once in the app during initial installation; that's it. It certainly isn't a measurement and won't change on its own. -- Some background on the hardware: The sensor is a hall sensor (or reed contact, I haven't broken it open to check which one they use) that gets activated by a small magnet on the last digit of the meter dial. The ESI counts those impulses internally and multiplies them with this config value to derive current and total consumption, which it then reports to the server. The LED variant is the same, just that there it's a photo-resistive diode resistor transistor (again, I haven't cracked one open to check which one) that watches a blinking red LED on the meter. Only the IEC sensor is a bit more involved, as the meter sends its data as a digital signal using an IR LED. In all three cases, the actual HMIP device is identical, it's just shipped with a different sensor in the box. That's why you get that "everything mixed together" reading. Thx for the input. I removed it.
After dep to ensure its updated before loading http on core installs does this work? http is loaded as one of the first things and it won't pull in after dependencies You would have to add it to L143 I think? So it gets promoted if the user wants to set it up. I fixed pre-stage1 after deps in
I think this warrants a specific check for the monitor target as well I might need some help here Kane610. So I know the uptime stats is not None and it's a dict . But how do I tell mypy that? I think I got it, but not sure if it's the right way? I don't think it. Can it be because that TypedDevice is missing uptime stats ? We should add a proper uptime stat to the library so typing is correct Kane610 It's pretty much duplicate work here. Was considering making a def that return the three sensors. Then we could at the end do something like ) make latency sensors("WAN") make latency sensors("WAN2") etc. I was not possible, at least of that I tried, to get use methods that had wan: str as parameter. Kane610 I'm not sure I'm on the right path. Will you please guide me? Something like this Should return a tuple For future safety, it would be good to make sure the key is present. You could do: If you update the previous function to return None if there are no latency values, you can instead disregard this function and replace it with something like async client wan monitor latency(...) is not None Do you mean removing it or? Signatures are slightly different? Either removing it and using a lambda or something to go from hub to device or updating it to use the hub to get the device and then call the latency function. Exactly combine those functions into one that take which stat to look at and you will remove a lot of duplication I see, it's applied now. Thanks! Last thing is probably to combine these into one method that takes the source as input You can make this an internal function within make wan latency sensors You could probably change this to return the full dict of entity descriptions and not need to input WAN WAN2 I have a little hard time do figure this out. Will not work, as make wan latency entity description 's wan is a Literal["WAN", "WAN2"] So mypy will complain saying Argument 1 to "make wan latency entity description" has incompatible type "str"; expected "Literal['WAN', 'WAN2']" [arg-type] So is there a way to either loop over Literal["WAN", "WAN2"] or fix it somehow else? Pushed the code to see :) No need to use factory as you don't want to prepare any state prior to starting the integration and you don't need the config entry so lets make it a fixture with config entry setup We could deduplicate quite a lot in this test if you input entity id, state, and the updated state in pytest parametrize, similar to the test client uptime I think I achieved it This won't work, you should do something like, as the supported function is expected to only get Callable[[UnifiHub, str], bool] This is probably the reason the coverage fails on async client wan monitor supported fn Not sure partial(async client wan monitor latency, wan, monitor target) will work, as the signature of value fn and supported fn are different. I at least get this locally Argument "supported fn" to "UnifiSensorEntityDescription" has incompatible type "partial[int None]"; ex
Since this is common to both if and else , could it not be before the if else? Good point. We'll throw 404 for non-existing images with invalid sizes that way, which is probably better than throwing 400. We should keep this line as it checks that the file is saved correctly. You could create a variable for TEST IMAGE.read bytes() so you read it only once I found it redundant since when we return the original image, we check its contents already. Are you sure we want to check it twice, once on the file system and then via the API? Yes I would keep and check it twice I re-added it
Please unpack multi-line ternaries into if blocks Done As above Done As above Done Maybe this should be a utility function that returns the unique id ? For the light platform specifically or for all platforms? I'd say for all platforms, so we can have it all concentrated in a single place that we can test thoroughly? So something like a util function like get unique id(entity, feature None, ..) that will contain all the logic to make it easily testable, instead of letting individual platforms to perform their own choices. Now resolved by latest We should read the range from the lib. It's not currently exposed by the library. If I add it to the interface is it sufficient to have a simple range like this or better something more generic with min , max and step We have the information there in the feature. Perhaps we should just read it from there, given the feature is always there with the same identifier?
- The schema can be inlined, no need to create a constant in this case. - Any reason this is limited coerced to strings? 1. I created a constant because it's used twice, once in TIME RANGE SCHEMA and again in STORAGE TIME RANGE SCHEMA . Should I inline it even though it will be repeated? 2. I coerced everything to strings because I wasn't sure how to represent "any scalar". Using typing.Any would theoretically allow nested dicts and lists (assuming the attribute code can handle that) but voluptuous didn't want to validate anything when I used it. Would vol.Or(bool, str, int, float) be more appropriate? 1. if it was a huge schema used many times, I would agree; this is overkill imho. 2. your suggestion seems acceptable I replaced the string coercion, so now it's Expanding this would give: This feels redundant and more fragile to maintain, as it's not clear that these have elements that need to match each other. If you'd still prefer this I can change it, but I think it's worth avoiding the repetition. I agree it's better to avoid repeating This one is a little confusing IMHO, sometimes it is added to the attributes, or otherwise it is stored in a data key. IMHO, this is magic we should avoid. Let's either always store it in a data key (or not). Honestly, I think we should always use the data key, mostly because it would allow us to exclude it from the recorder (which is an change that should be added to this PR as well). I like the idea of excluding a single key from the recorder history, but my goal with the "flattening" of data attributes into the entity's state attributes was to make it easier to build automations. How do you select, for example, data.brightness in an automation trigger? ![entity attributes]( ![automation trigger]( Accessing those is harder indeed. Alternatively, we do flatten them, but exclude all attributes from being recorded in that case. I just pushed a new commit that adds any custom attributes present to unrecorded attributes . Is that the preferred way to do this? That approach should not work, you'll need to also set the Entity class' private attribute combined unrecorded attributes : I wonder if there's something wrong with the test you updated, because I don't think the approach in the PR is valid. The test update is not correct, the state set by the test is just this, i.e. no data or party level state attributes: The test should assert the state has CONF DATA and "party level" state attributes, and then check those state attributes are not recorded. I think this approach is valid (or at least, it also appears at L49). I just pushed a new commit that updates the Entity class's unrecorded attributes like you suggested and adds assertions that the attributes are present on the entity to the test (in addition to the existing assertions that it is not present in the recorded states). Update: the test failed because it doesn't appear to override the current time, so the data attributes may or may not be there depending on
Please use the json loads helper from homeassistant.util.json import json loads done You could narrow this with json loads object instead and drop the type sounds good, done added the import for cast too
Where does the max length come from? The gateway has a 16 byte RX buffer. ( L571) Subtract the command, equal sign and terminator from this buffer and you will have room for 12 argument bytes. Should the dependency update be split into a separate PR? This PR has a dependency on pyotgw 2.2.0. How is this normally handled? As I remember it, it is customary to update the requirements first before adding new features that depend on them. See also the [development checklist]( 5-make-your-pull-request-as-small-as-possible), especially item 5. Ok clear, will create a bump PR for pyotgw 2.2.0 When you do, please specify that it fixes 113443 Done, I also reverted the requirement change within this PR. I believe sent is the correct spelling here. Same as above.
Honestly, that function is small, might as well inline it Would cannot connect be better? Is this a single config entry integration? No, you can configure several instances. (Am in the train, excuse the formatting) Oh, didn't catch this, thanks! Can be set outside of the constructor Maybe it makes sense to create a separate function for setting the attr but since you only have one attribute you're setting, why not use the native value property directly? You're right, we can just use the native value property here. Entry doesn't have unique id Never mind Suggestion: mock out the whole ImgwPib lib and just attach stuff to the fields, checkout analytics insights for an example This is testing setup, not only getting the form I think having a global client test fixture would optimise this because you don't need all these patches (Personal ick) Please replace all enum with is Should we test this with checking the config entry state? Ah yes, this is already testing a successful setup Use freezer here too We are already testing this in test unload entry , so imo we could remove this one Can we remove the side effect again and make this test end in a CREATE ENTRY? this way we also test that the config flow can recover an exception Also the unique id This one is left Ops sorry, missed that one. I think we can now do without
As a double check, is this standardized? The most command definition is Integrations sometimes use the constants from MediaType or their own strings or a mix of both. We could populate the list with the constants? I am not sure if this is possible, but it would be a good start I think From what I can see - If we provide a list; then the user can only select from the list. There is no way to allow them to select from the list or enter their own string. Since there is no single standardized list that all integrations support, we should leave it as a free form text field and provide examples in the docs (which I will work on next). I find that a strange example, it would fit a "play media" service more Can we make a better description? Can we use constants for the keys?
I don't think we need a constant for the schema if it's only used in one place.
I don't think the coordinator should know about platforms. It's up to each integration to implement the coordinator entity or not do that. Comes from the side-discussion [here]( in discord. It just creates unnecessary overhead by registering listeners for entities which has no use of it. Integrations shouldn't use the coordinator entity if they shouldn't use it.
I don't think this needs to be checked, it should not be possible to call the service if the LawnMowerEntityFeature.START MOWING feature flag is not set. If mypy complains, we should do this instead: Same for the other scripts What does this mean? It's copied from template vacuum obviously, is it still needed in this new platform? Should be sufficient with Don't think we should add deprecated keys Could we type this Already in from LawnMowerEntity
OpenAI doesn't have this. My impression is that this is an additional omission from the Open AI PR and that this is mandatory: has entity name-true-mandatory-for-new-integrations Open AI doesn't set a device so its a no-op, but I think it should. For consistency with OpenAI move this after init? For consistency with OpenAI move this into const.py? I didn't originally also copy this because the log messages would be weird: I went ahead and copied it but updated to use package instead of name which I think was intended and will include in my openai cleanup PR. For consistency with OpenAI move this into const.py? You should delete from here to the end of the file. These are testing the service which isn't part of the conversation agent entity. FYI OpenAI PR didn't remove this and I did here since it seems like an omission. I was going to remove from OpenAI in a followup.
I think this is stale. Use a more meaning full key, and do not forget to add it to strings.json Thanks. I've cleaned this up and included the strings.json updates. The repair platform already provides this so why have we included it here? I wasn't able to find any issue creation specific to aux heat deprecation in the repair platform. Is there an example I should model this after? Sorry, I meant that async create fix flow() is already included by the repair platform automatically so the whole async create fix flow() is not needed. But maybe it wasn't added by yourself so let's leave it as is Stale comment? Cleaned up in switch entity refactor I think perhaps it would be good to make a base entity in a preliminary PR and then add it here to reduce duplication I've created a base switch entity and a auxHeat switch inheriting from the base. Refacotred based on newly added switch code. Also below These changes are no longer needed. Have been able to revet these back to the original test assertions. Move this to init .py , there's no need to implement a repair platform since we don't implement a custom fix flow What do you think about removing the migrate aux heat issue callback and just calling async create issue() directly in the two aux heat locations that trigger the issue? That feels like it may be a bit cleaner with all the rest of that code going away. I've updated the PR to call async create issue() in the deprecated methods. Let me know if there is a reason that approach would be a problem. Remove this repairs.py has been removed. We don't have to depend on repairs anymore. Two comments on the name: - The name should the added to the strings.json file instead and set a translation key on this entity. This will the entity name translatable. - Entity names should be sentence style capitalized. So, in this case Aux heat only . Done. Thanks. The fact these services are called, is already part of the debug log. To me, this seems a bit duplicate. The service call above is already blocking. This integration uses a standard repair with no custom flows. There is no need to test this part for that reason (that responsibility is already satisfied by the repairs integration itself). The service call is already blocking Hmm wondering why http a dependency right now actually? I think this can be removed.
This isn't used for anything, so you can just remove it. Fixed. There's a now() function in homeassistant.util.dt that does the same thing. Maybe just use that instead? Ah. Fixed. Add an empty ControllerWaterUseSummary for the controller before this branch. That way there's always one populated for the controller, even if there's no sensor. Then you don't have to call .get() when fetching it from the dict later. Fixed. This is unused. You can remove it. Fixed. This is getting a bit unwieldy. I think we should make a method for each sensor type that returns the native value for that sensor type. Then the conditional here can either just be a conditional with self. attr native value assignments, dynamically dispatch to the methods with something like getattr(self, f' get {self.entity description.key') or via a manual dict mapping like return {"daily active water use": self. get daily active water use, ...}[self.entity description.key]() That at least reduces so much nesting of this logic. Good idea. Updated. This isn't reachable. getattr() will throw a AttributeError if the attribute doesn't exist. Fixed. I'm not a fan of all the side effects being introduced by these. I'd rather them just return values and have update attrs() assign the value to self. attr native value . Fixed. I think this always returns a float? Let me play around with that some more. I had it like that before but I couldn't get mypy to play along. mypy doesn't seem to recognize ControllerWaterUseSummary . Maybe because it is not exported [here]( L13)? The library doesn't have a py.typed file, so mypy interprets the library types as Any practically. If the typing in your lib is on par, consider adding the py.typed file and enabling strict typing here This returns float None same as above - float None same as above None should be a valid value, which means you can reduce the method body down to: self. attr native value getattr(self, f" get {self.entity description.key}")() Fixed If you put this condition first, then the controller water use only needs to check for self.sensor is not None . Or are there sensors that are associated with zones that we'll want to handle later? Fixed can we use icon translations? I am not sure how many entities you're going to add, but a common pattern is to extend the entity description to provide a value fn. This will then make sure all logic is written at the same place as the rest of the sensor definition. Would it maybe make sense to make this a base base entity, and then create a HydrawiseZoneEntity and a HydrawiseSensorEntity? This way you aren't combining everything into 1 object, which gives you the freedom of changing the behaviour of these entities without the need to keep adding if statements Icon translations
This statement makes the valve appear open. Is there a way to wait for feedback from the controller, and have the state reflect what is reported from the controller? That way if the command succeed but the valve is still closed, it won't be falsely reported. I would expect the API to return an error if the valve couldn't be opened, which would mean you wouldn't get to line 59. I can remove that, but it also makes the tests a bit more annoying since you then have to wait on a data refresh to check that the state was updated. (which I guess is fine since the side-effect of validating the API was called is the important part?) Done Same comment here. Done
Please don't change this file in this PR. If the change is needed, please make a separate PR with it. Sorry, I did it to test locally with the api by manually copying and installing the wheel package locally. I removed this change from this PR. What do you think about using a coordinator and use async set updated data to pass the update to the rest. This avoids using the event bus (or the dispatcher, as that's also frequently used for this) The design of the API is not REST based but it is based on a permanent connection via Websocket (established just after login). I tried to explain it here in the design principle : This callback function is asynchronously called from the websocket server side (for example when a cover is manually moved) and it helps keeping the state in home assistant coherent. When homeassistant starts, it will logs in and establish the websocket connection permanently. This callback is linked to received server side events whenever they arrive. It was inspired by the plex integration implementation and its plex websocket callback. The EVENT DIO CHACON DEVICE STATE CHANGED is send to all platforms (this pr does not contain the switch one) and the event is effectively used to update the cibled entity. I am not expert enough but I don't find how to use a coordinator in this situation. You can use a coordinator as the data owner, where you let the websocket update the data of the coordinator, which efficiently updates the other entities Implemented it with a coordinator : it works correctly with my local tests. Please use entry.runtime data OK, changed it. We should unsubscribe this listener on unload OK, added it. We should leave services for a follow up pr OK, removed it I think the flow would look way smaller and less complex if you inverted this OK, changed it Unique id is unique for the domain, so no need to prefix it If I do not prefix it, the default name of the integration is quite surprising from my point of view. Without this prefix, I have only my user id and itseems not really clear as meaning for me. Here is the result (I stroked the user id) ![screenshot integration config]( Small function, might as well inline it OK, inlined it. This would be something to do in init .py , but maybe the coordinator would be nice for that too, but i need more context for that This code is present in case I have two dio chacon accounts and one has not covers but only switches. Without it, I had an error at startup of homeassistant because the list devices was empty. I don't know if a coordinator can help for this. I have to search for examples and better understand the coordinator usage. But we can still move that to init and query the devices in there Indeed, with the implementation with the coordinator, this code has disappeared. Can we type this Done Not needed, is already logged Unneeded We should extend our ConfigEntry type to stay typesafe, check airgradient for an example Comment doesn't add much imo I think this is also logge
Let's type credentials as str, Any. I think it's safe to assume expiration is typed as date time. As improvement point you could look into creating it an object in the fyta Library Can we use constants for this? CONF ACCESS TOKEN is in homeassistant.const I think you have to define the expiration yourself FYI, minor version's default is 1, so this should be 2 Don't define this dict at class level, define it in a constructor instead. Otherwise this will have side effects which are hard to debug Please don't log on info level Why do we use the get here? That adds the possibility that the field is None Let's also add a test for the migration, where we insert a minor version 1 entry and then setup the integration, causing it to migrate to minor version 2 You can expect an access token to be present Why do we do this? Wouldn't it be better if we saved the expiration as epoch? This way we don't have to trouble ourselves with the timezones, since its all UTC I had to introduce this, as otherwise I had problems with the reading of the config entry on line 41: I assume, in case of the setup or the migration the data is in the cache and without the conversion on line 82 would be available as datetime. Consequently, line 41 throws an error. Once saved in the file, it is read as str and therefore I read it in with fromisoformat . Instead of checking the type in async setup entry I thought it is more efficient to convert it in the config-flow (and now also in the migration). With regards to saving the epoch, I do not yet see how this could be realized, as one would then also have to save the starting date, otherwise we do not know when the epoch ends. Or am I missing anything? You know the epoch is x miliseconds after 01-01-1970? You know the epoch is x miliseconds after 01-01-1970? No, I was not aware that you are referring to this. Is there a difference in the result? I guess the datetime would have to be saved as timestamp() and then read with fromtimestamp() , but besides this I don't see an advantage. An advantage could be, if the whole logic would be adapted from current local time to UTC, but this would require a rewrite of the client and integration, and I'm not sure if this is reasonable in the case at hand. The biggest advantage is that epoch is in UTC, so you don't have the whole timezone mess as it just works So instead of saving 2024-12-31T10:00:00 00:00 you're saving 1735603200 . I always find to have a love hate relationship with iso date strings. Yes, it's a little less readable, but it saves some headaches with timezones and people switching timezones probably I agree, that if I would start from scratch, UTC might be easier. But if you agree, I would prefer to keep it as is (and perhaps adapt the logic in a separate PR at a later stage). The only point I don't get is why you say it would affect the library? (If I understood correctly). Also keep in mind, if all users now have an iso string in their entry data, a migration is required to migra
This does blocking I O in the event loop Ah yes that's a pretty silly thing to just forget.
This is not correct. Instead, either override the options property method or set the attr options attribute. Done The device class should be set in the entity description Done Should it be more clear this is year month day according to the Hebrew calendar, or is that immediately clear to the user? Done
Please also test that the entity for the other endpoint is created as expected and gets a state in the state machine. What do you mean exactly with "get the state in the state machine". This is my first pull request and also first touch with home assistant development. I tested it with my physical device here as a custom component, everything is working as expected. Is it enough to get the state from the first entity with state hass.states.get("cover.wave shutter") assert state like in the other test functions. Yes, exactly! Please add a code comment and explain what we're testing here since the docstring is only talking about the other disabled entity.

What kind of value is signal? What does it represent? It is the signal strength of the WiFi signal received by the WiFi interface. Could even be rssi in dBm. That should be implemented as a separate sensor entity. available-device-classes
Probably need to double check that this doesn't fire when you reload the integration Yeah looks like it does ![2024-04-24 11-22-54]( Actually I am not so sure. I have not changed anything but it wont trigger now. Tried in debug mode to to trace the execution to on state update but its not being called on reload. AFAICT on state update is only ever called when a state message comes from the device which does not happen for an event entity until it is actually triggered so there should be no duplicates. The code looks fine otherwise. If you are confident its not a problem, it seems good to merge
Note sure if it makes sense here but self.add suggested values to schema exists now This is probably an existing problem, but I think we need to call self. async connection result(False) before the return But I guess we also need to not start the reconnect loop if the auth is wrong so may need to split that function into two If we know its failing we can resolve the available future right away so nothing else is waiting for failed connect as it would otherwise wait the full 30s timeout For security reasons, I think we shouldn't reflect the password back to the UI Moved in a sentinel to allow re-auth with the same password. Opened to ensure we always reload. Do we need to pass this at all? I'm honestly not sure I want it to make easy to let users try the current password, but it must be clear it is set or not. The option flow also allows to update the password and also sends the password to the UI. We could use a similar flow there. We do not want users to re-add their password if it was not changed. I wish we could use a better sentinel but I guess we don't have a way of telling the difference between no password and empty password. Users can show their password, so it should be something understandable I don't have a better suggestion at this time. This one is easier enough to change in a future PR if someone does however I think its to call entry.async start reauth(hass) here as its an exposed api See: diff-454ebc7d7d7827598c55e6611dd5af8a2409744ab7bf06c3c4923867b8d7788fR1114-R1115 It would be cleaner to check for active flows vs patching async start reauth If we don't set this before calling async connection result it will start trying to reconnect. async disconnect will do it but there is a chance it could suspend so it isn't set in time before we reach async connection result reauth config entry isn't used. Fixed with
Except for the line this is essentially what async reauthenticate client() does. Would it be considerable to pass username and password to that function instead of user input to have a common handler for the same thing? Maybe even move it out of the class as a helper function as it doesn't use self ? Good suggestion, which is also fine as follow up PR erwindouna as pointed out correctly above, some refactoring could improve this code here.
Why don't we create a time entity for this? Gives way more flexibility to the user so we don't really have a chance to set it. TLDR: this specific line is only changing local data, not sending to Ecobee Server. The only thing you can send is set ventilator timer which set a 20 min (fix) timer. Context: The real setting is set ventilator timer(id, True) this will force the Ecobee server to set ventilatorOffDateTime at a value of now 20 min. The reason we set self.thermostat["settings"]["ventilatorOffDateTime"] to an approximate value, is to get the local value in Home Assistant so the switch don't flick back on off until an update is done. When the ventliation is on, are there other entities that reflect that? no, not currently implemented. Also. If this would be implemented there would be 2 things. 1) if the 20 min timer switch is on or off 2) if the ventilator is on or off The ventilator can be on for other reasons than the 20 min switch being on. (exemple the min ventilator time number in the integration) Basically the way the device works is. You can configure it to be on x min hour. min ventilator time and then the ecobee turns it on off to match that number. But if you want to give a boost of ventilator, you can turn on the 20 min switch on the ecobee interface to run it for the next 20 min (regardless of the min ventilator time ). The ecobee behaviour is that switch stays on for that 20 min and go off after. This last piece is what I am adding today. For what's it's worth, if we wanted a binary sensor to say if the ventilator is on off it would be done by another data point call enabled equipement which is a coma separated list of all the things on. ex: fan,ventilator,heat The reason I assume nobody ever modeled it, is because of the bad refresh rate of the ecobee device (3 min) it makes it very un-usable Because the thing is, we generally dislike when the integration is assuming the state, so for example if I turn on this switch via HA and then turn it off manually, they are out of sync. Would it maybe fit to be a button instead to avoid keeping state ourselves? tbh, in this case I can just remove that line. The behaviour will be like the rest of this integration, aka the switch will flip to an "old" position based on latest data. Then will get updated in the x seconds after. Let me fix the code and remove that part. It should not change the functionality. Also, I would like to keep the switch beacuse it is useful to know when the 20 min is done. So folks can use Home Assistant to build timer longer or shorter than 20 min (which is limiting right now with Ecobee HW) Yea but that's what I meant with the question if we can see the switch being on in other entities, and if I understand correctly, we can the other entity would be on enabled equipement and we could not distinguish if the 20 min timer is on. (vs just the ventilator) I don't really see a reason to differentiate on the reason why the ventilation was turned on. Let me ask someone e
This entry contains a username and a token. These should not end up in diagnostics. Diagnostic data must be stripped from personal data. What would be interesting about the entry data in this case that it is useful to put it into the diagnostics? .. Frenck Oops, indeed! That has been properly redacted now. Other than making it more complete for diagnostics, there wasn't a particular property that I wanted to expose. Overall I wanted to add diagnostics to help around after this [issue]( where MELCloud silently failed. Having the opportunity to see the last reported timestamp will help to see this behaviour, if help is being provided via Github.
could be not in
Honestly, this is extremely long... I wonder if we even should show the mac address at all. I think we still need to show the mac because I see quite a few cases where they have multiple of the same brand of adapters and the only way to tell them apart is the mac. It's also a commonly needed item when we collect debug data from the user to figure out which adapter is being flakey or which adapter can see a specific device. I think we could drop the usb id from the title though. Thats probably not so useful if we have an adapter model and manufacturer
Please split multi-line ternaries into if blocks Please split multi-line ternaries into if blocks Fixed in ad582b2 Please use f-strings here Fixed in 9bc2c92 Please make [STATE OPEN, STATE OPENING, STATE CLOSING] a constant set Fixed in 61ddb28 With all the branching here, it probably makes sense to subclass Valve so we can do all the branches in each subclass That was also my initial thought but went eventually for this implementation as the switch with type valve is already there and should continue to work. In opinion this is the cleanest solution without requiring larger code changes. Of course we can create a base class type for shared functionality and subclass switch and valve, but I think it's bit overkill here. I would prefer not to have to maintain the branching long term especially since valve and switch are completely separate platforms it's likely they may diverge more in the future. Please split the classes with a base class. Ok, I understand. I expect to have time to do this within 1 or 2 weeks. bdraco - Please check the latest commit. I adjusted the classes to reduce duplicate code. Please see the comment I added about the test. Thanks I have split the tests. Merged with your last commit. And did some quick testing from within HA HomeKit. Please split this into two tests as we aren't allowed to have if branching in the body of new tests I have split these tests.

Why don't we just create 2 entity descriptions? Also, I see that there is one for hours and one for days. You know that when you have a device class of type duration, you can just change it in the entity settings? If both have the same value I don't really see any benefit in providing two entities for the same value. Now I'm reading the PR description again I'm assuming the days means "days this has been installed" and hours means "hours of active use". I think we should make this clearer in the names. Preferably the names should not contain the unit of measurement, because like said, that is changeable by the user and looks strange to suddenly measure "Filter Used Days" in weeks. I was mimicing how the existing "runtime" devices attributes are. Is there a better way to do this? I've added a commit changing the names to what I think is a better description of what the values track How do you mean runtime? Oh wait never mind. I mean, this feels like adding a lot of abstraction for something that feels really simple I think we can do this smarter, but let's await the other question first To describe my issue with this btw, let's add a way to do static unit of measurements without adding all kinds of untyped parameters to a function. Something like the default implementation would work If you add this as the first line of the function, you could have 2 entity descriptions for the new entities and just set native unit of measurement . Let's split this entity description up into 2 Let's wrap the lambda in paranethesis Please use sentence case
Untested, but I think this will work I'll give it a try That works, probably could make that same change to the switch as well In theory that line could be moved out of binary sensor and switch to the base class constructor in entity.py , let me try that. This is ok now, but if we get more of these, we should switch to BinarySensorEntityDescription. I was thinking the same thing, will switch if I add any more.
Could this number be automatically discovered from the PDU (eg if 8 and 16 are the only choices, try to query outlet 16 and see if it works or not). Sure, now it polls the status and instantiates that number of outlets. I don't have one of these units to test if it's intended behaviour, but here L34 it appears that the string generated will be one digit too long. E.g. outlet index 1 on an 8-outlet PDU would generate 010000000 (9 digits). I can't believe I missed this. Good catch thanks. I am not sure if the outlet name is user-configurable - would the outlet index be a better (more stable) choice? Agreed, probably more stable. Changed. Is there a difference between get name() and name ? No difference; should have used the getter. Changed. Please don't log on warning Please use [runtime data]( Why do we create the device here? Function is small, might as well inline it Please type the update coordinator with the returntype of async update data unused Now you can use self.config entry after calling the super constructor If we're retuning nothing valuable, just don't return and type this to return None You can add attr has entity name True here and the device info would be nice as well Please remove empty fields Unused The default is already present in the schema Not a nice title imo I always prefer to have the coordinator first Let's also give this a better name speicifc to the integration This is the default for coordinator entities, can be removed
query str Template(query str, hass hass) so you can skip the later assignment on line 87. Still need to have that one in case it's already a Template I moved the assignment into else and put the initialization into the constructor. Same here, assign hass variable at the Template initialization. Maybe debug logging level here. same here. hass as an argument in the constructor. Seems unrelated to the purpose of this PR?
Why do we call lower here, isn't lower case already guaranteed by the schema? I think we should also, in a separate PR, remove the call to lower for the project name above. Sure, I'll update my PR to remove this. I'd gone with consistency, but you're right it's overkill. Also break out of the for loop when handling the project name above This should be a ServiceValidationError , with translation in strings.json . Same for the project name error. Let's not add the unnecessary lower-casing to new code. I've removed .lower() from section name as initially asked, because it's already lower-cased by the schema. But because the user-entered data is lower-cased, then the section names from the Todoist API need to be lower-cased for comparison? Either this .lower() needs to remain, or lower-casing should be removed from the schema definition. I am not a fan of the case-insensitive comparison, but since it's happening for the project name I followed the principle of least surprise. You're right, sorry Would something like this be more natural?
Why not? assert mock setup entry.call count 1 copied from above switched both in b9c48d92998ee7b80696b9499286636fa8331787 Do we need to verify this new password percolates into the config entry? b9c48d92998ee7b80696b9499286636fa8331787 This is cool, didn't know that could be done
Stale docstring
I won't add the suggestion but generate the file locally instead after the other comments have been resolved Aight, done now! Is there a reason that you don't use the async version? (And that the client object is each time newly created) Kinda? I derived this TTSEntity from the google translate integration and the gTTS entity is created with every single request as well - but that's mostly since there is no such thing as a client there. Thus, I will refactor the client-init into the creation of the Entity. Regarding the async version: I'd be happy to provide the async version if that's better practice, just let me know and I'll add it :) Yeah, I understand, but here it should be possible to move it into the init function. And yes, async should always be used where possible because Home Assistant is running in async and every sync function adds overhead to it. I saw that the library has a async client interface available, so that should not be a big problem. Do you not want to put yourself as a code owner? Done! Can you rename integration ot just elevenlabs Changed it :) It's cloud poll, as we have to request data from the cloud. Not needed Can you set the title to the voice ? Done! This is not possible as the schema marks it as required Errors should be keys that refer errors defined in strings.json This is not possible so instead use assert Just name it after the voice as it's already linked to ElevenLabs integration. validate the API key still works before forwarding entry setup This changes the semantics a bit, though I'm sure this is not too bad. Instead of calling both and awaiting afterwards, we await the first and only then call the second. I can still implement the new behaviour though. This might end up with 2 voices being called "Unknown". Can you use their ID instead? Same. Not possible so just use assert to satisfy typing. This makes little sense. You now allow a user to pick a voice "Unknown", which you cannot resolve. Instead, you should make sure voices is a dictionary mapping id name
Why do we make this abstract? We could implement this twice and enjoy the type safety it adds right? Do you mean two separate classes of data update coordinators? What's a TimestampDataUpdateCoordinator? This is a DataUpdateCoordinator which keeps track of the last successful update: L453-L463 WeaterEntity uses it: L147-L155 Can we make this a generic so we add the return type annotation? I think this can be a generator expression We can retain this coordinator type I don't understand, why do you want to use SingleCoordinatorWeatherEntity ? I assumed the CoordinatorWeatherEntity also takes in a coordinator in the type CoordinatorWeatherEntity[AccuWeatherDataUpdateCoordinator] (but then the new coordinator) Huh, how does this constructor work? L1086-L1114 Oh cool :) Snapshots would be a nice improvment for this test As you wish
Perhaps provide some logging here or something for the user to get the error? From the config flow it looks like this can raise other errors than this? All those errors are children of TeslaFleetError, so there is no need to handle them separately, to do the same thing.
please use CONF HOST and CONF PASSWORD Fixed do a await coordinator.async config entry first refresh() before adding it to the entry Fixed Fixed is default Fixed are you planning to re-use validate input? If not, just do it inline, can also save you the extra exceptions can this not throw errors? idem idem idem add those later in a separate PR Removed this. why the generics? firstly, I'm not sure I like the decorator just to avoid a single self.async request refresh call, because I'd argue that call is clearer than the decorator. Secondly, do you really need to do an update after each call? Can't you assume that value was set if the call didn't throw errors? use the attr here instead Fixed I think we can also use the attr for brevity Fixed but you are updating something here? If you really don't need to can't we just stop the polling? where is the push happening? The Swidget API client creates a websocket to the device. The device will automatically push change notifications back to the Swidget API client over websocket (so you don't have to poll it for changes). needs to be set for new integrations Fixed what if the device is not a dimmer? It doesn't have any entities? Why even add it at all please fix the exception and continue the test (if in a non-terminal state) to show we can recover from errors. I'd suggest you switch to parametrized tests for the exceptions While (afaik) tests for your platforms are no hard requirement atm, I would suggest you add test cases for them. I think this method is preferred, instead of directly accessing the event loop
These actually countdown (as in become a lower value as time passes, making them timers). This is not allowed. They are set and do not change during the runtime of the irrigation process. They reset when the switch turns off. That is probably specific behavior of your device, but defenitly normal behavior for this data point. My original comment remains. The documentation linked, does not have the DP codes that are used here; indicating this is a non-standard device. We don't support non-standard devices. At minimal, we should support the standard (documented) instruction set. So based on this comment, you are rejecting this PR? Or do you think there's something which can be done to make this acceptable? Since you do not want to support this device, how are people meant to use it? Is it possible to have this device working in Home Assistance Tuya integration? It's disappointing that I cannot integrate it in my automations.
We shouldn't do this. The TrackerEntity is originally only meant for GPS trackers. If we want to use it for other things we need to discuss that in an architecture discussion. I felt like it kind of fitted because GPS coordinates were optional. But I'll remove it. I can't see another similar entity type that might make sense for the nearest AP. Perhaps if scanners had a way of changing areas? You can open a discussion and get ideas. Let's just remove this for now. We shouldn't need an options flow since device tracker scanner entities are disabled by default. Yeah, I didn't really want to flood the list with disabled entities, and I wanted to be able to choose what type of tracking to do. I could remove the flow, but I sort of prefer to choose in advance which entities to track. Also, I'm going to add a poll frequency option for device tracking. So I'd rather keep this if that's ok? No, we've made the device tracker entities disabled by default so we don't need any options. Poll frequency option is also not allowed. The user can turn of polling for config entries and automate it themselves with the homeassistant.update entity service. defining-a-custom-polling-interval OK, I'll remove the options flow too... I'm a bit confused how the manual refresh polling automation plays with the Update coordinator, which updates the whole list of entities. Would the user just select one entity and that would have the side-effect of updating them all? How would they know to do that? I assume the update coordinator is clever enough to not poll if there are no enabled entities listening to it, even if I call the initial load method, and also clever enough to not poll twice if two entities ask for a refresh at almost the same time. It's ok to add a section to the tplink omada docs of how to automate the polling if you think that's needed. The first explicit refresh by the integration will fetch data. There won't be any recurring refresh by default if there are no listeners. There's a default refresh debounce of ten seconds in the coordinator. It means that if there was a refresh, any subsequent request for refresh within ten seconds will not be executed but scheduled to run after the ten seconds have passed, and only one refresh will be scheduled. Eg if three requests for refresh come in during the debounce time, only one refresh will be scheduled to run after the debounce time expires. The debounce can be customized by the coordinator. See the debounce helper for details. We shouldn't use entity descriptions for the device tracker platform since the base device tracker entity doesn't support that yet. Ok. I based this mainly on what Unifi's integration was doing - it has Entity Descriptions. I can simplify. Commented code. Please break long comments around max 88 characters per line. We can remove this. We can remove this. Should we add both wireless and wired clients? I don't think so. Maybe if someone requests it? I think wired devices are unlikely to be porta
If those variables are not used outside this module, user prefix to mark them as private: private-variables Annotate the variables as : Final This line seems to not be needed. Same above Tests fail because of socket.socket if I don't have that. Some points I believe might be missing on this class: Annotate with device class for these sensors (unit of measurement is already implemented) In case of being a numerical sensor, stating the StateClass so statistics can be properly stored for this sensor. Adding tests for sensors created by this integration (this should increase the test coverage) Not sure what you mean by annotate with device class Also not sure what you mean by stating the StateClass I don't actually know how to test sensors that are created by use an API. All the integrations I know that do a similar thing don't have tests on their sensors, so I don't know where to look for examples. Any suggestions? Sorry. Been a while since I've worked on this. State class is set in the sensor descriptions. I'm still not sure about device class... Why not using the option to suggest the precision at which to render the sensor's value: L464 ? This logic seems to be best suited on the init method by overwriting the attr native unit of measurement property of the class. Then the parent SensorEntity class would pick the value and cache it: L475 better to raise ConfigEntryError here until you implement reauth that looks like something that should be moved to the coordinator probably no need to add it to the config entry, as you can retrieve it from the coordinator you don't need this move it to its own file is the default this is constant just a bit shorter this should be part of the entity description, to avoid the if here. Can there be different pressure units? delete this file and folder, this will be auto-generated for core integrations
Not needed Is there any way we can check if the API key is valid?
Looked this up, makes sense! Thanks! Or just overwrite it in the sensor.py (continues from last comment) It would make a lot of sense to use entity descriptions here. That means you create one generic sensor, which is changing shape depending on the entity description you put in. Change made. Code is much cleaner! Thanks! There is an issue about increasing the scan interval, you can find more explanation about that limitation there: discussion r1557326343 Yeah seems like it can definitely be a problem if the user has a few devices. I think it should be up to the user to decide so I've added it to the config with a default of 600 . Thanks for your review! Oh, nice idea I am not sure if future is used or not Removed I think Meter, MeterPlus and Outdoor meter can all be handled the same way looking at the API. Can we handle the 3 types ? Yes good call! I've added support for all three. They essentially behave the same so we can treat them all the same. Maybe add in the message that there is a limitation of 10000 calls a day ? I've added it to the documentation PR. I think adding it here would be too verbose unless there is a way to add helper text or something like that? I couldn't see a way. Ok ! We don't allow exposing modifying the scan interval. They should be set to sane default values. If the user wants a short update interval, they can use the service [ homeassistant.update entity ]( service-homeassistantupdate entity) Fair enough. I've reverted this. It will use the device class name Either extend SensorEntityDescription to add a value fn or do One thing I am wondering: When can coordinator.data be None? That would mean the coordinator update failed, but then the entity would render unavailable, right? I think you're right, if the code gets here then we should have data I take that back! I believe if the SwitchBot API request fails, we can get a NoneType here so we need the short circuit. It does seem to fail occasionally. Just tested and observed this happening. What error is it raising? We should catch that in the coordinator and raise UpdateFailed , which then renders the entities as unavailable A timeout error during the fetch. It does render the entities as unavailable in this case. oooh wait, I think I know what's happening. This is using the coordinator callback. When an entity turns unavailable, the callback is called, and then this guard is needed. If you would use the native value property like below, it would just try to get the available property (which is implemented in the CoordinatorEntity, which sets the entity unavailable when the coordinator fails), and then proceeds to not request data from the native value property. So tldr; I think we can use the code snippet below. But this is a code style question, since both are used in core, and the current setup is used in switchbot cloud. I personally like the native value property when there is little to no logic involved into setting values, but there is no preference. Ahh ok wel
We don't allow overriding a builtin service. That would be confusing to users. If there's no message to send the integration shouldn't implement a notify platform. The other PR that implements a custom service is ok. But the service is not overriden Instead an additional service with a custom service schema is registered alongside the builtin service from the notify platform. This is currently required, as the notify entity service does not allow extra data keys like the legacy notify platform (required for item field). I also changed notification type to message, as that is basically the message that is sent, just that only 4 predefined keywords are allowed. In contrast to other notification services, bring does not have a free text input for the message. The custom service schema does therefore define the message field as radio input. I know the new notification entity component is still a work in progress, joostlek asked me if i could implement this feature with it. Maybe this can serve as some kind of use case for the further development jbouwh Please use ServiceValidationError instead Raise ServiceValudationError and move the error message to the translations ( string.json )
Use caplog to very log behavior during tests I think this test can be omitted. I might think we prefer not to allow this yet and explicitly fail. If there are use cases that need this perhaps its a followup discussion? (Similarly, then registration can fail if the tool isn't registered) Remove asserts (not a pattern used in production code). The rationale here is that for something like this if the specification is None its kind of undefined behavior so let it fail naturally (the caller had to do something really weird and it is a shouldn't happen case. But also, i think it does something different in production code) I think specification should be its own dataclass passed in during registration of the handler, then it gets functions like being converted to a dict or repr . A common pattern used for other registration is to separate the arguments needed for registration vs the arguments needed for the implementation of the handler. Have a look at [Services]( for example. (This allows the handler implementation to avoid inheritance and prefer composition) I have changed the Tool.parameters to be a voluptuous.Schema , this matches what we have for the services. I don't know how to dynamically create a dataclass , but the vol.Schema should do the job. Can this be limited to the conversation domains or do we need to support arbitrary domains here in the platform field? I think right now the only expected value is literally conversation , but I can imagine that this field could be useful in the future. Please let me know if I should remove it or make a white list, etc Consider a scenario where one AI agent asks another AI agent to do something What is the text input if an LLM invokes the tool? would text input be one of the intent tool args or not used? This is the user prompt. It is not really used, but intent handler expects it. I could use None, but then I thought there could be use cases in the future to have both user prompt and LLM arguments. Please let me know if I need to remove it. We talked on discord about potentially extracting an input class for a number of input arguments, similar to how conversation agent inputs or how intent inputs work. Note that there can be different APIs for these two use cases if it helps: - how llm tools are called - how llm tool handlers accept inputs Done, please check The conversation agent integration that is calling the tools should take responsibility for: - exception handling: if the tool call fails (they catch HomeAssistantError ) - json serialization - json deserialization Similarly, the tool implementations are responsible for being well behaved and throwing exceptions (e.g. HomeAssistantError ) on failure. Done Remove since this is not used, and having a default seems reasonable I'm not sure what is happening here with the pre processing and looking up areas and floors. Wouldn't the intents themselves handle all of this? No, intents (the DynamicServiceIntentHandler specifically) expect area id and flo
Shouldn't this be the default on NotifyEntity ? It is the default: L131 removed Are these things tested in the notify integration? Otherwise we need to test it there. I'll remove this. I added the tests to the notify entity platform tests: I was mostly thinking about the legacy service. We still need to have test coverage for that. I was mostly thinking about the legacy service. We still need to have test coverage for that. See
What could effect ever be? In WLED effect is the current light routine. It could be solid or one of any choice the controller supports. These are already exposed in the light via the state attr(entity id.effect list).
We don't need to update the internal state here, the coordinator will push the first state to the entity. We can move this block to update state(), checking if data is None before and returning in case it is. Here we can assign self. attr native value value directly instead of calling this method. Let's try to eliminate this function. Can we type this datetime is a bit broad. maybe device-datetime or something would at least explain more what the entity does. (not that anyone ever looks at the unique ids, but if you are going to add more datetimes in the future, having one that is literally called datetime is strange types Did they write their backend in javscript or something maybe matlab? Let's just compare as dict Can we also test this part?
I think I've actually fixed this so I can remove all these late imports Nope, still circular This is only for testing to see if the CI can catch anything For a future followup PR; Since most of the events (state events) come in via async fire, I think in this case we might even consider that it's worth the performance tradeoff here to always check even without debug mode since it's frequently the place where a CC gets this wrong Also in the future we can rename async fire to async fire internal and change all known safe high volume usage to use that Then we can make the length validation a separate function and call it in fire as well and update fire to use the internal function since we know it's passing through a call soon threadsafe Finally we turn the threading check on in async fire since it would only be rarely called from integrations now as all our internal usage would avoid the check. At least on my production, async fire is called orders of magnitude ore than async fire so this seems like the overall performance impact will be minimal and it seems worth that tradeoff img width "591" alt "Screenshot 2024-04-23 at 11 57 48 AM" src "" Started working on that in In the future, we could add a fast check to entity sources to see if it's a custom component and always do this check if it is We would also need to make sure we aren't called from a call soon threadsafe if we did it by default for cc since it would be a waste in that case I very much like that idea. And it will be easy to search the code of custom components for calling anything internal . will implement that Can we default this to the debug value in [ RuntimeConfig ]( L55) Yes 18e88c20d9d53f0ce45e12b667d66e7df4c478a6
As discussed elsewhere, I think I'd prefer if we can also check if the add-on is either running or auto start is enabled. Just in case we have folks which have the add-on installed but don't use it. Looks like we don't need an explicit type annotation. Do we need to reload the config entry too? By my testing, after the config flow completed, it shows the "Home Assistant SkyConnect" config entry correctly: ![image]( What would a reload do here? :thinking: This is the end of the options flow and normally we want to reload the config entry so that it can use the updated config options. I didn't find a listener for config entry update that reloads the config entry. The PR empties the implementation of async setup entry , so a reload won't do anything as I understand it. Ok. Why do we do a major version bump? Can't we do a minor version bump instead, where we add "product" and "firmware" but keep "description" ? I've implemented a minor version bump. If there's a reason for the major bump, we can always do that later. Why is the implementation of async setup entry removed? The old implementation did two things: 1. check multi pan addon which essentially started the Multi-Protocol add-on whenever it was installed. This has some problems, like if multiple SkyConnects are used, or if the user migrated away while still having the Multi-Protocol add-on installed. As we recommend dedicated Thread firmware nowadays, Multi-Protocol is seen as self managed (the user should control the add-on, e.g. make sure it is configured to auto start etc.). 2. The USB scan created a ZHA discovery for the Multi-Protocol add-on. For now, the user will have to manually configure the ZHA integration when using the Multi-Protocol add-on. The plan is to add a hassio discovery to make this process automatic again, so it will be quite easy again to install Multi-Protocol. So essentially, for the current focus on Thread Zigbee, these Multi-Protocol related things are no longer required. Since this class is only for installing SkyConnect firmware, maybe we should name it accordingly? This comment does not seem relevant, we bail out at the beginning of this method if the correct firmware is already installed? I don't understand what this means. What does stalling addon startup have to do with detecting what firmware is on the device? By design, add-ons which are used by Core have the startup type service . This means the Supervisor starts them before Core. And conversely, this means the add-on might already use this particular radio, and we should not talk to it as it would interfere the add-on's operations! Unfortunately, we don't have a global serial port management (yet), so we have to query the usual suspects manually here. OK, I see, that explanation is clearer. Can you make a suggestion which makes the comment equally clear? This seems non deterministic since the zha config entry may or may not be loaded when this function is called. Could we make zha an after dependency of thi
supported should be used to determine if the unifi object is in a state to report the relevant information. If the data is always expected to exist then supported can be omitted and it will always be True Allowed is the proper one to check configuration settings supported should be used to determine if the unifi object is in a state to report the relevant information. If the data is always expected to exist then supported can be omitted and it will always be True Allowed is the proper one to check configuration settings
This could be set in on static info update Thank you!
This line raised an error: (Positioning failed and so my roborock created a new map) that should be self.coordinator.maps.get(self.coordinator.current map) will fix. Thanks for testing! Out of curiosity, did you just see this PR and decide to test? Yeah, there is this checkbox when you submit a PR, that encourages to review 2 other PRs and as I own a Roborock, i thought that could be my first review :D (still need to review another PR though) what's this for? tbh - I don't typically create an entity without a description - I just assumed it needed the key specified, does it not? the key of an EntityDescription has no use other than for identification. Integration use it in their unique id and stuff I don't like the implementation of the new sensor, as it is dependent on the image entity. The new sensor will never update if the user disables the map image entity. Entities should not depend on each other to work. Unfortunately it has to - there is no where else that contains this information other than the map parsing. I'm not sure how I could avoid dependency. I guess I could potentially move the logic for getting the map and parsing it to the coordinator? And then the image would just have to grab from the coordinator? Would that be better? That would be a better solution indeed. The nice thing about coordinators, is that they stop working if no listeners (entities) are active as well.
Added Sorry, I accidentally commented on the wrong line and, the wait background tasks should be a parameter for the async block till done Noticed after committing your code but didn't had time to fix it. Thx ! I'm not sure if Motion active is a clear term for the end user. Maybe Motion detection would be better. What do you think? Done
Set this as class attributes (outside of init ) instead of instance attributes
To be consistent with the other services registered here, this string should be "partymode" Please rename to partymode so that the function name is consistent with the service name. While this looks like it will work, we shouldn't have to do anything. The mock should absorb the service call and then report whether it is called via sock mock.partymode.call count. There are other example is test media player.py Remove the trailing comma; this is why the format check is failing., Imports need to be sorted alphabetically, running black will fix. So this needs to be moved in front of Here i think you have a formatting problem. There should be one blank line at the end, are there?
Please use the websocket client instead to test this API. Example: L17-L62
As mentioned on discord can we cap this if it's a crazy amount of hosts Added MAX RESULTS and have set to 12. Seems we're not using the nameservers in init so I guess you can move the results[0] here too to make it consistent. I've updated the QueryResult class so we can initialise it with an IP which should be cleaner. Sorry for coming back late on this one but could we change the attribute to ip addresses and then also add a translation in strings.json
select ? Hah, its wrong in the file I copied from too. L15 Fixing this now. What is abc-123 ? Unique identifier for the wall connector. Doesnt need to be redacted.
You shouldn't need the cast here since it already occurs in simplisafe-python : L255-L265 Don't nest this make this service a top-level one inside this object, then do the service registration in async setup entry . That'll be consistent with other integrations. Same. If we don't know whether this integration supports indoor motion cameras, too, why not avoid subclassing and just put this all in a single class? We're registering a service for every camera? Well, this does not error, but it does not work either ... my handlers do not get called. Can you suggest something else I could try?: My service handlers need a "self" that points to a specific camera. self will be provided by the entity platform. Take a look at how RainMachine does it. Here's where the services are registered: L182-L196 ...and here's an example where the handlers are registered: L348-L357 Crucially, note that I don't register the service for every entity. I believe I am following that pattern exactly, but my handlers are not being called. What calls this method? Also, we should unregister the services when unloading the config entry, not when destroying a singe camera. Why don't we use self. websocket events to listen for ? EVENT CAMERA MOTION DETECITED is not included in WEBSOCKET EVENTS REQUIRING SERIAL , does it mean every camera will trigger when there's a motion event?
I filled REGISTRY based on entry points. (For those who don't know, I authored Entry points have names, I intented HA to use the entry point names instead of class names. Also, this looks identical to REGISTRY HASH . ah yes, I am learning python (I am an ex-java dev) and did not realize the entry points could be used that way. You are right, then this hash is redundant. I am willing to try to improve it (to learn) but cannot get to it before this weekend. I pushed some changes to do as you suggest Won't invset remain empty for people who would upgrade to a HA version which includes these changes? Either use - entry.data.get(CONF SOLAX INVERTER, REGISTRY HASH.keys()) or (entry.data.get(CONF SOLAX INVERTER) or REGISTRY HASH.keys()) - or implement async migrate entry() yes good point async migrate entry() is a good approach - I did not know about this callback then I guess I can do this and test it. Not before the weekend :) If you already have some code, happy to reuse. You are unconditionally providing the inverters kwarg, discovery() could receive an empty set this way. discovery() will use the inverters value if provided, even if empty. If that is what you intented it is fine. PS. What I envisioned was to have entry.data store one solax entry point name, not an iterable of names. Again, I would prefer using importlib.metadata.entrypoints() to build this dict since I consider those keys more stable. I made the change in the latest commits, see if this looks better? Not that familiar with voluptuous , it prevents data[CONF SOLAX INVERTER] from being en empty iterable, right? I would prefer passing return when asyncio.ALL COMPLETED to discovery() here and making sure the set it returns contains only one inverter only inverters of the same class. not sure I understand? why not FIRST COMPLETED? The problem with my inverter (X1HybridGen4) is that it crashes randomly when going through the full discovery. Ideally I want the discovery to stop as soon as one class works (and only the one I configure in the config flow) I could test both approaches on my installation (this weekend...) I should have fixed the main cause behind the randon crashing during discovery in 3.1.0. But since [X1 Mini V34 can also handle the response from an X1 Boost]( issuecomment-1646691601) it would, in my opinion, be best to detect such cases and have the user deselect X1 Mini V34 in this example. I forgot to mention I only want to use ALL COMPLETED only during initial configuration [reconfiguration]( In async setup entry() I want to use FIRST COMPLETED and pass it a single Inverter class. ALL COMPLETED does not work on my installation, I get timeouts with the following code I use to test the upstream solax library: inverters loop.run until complete(solax.discover("solax.home.arpa", 80, "XXXXXXXXXX", return when asyncio.ALL COMPLETED)) I think my inverter (X1HybridG4) crashes in this case. With FIRST COMPLETED it works.
The reason the scan interval is only once every 10 minutes is because of the limitation of the Switchbot API to 10000 calls a day: request-limit Calling the API every 600 seconds means that we can have up to 10000 24 6 69 devices (only for polling, we also want to actually control the devices so the actual number of devices we can handle is reduced, devices not requiring a feedback like IR devices are fine). Calling the API every 30 seconds means that we can only have up to 3 devices. With only 1 lock, it means that just for polling, we are using 2880 calls, for 2 locks, it is 5760 calls. Supposing that a house only have 1 lock, using a lock with the current settings leaves 7120 calls, meaning up to 49 devices with the current scan interval. We are supposing that we are not controlling any device. I believe the best solution is to add the ability to receive pushes from Switchbot. I fully agree with the reasoning regarding the poll intervals. If there is any way to hook into the Switchbot webhook system from a Home Assistant integration, I'd be happy to implement it. From my understanding of the API, it isn't easy to facilitate, since it would require the Home Assistant server to be reachable from the wider internet (and have a somewhat IP address DynDNS setup). If there is some native integration available for this, please let me know and I'll take another look. As an alternative immediate solution, I would suggest setting the default intervals to 600 seconds for both locks and other devices but expose this setting to the user. I'm indifferent to whether it should be configurable per device or per device category, but I think it does make sense to have some things like locks be updated on a higher frequency. I am sorry, I do not have the knowledge about this, let us ask joostlek as he often reviews this integration if he has an idea, miterion Seems like [laurence-presland]( found a nice way to handle it in As an alternative immediate solution, I would suggest setting the default intervals to 600 seconds for both locks and other devices but expose this setting to the user. We don't allow exposing modifying the scan interval. They should be set to sane default values. If the user wants a short update interval, they can use the service [ homeassistant.update entity ]( service-homeassistantupdate entity) Would avoid code repetition. Please split the dependency bump into a new PR as we require that the PRs are as small as possible. Keep this PR in draft until the other one is merged. The advantage of splitting is that it allows us to ship dependencies bumps in patch releases. Not needed as the lock don't sets SUPPORT OPEN . See How come we optimistically set this here? Do we know the command succeeded if send command(LockCommands.LOCK) did not raise? If not, should we request a coordinator refresh instead? Essentially yes, at least from my local tests this command will raise an exception if the locking unlocking fails for any reason. Same comment We s
Process fetch service call. We could also put flags similar to in the service call and return only the selected items. My aim is only to return text and some basic items as the rest can be retrieved from the event info. Further the info needs to be serializable. Maybe this should become an async context manager since its used in quite a few places? May you have an example on how that can be done? Then I can open a PR for it. BTW it is intended to have a seperate session for the service calls apart from the base service of imap integration it self
We prefer to have the entities under the tag domain, please move the entity class to init . How can the user make use of the device id attribute? Also, maybe instead of calling it device id , I think it should be clear from the attribute key it's the ID of the device which scanned the tag. How can the user make use of the device id attribute? As also noted in the tag documentation you may want in an automation to have different actions depending on the device that triggered the tag. Also, maybe instead of calling it device id , I think it should be clear from the attribute key it's the ID of the device which scanned the tag. Not sure what it should be called then? device id is already in the documentation with an explanation tag-scanned-events Yeah, but with a device id key inside a tag scanned event, there's context which is lost when the device id is a state attribute. I think the attribute should have scanned in its name, for example last scanned device id or last scanned by device id . Makes sense This sets the entity to unavailable because the entity is in the entity registry, then, just below, the entity is removed - twice - from the state machine. This all seems odd, what do we actually want to happen when the tag is removed? With the current code, the entity will be back after a restart of Home Assistant, with the state set to unavailable because the entity is in the entity registry. If we want the state to be removed, we should remove the entity from the entity registry instead of removing it from the state machine. Some copy paste errors from previous attempts when this was in the entity itself. Corrected shortly These entities are not recorded in entity registry. Do we want that? Why does this default to the empty string instead of to None ? Why do we default to the empty string for device id instead of to None ? We should probably let the existing tooling pick the entity id This doesn't set the entity id , this allows the integration to influence the entity id picked by core. At the same time, we should of course not do this unless it's needed. Right, but do we need this as isn't it nearly the same as what L749 does already? Similar to sun this is not setup with async add entities so neither will it set an entity id nor will it run async added to hass() We don't usually pass hass when creating entities as its gets set by async added to hass See comment above. This is not run through entity platform helpers. Let's move this cleanup to another PR which does not add functionality Prel PR for cleanups is We should not add more according to this pattern, instead we should use HassKey . This can be done in a separate PR which does other unrelated cleanup Why is this needed? If we get warnings about the entity being created without a platform, something is wrong and we should now hide it IMHO. Isn't it an error if we get an update for an unknown tag?
Please don't change the internals here. Guard with has service instead Perfect, this answers my comment in the PR. Thanks :) (not sure what you mean by "changing the internals" though -- this function never behaved the way its documentation implies) The change to this function has been reverted and will be implemented in a separate PR. Change applied. This is going to have a completely different return type than if its not called with return response . I think this should be a different API Let's chat about this in the architecture repo. The architecture discussion is approved, it's OK to have a different shape of the data when returning service call response. Let's not conflate directives to the service call with service call data, it's enough with a query parameter: Sure, it was mostly for flexibility: depending on what the user is doing, it might be easier for them to change the JSON payload rather than the query string. Done, please take a look. We should return a dict with the response and changed states: Cool, that's what I had suggested in the latest version of the architecture proposal. Done, please take a look and resolve if it's all good. This looks like an unrelated formatting change ? Ah, that was probably Black auto-formatting the file because I had it open in IntelliJ. My bad. This looks like an unrelated formatting change ? both sides are an enum Until hass.services.supports response has been improved, let's check the service exists Let's restore this test Let's improve the test to also check the response and status code
maybe it would make sense to add a has system stats to a device inside the aiounifi package? For now just make it a method as lambda shouldn't be multiline and I think this suggestion doesnt get short enough either I think you can skip device here, there are nothing else that can report cpu so I think cpu utilisation is name space enough :)
Please define this as class attribute instead of disabling the pylint rule Just below VERSION add: entry: ConfigEntry None None Thank you for the helpful instruction! Use async update reload and abort() Will do. Argument would be the same ( reason "reauth successful" )? That reason is the default so you don't even need to specify it. Should it be possible to change the username? Yes, as the user may change the username in the App as well. This isn't needed in the user step so why we need to merge in credentials in reconfigure? I also added it for the user step (line 72). It is not yet read in async setup entry , as I understood this should be added in a separate PR. Not sure I understand. If it wasn't needed before why it's needed now? I removed the lines in order not to withhold this PR. Still in async auth Sorry, missed this. Not used? Not used?
These 2 can be merged now, as in, there is no technical reason anymore to split them Might as well just keep this one out of scope for the event entity Why is this a date? Is there a datetime data class equivilant? os should this technically be converted to a timestamp? I think timestamp is the way to go idem We can just make build a parameter for the AzureDevOpsBuildSensor and just pass that in together with the description
Side note: I think we need to add "repairs" as a dependency in the manifest. Hm good catch
Thanks, applied all changes
You can simplify that with a number selector. In addition, the input should follow the model of the other services when dealing with temperature and take the temp argument in HA's configured units. See the create vacation service, for example. For consistency, this service should take the temp in HA's configured unit and convert to F, in the same way other services do. See the usage of TemperatureConverter in create vacation() I've implemented this, but I'm not sure I like it. Ecobee seems to pick the closest value. They allow changes in increments of 5F, and working in C it gets a little fuzzy and I worry that might introduce some instability. However - it works. Thanks. This substitution is referencing itself. In this case, since this is the only aux cutover service, the entity id description could be a plain string describing what they're selecting. Something like; Looks like aux cutover threshold is no longer used here and can be removed. Thanks. If we know the current value, why don't we make this a number entity instead? That way, we do not need a service and we have an actual entity to work with. We surely do not want to introduce more state attributes, especially when they are not needed to be introduced. Why not a number entity? Because I copied the code from the fan runtime. (SERVICE SET FAN MIN ON TIME). I think this is because of the upstream library? I m very much learning how this all works (python and HASS) so my apologies if it s obvious. I don t have the ability to test this code for a little while. I think this is because of the upstream library? The code shows the upstream library has the features. I don t have the ability to test this code for a little while. Well this is not about testing, but about implementing a number platform for this integration. We, unfortunately, cannot accept the PR in the with the current implementation, simply because we are moving away from state attributes for cases like this. Would you be able to implement that? .. Frenck I ll give it a shot. I suspect that s a whole new PR what with updating documentation. The principle is that the aux heat threshold shows as a wholly different entity as part of the overall ecobee integration, instead of a property on the climate entity, correct? Similar to sensor.home assistant host os agent version in the Supervisor integration for example. Yes, except the example you gave is the sensor platform, in this case I'd expect the number platform to be used (as sensors are read-only, while this aux heat threadhold can be set as well). Number Entities are the way to model read write numerical data. This is the same feedback provided in April. issuecomment-2041280235
Can the current humidity be unknown ? In that case we should return None or we should change the return type. We don't want conditions in tests. Please parametrize the test instead. Thnx, missed that one. You are right:
Is async create task() required? I am unsure if its required, but this is how its done in adobe, airvisual, apple tv, cloudflare, and so many others. Testing to see what difference it makes now. This has been removed. Is this not already covered with test reauth errors (in particular lines 181 ff.)? The intent of this test is to cover when everything goes right, the intent of test reauth errors is to test when something goes wrong. I dont know if there are any conventions for this, but in my mind, if test reauth fails you know its an issue with the reauth logic, but if test reauth errors fails its in the reauth error handling. Agree and I also don't know if there is convention how to do it. My approach was that if the error-test passes and you get 100 coverage, all should be fine and you need no additional test. A wise joostlek once told me "I hope you're not just writing tests for coverage", which I usually am, but in this case the success test isnt just for coverage, it's for testing the users expected path, the success case. The reason the failure tests also resolve to success is because that's a Home Assistant unwritten best practice. No need to stringify as it's done by itself Use self.async update reload and abort() It's only a test but change something here and not use the same config which is already in place in the config entry so we can see it changes Done Use the parameters. Not sure why this is here. joostlek and I were speaking about this a few months ago, its a testing performance thing, using a for loop doesnt require the integration to be completely setup for each loop. I have no issues going to back to parameters instead. Oh no, I have both? thats a mistake As you made a comment tests are not only for coverage so I prefer parameters as it's more realistic than having all errors in the same flow. I don't think the advantage in performance is that significant it outweigh the use of parameters.
In that case the sensor itself would also be unavailable I guess so maybe bail out early if the sensor is not available as then this service call won't work either? True, with a bad config the sensor should never be available. gjohansson-ST Is there a standard error to throw when a sensor is not available? I just came across ServiceValidationError but don't know if there is a standard translation key for example? I tried to look for something like that in the code, but could not find it. exceptions You need to make the error yourself from that the sensor is not available. Just re-raise makes more sense IMO This is not an OK way to test, use pytest.raises instead. Either split the test in two, one with the happy cases where we assert the service passes and one with the bad cases where pytest.raises is used, or pass in a context manager as parametrized test parameter; here's an example of the latter: L532-L540 Splitting the test in two makes more sense since there's no response to check in the bad case. Should raise UpdateFailed I think and we can remove the logging. Or perhaps better to use a try...except block in async update data instead as this method is also used by the new service. It's a bit confusing to prefix with SENSOR when the new service is no longer an entity service, Maybe just CONNECTIONS MAX or MAX CONNECTIONS ? yeah, makes sense Why is this changed? was needed for the sensor service, but not anymore for a integration service -- reverted I think we should consider adding this to homeassistant const.py to make services more aligned across integrations (in a separate PR though) will make a PR I'd suggest to have the translation key technical, config entry not found This error message could see some improvement, maybe: "{integration name} integration instance {target} not found" or "{integration name} instance {target} not found" Do we want to say "integration" or "instance" here? I don't mind whichever, but it would be nice if it was aligned across integrations. Switch to instance like for mealie I don't like the word instance as it immediately sounds more technical but it's nothing for this PR in particular. As discussed on Discord: Either the name of the integration should be translated, or we should inject the untranslated domain name here. As discussed on Discord: Either the name of the integration should be translated, or we should inject the untranslated domain name here. Coordinator already does logging so these should be removed (can be done in a separate PR) separate PR Why is default date.today() It should be some integer? Add test without limit provided by the user
Hi, as you are creating entities I don't think you need to create a separate device registry entry as it will be created from the entity. Generally it is better to create your own base entity in entity.py and set the device info there. Then you derive from it in each platform. automatic-registration-through-an-entity. As I see you are planning to add the binary sensor afterwards you might as well create the base class at this stage. Hi sdb9696 tanks for the review! Great, I removed the separate device registry and defined a base entity to use in sensors and later in binary sensors entitites. A side effect of this change I made is that when reloading an integration, if there's any field of the device data that changed, like the firmware version, then that's not longer updated in the device page. I will research how to fix this. Did you get anywhere with this? The device info on the entity should be read when the config entry is loaded. Done, now the data is updated properly, thanks! These seem to only be used by the config flow so I'd suggest defining them at the bottom of config flow.py . You could move MQTTNotEnabled to init .py or maybe drop it altogether and just allow the error from mqqt to bubble up. i.e. Do you know that problems coming from mqqt are always because it's not enabled or could there be other types of error that you're masking? Yes that's better. I removed the exceptions module and defined the exceptions where they're used. Regarding the MQTTNotEnabled error, you're right, there are other errors that may break the MQTT communication, like the broker being down, so I created a more generic MQTTEerror to show. I think this is only used by the device registration so should be defined where that happens, i.e. entity.py or init .py Yes, I moved those constants to the entity.py module. Do you need this wrapper or could you just create the library class directly elsewhere? No, it's not required. I simplified this by directly instantiating the library class where it's used. Could this live in init .py as it's not actually a device and it'd be easier to see what's going on in the one file. Yes, much better. I moved this to the init .py .
What is the point of this? self.data is the old stuff right. Why remove devices lf we dont have any? this is to ensure, even after a restart of the integration, that we check if there are any obsolete devices in the registry left With the above change i think you should always run the cleanup. the condition (not self.data.devices and not self.data.templates) will only match on first coordinator data fetch, because there are no previous data, but we already collected the current new data, so we are able to check the device registry for orphan entries ... on every upcoming coordinator data fetch, we only check for orphan device registry entries, if there are no more existing devices or templates . Ok. I would probably just always do a check on first refresh inside async setup instead of coordninator. But okey. mhhhh sounds reasonable ... will add a async setup method to the coordinator I think there was some proposals for a init method for coordinator. Called only on first refresh. Not sure if that got merged yet. b4decb18b3da2b4f26d4cf189be0341166747e77 Pre calculate the accepted set at the start of the function so you dont need to redo that. Then you should be able to do: efa950af8385ac222d5124b9829647e88f73bcff available thanks will create a PR soon
Please use lowercase variable names
Should we really allow to turn the heater off by setting target temp to 0? It's not really logical we can already turn off by turn off or by set hvac mode This is inside the async update, so testing for target temp equal to 0 is testing if the heater is turned off. That is how the heater API reports that the heater is off, by reporting target temp equal to 0. If you look inside set hvac mode, the actual way it is turned off is by setting target temp 0 (line 167) Yes, I looked incorrectly. Thanks gjohansson-ST Here you can see how the heater is turned off, by setting target temperature 0. This is simply how the local API of adax works. The way I discovered this was by physically turning of the temperature on the device (by pressing down arrow until the display reads "-") and discovering that it was returning target temperature 0. Use cons.json to set icons for states The non-local AdaxDevice longer up in the code still uses attr icon, look at lines 125-132. Therefore, I have implemented it the same way. I suggest to accept this non icons.json for now for consitency, and then rather move to icons.json for the entire file as an improvement in the future? I guess we need to change both at the same time so it would be great to see a folow-up PR to fix that The non-local AdaxDevice longer up in the code still uses attr icon, look at lines 125-132. Therefore, I have implemented it the same way. I suggest to accept this non icons.json for now for consitency, and then rather move to icons.json for the entire file as an improvement in the future? There is a bug in the code that I discovered through this suggestion. self. attr target temperature is keeping track of the temperature when the heater is off (i.e. when the heater is reporting 0), so that when it is turned on it is turned on at the last set target temperature. Will make a new commit that fixes this. Not familiar with this coding style. Presumably it sets target temp inside the if-statement and uses that down the line? If it is only cosmetic I am fine with the change. It assigns a variable as it computes the statement and hence we can use it further down the code. See for some explanations
Why do we remove this? It isn't used anymore since the unit tests moved to snapshots a few months ago.
You could move this inside the if statement and move both session.close to on finally clause We should not close the clientsession we got from Hass, this is a shared session :) Ah, OK. I closed the session as the unit test complained about an unclosed ClientSession. This should be removed, why wouldn't you want to validate config Why is this block preventing the config from being validated? On line 38 it is if user input["check"]: Oh, okay, my bad. GitHub only showed me lines 14-17, so I got a bit confused I could have been more clear. I thought it was clear it was about the utilization of the bool. I think it should be removed altogether Oh, I was mistaken. This block should stay, as the inverter is only available when there's sunlight. The user can disable the check, so they can set this integration up, even when the inverter is offline at the moment. I don't agree with this, if the setup fails then you have no way to reconfigure it either and would have to remove it and set it up later on If you say so I've now removed the option and modified the test accordingly You should patch the lib instead of mocking http calls. The unit tests should also be way more complete. One for the happy flow and one for every bad one. But the example wanted me to create a test making sure the flow can recover from an error and it just wouldn't make sense copying the failing part. Please look into sensor entity descriptions, it will decrease the amount of code duplications by a lot! Can you remove this Please change the domain to apsystems Just to double check, is Sonnenladen in the loop that they are added as a maintainer of this integration ? This is not used and can be removed stale comment Why is this total, but for today production it is total increasing? Can device names be changed by the user? If so, they cannot be used as a unique ID. Don't override state, that's managed by the sensor class. what warning are you ignoring ? you can use existing self. attr native value property instead of creating your own property function Don't expose the update interval to the user. That should be set by integration author. Are you not able to get the name from the device? How is it shown in their app ? If the app has a static name, we should adapt that too. just hardcode the interval, don't allow configuring it. Don't override internal methods. Either override async update data or set self.update method .
Isn't used anywhere, so this can be removed removed now You already do a await coordinator.async config entry first refresh() in init .py which fetches already fresh data As the buttons look pretty similar, maybe consider create some press functions and extedn entity descriptions like e.g. tailwind The code structure is the same as in alarm control panel and binary sensor, so I'd like to keep it the same within the integration if that makes sense. Honestly, looking at the binary sensor platform, i would advice to do the same change as well, since its a lot of code duplication that could be avoided I spent more than an hour this morning trying the other way and still don't have it working. I appreciate wanting to make the code better, but I don't have that much time to keep working on it. I hope we can move forward with the currently functional, though not fully optimized code. Can we bump this independently from adding the button platform? The bypass functions require the updated total connect client. We can bump this in a preliminary PR before merging this PR. This way we dont have PRs that do too much Moved to When can the serial number be None? Some of the other older TotalConnect hardware does not report a serial number. The zoneid is unique (but just a database key). Shouldn't the device identifier be used in the unique id? The only thing that rests is to make a list of SENSORS, that contain a list of TotalConnectButtonEntityDescription (which is a class that extends ButtonEntityDescription and adds a press fn: Callable[[ type of location or Any], None] attribute. And then just loop over that array when adding entities. Oh and please bump this in a separate PR Even when bumping is required for this PR to work? If the "bump PR" gets approved later, the bypass functions added here will fail. This PR would fail without that bump, but they are usually approved waaaay quicker We should use translated names here idem This can now inherit the TotalConnectZoneEntity With inheriting that class, this class can be a lot smaller since a lot of code is already shared with the base entity. You could consider extracting the entity description like I've updated in binary sensor.py with SECURITY BINARY SENSOR . This one can now inherit TotalConnectLocationEntity and also remove a lot of its code since it's already in the shared entity Instead of running tests like this, you can use pytest.mark.parametrize and then you can create 1 test and have the data as a parameter. Please patch the library at the place where its used Please checkout the snapshot tests I added to test binary sensor.py . If you add it like that, you can run pytest . tests components totalconnect --snapshot-update and it will generate the test button.ambr files for you.
If they have multiple config entries this might not work since the service will already be registered Added a guard Integration services should be registered in async setup since we want them to be available even if there's no config entry loaded. The service handler should handle a missing or not loaded config entry. See: Services should not be removed on config entry unload. See:
It might be a bit clearer to refer to this as a state map. If I understand correctly, this is mapping states from the integration to states within HA, and the actual mapping to icons happens later with icons.json . Initially I was confused because I was looking for these strings in the MDI library. If you agree, the same change might apply to the docs PR. What do you suggest for a name? STATE MAP ? Done! :)
According to the diagnostic dumps, this is not a sensor but a setting. Shouldn't it be a number entity instead? These seems configurable and thus shouldn't be a sensor? The are exposed as functions according to the diagnostic dump provided in the linked issues. Same as above, should this be a number entity?
wouldn't something like this be enough? Sure, I didn't see this suggestion in the stack overflow link you provided, I went for the accepted answer. xD But 32? Isn't it too much? "The argument for token urlsafe is number of bytes. On average, one byte is 1.3 characters (base64 encoded)" So 32 will generate a 42 characters password. Maybe 15? That will generate a 20 characters password. I just copy pasted an example on the phone, you seem already to have read more about it so whatever you see fit and usable Gotcha! I think this is more explicit, change sounds like something that can take an input, not sure if regenerate is the best word but it shouldn't be change :) Should also be reflected in key and unique id You are totally right, my mind focused on "change" because of the old service I created. I like regenerate. This fits better with the specific test. This function is mostly to make the integration setup easier Ok
Copy paste? Yeah! Provide a supported fn that validates x passphrase is reported, this would otherwise fail on non-admin accounts Is this related to my previous question, to circumvent the sensors not passing requires admin True? You need the supported fn to make sure there is a value I've performed a test with a non admin account, the x passphrase attribute is still returned but with value None , so it's shown Unknown as value in HA interface. This means it wouldn't fail, but still I've created the async get password supported fn to guarantee the x passphrase is present. P.S.: I didn't check for the value itself because a Guest WLAN might have an empty password, in this case the sensor will still be shown. What do you think? Make supported fn be x passphrase is not None then Make supported fn be x passphrase is not None then Doing so will make the sensor for WLAN Guest with no password not be shown as well, even for admins, and I think it should be shown, that's my point. I know a sensor with no value isn't important, but maybe it doesn't have a password now, but will have, and this sensor can be used in some automation, I don't know. Do you get my point? Every restart that will be reevaluated so I think it's fine. Why show a sensor with no value hmm.. ok then! This will always return true as it's a property method L288 You can probably make this a lambda in the entity description if it fits on one line Done!
Assuming on update is being called when the device state changes, it would probably be better to assign self. attr available self. unit.is available() in there? See entity-class-or-instance-attributes your call though, this looks otherwise good to me. Btw, it's a good practice to use properties instead of methods for information that do not cause I O, this makes it easy to see if something is safe in contexts where no I O is wanted. So you could do something like this in your library in the future, no need to change it for this though.
Should the group only support HVAC that are available for all climate entities? Done Should the group only support swing modes that are available for all climate entities? Done Should the group only support fan mode that are available for all climate entities? Done Should the group only support presets that are available for all climate entities? Done Should the group only show supported features that are available for all climate entities? Done Would we not get this from the entities? I don't see why the user should configure it? Done Why would we not just call async update supported features() directly which would set attr supported features ? Because as other group implementations, this dictionary is holding the entities in the groups that support each features or service, and then use to just call the service on top of the entities that support the feature (rather than call the service on top of all entities in the group). If it's unavailable we can probably bail out early? Checking at the rest of group implementations there is no early return in case the entity is marked as unavailable. Also conceptually, availability and working attributes of the group entities are independent attributes (if unavailable the entity should not be marked as not having any other attribute). On this one and remaining below. Should we really return the most common one instead of having a sort off priority of states? Example: One is heating and two are off. Should we then not return heat instead of off ? HVAC modes used as state of a climate entity can be seen as an binary state with multiple ON states. Here the logic is filtering out the negative stats (OFF, UNAVAILABLE) so if any entity state is active (or ON state) those values are taken into account. Then similarly on how some enums attributes are being aggregated across entities in other groups, taking the most common enum value has been the consensus at the moment. Ok. So perhaps I took a bad example so let's do another one. 3 entities, one is heat and two are fan only . With your logic the group state would be fan only . Is that really what is wished here instead of returning heat ? Btw: Don't resolve until we agree, it's annoying to have to unresolve to continue the discussion 3 entities, one is heat and two are fan only. With your logic the group state would be fan only. Is that really what is wished here instead of returning heat? Yes that was my intention since the beginning. I think the logic behind of why heat might be more important than fan only could be driven that could be a more costly mode. This issue was raised on the discussion of the original docs PR: discussion r973765098 That being said, I believe that most common mode might be the fairest approach as ranking can be really hard to do. heat might be ranked higher than cool or fan only on colder countries, while it could be the other way around on much more hot countries. This can be a matter of perspective depending on how costly each mode i
Device class should be set to distance I believe CI is also failing and needs to be addressed fixed device class
If you're only going to use the values, why bother making the BUTTON TYPES a dict? Probably copied that over from one of the other platforms where I needed it but you're right don't need it here thanks Why would it not be? Good question, I wanted to remove it but forgot icon translations Thanks! There are references you can use [ key:common::action::connect ] There isn't one for disconnect right? There is, just add dis Where can I find a list of these references? I can't find any reference to [ key:common::action::disconnect ]? Same for favorite Homeassistant strings.json There isn't one for favorites, hence I didn't include it in the code this comment is attached to Thanks! Thanks!
nit: This comment about the special cases seems to be incomplete. Perhaps "also exists as a resource"? Same comment is also in three other places. Done nit: nit: "an device" - "a device" nit: "an device" - "a device"
I think the docstring should explain the special treatment of lists too I added a line for explaining the list treatment. The function returns the empty list in case of any error , is that wanted instead of erroring out? Why don't we want to blow up instead? I changed this so it blows. I think we should fail on attempts to use sort by when the response can't be sorted This is already guarded that it needs to be a dict and also below it will raise if the key provided does not exist in the dict. Maybe we can be a bit more specific, perhaps f"Key 'selected key' missing from response" I find it hard to understand the expected test outcome when the input is in the test and the expected output in a different file. I'd suggest to keep the expected output here, or have both input and expected output in a separate JSON file accessed with the test fixture helper. Both response and render is now in the snapshot file (sorted) Same as above, we should probably fail if we won't be able to pick a key Same answer as above Please add a comment explaining which lists will be given special treatment (why we require the length to be 1 and so on) Comment provided but I'm not entirely sure it's self-explanatory enough for an outsider to understand Please explain why we break out of the for value key, type response in entity response.items() loop Provided explanation (as logic is handled below for when it's not a single list with dicts.
Maybe you could use those states for the min max temps: I tried making attr min temp and attr max temp as properties with those attribute getters but pre-commit told me that I cannot do this :( adding setters for them didn't help... I looked at other examples and these fields are always constants. I don't know why... Use def max temp and def min temp , cf. domestic hot water production.py attr prefix is the default one when it's static, however it should be common for all instances. done! thank you! Let's use the full name (if that is allowed by the pylint checks etc.) since your device is very specific. Does this state change? If not; please set the attr max temp in the constructor. I have just recently added those getters as Tronix117 requested in discussion r1537705518 Other devices that share the same controller name can have different max temp and min temp than the one that I use. So do I make them static or leave them as getters? :) Are these states present for your device? If so; you can retrieve this attribute or state directly in the constructor. These states are present on my device, of course. Is this what you mean? Yes! Done. Sorry for my poor understanding, I'm a non-native English speaker and non-programming engineer :) Same You should always return a valid operation mode, you can't just return the self.dhw mode value. Can the fallback (in this case STATE OFF) happen? Sorry, I saw no harm in returning a custom mode that is not supported by exactly this device. This device reports ManualEcoInactive for Manual, and ManualEcoActive for Eco, but there can also be Eco mode that can report something else, that I couldn't find out, or any other mode, that is not described in this particular device, but shares controllable name with it. Any other mode not supported here would report STATE OFF instead of the actual mode name. I will do as you say, of course. Good to not use other constants enums, even though the underlying value might be the same (at the moment). um... there's no such field as PERFOMANCE in OverkizCommandParam. Than we should add it . Using STATE PERFORMANCE for both sides can cause unintended side effects when Home Assistants changes a constant. Small chance; but still good to have constants reflect the reality. Done Waiting for pyoverkiz 1.13.10 prerequisite in HA core now, I guess. iMicknl Ok, I'm tired of refreshing the overkiz manifest.json contents manually :) subscribed to its updates, but I can miss one, so if you happen to remember that this PR exists after you bump HA python-overkiz-api version - please ping me :) thank you ALERTua will do! Let's try to get your PR in for next months update. Created Do you plan to make more contributions to the integration? Feel free to join our Discord Is this required? You only use this once? I would just add this to current operation function. Done You should import LOGGER from const.py . Sorry. Forgot to delete the logger after debugging. Done
Please add tests which test also the other supported services I tried to add further tests but as in the [other pr]( issuecomment-2103223337) I do not know how to do that in the end. I removed the tests for now. This is not great, I'd suggest to open an architecture discussion suggesting to add FanEntityFeature.TURN OFF FanEntityFeature.TURN ON Adding those should not block this PR though. Is it useful to log an error here? Maybe either fail the service, or set it to the lowest possible fan speed? done, rely on percentage to ordered list item You can not compare with is not here. You have to use ! The same applies to the other comparisons We can also show the active percentage in the Modes VENTILATION and SENSOR OVERRIDE. The app shows also the four different values in this modes. done Perfect. Can you change the comparison to if self. attributes["active vicare mode"] ! str(VentilationMode.PERMANENT): because we have two different types of objects here. So comparing with is Not is always false. After your commit I ll give it another try. During my test I noticed that the API sometimes needs several minutes to deliver the updated value after changing the fan speed. Is this due to the limitation of Viessmann or the implementation of the Vicare library? The API response cache is invalidated after a set command. This should pull the newest data from the API. But it's known on other occasions that the API is not updating that fast: L134-L136 Probably we would need to have some kind of blackout period where the entity reads the values not from the api but remembers that it was set to a certain value. Same here: Should be if self. attributes["active vicare mode"] ! str(VentilationMode.PERMANENT): Please move the side effects out of the constructor for the entity and into the function that runs in the executor. We want to avoid side effects in init Generally we don t add extra state attributes to new entities. They should instead be first class sensor entities with proper device classes and descriptions For context: Unless, there is a good reason to keep them here (which generally only means they have no meaning on their own as a separate sensor). These are the causes of the effects bdraco is talking about Should this be handed into the constructor instead or rather handled in the update function? Removed for now, I maybe can add this as a real entity later on (this applied also to other platforms). Translations for the extra state attributes are missing As hassfest pointed out, these are not valid translations keys. The key in this case comes from the api, so I need some kind of in place translation here, right? Is there some helper available to do this? There is no helper for this. You'd need to define a mapping between API and HA in this case. There is a - sign in the editor where you can directly do(suggest) the changes in the code. I can t change the code directly in your pull request.
Since we have both sync and async code in this codebase, please prefix coros and callbacks that are safe to run in the event loop with async This one probably should be another PR though as it looks like the base class is expected it to be explicitly named Yes, this is a base class abstract method. It is more appropriate to create an independent PR. This can probably be a set, which would be more efficient.
I think "user" is supposed to be "use" here(?) thanks
Change reverted. [Casting is required]( step:9:28). Can you get rid of the branching in the test? Not unless I stop testing the name of the camera or go back to a more basic camera entity name (which a lot of people complain about being confusing). The package camera channels are bundled in with the normal ones, so there is no really easy way to identify them other than the name of the channel. I could abstract the core code I use to [generate the base name]( diff-b819c8e3744961cb309ae3feb57a14ebbfc3a62284a1aad26d16ec1109a6c33fR196-R198) and use it in both camera.py and the tests, but it would still have a branch regardless. That would be a bit better as it avoids the complexity in the test It does not really change anything since the branching would just be moved from a test helper function to a shared helper function. The branching is not actually in the test itself.
It looks like the fallback changed from https to http here. Is that what you wanted? Yes, as I introduced that parameter just the other day, I realised when doing the tests here as the port would still be whatever configured before and that would mean "http" protocol I changed back to http in this specific case. Once its been populated it should always be known what the user has configured. I'm not sure why you just wouldn't change the default in that case. If the user is reconfiguring and hasn't previously set the protocol, the default is http, but in all other cases the default is https? Probably I am missing something. Reconfigure should present the opportunity for the user to change the current configuration, thus it should use the current parameters unchanged. So either the case would be that the integration is set up without a configured protocol and it would mean http and whatever port currently configured or the user has selected protocol and its corresponding port and everything is ok. Default for setting up new devices will be https and 443.
Is trouble a word used within the risco system? Yes, that's how it's described everywhere in the Risco ecosystem Would the battery low device class fit? From what I understand this means a general problem with the battery, either it's empty, or defective, or not working for any other reason. Not sure if that fits the Battery class, but happy to change if it does. I think keeping it this way best reflects the risco use case After looking at a couple of Risco docs, this is usually described as low no battery, so I'm going with your suggestion Please add entity translations and add icon translations Since these are the names by Risco, does it make sense to translate them? I think it still adds to the user experience. When a French company creates an integration we also translate the names to English in the code and back to French again via translations. Otherwise your English dashboard would be polluted by French names. I think the same can be said the other way around here. We usually just create one list and extend that and pass it to the function. Not a blocker, just wanted to let you know
In a future PR it would be nice to make these named constants enum so we don't have magic numbers here
Both of these are always positive values? Yes, they should be always increasing in life. But it is still Enphase... This could be replaced with attrgetter('energy delivered') from operator import attrgetter This could be replaced with attrgetter('energy received') from operator import attrgetter Since this pattern is existing, lets adjust this in a followup PR and do them all at once
Note, I excluded this line from code coverage as it covers a hypothetical future scenario where a user downgrades from a future major version to this version. Any test that covered it would be a work of fiction. It is included in the first place because it exists in the [example developer documentation]( config-entry-migration) See L238 as example on how to test this. I will do this, but the reason I didn't was that in a future major version, by definition, both the code and the config entry will be of a significantly different structure, so we are not actually testing anything 'real', and the in that context a passing or failing test will not add any clarity. But either way I will add the new test. Implemented in [ed7237d]( As there is no change it's not needed As there is a default in the schema there will always be something here so no need to use .get() to specify a default value Also below I will make the same change to the two lines above as well Removing the .get() defaults Causes test form to fail Should we have a default here too so the user can't leave the field empty and thereby not get a value? I was following the lead of where defaults were removed here. Presumably because they were unnecessary duplicates as defaults are defined here: diff-f7e2ef265b774da4533e59e774aad087920f82fc97c3b9e7801f15537360bb5dR47-R51 You're probably right so let's not have the default in the schema for the options flow. Just have a check so if left empty we set it to 53 . Isn't that achieved by: L176-L180 As user omitted inputs are replaced by defaults? N.B this is not the same as Line 118 which is discussed in the thread above Tested at [c9e6f5b]( And this scenario is indeed tested by L249 We could just use the same constant right? We could. I didn't because I couldn't find an RFC that said 53 is definitely the default port for IPV6 and its not a fully implemented standard so I wanted to give scope for things to be easily changed. That being said, it wouldn't be hard to make the change in the very unlikely event it changes to something other than 53 so I will make your suggested change Done in [fabfea5]( A bit odd to use the parameter name only for the last one, also below for ipv6 No need as we have a value always
Why not use a [ deque ]( collections.deque). No trimming necessary. The list isn't uniform. There is one system message followed by pairs of user and assistant messages. I could use a deque if I broke out the system message and made the list contain pairs instead... Oh right Why do we offer this to users? Also not ask on initial creation, maybe even never. Unlike OpenAI, context window size is a factor you have to take into account locally. Models like phi become almost useless with too much in the context, I've found. But how will a user know? Looks like they can't currently: yuk We should not ask this on initial creation of the config entry. Removed model options for now Not for this PR, but it should be interesting to explore if we can have an error message that is for humans, and an error message with tech details. Do you want your voice assistant to say: "Cannot concatenate None Str" ? Why copy this ? With this, in the tests the mocked client.chat call args all had the same value because I append to the message history after the call. So every call args["messages"] had the full history instead of just the history up to that point. I figured this would be better than working around it, since the Ollama client could technically store a reference to the list for some reason. One day Why do this? By default, Ollama only keeps a model loaded in the GPU memory for a few seconds. From what I read, this is because people use it on rented GPUs and it costs them money. Since our goal here is local, it ends up just requiring a significant amount of time to reload the model if you don't constantly use it. Don't forget to also log this error. let's rename the integration to ollama . I don't know why I added conversation to openai but let's not repeat that mistake This can become 1 big if-statement no? I don't think that we should ask these in the first form. It should just be the URL. For model, maybe has 2nd step when we could query available models ? Or maybe we just defaullt to llama2 ? Should we allow changing URL? That is not an option but an authentication thing? This should be a reconfigure flow and out of scope for this PR. Booleans are numbers from functools import cached property These should all be removed from initial user setup.
Please also implement async unload entry to allow a config entry to be removed without requiring Home Assistant to be restarted. Please change to use this pattern instead of storing in hass.data I think this pattern means only a single config entry will be created? Should we not instead create one config entry per discovered device? The benefit of creating a config entry per discovered device is that it allows us to leverage zeroconf to update the IP address of the device. dukeofphilberg can you rewrite this integration to be based on a single device per config entry. The pypi page does not link to the repo at also the repo does not have tags for any of the releases. Is this something that can be fixed? The repo has a [release workflow]( is that not used to make releases? Move this and the other constants which are used by the media player platform to media player.py This will trigger on any UPNP devices, is it useful? Is it really user friendly to make the entity id default to the UUID? If you don't set it, it will be a lower case version of the device name which seems better for users? Also, set the unique id to just the uuid please. Move these and the content type below to class level The way this is handled is weird, it's set to MUSIC here even though the media player's state is unknown. Then it's set to None forever if the media player is stopped Why do you set this? I don't see where such a device is created? If this log should be user visible, make it more descriptive. If it's intended for development, decrease severity to debug. Also set available flag to False. Please remove this comment, it's intended for the implementer of async browse media It is possible to browse the media through the LinkPlay API, though it is not implemented yet in the python-linkplay package. I'll remove it for now. Dispatcher signals are global. Set media player to track device name: This is not a web UI for users to use. So should not be offered. I don't know if it is specific to the media player I'm using, but when you browse to the endpoint you have several options to control the media player and its settings. ![image]( Can this raise a LinkPlayException ? If so, let's create a decorator around the command methods to turn those into HomeAssistantError All API calls raise LinkPlayRequestException on error so I'll re-raise them as HomeAssistantError Why guard this? What if our state is not up to date This does not seem to be able to discover a Wiim Pro that I have here for testing. Which is another reason relying on zeroconf will be helpful. How often does this fire? We don't want to have the state updated all the time just because the time is elapsing.
Same comment as was already linked, we should not ask for comma-separated input. That is not a good user experience. Ok, thank you. As Is aid, it's my first PR. I thought it was a good idea to implement it in the samw ay it's done in the API, the PVGIS tool and all other tools I checked when I tried to wrap my head around the horizon feature. I'm sorry for causing you inconveniecne. I guess I'll eventually figure out how to get this functionality into homeassistant in some other way.
Nit, align wording with the one used in the more info page (
Whoops no
Don't forget the walrus!
This function shares a lot of code with find referenced areas and find referenced devices . Can we create one private function out of it and reduce the duplicated code? Into the new common function, we need to pass in ATTR FLOOR ID and Script. find referenced floors I've merged the floors areas finding. I've not merge it with devices entities at this point. While they are similar, they are different (e.g., handling of condition logic). I didn't want to put that refactor into the scope of this PR
no need to redefine this, this can be imported from homeassistant.components.lock is this really true for every August lock? As in, some people might have doors that don't have a latch. You probably need to check if this is enabled for this lock in your library first We should only set this for devices that support open Looks like we are missing coverage for these Please bump this in a separate PR. Usually we ask it to be split, but only when there are no breaking changes. It ok to bump in the same PR as there are breaking changes as there are new lock states that need to be handled Please don't change the common constants. If you need a constant define it in the August integration. This line looks like left over testing? use pytest.raises with a match here instead
This looks unused Please remove commented code There is some duplicate code here. Please refactor the LutronCasetaCover to have a base class so it can share so we don't have duplicates actually i think this wasn't correct anyway, stop and tilt stop are separate methods Its unexpected to call async update here... this may be an existing bug that was copied .. will dig into this Looks like it does update self. device in the base entity class. Thats a bit messy but an existing issue ATTR TILT POSITION is required so this can't be missing. Please remove the guard L224 This guard is not needed since it can't be missing L181 This is an existing problem though no problem I can clean it while I'm here Looks unused now
We set the self. attr assumed state True in L124 which cause the frontend to display seperate Play Stop buttons since we don't know the play state, when you know it, we should set it to False so the frontend will display the correct Play Pause state. See for more information about it When a TV supports foregroundAppInfo does it support if or all apps or we need to fallback to assumed state if we don't get information? I am sorry this is slow and taking time I don't have a TV that reports this so it is hard to me to understand what we should do. It's supported for every streaming and media player app that I've tried (youtube, netflix, amazon, spotify, built in media player app, jellyfin), so I assume it is for all. The PR is still marked as draft, if I understand correctly it is ready for review? To be on the safe side, It would be better to set it to True so if a source will not support it we fallback to assume state
This looks wrong, if the swing mode register do not respond, the swing mode should be set to unknown or something similar, so the user sees the problem. A log entry would also be good, since it might be a bad configuration. janiversen Tried to fix it: I removed the test against None because it seems that in case of missing answer, the bus answers -1. and it is never None. If you like this way, later (other PR) I could apply the same also to fan mode and hvac mode. This is not documented. Doc updated You need to test with all addresses in the configuration (check config). What if one is a list and the other an int. janiversen I was managing this request related to the function def check hvac target temp registers , function written at the time when no central validation of the modbus entities existed. I wrote that function to check if the new target temperature registers overlap with some.. Now, instead to fix that, I was checking how your function def validate entity works, because in my opinion it could be the best way to manage also the conflicts inside the same entity. I found 2 main problems: 1) that function doesn't consider the possibility to have [CONF FAN MODE REGISTER][CONF ADDRESS] as list and [CONF TARGET TEMP] as list. 2) it doesn't recognize conflicting registers inside the same entity. I tested this also in my production server, updated at the last core. I may suggest to work only with def validate entity fixing the bugs and removing my previous function def check hvac target temp registers in order to simplify the code. But as maintainer, I kindly ask to you how you want to proceed. Thanks. Let me know. Check config existed when you made your first modbus contribution, but you might have overseen it. the validate functions equally existed (but are now no longer inline functions). This PR is about swing mode, so please do not mix a lot of other changes in that, make a new PR instead. Mid term I am removing all voluptuous validators and add them to check config, since this allows to create an issue and thus be a lot more user friendly. Ok. So, at this time I'll improve def check hvac target temp registers only.. Then, we'll see. Fixed the case where swing mode register is a list. ( CONF TARGET TEMP is always a list. The goal of the function was to test only if CONF TARGET TEMP is overlapping with some other registers.. This function and validate entity will be fixed in a another PR to check registers conflicting into the whole entity. Are you testing that a list only contains 1 entry. This piece of code is not related to this PR, anyway the list cannot have more than 1 entry because it is checked at line 313 def register int list validator(value: Any) - Any: and a proper warning is raised. This need to be different for a list. Dear janiversen , you're right. But the same should be for loc addr.add(f"{hub name}{entity[CONF FAN MODE REGISTER][CONF ADDRESS]} {inx}") as I tried to tell you respectfully at 108906 ( discussion r1467787468)
I think its reasonable to change the default in the future when not set, so perhaps not set this? As an alternative: I am curious what you were planning to set the of days? I was curious if we should just increase the default. I saw this before at 7 and thought that it was pretty low. Not sure if it would solve your problem to increase the default and not offer this as an option. I think its reasonable to change the default in the future when not set, so perhaps not set this? this is just to add a value to the config entry options if there is no one, yet. As an alternative: I am curious what you were planning to set the of days? I was curious if we should just increase the default. I saw this before at 7 and thought that it was pretty low. Not sure if it would solve your problem to increase the default and not offer this as an option. The default for YAML config is [1 day]( L70) and changeable by the user on demand. When configuring via UI, than we actually set 7 days which might be enough for many ( most ) of the users, but sometimes it is to less ( see 108003 ). So i thought to make it configurable again, would offer the most flexibility to the users. My own use case is my birthdays calendar - i don't have much friends, therefor not much entries in there so it happens that next date will be a few more days weeks far Would there be a down side if we just set the default to 30 days? or 60 days? yeah, i think it might still not be enough for some users. tbh the link issue is the only one i know complaining about it, so i think the 7 days is already ok for most users. Maybe we should just mention the 7 days and the possibility to change it in the docs? one downside of statically increasing to 60 or 90 days, it might result in higher load on CalDAV servers, especial on well filled calendars If we can find a default that works for most folks (e.g. 14 days, 30 days) that seems like it be ideal to not need extra configuration options. please don't get me wrong, but why not give the user the possibility to change this on it's own preferences or needs? Sure, we can also increase the default to 30 which might be also good for most users, but also might increase the load on their caldav servers ( since more events might be returned ) and and their HA instances ( since more events needs to be checked which is the very next one ). Further i think most users are already satisfied with the 7 days, since we we got only the one issue till now. My general impression is we want to not offer additional configuration options unless needed, and not necessarily support use cases that are far outside the norm. If we can find a balance of end user simplicity and performance then that would be ideal. If its not possible to find that middle ground because its too expensive, then its not possible i guess. (Perhaps bad idea: could also be adaptive (first try 7 days, then 14, then max 32 if no events are found).) allenporter: I am the one who opened 108003 and I certainly wo
The total sensor, in general, is by far the most common sensor to use on the energy dashboard. Why is it disabled by default? Good point, I simply didn't want to flood the users with a bunch of new sensors. Considering this being a total, it might make sense to set the suggested unit of measurement to KWh? So we would need to convert here on the fly, right? Doesn't the energy dashboard do that in the end to have better readable values? So we would need to convert here on the fly, right? Well, Home Assistant handles that. Just set the suggested unit of measurement property additionally to the native unit of measurement. Doesn't the energy dashboard do that in the end to have better readable values? No, this won't matter for the energy dashboard at all. This only affects the display of sensors. Ok, nice.
We should instead import this yaml configuration and automatically create a new config entry from it. Check streamlabswater and suez water for examples Although I like these steps, let's keep them for a followup PR Why do we only support one instance? You only have 1 step, no need to make errors a class variable I think you can just inline this into the flow instead of creating it a separate function. This will save you using the class variable raise a ConfigEntryError instead. In the future we should create an issue of some sort for the user to act on. (I can assume that Rova will gain new areas and lose some areas in the future, causing existing setups to fail) Thanks, updated but added small change to pass tests (got a UnboundLocalError for is rova area otherwise) Why do we strip? Instead use self.add suggested values to schema Deprecation period is 6 months, let's aim for it to go in this release You don't want to use the name for the unique id since we want to use translation keys here and then name will be None Would this not result in a breaking change as description.name is referring to the values in SENSOR TYPES (e.g., sensor.[address] bio will change to sensor.[address] gft ? Unique id ! Entity id, so unique id can for example be a serial number, while the entity id just a normal sensor.device something . But since all these entities are already in the entity registry, it won't change the name (but that's with entities with unique id, that is, so I expect it will change, but we don't consider that a breaking change) I'm missing a few strings. Cannot connect error and the text for the issues I'm missing the strip here Why the default Without default, when left blank not provided by the user, it'll result in a KeyError: 'house number suffix' at suffix user input[CONF HOUSE NUMBER SUFFIX] . Please move to conftest.py Please patch at the place where this is used. Checkout the epion tests for a nice way to patch the lib. Shouldn't this test fail because the suffix you passed in is not the same? Please use parametrize for this. the tests should always end in either an abort or a create entry to also test that the config flow is able to recover. either suez water and streamlabswater has some good examples for this I am missing the import flow test to abort if the entry already exists Please update the test name and docstring This test now only needs to repatch the lib to not raise the side effect and to show that the integration is able to set up after an error This one also should be made to succeed afterwards
I don't think think this is a proper name that is generally reflected in Home Assistant. This is about importing energy, right? I agree with you, however, I decided to use the same name as on smarlife. I will send an image of smartlife. Feel free to suggest another name! ![WhatsApp Image 2024-03-18 at 13 37 21 9081a7dc]( ![WhatsApp Image 2024-03-18 at 13 37 21 6fac042a]( Changed the name as recommended, it really looks better within Home Assistant.
Should we only do this when enabled is true? I was going to say that there is no reason to call the service if its not already enabled, but someone will do that of course adjusted
Instead of logging, should we fail the service by raising ServiceValidationError , or it's more logical to just go ahead when the volume is unknown? When can this happen, is it only when the media player entity has just been created, or could it happen also when connection with the remote device has been severed? I think the approach is to just go ahead with the service, even if the absolute volume can't be determined. The overlay will then play at the device's current volume level. self. volume should pretty much always be known and would only really be unknown if the device is not behaving as expected, so this check is probably not necessary.
We should retain the old config, else the boot would fail since I marked ALLOW EXTRA below I was able to import with the old configuration from v2 - since the settings are not useful with v3 they are not useful anyway. Any other reason to keep them? I think it would be nicer to implement diagnostics in a follow up to get debug information good idea - should I remove the debug logs for now or keep them for now and replace them with diagnostics in a follow up next PR? Instead of assigning the coordinator to the entry, please assign it to hass.data[DOMAIN] . If you support multiple instances of the integration, please use hass.data.setdefault(DOMAIN, {})[entry.entry id] to store the coordinator yes, I support multiple instances. Most users will likely only have one but each TheThingsNetwork application would need a different instance. I will use hass.data.setdefault(DOMAIN, {}) . I would also need to use this for other information saved at runtime in entrySettings.py . Please do this before setting up the platform or assigning it to hass.data Please check other integrations what they do ( epion for example) Unneeded There is no options flow, so we don't need this yet Everything can be done in one function that would clean up this config flow a lot. Please check youtube for an example. Alternative is to add reauth later on. If we can make this nice and neat in a few cycles we can keep the reauth in, otherwise we can split it This sounds like something stored in options, which we don't do at the moment right? right - removed all the unused const Please have a static update interval. It sounds like you wanted to make it configurable, we don't allow that. We steer people to use the update entity service instead. After the super() init the config entry is stored in self.config entry ok, I will switch to use config entry Please type the Data update coordinator the return type of async update data Please stop using , we only usually use (it's throwing me a bit off ) uhm, means private vs which means protected. I can switch to use only protected if this is the style here. Please let me know. What's this? before removing the options menu, this was used to allow configuring the refresh value. Since the feedback was to remove the support to configure it then I will remove this option. I think it would be way cleaner to keep the coordinator responsible for fetching the data and have separate methods in the async setup entry in the platforms responsible for adding new entities. An example of this can be found at withings , especially the sensor platform. With that approach it would create a listener, and I believe you mentioned something about not always polling, can you maybe give more information on when you exactly want to poll? Please add the coordinator type as type generic to the coordinator entity Also, please use CamelCase for the name. TTNEntity or TheThingsNetworkEntity would both work for me Not sure why this has to be a static one (I have not encount


May be this should become a config option as well so we can suggest https as the default protocol? No I don't like to expose this kind of config over options, if it works it works and they don't need to change anything. If they want to limit to https traffic on device it will trigger a reconfiguration flow I does not seem to me this should be part of the unique set, same applies to CONF PORT , but that can be addressed in another PR. This is the reauth flow, if the user chooses to change to https this needs to be part of it. I do not understand why. Removing port and protocol here would be better. This command validates the already registered unique id and if it matches it will update the config entry data with the input you see Should be consistant with the other check No, this is from discovery and it always provides HTTP port, so we only want to update the address if it changes, but we can not trust the port information now as HTTPS is in play. Why whould you want multiple enties to the same IP with the same user? It is enough to have IP Usename unique IMO. This command validates the already registered unique id and if it matches it will update the config entry data with the input you see Thnx for explaining.
I think you used the refactor button and forgot to check what else it changed I searched and replaced. Thanks. I changed it. Not sure if there is a big difference here And the docstring is not correct
This is an average. Averages cannot have a state class. Thank you, I removed the state class. Instead of adding a name here, it should be added to translations. Moved to strings.json I think the second word should be lower-case to follow [HA style]( "Entity names all start with a capital letter, the rest of the words are lower case"
convert temperature if needed doesn't accept a None if you're confident your self.coordinator.data is present you can use self.coordinator.data[Attribute.INDOOR TEMPERATURE CONTROLLING SENSOR VALUE] since current temperature can return a None, and likely will when first polling I'd do this: if mypy complains you can explicitly check for the key with an if statement. My 2 , avoid casting whenever at all possible EvanSchalton Thank you for your feedback. The cast is because self.coordinator.data is dict[str, Any] , so I am casting specifically to a float . Technically the data itself can be str float , but in this case it is always float . I updated the type hint on convert temperature if needed to be float None (which was already handled). I see in your other comment that we said the same thing. revert same same may be sensitive to value None, consider turnery EvanSchalton Mentioned above, but convert temperature if needed does handle None so this should be fine. You could ignore a lot of my earlier feedback if you update thie function to handle the None temperature: None float EvanSchalton Thanks for your feedback, done. I think I asked before on the last PR, why did we do this again? Like the whole status thingy joostlek It is getting all of the possible sensor types and including them if either: 1. status key or status sensor exists values is None , indicating that the sensor should always be added 2. The coordinator data for the status key is one of the allowed values in status sensor exists values The reason for the slightly clunky logic with the status sensor exists values is that the thermostat returns a value for the status for which multiple may correspond to the sensor being available. For instance, the Indoor temperature controlling sensor should show in the UI if the INDOOR TEMPERATURE CONTROLLING SENSOR STATUS value is either 0 (normal) or 1 2 (installed but in an error state). What do you think about maybe splitting the classes into the different sensors you are providing here? Even tho this works, you have a shared entity (And entity description) that doesn't have that much overlap. For the controlling sensors status sensor available value , status sensor exists values and value fn are all the same, while for the status ones, status sensor available value are all the same. Also since the available property is based around the difference in both sensors, would it make sense to maybe split the AprilaireSensor into 2 classes? (You could add a third to have 1 class inheriting both BaseAprilaireEntity, SensorEntity and then have the two other classes inherit this superclass). I think this way, the code is more clearer on what it does and when it does something and is easier for extending in the future. But let me know what you think (don't see this as a must, just throwing an idea) joostlek Personally I think that would introduce more complexity than it's worth and it would reduce the flexibility, especially considering future uses that 
Thx. I've just copied them 1:1 from here: And in my mind they had to stay "original". But you're right, they deserve some improvement Doesn't None mean there is no error rather than unknown ? Yes, it means, that there is no error. And the python None is translated to unknown by Home Assistant. Should I use a custom string instead, like no error ? If None means no error it should return as "none" "no error" ... that can be translated into something that means no error. I already had it like this, but I changed it. See comment [here]( discussion r1545754481). Should I change it back? I already had it like this, but I changed it. See comment [here]( discussion r1545754481). Should I change it back? Is this list not available in the library to pull instead of listing explicitly here? Yes, it's available from the library. I got it from the library [here]( But I was asked [here]( discussion r1530778803) to literally list the options. So I expanded this to this PR. Should I change it back? No, let's leave it as it is. Should not break anything but for translations etc. I guess it's better to have it controlled.
is the default should be the same should be the same I'm getting an error, while trying to push the file with the changes above. Here is the error: homeassistant components arve config flow.py:37:4: W7432: Return type should be ConfigFlowResult in async step user (hass-return-type) I think that's not directly related to my change. Just the FlowResult return type was recently migrated to ConfigFlowResult . Yes, sorry, refactored the code and was able to push the changes porbably better to at least log a warning here please remove any empty keys info is for core only, use debug instead you can also set this as attr during init store this in a variable to avoid duplicate code this can also be a function btw we require the code to be hosted in a public repository in GitHub or GitLab and I couldn't find it, could you please share a link? Hello, thanks for your comments, do you mean public repository of the python library ? yes exactly Here is the link to the public repository: thx! that's really often, is it really required to query that often? So the device sends the measurements each 10 seconds, if there is any restriction about scan interval, I could change it Currently you are polling the device every 10 seconds. If the device sends the data you should move to a push style approach (but that could also be done later as an improvement). I'm not aware about any limits , Limit is 5 seconds, but 10 seconds is still quite often and you are putting load on the system of your users. The question is, if there is really a benefit in doing that, or, if the data doesn't change that much, wouldn't less frequent polls be enough. Also, since you say it's a cloud polling integration your also putting load on the vendor's system It works so that the device sends the data to our web platform and the integration gets the data from this platform, not directly from the device. In that case should I define the type of integration as cloud push or stick with cloud polling ? ah understood. In that case stick with cloud poll I suggest you move to a DataUpdateCoordinator . That way you can get an update for all entities at once (since they all appear to be using the same endpoint), and don't need to do updates per entity. Thank you very much for your suggestion, does it mean that I will need to get rid of the Entity descriptions, or only from value fn field in this descriptions in sensor.py ? no, it has nothing to do with that. You'd basically add a separate file coordinator.py and move the update logic from both the sensor and here to there. Here's the offiicial documentation: coordinated-single-api-poll-for-data-for-all-entities and here's an example for a simple implementation Thanks for the information Hi, I'm trying to implement DataUpdateCoordinator as you suggested, but to be honest I'm having difficulties with it. I looked into the documentation that you provided as well as into simple example. I've also found a couple of other examples. In those examples it seems
There's already a pressure sensor reporting in bar, is this the same data, just with a different unit? Yes, I made it this way so that the specific equipment pressure sensor will display the value with same unit as in the myUplink App. Just to double confirm, we create multiple sensors in Home Assistant for the same data but with different units? Or will the backing hardware EITHER have a pressure sensor reading in Pa OR a presure sensor in bar? Same question for the duration sensors. Nope, the API exposes 20-100 datapoints ( sensors) for a typical heatpump. The API will for most sensors send metadata describing the type of data ( device class) and unit ( native unit of measurement) in addition to the actual value There can be many different pressure measurements. Some pressure sensors measure internal pressures value across e.g. a fan and some could represent athmospheric pressure or water pressure in floor heating systems. So the entity description will assign an optimal set of arguments for the specific measurement type. Same applies to duration measurements. Some sensors will tell you how many seconds the compressor has been running in the last cycle. Another sensor can display for how many days the compressor has been running the last year. I think it is reasonable to use the units that the API suggests as defaults in HA. OK, and the user can differentiate between, for example multiple pressure sensors, because the name of the entity is set to device point.parameter name which is descriptive enough to make sense? Exactly. These are the auto-generated sensor names for my Nibe F730 heatpump. ![image]( There are already multi sensors reporting time, are the ones added in this PR the same, just with different units? Same reason as above. This is to keep the default unit the same as in myUplink app for each datapoint. The API can expose many different points of duration data, in some of them seconds is the relevant unit in others days are relevant. I think it will be a better user experience if we stick to the defaults that the API suggests in the metadata.
from homeassistant.const Hey, thanks for your review! In another [PR]( discussion r1505566658) I was explicitly asked to remove the DOMAIN from hass.data. Is there a specific reason why you want to keep it? because I read it wrong, ignore this one is the default use the attributes attr ... instead attribute also can those throw? oh yes true, when the device is not connected anymore, there should be an exception when calling. open for discussion: If you are getting all connected devices anyways, wouldn't it be easier for the user to just add all of them in one go and switch the integration's type to hub? It's an interesting idea to let the user add multiple devices at once, but I am not sure how often it will happen that someone adds multiple USB Power-Sockets at the same time. For me a hub is a component which uses one physical connection to manage several devices. In this case each device is connected via USB to the host. just a bit shorter any reason why you're not using the one from const here? I should do that, you are right I believe style guide suggests a new line after docstring since recently I believe is the correct way to call a blocking function will be handled correctly by HA. I'm not 100 about the "f" string, but ruff will tell you raise HA exception here too and here getting nitpicky here, but since this is not really the config enty, I'd prefer DEMO DATA or something along that lines I'm not sure I like this approach, because it depends on the switches being added successfully and feels a bit error prone. Can we maybe switch to parametrized tests and snapshots?
You can overwrite the type in the coordinator by just setting On class level Snapshot testing? I don't think this item is used as intended. This is the url for the application settings, not for the mower device settings. It's not possible to configure the device at this url. Please remove this item.
Usually we would put the index in DeviceRegistryItems See the entity registry for an example My bad, I simply copied the functionality from an [old PR]( and failed to notice the entire paradigm has changed since then. [This]( L791) is what I've found. Apparently, there is no search by name in the entity registry . I have [found something]( L117-L118) in the area registry , though. Do you mean I should simply move the index part in the DeviceRegistryItems class or that I should leverage the already existing [ DeviceRegistryItems.get entry ]( L448).
Empty keys can be removed addressed, thanks for the hint! I would use device info instead of devinfo to avoid confusion makes sense, renamed Please move all the connection logic into the library. We want as little code as possible in Home Assistant that communicates with the device thanks for your help! Addressed, please check Can be removed please clarify what exactly, VERSION var ? Has to do with migration, see config-entry-migration I was told it can be removed since VERSION 1 is the default Use CONF NAME and CONF ADDRESS from homeassistant.const for these keys, I would use these everywhere you use "name" and "address" Here you can use CONF DEVICE from homeassistant.const, for the device info and is disconnect by request I would create your own constants in const.py like CONF DEVICE INFO "device info" and use that everywhere I wouldn't use an assertion here. What if some BLEDevice becomes available shortly after async setup entry is called? Then it will only become available once HA restarts again. You can also register a callback with HA in your async setup entry that will update the ble device for your dice. This is useful if your device becomes available through a different adapter or bluetooth proxy: initially I used assert not None to fix type check failure - async ble device from address returns BLEDevice None, while BleakClient first arg is BLEDevice str. But yes I agree that in case ble device is None then AssertionError will be raised and HA will skip connection retry. I've put that code snipped under try-catch too to make sure I wrap an exception with ConfigEntryNotReady if any If you ever get a type check failure you can also use TYPE CHECKING constant which will only execute the assertion for type checkers: But in this case I think the best way to solve it is indeed to use ConfigEntryNotReady , then HA will automatically retry it later. I would still add the async register callback() though to always have access to the latest BLEDevice does not async ble device from address return the latest ble device ? I supposed it does. Theoretically I can register a callback to receive the last ble device too after a call to async ble device from address but I'm not sure I need it anywhere now. I try to connect once when the integration loads, then if it fails I just raise ConfigEntryNotReady leverage HA reconnect. In case of receiving new ble device while integration is alive I will just lose it after initiating integration reload since as I understand all vars are lost between reloads. Please correct me if I'm wrong Do you only connect once when the integration loads and not anymore after that? In that case I don't think you need the latest BLEDevice, but if the user can initiate a connection themselves then you should use the latest BLEDevice for that as it contains information on what adapter it is available on Correct, I connect once only when the integration loads I would personally put these keys in const.py not sure it is needed since 
The on off handling is already handled by the climate entity: L224-L228 And thus should not be added as a switch.
Don't use f-strings in log warnings, do like this instead This should be protected This too should be protected
I think all these extra attributes need to be added as sensor entities instead of attributes. I don't think this is allowed, but I will ask for a second opinion. The benefit of sensors would be you get a history, users can enable disable the ones they want and it is better for the state machine database. Agreed! I usually leave the unique id in the constructor of the platform entities. Each entity requires a unique id, so I don't see an advantage in doing this. Please call it entity.py This should happen in sensor.py This will hard code names. We should use translation keys. Even tho every sensor would only need 2 fields (or 3 if you add the value function as well), I recommend looking at entity descriptions for this. Can you explain how media player entities are created at the moment? I understood that we create one per zone, is that correct? Yes, one per zone. After the change we will have 11 per zone. The zone attribute is that you are able to see which sensor entity belongs to which media player (main) entity. But you can already see to which receiver it belongs, so how much added value do these extra state attributes add? Fyi, we're more hesitant to add new extra attributes, because they usually can be extra sensors or are unneeded, but still take a lot of space in the database. Tbh., I would have problems to see the relationship between the media player entity and the sensor entities without the Zone attribute. I can assume that there is a relationship based on the suffixes of the entity names (no suffix, 2 , 3 ), but this relationship is gone when I start renaming the entities. That's why I added this property. However, I checked the properties and all the sensors belong to properties which are device settings and not zonal settings. Thus, we don't need to create them multiple time and will have 10 sensor entities one media player entity per zone only. Is every media player its own device? Don't I then have a device called "living room" and "bedroom"? Nope, a device represents a physical receiver which can have up to 3 zones. Each zone is represented by a media player. It is easy to figure out a relationship between a device and its entities, but it is hard to figure out relationships between different entities of the same device. As I said before, you could assume a relationship depending on the names, but this lasts only until you start renaming entities. Anyway, the relationship between entities is a theoretical discussion now, because there is only one sensor entity per device left. I am more talking about the relationship between devices and the sensor entities. If the device is called "Bedroom" and you attach these entities, it would prepend the devicename, avoiding the 1 and 2 . It would look like sensor.bedroom something . This would also rename when you rename the device, it will ask you if you also want to rename the entities attached to it. But looking at the sensor setup code, you only setup the sensors for one entry and not pe
Is there a reason for this not following the pattern of the previous items (if "XX" in family)? No. Fixed. Done Done
Maybe this was better to leave as a sync function as the load config is doing IO. Replaced with await hass.async add executor job I think better just to revert it to a sync function and let the notify component run it in an executor job for you. There was no reason to change this in the first place afaict. Other than that all looks good. Or similar Maybe a comment here just explaining that you're using async load platfom because notify doesn't support config entries. I decided to not do this because the other notify platforms don't have this. Is it possible that the yaml import could be picking up these values and trying to store them with the config entry? Do you maybe need to make sure to strip them out before starting the import flow? The import config flow both validates and only includes relevant values automatically. Nothing extra is included. I looked at a number of other notify platforms and many of them pass the config as the config parameter as opposed to the discovery parameter (some pass both) but I couldn't find any passing empty dict as the config. Your changes below to get service switch from the config to the discovery info. Are you sure this is correct? (I'm not sure myself but async load platform asserts that the config is not none and AFAICT this is config as opposed to something that has been discovered) I'm not terribly familiar with the architecture of HA, but I have seen from pulling this up in the debugger that passing in the data through the config entry doesn't seem to work. I got this idea from the discord component ( L42) and it seems to work correctly. Okay I debugged it again and remember now. The config is only presented when configured using YAML. Discovery info is presented during config entry setup. I changed it to also pass the hass config to the load platform call so that the notify component is loaded correctly. This seems to be what other components are doing as well. Sorry missed that this should now be 2024.5.0 Done This should do the job Replaced with await hass.async add executor job Please prefix functions that are safe to run in the event loop with async Done Done Thank you for your contribution thus far! Since this is a significant contribution, we would appreciate you'd added yourself to the list of code owners for this integration. Please, add your GitHub username to the manifest.json of this integration. For more information about "code owners", see: [Architecture Decision Record 0008: Code owners]( Done writing-tests-for-integrations Please don't patch the integration itself in tests (there are a lot of bad examples of the tests already doing it and we don't want to add more). We should let the issue get created and verify it exists in the registry instead. Done r1584794986 We generally make exceptions to this rule for async setup entry and async setup Done Please reverse the condition and continue when it does not match to reduce code indentation. Please mark this as a callback and prefix it with 
This doesn't show that the thread id is passed to the API. The test already uses the fixture mock external calls indirectly via the webhook platform fixture. I suggest to modify the mock external calls fixture to yield the patches instead of yielding nothing, then you can test here that telegram.Bot.send message was called once with the correct data. Hi emontnemery , Thanks for the heads up. I added message thread id to event log (since it might actually be useful in automation or for debug) and added the corresponding test in tests.
port should never be None , since we take it from the configuration entry, where it is a mandatory paramater this should be handled in the config flow, so that a configuration entry always has a valid port in its data no need to define data schema , just use the vol.Schema in the async show form as it was before place here the logic about the default ports from above I think we should also remove self. port ssdp location.port from async step ssdp , extend the schema in show setup form confirm with the ssl option and also add the logic about default ports in async step confirm With this we were also able to provide ssl support for discovered Fritz!Box we should also test that the logic about default ports, based on ssl option is working as expected and that the user can overwrite the port in advanced mode. this could "easily" be done with the pytest.mark.parametrize annotation. If you need support with the tests, don't hesitate to ask
Is wifiguest always correct? Should we set some flag so we know which device trackers are guests? There is no way to configure this value on the Freebox OS. I got wifiguest value in the result of the following API request: GET api v4 lan browser interfaces ([source]( )) Good point for the flag. But I don't know the best design practices for defining this flag in a device tracker. Just implement an extra state attributes property in the device tracker entity. The unifi integration actually has an is guest flag, I'd suggest to use the same here: L42-L64 L349-L362
Can be omitted Done For some reason they are back Fixed again, thanks You probably did this because the config entry unique id can technically be None. Please assign it to a variable and assert that variable Done Since you use a coordinator, that means the BaseAprilaireEntity is inheriting a CoordinatorEntity - you should also call super().available Oh I see you do now, but can this statement be simplified? joostlek I have simplified what I can. Hopefully it is a bit clearer Please avoid using inline ternaries if they span more than 1 line Done Please use sentence case instead of title case Done these status sensors look to be returning a default set of names. You can make these an enum sensor. The added value of this is that you have to pass in a list of possible values (via options ) and when users want to automate with it for example, they can see what possible values the entity returns. This does require that the values returned by the sensor are in snake case and then you can add state translations in the strings.json. Good idea, done What do we do here? joostlek There's not really a better way of writing this I don't think. It is getting all of the possible sensor types and including them if either 1. status key or status sensor exists values is None , indicating that the sensor should always be added 2. The coordinator data for the status key is one of the allowed values in status sensor exists values The reason for the slightly clunky logic with the status sensor exists values is that the thermostat returns a value for the status for which multiple may correspond to the sensor being available. For instance, the Indoor temperature controlling sensor should show in the UI if the INDOOR TEMPERATURE CONTROLLING SENSOR STATUS value is either 0 (normal) or 1 2 (installed but in an error state). What does the Aprilaire device return? In what unit? Is this dynamic? Looking at the util.py the device always returns celcius. Can you maybe give an example why the special rounding is needed? The device does always return celsius. The problem is when converting to Fahrenheit, the device itself uses away-from-zero midpoint rounding, whereas Python uses banker's rounding. This leads to inconsistent rounding in the case of values when the user is displaying values in Fahrenheit in HA. Consider 22.5C which is 72.5F. With away-from-zero rounding, the device displays this as 73F. However with banker's rounding, HA would show this as 72F. The solution as implemented is to have the sensor always report that it has the same native unit of measurement as it is configured to display in, and then handle the correct rounding when returning the native value. This actually reminds me that I need to do the same for the climate entity. This fix was made in the HACS repo after I started getting this merged into core, so I never made the change on the core side. Please let me know if you have any other questions about this
I'm not sure if lock makes sense here Ideally this becomes a separate test or parameterized as we want to avoid branching in tests r1534644418 r1534644418 I realize this is copied from lock, but add default code is a really confusing name of this method IMHO. Can we try to come up with something which better describes what it does? Maybe code or default code ? The doc string is lying, maybe Can this be simplified? Why not initialize to None ? Why don't we default to None ? Let's shorten the variable names a bit to avoid some of the line breaks: Why is this changed? These integrations doesn't require a code for their methods but was by not implementing code arm required actually setting it to True . We are with this PR introducing validation for code so without setting this property to False these integrations would require a code input from the user. See blog post link in the PR description.
I'm wondering if we want to let the potential exception here (and have a potentially "ugly" error in the logs), vs catching it and wrapping it slightly with "Oops, couldn't get this image to send it" (and still including the stack trace via LOGGER.exception As in the original: asyncio.wait on an empty iterable is a safe no-op Can iterate directly over what we grab from data : no need for interim tasks lists (please feel free to improve on my formatting though ) Minor: I love pathlib and I fully support its use, but I'd universally suggest doing from pathlib import Path to avoid using pathlib. suffixes in code. Some sans reduced-IO ideas: - [Good] Use AsyncSpooledTemporaryFile instead; just like [SpooledTemporaryFile]( tempfile.SpooledTemporaryFile), all the data is spooled in-memory instead of using the disk, which can be a precious resource on some low-resource systems. - [Better] We don't even really need the idea of a temporary file; we just need something to iteratively read bytes from. I think that modifying send image to accept either an image Path or resp.read() directly would easily cut out the need for temp files at all Please feel free to modify send image to accept a pathlib.Path rather than a str: I think it'd be better that way anyway Can't verify ssl for http : )
Acking that I've seen this PR as well as ! Lmk which would be more helpful to take a look at first and I'm happy to do so. And feel free to reach out to me on matrix as well I think unfortunately, this won't be able to get in because of the dependency conflict with matrix-nio requiring cachetools 5.0.0 . Since theres this conflict, I might let this PR sit until sometime in the future whenever this dependency gets upgraded in the matrix-nio library. is ready for review however. alexyao2015 Gotcha; please feel free to file an issue on matrix-nio itself tag me, as I also maintain matrix-nio and we can probably get that done. Will start looking at 112539 in the meantime! alexyao2015 has been opened to bump the cachetools requirement for 0.25.0
The config flow requires full test coverage ([dev docs]( testing-your-config-flow)) Do we need to close here? I saw your are passing a aiohttp session in the coordinator to the client Checkout e.g. the holiday integration how to use the SelectSelector , this way we could make the options translatable No need to create a new const, we have homeassistant.const.CONF COUNTRY done. I don't see that SCAN INTERVAL is used anywhere else, so keep the definition in this module instead of const done. .info is reserved for core, please use .debug done. Please wrap multiline lambdas into parentheses i have put it on one line, ok ? Is there any other data provided by the API that makes it necessary to add the service type here? Is a attribution needed? First of all, thanks for all your suggestions, i am pretty overwhelmed on how this whole project runs ! - ok, its my first approach on submitting something to such a ahuge project ! what does attribution generally mean ? do i need to set it when the API provider requires me to ? i basically took the easyenergy integration as base sigh It's no problem we are there to help! And no need to be overwhelmed, you can address the points step by step if you want to. Normally the API provider has some terms of use. And some have a clause that in order to use the API you need to credit them, in some cases even writing what you should use as an attribution. But when there is no such clause, it is not needed. Exactly what autinerd said. The problem with the attribution is that it's not translatable, so it would be in English even though the rest of the UI is in your chosen language. Thanks for your answers, on the page they say that one can use the API for free with fair-use (max. 100 queries a day). Thats why i only query every hour. So i think i can remove the attribution. But, is there is a way to query the api once on integration start and then every day at 14:00 some random delay as the data only changes at 14:00 ? and how would this be implemented ? Another question regarding entity-id's: mine look this: sensor.energy market price current hour whereas easyenergy's integration entity is: sensor.easyenergy today energy usage current hour Shouldn't they be unique (to have all energy providers providing the same entity-ids, but then you cannot have more than one energy provider) ? Or should i add awattar to the entity-id to distinguish them so that every integration providing energy data has different - and unique entity-id's ? I think the other points (except testing) i already solved thanks to your suggestions :) Why not set as default in the dataclass above? Is there a reason why you do this? sorry, was old code - i removed it completely, can you please take a look at the code and check if it is ok now, i also made some other changes according to all your findings, should be ok now :) Not needed. For this integration a Schema config flow would be ideal. Check out webmin or systemmonitor for examples. You could use CONF 
This could also be a property as it's only called by entity.py without a parameter. Which would make more sense to align with the rest. This may change back in a future PR, but for now its a property. Is this really a validation error or simply the service returning with an error. We should separate a validation problem ( ServiceValidationError ) or other issues such as connectivity etc. ( HomeAssistantError ) Seems to be more cases also below I recall being told or reading that service failures were ServiceValidationError not HomeAssistantError , but I'm probably wrong. I have changed them all over. exception-handling-during-service-calls Already in the base entity? Removed Use pytest parameterize instead DOne Why are we removing these tests? This PR removed the first refresh code from the coordinator so this test is no longer valid. I think this could be good to have as a decorator instead on the respective methods that's using it (in a follow-up PR) On line 115 (out of reach for this review) in a follow-up move from hass.data to entry.runtime data Don't both log (above debug level) and raise an exception. It's enough to pass the message to the exception instance. The message will be logged by the exception handler. If you want more information than the message for debugging, log that at debug level. Addressed in Please move the log down out of the try... except block.
Can move the CoordinatorEntity to the base class moved Maybe disable this one by default entity registry enabled default False added for all enabled it now per default again, why would like to have it disabled per default? cause enable every sensor separately is tedious job, (didn't see that on testing before cause i didn't do factory reset) Typically entities which are not used so much should be set as disabled and the users who wish can enable them. I didn't say for all, just for this one as it's quite uncommon rssi provides any value. There is also possible to mass-enable entities so no, it's not a very tedious task. nice, wasn't aware you can set all at once makes sense, most users don't care about rssi, disabled it now per default again What's the state of this sensor? its the raw value of the optical dirt sensor, its rough around 4000 when dustbin is empty and gets 4000 or less when dustbin is full 4000 what? Should we disable this by default? It doesn't sound like a entity that is useful for the majority of people its a raw number in range between 0-4096 disabled it now per default Maybe consider just using "runs" since the entity name already contains "cleaning" changed to runs Would the state class Total make sense? jop, changed it for all total sensors Unneeded removed Stale docstring changed to """Initialize the RomySensor.""" and """Initialize the RomyBinarySensor.""" whats missing or what do you prefer? I just noticed that it isnt a StatusSensor, so that was my issue mostly
Should we raise here an exception to trigger ip ban? Please limit docstrings to max 72 characters per line in accordance with PEP8. Why do we set the default to import time offset? Why do we never set this attribute during run? Thanks for the catch. I use now the init function What other types than None and the generic type can data be? None and StoreData (TypedDict) are the only types. I copied this check from auth store.py Ok. Maybe we don't need the check for dict then? This can be an async callback. Can the session instantiation raise or is it just the line above that can raise? If the line can't raise, please move it down out of the try... except block. Can any of the method calls to create and set the cookie raise an exception? encrypt will raise a TypeError if cookie data is not bytes , but the encoder is returning a str, which will be encoded. So the TypeError is not raised. The encoder itself could raise JSON ENCODE EXCEPTIONS so maybe we could catch these. Normally these errors shouldn't be raised as we control the data, which is encoded. What should happen if an Error is raised? If we control the data it's ok I think. It's important that we don't leave any room for an attack that can crash the server. Maybe use slots for this class? I think we should add a comment here why we filter away all existing sessions for this refresh token. It means that there can only be one session per refresh token, right? This seems important. I'd add what the actions are in the body of the docstring. 1. Check ip address. 2. If ip address is local let the request through, otherwise 3. 3. Show static page if that's enabled, otherwise 4. 4. Close connection. Should we show the static page also for invalid ip addresses? Why do we update the secure key in memory stored cookie params here? It doesn't seem used afterwards. We update it again before setting the the cookie in save session and the parent save cookie doesn't seem used since we override save session . Is it just if the parent class would use save cookie in more places in the future? I'd add why we implement our own child class in the docstring body. My conclusion: 1. We want an lru cache for decrypting the cookie. 2. We want to use is secure in the cookie name and params. Maybe add a comment why cache control is important?
You can avoid the mixin when using kw only True Isn't used in file Consider using the binary sensor device class Battery charging
Any tips how to get the tests cover these lines are appreciated? This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository. changing-the-entity-model If I remove this part from the PR, only implementing the per-device speed setting, any chance this PR is going to move forward independently of that architecture discussion? Setting a default speed is ok. Please open a new PR in that case that doesn't touch any core files so that the core team isn't notified.
May be add a test to ensure code test coverage. Was a mistake in lock state which made this but it's now also tested properly This is technically correct as open means unlocked, but it would be easier for the user in the frontend if this would be"{entity name} is open".
strike weather weather Fixed! Took some inspiration from the weather integration and forgot to remove all traces :) should this timedelta perhaps be configurable We thought about it, but wanted to keep the integration as simple as possible for the first PR. But this is definitely something we want to implement in future versions! We don't allow configurable polling intervals in the UI. This can be archived with disabling the automatic polling and using a automation for it: defining-a-custom-polling-interval just for styling why do we need the executor job? Can we maybe move the initialization of the ApiClient to the coordinator? is the default appears it's not used currently why the executor job? catching broad Exceptions is not allowed outside of the config flow what's the benefit of the extra exception here? can't we just move simply all of this, if we move it directly to the coordinator? l-holter are you fine with being a code owner? why that extra file? Apparently it's only used in the config flow? you don't appear to use those anywhere else, so I'd just use them directly no reauth in this PR no references doesn't have an options flow I believe that this should be a service, also need to set it in the manifest then please finish the test, to show we can recover from errors idem idem, I think we could just use a parametrized test for all 3 of those we don't usually test internals like like coordinator. Rather write tests showing the side effects of those errors (e.g. sensor going unavailable)
Please don't add constants to the common constants. We only do that after we see that they have multiple users and are actually common. Understood, I will move it into the component directly, sorry about that This appears to work even though US originally defaulted to Maytag. I'm not sure that it will work for everyone, but in the "worst case" the user would need to delete and re-install the integration. We should also test init integration without CONF BRAND: verifying "update" works. Good call, I've added test setup brand fallback in test init.py to test that setup without a brand uses Whirlpool The translation strings in strings.json haven't been updated. Please do that. That will also show how we're going to explain this to the user, which is important. I've added a line in string.json for the brand. Whirlpool makes the brand very confusing, as far as I can tell it only affects the output of the shared appliances query, so the string I added was "brand": "Brand of appliances" . I'm not sure what happens if there are users with shared appliances of multiple brands, but I think we'll have to cross that bridge when we come to it. Will users know which one to pick from this item name? Should we add a data description as well with a bit longer description? Added a description that gives more information about which brand to choose If the brand is incorrect for a user, will there be an authentication failure and a re-auth flow started giving the user the chance to correct the brand? Yes - authentication fails if the user name password is not the correct "brand" for their account. I would make sense to add brand selection to the reauth flow - pre-populated with the current value. mkmer Right now the reauth schema just has the password, would we need to add the brand to the reauth schema in order for it to prompt the user to add update the brand value? Yes, you would need to add it as an option to reauth flow (mostly just copy from the base auth flow schema). I feel like it's one of the better paths for upgrade failures to recover without deleting the integration - if the brand is wrong, they will get a user password failure. I've added this and also expanded the strings in strings.json a bit so make those more descriptive. MartinHjelmare I've added a description to the config steps (both init and reauth) to give more info on what to choose for the brand. Let me know if that looks okay or if I should do something differently there We have the data description item to describe data items in config flow step forms. Example: L14-L16 Thanks for pointing that out, I missed that my first time through the docs. I've switched the brand info to the data description now
Why do you need the device id in a system entity? Maybe I'm overseeing something. This sensor is added to the HA device with this device id. This is the most user-friendly way to handle a system with one single device. The vast majority of heatpump systems has this configuration. In a later PR we will create a separate HA device on the system level if the system contains two or more heatpump devices. If you have more than one system, will this be correct? I thought you should find the correct system based on system id ? Good catch. I will correct it. Can we use entity translations? Yes, we can, but we don't use entity translations in this integration because all other entities are named from data in API or by device class. But it is reasonable to enable translation of this entity name so it behaves similarly to those named by device class. OK It would be nice if this was a dict so we didn't have to look the system up every time. This could then be its separate property for easy access I put the dict comprehension here for now. It could be moved to the DataUpdateCoordinator, but this is currently the only place we access one specific system in the integration. I would prefer to keep it this way for now. The conversion of Systems to a dict would have implications in many places in the integration and I think it is better to do that in a separate PR. Agreed. But since you only use this in one place now (which I didn't know) I think I like the for loop more as that would be more efficient at times Reverting! Why doesn't this inherit the class above and overwrite the relevant properties? Done! Why the noqa?
Please move this to icons.json :
What about an and instead of the nested if ? It may improve cognitive complexity by removing a level of nesting. Same thing below. Thank you for your suggestion!. I'll update the code accordingly to reflect this readability improvement. This should be done in the init function? See L42. Also, I don't think the native max value inherited property should be replaced, shouldn't you use self. attr native max value and self. attr native min value instead ? Should we call this min value state or default min value state or something similar? Tronix117 what do you think? Let's try to make this as descriptive as possible. By order of priority (first is higher), there is : 1. attr native min value 2. native min value from state 3. native min value 4. DEFAULT MIN VALUE Indeed, we should drop the native prefix, it does not make sense here. I don't think default should be part of the name, we are levels ahead of default in the hierarchical order. The key suffixe is used in some other files, but if I were to do it I may have wanted to be consistant with Overkiz naming, using a state name suffix. However pyoverkiz constants are simply named state so I guess it's better to follow your suggestion min value state or more verbose min value state name .
Maybe we can assert the whole response with a snapshot so it's easier to see what this service would actually output? Good call! I have made that change. Is there any use for this for an end-user or can it be removed (I see no use for it)? It is used for load multi map name multi map recover multi map which are used by some end users. I could go either way on this. Let's keep it then Somewhere it says there can only be returned the active map. So should this really be a list or not just return the correct dict for the current map? It caches all of the maps that is has seen - and it should see them all on startup. I suppose this is empty as it's not the current active map? So this was actually a side effect of the map flag not being updated in the coordinator. It gets updated on status change - but a) that doesn't happen in tests as status is static and b) in the real system that also wouldn't always happen before setting the room info. so I manually set the current map now.
you can't change internals (at least not in this PR) services.py is reserved for HA services. This looks like it is the downstream lib also need to put it in the manifest I'm not adding any new service (not for now at least). I have a file that I called service.py where I'm putting all related to my PlexampService to have it somewhere while I work on this and that I will eventually move out. I've been looking at what other Media Player like integrations are as integration type and almost all of them are 'hub'. If I don't provide any service, should I still list it as 'service'? I really appreciate your time and doing the code review. I still have it on Draft and I really wanted to know if I was very off with what I was doing, your review has given me some reassurance! not needed lots of duplicate code here, I think we can simplify that I'd suggest moving the sonos stuff out, for now, to make this PR smaller this looks like it belongs to the downstream libary and not here you'll need a downstream lib in PyPi where you put things like this
I would suggest to extract the login etc. to a helper and reuse in cover . I don't think this will help much, it wouldn't really reduce on lines since we have to pass in email, password, etc. into the helper again anyways. Can be removed once you create device info here. Can be set outside of the constructor I'm assuming this is also present in cover.py. consider creating a base entity where all similar calls are stored to reduce code duplication This looks a bit ugly tbf. Isn't the client already present in the coordinator? I know, but Linear in itself is very ugly to begin with. Not even their own mobile app is reliable The client uses WebSockets, but, it's extremely unreliable, and the only real way to get working communication without somehow not receiving messages anymore, is to pretty much connect only when we need to retrieve data, then disconnect. I haven't really found a good way to fetch data other than this, hence this ugly mess What would you think about moving this to the coordinator anyway? In what other places do you create this? Should I just move linear Linear() to the coordinator and then access it from cover and light ? One question i still have, do we need to login every time? You could make this a property in the coordinator so every time you fetch co rdinator.client you get the logged in cli nt Yes, sorry. Every time you connect, you have to send the log-in request. If you stay connected after sending a request or fetching data, it will completely stop responding to requests, which is why I went with this method. Is there something I need to do here or can this be something fixed in the future? Beta has been cut, so let's take the time to make it nice if you don't mind :) Please don't touch internals This is practically testing the same Consider creating a broader patch, checkout analytics insights or Epion Take a look at what I did with the patches, is that enough? Edit: Just realized this makes the tests fail, reverting Let's do this change in a separate PR I think unneeded because it's used in an f string Oh and you don't need this as this means the state is updated every 60 seconds, but since the state is updated through the coordinator, that doesn't make a lot of sense. This is the default, why do we set it? Truncating will cause annoying off-by-one errors, I suggest to round instead, both here and in async turn on We can use a translation key for this
Might be better to add eager start to the existing function The tests that call async methods should really be coroutine functions so that the context is correct.
This attribute is always overwritten line 74
;) You're already snapshotting the attributes in the snapshot test down below. So this test is obsolete imo.
Same comment as on the previous PR discussion r1404558026 Sure, I'll have a look at this I moved the uptime calculation in the DataUpdateCoordinator as requested, let me know if this looks better. Thanks ! It appears translations was not generated given the strange name? You're right, and the tests weren't running on the uptime sensor. I updated the snapshot, reference uptime and also froze time to fix the time reference used in the snapshot. It would be better to use handle coordinator update() also here so you can remove native value completely as it's defined already in SensorEntity Thanks for the suggestion, I wanted to minimize change to the existing sensors but it makes sense to be more consistent with the uptime sensor. I'll test the change and submit back if this works. Done, I have moved the code to handle coordinator update() and removed the native value() override Same as previous comment Done Should be able to remove this completely handle coordinator update is not called by the DataUpdateCoordinator during initialization of the sensor, so I have to add this initialization of the value for attr native value. If I don't the sensor remains null until the second API update one minute later. Yes. But in the base class you could have self. attr native value self.coordinator.data[self.entity description.type] So instead of calling get uptime() here you can do it in the coordinator to store the data properly in the dict and also it would be better to control the refresh rate of this in the coordinator than in the entity update. Ok got it thanks! I'll update this. Done, most of the code specific to the uptime sensor has been moved to the DataUpdateCoordinator Why would this be needed? The coordinator only updates once a minute. The glances API provides a string representing a timespan (like "uptime": "3 days, 10:25:20") but does not provide the absolute time it refers to. There is a sum of delays which varies each time the API is called (internal Glances poll loop, duration of the Api call, time inside Home assistant before converting back to an absolute time..) which means that the resulting datetime computed in the HA sensor varies from a few seconds to a few minutes depending on the configuration, for each call of the API. It's not a big deal for an uptime sensor as it is typically measured in days or weeks rather than seconds or minutes. But without this check to eliminate small changes, the sensor value changes every minute which makes the history UI unreadable and spams the database uselessly. I have moved the update frequency code to the DataUpdateCoordinator This does not give an uptime. It gives you the time it started. Should the sensor be named differently? This seems to be the standard in home assistant : uptime sensors return a datetime which is the moment of startup. See for example the uptime integration : L34 A few other examples: L111 L143 In the UI, the absolute datetime is displayed as a relative time (like 2 days 10 hours.
Instead of putting this here, you can extend the ValloxButtonEntityDescription with a press fn and put the function in there. Check Flexit bacnet (I think the number entities) for an example I was thinking ValloxButtonEntityDescription will be stored somewhere, so it would be bad to extend it with non serializable data. Will take a look. Nope. Some integrations contain 10s entities. To avoid creating 50 separate classes, we have this entity description that we can inject from which it takes data. This way we can keep all the logic of that sensor concentrated in one place. I do not think this integration would ever have more than one DateEntity. Filter change date is the only only one that unit exposes. But then we shouldn't use the entity description. Although this works, this isn't the optimal way of using either method I see DateEntity class has entity description: DateEntityDescription parameter. No idea what it is used for. Well the idea behind an entity description is a way to quickly create new entities. For example when you look at a device class property: So instead of having 50 classes with each their own variation, we have an entity description, a class we can inject and then the trick is to encapsulate all the variation in that entity description. Your SensorEntity (as example) would then be a generic class that gets the right values from the entity descriptions to still express that variance. Since you can manually update the date, wouldn't it make more sense to use a DateEntity? That would make it more useful for example for people who changed the filters last week. Can you also retrieve the last filter change date? Hmm, I received request for a button, but that makes sense. Will change then. True, a DateEntity would be a bit more flexible. I liked the simplicity of the button though. OTOH, if one presses it by mistake or forgets to press it after actually switching, it could be useful with a date input. I mean, you can replicate the simplicity of a button by using an automation :) Please just repeat the translation key instead of referencing it. Stale docstring Stale Stale Stale

attr device class can for some reason not be defined like this. Running the following after startup: Returns The previous method worked as expected.: That's interesting, I have implemented it like this in a lot of integrations Is it because the order is inverted here? class BangOlufsenEntity(Entity, BangOlufsenBase): Oh that's something I should look into Ah, apparently we set self. attr device class None in the constructor Should imports still be this order? This one doesn't matter as the BangOlufsenBase doesn't override anything from the Entity Wouldn't this be better to have in the BangOlufsenEntity class? I usually only put this in the platform it applies to, so whenever someone is going to add sensors or something like that, they don't have to refactor that
Doesn't this assume the entity is using attr shorthand? Yes. It was just a quick and dirty to have a discussion around but I didn't come back to it yet. It's not in a state that it would be any good.
We should be able to think of a better sentence that includes the name. We wouldn't want the name to be first in the sentence though, as a long name might hide what is to be repaired. Maybe something like: The integration for {name} needs to be reauthenticated Not sure about the "for", it depends how other integrations use the name title I've pinged UX for help :) I was personally thinking maybe something like Authentication expired for {name} But it depends on the guidelines for repairs which I don't currently recall. Do we describe the issue or the fix the user needs to do ?
If there is only one light, we should not return "", it should be its own translation key Done. It is required to set the supported color modes ( Done. Done.
You can avoid creating a list here Done. (Though, the previous approach was consistent with existing code in this integration.) Please use icon translations: icons How does that work, now where I use two different translation keys based on whether it's the only pump or one of multiple? Do I have to duplicate the icon translation for each translation key? (FWIW, I just did this consistent with the existing code in this integration which already uses the icon property in binary sensor.py and climate.py .) How does that work, now where I use two different translation keys based on whether it's the only pump or one of multiple? Do I have to duplicate the icon translation for each translation key? Yes, you need to duplicate the icon translation for each translation key. (FWIW, I just did this consistent with the existing code in this integration which already uses the icon property in binary sensor.py and climate.py.) It's true, we haven't migrated every integration yet. The icon translations are quite new (introduced with 2024.2), so feel free to create a PR for it. Edit: Ok, there was a PR for this, that has been merged. Done. I got rid of the duplication, not sure if there is a model with only one pump anyway.
Can you add a test that uses this fixture? I guess this not necessary then? :thinking: Oof, yeah. Removed it The whole wind feature seems a bit weird to me :sweat smile: . I wonder if making them preset modes is a good idea. From what I understand, the Natural Wind mode is meant to emulate natural wind (presumably vary a bit?) but based on the current setting otherwise. It is like a "feature on top" of the regular setting. Maybe better to just leave it out completely for now? Or make it a boolean configuration entity so it can get toggled manually? :thinking: I thought about it for a while and it fits HA presets - I see it reversed, I think its super strange they made this a separate feature. If this mode is enabled, the device handles the speed, just like with a preset. I'm open to more ideas but making it a configuration entities doesn't make sense to me as its in fact an additional mode, impacting the primary functions of the device. Maybe a separate input select entity but that decouples it entirely which is imo not so nice UX I thought about it for a while and it fits HA presets - I see it reversed, I think its super strange they made this a separate feature. They made it separate because it is based on the speed setting, see: 4.4.5.2.1. SleepWind Value The fan speed, based on current settings, SHALL gradually slow down to a final minimum speed. For this process, the sequence, speeds and duration are MS. "based on current settings", that said, the same is missing from natural wind, but I would expect that the natural wind feature too is based on the current setting. It says it is "manufacturer specific", so I guess technically it could be both? :thinking: Maybe a separate input select entity but that decouples it entirely which is imo not so nice UX I guess both could be enabled at the same time (in theory) so input select is also not ideal. But IMHO, it would be better so it can be selected separtely to the presets. Both can be enabled at the same time ? That is even more strange. So, what you are proposing is a "multi select" input select entity then or 2 switch entities ? That also feels like a weird hack to me and completely detached UX-wise for the user because we do not logically group the entities together for the user. But yeah, if wind mode is a special feature on top of fan modes and speeds we should make separate controls. I'll quickly discuss this with a vendor first. Both can be enabled at the same time ? That is even more strange. It seems device dependent, but it could be possible it seems :see no evil: But no idea what is out there, and if that would ever be used together, so... :man shrugging: I think I'd go for two separate switch entities still, but I honestly don't have any strong feelings here. A separate input box is fine by me too. Like discussed just now in PM - Vendors will also treat the wind modes as presets - the fact that it is separate is just some inheritance from the zigbee clusters and in practice no device w
We should create repair issues instead to point users to the fact that they need to remove the YAML. Please checkout integrations like lutron and suez water for this. Done I think this function would work better inlined in the user step Done Only have stuff in the try block that can raise Done This step is missing a check for uniqueness. Can we fetch some kind of value from 17track that could act as unique identifier? Otherwise we should use async abort entries match to compare the new user input with existing entities. Can users change their username in the 17track app? Done. I used account id from the 17Track API I'd argue that this is a service instead of a hub We should keep this import in the sensor.py I'm not sure what you mean? If I move this to sensor.py I get the following error: [ERROR] [CONFIG SCHEMA] Integrations which implement 'async setup' or 'setup' must define either 'CONFIG SCHEMA', 'PLATFORM SCHEMA' or 'PLATFORM SCHEMA BASE' Currently the integration is setup in sensor.py (with I think either (async)setup(platform)) removed setup from sensor.py Currently this is never set or imported afaict see Line 314: self.async update Throttle(self. scan interval)(self. async update) yes, but I am talking about how this data got into config entry.options you're right. I'll just use the default Use default constants I would omit the integration name in the entry name, it adds no real information. Is it possible to combine USER SCHEMA and OPTIONS SCHEMA here to avoid code duplication? Done Can be removed removed This error doesn't add anything as the error message already reflects this Issues should be guiding the user more to what they did wrong. Did the connection fail? Are their credentials incorrect? Please check integrations like lutron , suez water or streamlabswater for examples
Use [translation keys]( entities) how do you suggest use a translation keys and this goes to strings.json But it would not be used if you overwrite name . Just noticed that you can have placeholders in the translation as well. Would a naming like "{sensor.name} motion sensor" make sense? no, actually the user can edit the name from our app, not needed to add the type of device in name I thought that you're supposed add each entity as a device, set name to none, and use has entity name True. Then the type will automatically be populated. See [entity naming section here]( use list comprehension Your solution is better :) If name comes from the sensor, can you omit the entity description.name ? Please use has entiy name for new platforms has entity name-true-mandatory-for-new-integrations Yeah, that's what I figured. has entiy name is inside MicroBeesEntity alrady The way I understand it, you create a device for the physical sensor. The main thing the sensor measures has an entity with a name of none. Any other entities related to the sensor are separate entities with names, i.e. low battery, tamper, etc. You then attach all your entities to the device. [see here:]( microBees has several Bee(device) prototypes, every prototype (or device class) have sensors and actuators. For example a light (LightBee) has 2 sensor (absorption sensor and switch status sensor) and 1 actuator. The name of the sensor can be changed from the user but usually is "absorption sensor of the bee 12345". We have devices offers sensor only too without actuators. We could add SensorEntity also to light and some kind of switch, but we've seen in the integrations we've studied before submit ours, so we separated the platforms. Make sure you are looking at newer integrations, the scheme has changed. In the case you are describing ( bdraco correct me if I'm wrong), you would create a light entity. It would have an entity name of None. It would also have a device property filled in according to this: [device properties]( device-properties) Your identifier would probably be the serial number. It's name would be the name and name and name by user properties. you would add the switch status sensor binary sensor entity. It would have a name like "Switch Status" as a name, and it would return the device object you created when you created the light entity as the device property. rlippmann we haven't seen any Integration act like this. can you please suggest some sample? it's a new practice but I think is still valid the old one we have followed. Is this PR legit and ready to be merged? Look at any here: [February 2024 new integrations]( new-integrations) They sometimes use self. attr device info, but it's the same thing. Hello rlippmann , as you can see and (for example) we do the same exactly thing. we do in the entity. 1) I have no authority to approve or deny a pull request. I am merely giving you suggestions on how you would go about getting it approve 2) both those instances cited h
Although only tests, these lines are very long. So maybe break up the strings into max 88 characters per line. We should probably follow the max line width of 88 chars here. Should also be fixed in some other places. The extra check (and not always writing on value off value ) is done to make sure the type is a bool , right? Is there really any difference though (or is this done bc of some other reason)? zigpy should always use the correct "Zigbee type" at least. no these are to use custom on and off values... meaning we have to write something non 0 or non 1 to the device to make it on or off. there is a test for this. Yes, but why do we need the third condition for that? on value and off value are 1 and 0 by default. We can just always write on value (or off value ). I would think this logic could be simplified. (Might be missing something though, I'll have another look at this later again..) Adjusted The (double underscore) in zcl enum metadata seems to be a typo. I'd put this in one line here: Technically, the line is also a bit long. Maybe put the comment above and make it slightly more clear? Should this message be a warning maybe? Like, this shouldn't really happen with any zha-quirks release. So, having a warning would make it clear why a custom entity isn't created for people developing a custom quirk. Referring to the above comment with changing a log to a warning, this one should likely be changed too. Referring to the above comment with changing a log to a warning, this one should likely be changed too. Some of the entity classes set the category for HA (e.g. ZHASwitchConfigurationEntity , others like ZHAAttributeButton do not). I'm not seeing anywhere where attr entity category is set to the entity type of zigpy EntityMetadata . Should that be done in the base ZHA entity class? not in the base intentionally. the type is only used in the matching logic here atm and most classes set the category appropriately. This needs to be addressed subsequently when it is safe to set it in the base. will try setting this in the base entity. I don't think it will hurt anything but in the cases where the match is to a specific class that overrides it this could be confusing. once this is in we can migrate a lot of these classes to quirks definitions and remove them from HA. This will make this much easier to clean up Should this also set attr entity category to the entity type of zigpy EntityMetadata ? Do note that some classes like ZHASwitchConfigurationEntity would overwrite that category again. Might be nice to also add test coverage for this line. test would be contrived. the only platform that would combine them atm is update and there is no way to express update entities from quirks yet. The update method returns None so I think this would actually fail. You may be able to replace both cases with this (and remove maybe combine kwargs entirely?)? The following three tests all share quite a bit of code. Maybe parametrize could be used here (easi
I suppose we could move this up to get description and then use it also in find matching platform The name could also go into get description Definitely possible, but we chose to do it way in previous platforms (sensor, binary sensor, switch) following advice from the reviewer. The EntityDescription classes are immutable and that makes it more complex to change or add attributes. We pick up static data from get description and then add other more dynamic attributes by setting attr this way. We should not add entities without an entity description. Can this even happen? Yes, it can happen. In fact it is common in sensor platform. The API delivers some 60 device points for e.g a Nibe F730. It is not uncommon that we can't identify the optimal device description from the meta-data. Then we create the entity without description. The name is most likely enough for the nerd-user to understand what the data is representing. But the names are not stable enough so we have chosen not to use names for selecting platform or device class. If a device point has the attributes maxValue and minValue set and writable is true it is best represented in HA by a number entity even if we cannot assign an optimal device class or icon. Why isn't it sufficient with the first one as they both result in the same entity description? The world is not perfect... Or the upstream implementation of the API is not perfect. The myUplink cloud service is an attempt from the Nibe group to consolidate the service for all their brands (Nibe, CTC, Contura, Ceteterm and 10 more). Most of these heatpumps report DM as unit of meaurement for degree-minutes data while Nibe F-series products leave this field empty. But all F-series appliances feed this data point from the same parameter id. That is why we need an override table, also used in other platforms in this integration.
I think we can use icon translations instead? Indeed, we could (and likely should) do just that. I suppose we cannot provide these programmatically, but they need to be defined in the JSON file. Right. They allow a default icon and one based on the current state Example: Created some entries for testing, alas, the manual icon definition overrides the translation key so we need to rethink how to expose custom icons in cases where no icon translation is (yet) available. Maybe we can programmatically check for the existence of a translation icon in our own icon property implementation, and use that to decide whether to return the custom icon definition or None (for translated icons)? That sounds rather hacky, though, so I hope there is a better solution available... Doesn't having to hardcode the icons in the icons.json lose some of the flexibility we're trying to introduce with the features? Yes, I think we don't want to do that until we find a workable solution for this. I tried to look into how we could check for the existence of translation, but couldn't find a quick solution. 103294 is the relevant PR, adding just here to have it written down somewhere. Given it is just UI candy, we can do without it for the time being. As we now have static identifiers for features, I think this is now resolved just requires us to add icon translations for the features we want. We can strip the new platform out before merging and put it in a second PR Yes, this PR is just for development use, the final one will be split up, and the new platforms moved into separate PRs. We can strip the new platform out before merging and put it in a second PR Its a bit strange for the library to know about HomeAssistant. I think we should rename this legacy compat instead So this is a counterpart for - basically, we need some way to inform homeassistant on its own special handling for some features. An alternative would be to store this information inside the integration, but I was thinking that it would be better to keep this local. We could inverse it by 1) adding static ids inside python-kasa and 2) using those ids to map for wanted parameters. Do you think that would be a better approach? We definitely shouldn't be teaching the library about Home Assistant. We should store this information in the integration. I think its fine to add information to python-kasa to make it easier to map in Home Assistant, but its separation of concerns problem for the library to start learning about HA Yeah, I tend to agree on that, back to the design board then. I think we could map some information directly using the unit information the library provides, for some other we may need to have a static map inside homeassistant. For the static ones, we need probably set static identifiers instead generating ones from pretty names to avoid breaking this in the future. requires static identifiers for features, so we can move the mapping inside the integration. done. Changed in be3b586ce8d7 I thin
You can avoid creating a list here Please use icon translations ( icons) Why do it this way? Are there more IDs? yes, i have more IDs This way you could avoid create a second dict and maintaining the IDs twice. Maybe use BUTTON PRODUCT IDS as the const name instead
You should consider add tests actually they're not mandatory and we've speed up to introduce all our platforms, we will write in future releases Invert the if and raise if the sendCommand failed. Then we can outdent. Why you use Timer here? You could make use of async call later , which is a helper function. Same as above Move outside the init Move above the init for better readability There is no way to determine the current state? no, there's not Ok, but we still need to set attr is closed to an assumed state after we have executed the open or close command. Otherwise the state would always be unknown. It will be always unknown. Our device doesn't know if cover is open or closed. Ok, but we still need to set attr is closed to an assumed state after we have executed the open or close command. Otherwise the state would always be unknown. we cannot determine or assume the status because you can also use manual mode (without our device) to open or close and we have no way to have the actual status. You could take a look at the Comelit cover platform, which also cannot retrieve the current status. I'd rather have a status that doesn't match the physical status of the device 100 (due to manual intervention on the device or something) than a constant "unknown" status which is not a good user experience in my eyes. Actually we don't like the Comelit solution. We prefer customer can open and close in every case and stop. For example if I want to open just a little I can do it stopping whenever I want. Assuming the actual status avoid this and can cause inconsistent status in case of manual intervention or something else. In our opinion this is the best user experience and freedom for the use of the device I talked to another core dev about this, and it's fine to have the permanent "unknown" state, but you should probably note this in the documentation as I suspect there could be some issues coming if the entity is constantly "unknown" . So feel free to mark the PR as ready for review. Please use a generator expression instead of filter lambda. The library should create human readable abstractions for the product ids etc so that the library user doesn't need to handle these magic numbers. One way would be to create enums that name the numbers.
Please use identity checks to compare enums Usually we do the lib bump in a separate PR if its not a breaking change This is the only change between version 22.1.0 and version 22.0.0: But I will prepare a PR to change the version. 111435

Why is this case added? If it's only needed for preview, it should be possible to handle it in async start preview , if it's a bug fix it should be moved to a separate PR. Yea, that's just the case for preview. I moved this to async start preview . See the new PR as I screwed up the rebase
Would be faster to initialize the schema once
Can we create a private function for it and use it also in label devices and label entities Done!
Should this be handling multiple adapters instead of picking the default? Yes, I think we can always pass a list to the socket initialize method. Will test it I think we should try the default one first, than add the others so we can catch OSError on subsequent ones so we don't have a repeat of I followed discussioncomment-672957 Should be safe. I think we should have a test that wraps context.initialize checks what is passed to it based on a few parameterized network configurations I added a test with 2 ip addresses, while the others use the default one. We can always expand it, but I need some help ;-) I think you want to patch it with wraps unittest.mock.Mock and than check what it sends wraps: Item for the mock object to wrap. If wraps is not None then calling the Mock will pass the call through to the wrapped object (returning the real result). Attribute access on the mock will return a Mock object that wraps the corresponding attribute of the wrapped object (so attempting to access an attribute that doesn t exist will raise an [AttributeError]( AttributeError)). I think this is duplicate logging since it will get logged at L33 if the network integration has debug logging Discussed on discord that it would be helpful for this information to appear in the shelly debug logs when enabled from the UI I added it only because users usually enable debug from the ui and this will be only for shelly component and aioshelly so to get the info easily, IMHO the debug on the shelly side is useful.
This should go before the repair cases (we shouldn't have those repairs if this is what we want). Also likely update the description of those repairs to make them more clear and easier to understand. Need also to update get valid units below Name this more specific on what it's testing Should probably also change a source sensor to another UoM to test that behavior in this case after the asserts below
We should preferably catch ClientResponseError first and raise ConfigEntryAuthFailed for status 401 403 as specified by the API. Raise ConfigEntryNotReady for other client errors. Example: L168-L175
Why do we update the vicare programs attribute but not the attr preset modes ? If the programs can't change, we should probably set both in init , if they can change, we should change both here? Also, can't the call to getPrograms raise PyViCareNotSupportedFeatureError ? Also, can't the call to getPrograms raise PyViCareNotSupportedFeatureError? getPrograms iterates over a fixed list of known programs, if no PyViCareNotSupportedFeatureError is raised, the program is considered as supported and added to result list. I see no reason why this should change, so will move it to init .
Can raise KeyError on old self.categories[scope][category id] Nice catch! Addressed in [a42423e]( Could we add a test that the same name can be used in two different categories if the scope is different? Not sure if we should add it here or in the helpers test category registry tests Added to both, done in [d9c7c92]( actually ulid is faster. Done in [ccd62c1]( How can an entity be in different categories? Shouldn't it only be able to be in the category for the scope that is the same as the entity domain? Depends on the view dashboard. From the entities dashboard, you could have a different categorization compared to your automations or zones dashboard. Yet, entities are on both, and both can have a different set of folders categories. The original PR ( 93498) was based on a domain , but we changed it to scope as it doesn't have to be a domain-limited view (like, for example, an entities dashboard, helpers dashboard, or whatever else). As this is a full frontend visualization thing, the scope can be managed by the frontend to match its display. Same question as above: this can just be a string ID to the category that belongs to the domain ? A entry.categories.get(scope) should be faster as it only needs to lookup the scope key once in the dictionary. Addressed in [deb45eb]( Same Addressed in [deb45eb]( It could also be the scope that is missing. The error message isn't wrong, as the category entry for that category id wouldn't exist in that case either, but it's confusing if we also don't mention that the scope is missing. Well, this is a safeguard (which should technically not happen). If the category exists, the scope would as well (as a category is nested in the scope). From the end-user, they can create categories, they can't create scopes. So, from that perspective, I think the current messaging is better in that regard. Side note: we probably need a way to group the loads in the executor here There was a base class for registries added a while back that could be used here "a while back" ![CleanShot 2024-03-14 at 20 51 34 2x]( done in [ef197e3]( It felt longer. The items besides categories should probably not change. Hmm seems like I forgot to update the translations before generating these fixed in [51f8417](
This seems wrong... What is Python runs in optimized mode and the asserts are not ran? Then we don't fetch this at all? PS: We can rewrite this without having a need to assert at all. Avoid the use of cast and assert whenever possible. How would you do it? Raise if None ?
There is no host in the user input in the async step credentials function: Thx, wrong variable used :-( Should we increase the config entry minor version if we add a new field? This will raise a ValueError if the user provides a host with : but no port number, e.g. 192.168.2.56: . You want to guard against ? Current code if you put a ":" in the host raise an error as well; Done What about gen2 battery powered devices? You mentioned that they also don't work when configured via a range extender. Shelly is checking in order to support them. Seems it's trivial. EDIT: Currently you get a Cannot Connect error so it's fine. Will make clear in the documentation Fixed with latest aioshelly I think this will look better in one line: ![obraz]( We shouldn't be using a custom parser for config flow inputs. The config flow uses voluptuous to validate user fields and fields should be visible to the user which will also make it easier to document them. Example (all other integrations with HOST PORT are the same): L14-L17 configuration-variables Was discussed with bdraco and due to the fact that that less users will use this config was suggested to not expose the port field to the flow Why are you returning the input port as an output? the caller already has the port ? (we are also not returning the host here and they are used together Probably a leftover when port was parsed. data.get(CONF PORT, DEFAULT HTTP PORT) this repeats 3 times in this PR, can we make it a method that receives the data dict and return the port? get http port It is no longer just host Fixed Please make sure to add a test to cover this Honestly I'm not sure this code path can ever be executed as "gen1" devices are not supported so they cannot be reauth with custom port. If it can't be executed, what is it here for? get http port get http port Need to add a test that verify that existing entry that doesn't have the port in stored config entry is loaded correctly, otherwise someone might remove this get in the future thinking it is not needed. Sorry but I miss the point: we load a default for all config entry that doesn't have a port. PR description mentions devices behind NAT (which is correct), and the error is custom port not supported , the description should be similar. Done You should not patch the code you test itself, you should patch the upstream method. This patch removes 46 lines from being tested. Please patch BlockDevice.create A similar example for patching upstream in this test is the "homeassistant.components.shelly.config flow.get info" which patch the get info from aioshelly so only the upstream code is not being tested here. Done Fixed
The frontend probably would want to list labels that are used by a specific type (ie automation) to render a filter list. Can be added in a future pr Should we enforce hex format? Will do Done in [9c7748b]( Why bool it? Yeah odd huh? Data can be any, thus it could be something that implements the equality dunder method, which doesn't have to return a boolean. Long story short: mypy wants it. Ha, interesting. And I think pylint wants us to have the variable on the left side of the comparison An alternative could be to type the event [like this]( but keeping bool is fine. The problem is, that async listen will not accept that either. Let's assume this: ![CleanShot 2024-02-18 at 10 31 51 2x]( This will result in: How that is solved on some places, is by silencing the arg-type rule: ![CleanShot 2024-02-18 at 10 33 44 2x]( As far as I understood, we can't turn Event into a generic just of yet. Not sure what we prefer here. Since I've found some occurances, I'll go for ignoring the arg-type rule Done in [9c7748b]( This one might get expensive if we call it a lot since it has to do the linear search. We can always add an index if that turns out to be the case It isn't used a lot. This pattern is in most registries.
Can you maybe sort it? Unused Does it maybe make sense for the integration to have a shared base entity and maybe a device?
Is there a reason to have this moved here? Yes, the setup from YAML was moved to integration level. You're already doing hass.data[DOMAIN][config entry.entry id] None in async setup entry if I saw it right thnx Hm, we normally don't want to collect names in config flows, but I'm also lacking a better idea since we are collecting multiple recipients. Otherwise this looks good to me, I've tested this and it works like a charm, great work, thanks The name seems a key feature to determine the notifier service name, I left it away at first, but then that will break the existing configurations. Okay, thank I think this is okay We must use the async API inside async context. async load platform . And a task must be created to not deadlock. Addressed in 110857 We shouldn't use platform details outside the platform. This needs to be refactored. Addressed in 110857 Don't remove the schema until we remove the import. Addressed in 110857 Why don't we do the import from the notify platform? Addressed in 110857 Setting up the smtp integration notify platform via configuration.yaml is deprecated. Addressed in 110857
Since the reauth is quite big, can we extract it into a separate PR? These values are never set in the config entry data? Please make it a list Please refresh before setting to Hass.data Please add this in a follow up PR Please move this to entity.py Already set in constructor Also set in constructor, but you need to overwrite the type using I'd suggest creating a base controller entity and base plant entity So wait, the controller has the same sensors as a plant? Please only call async add entities once Isn't this already something for the device name? What does this measure? What kind of measurement is this? Idem Idem Idem Please use constants for this Doesn't need translation key because device class translations Can be removed, comes from device class Light in mol d? Please use icon translations Can be removed Idem Can be removed Idem Idem Idem Please leave this one for a followup, as I'm not 100 sure we like this kind of sensors. This way the PR can be merged faster What value does this add?
This is already done in the mock config entry fixture. Make this a fixture. Make this parameter a fixture. Example: L39-L56 We can set the platform fixture like this or in a fixture defined in this module that is auto used by all tests in this module. L16 I'd use hass.config entries.async setup instead. Remove this check. It's up to the tests to override the platforms fixture when they use this fixture. Indent this line too. I think we should yield the mock config entry within the context manager so that the patch is in place for the whole test. It could have weird effects if the platforms differ during the lifetime of the integration. We use the Platform enum to populate platforms. L31 I had problems to set the returned type. This variant removed the complaints but I must admit that I don't relally understand if it is correct. Can this raise exceptions? Yes, We do a response.raise for status() after every request in the lib. Normally there should not be any exceptions here. I can think of one, an error 409 - Conflict when the turn on service is sent to a switch that is aleady on. This could happen even if we check the state here. Someone else could have toggled the switch in the myuplink app or on the web-site. The state in HA is updated just by polling every minute. Can this be acceptable for the time being? No. We need to catch the expected exception and raise HomeAssistantError . Preferably the library should raise library specific exceptions that we can use here. For now we can catch aiohttp.ClientError . This just makes it harder to read and understand the test. See comment below I still don't see a reason. Fair enough, my thougths were already in updating the pending test sensor.py where it is more relevant. I will revert. If it's only used once we don't need a constant. I know, but in next iteration (new PR) I plan to use parameterize to test more sensors based on parameter id (unit of measurement) and override categories. Please change it then in that case. We should not add code prematurely. Hope this is OK for now. We will sort out the exceptions in the lib within short. Yes. Please add a test for the fail case by setting a side effect on the client mock method. Please add a parameter for the service name so we can test both turn on and turn off. Use pytest.mark.parametrize . Here's an example with two parameters. L177-L185 The two tests test switch on and test switch off can also use pytest.mark.parametrize as below.
Why is extra slot names not derived from extra slot schema ? Can this be done in all cases? It seems you can nest arbitrarily code into the schemas, so I didn't see a way of always being able to extract the keys. I decided to make the extra slots required, which meant I could just use a str - Schema dict. Yeah if it doesn't work just crash and we can deal with it then Consider making it a cached property . Done. Instead of making a copy, why not define attr before checking the extra attributes? Done. This service made me wonder how will we respond if the specified entity does not support the set volume service? Hmmm...we may want to consider an "unsupported feature" error message. We already raise that error from service helper Just would need to translate it for voice why coerce to int ? I copied the schema from the cover's set position service call. I suppose it doesn't matter since it'll be coerced there anyways. Why don't we just accept 0..100 and divide it by 100 before passing it to the service? I don't think that we should let our service design decisions leak into the intent? That will also make it easier if ever AI needs to generate intent calls. I'm happy to do that : 1: This is typed as a vol.Schema but you pass a dictionary everywhere. I don't think you need this. Just iterate extra slot schema , single source of truth.
The result is generally meant for data. Since we have no data, we don't need to add "success" as it's already a result message, which indicates success. You can pass this to async listen as an event filter. Although this is already a callback, so not sure if necessary We made these callbacks yesterday. L13-L15
You can probably combine them without the mixin after switching to kw only True
Bit in doubt on how hard to break with the current behavior. If current users don't update their config, this new config will default to None and they don't get time based integration, changes are minimal. We could also decide to pick the default of 60s here. Leaving less legacy. But that would trigger sudden state changes of this sensor even if the source doesn't change (which is also the point of this PR). We should always avoid breaking changes I can leave it as is, then current users will get a None value for max dt and not get time based integration. I would advise the use of a more sensible max: 1hour ? 1 day ? For most users 1 hour or 1 day is probably more than a sufficient max. However, - I can imagine users with slow updating source sensors wanting the flexibility of waiting on a state change for longer periods, e.g. days, weeks, months. - Setting this value very high is effectively disabling time based integration triggers. Which is can be useful with the number selector in the webinterface not accepting None . See also my other comment about this. As per my comment on the main thread, I suggest the use of zero to disable max dt Good suggestion! Done. I did not convert it to None in the config flow, but it the constructor of the sensor. Will see how it can be done in the config flow. What did you mean with "You can use zero as a special value that is converted to None in the config flow"? I guess my current approach overriding it in the constructor of the sensor is not what you meant? How would I convert 0 to None in the config flow ? If found the method async config flow finished and that could be used like this in the ConfigFlowHandler ? This works, but this method is almost never used in the repo, so in doubt whether I'm doing the right thing. Did the conversion of 0 to None in the async setup entry , looks like the right place. availability should be set when the sensor is added and should follow the source, why remove ? This has been moved to line 446 and it is (like with the current implementation) set after it passes some validations checks on the source. it's in integrate on state change but this method is not called by async added to hass Correct. But in the old situation it was part of the method which was defined in the scope of the method async added to hass . But it was only executed as part of state changes. you are right, should probably fix this is another PR Good to know! Availability was and is now set only if the source sends an update. We can address this method afterwards. There is also a legacy comment in the async added to hass . I expect this PR makes it easier to address because of the extraction of the calculation logic. We should not create a breaking change This might be an issue, as the state might be written twice ( derive and set attributes from state plus this function) I've removed the write state call from derive and set attributes from state . Then now it will only be called once: on unavailability of
The best practice is to raise a HomeAssistantError when a service call fails. Catch and re-raise? You will need to add translations for the raised error as well... exceptions I see you were caught by the "do it like the other service" - we need to update the L132-L136 as well - I'll put that on the "list" :) This is more like how to do it: L106-L111, except add translation to the new one. I'll also put "general translation" on the list for the rest of the raised errors. Okay, I will look into updating all services as well. I've already made the updates to the other services. You just need to fix up this one. Thanks, saw that already. Will finalize it tonight, didn't have time to fix CI yet.
Failing tests: When this point is reached from test config flow self.config entry reauth is None. It is correctly populated when running Hass. Failing test: result2 result1 during test run. I.e. async configure() is not jumping to next step. Same thing is happening in test full flow() above but it is passed unnoticed as we dont pick up the return value from async configure() in that case. It's enough to add a MockConfigEntry to hass. Example: L460-L531 Passing the existing config entry data is correct. Don't do that like the example I posted. :smile: Confirming the step will pass an empty dict. We have a helper now to do this: L2030-L2041 Everything works fine when running hass, the entry is updated, the integration is reloaded and the flow is terminated. However, when running test config flow I can see that self.config entry reauth is None here. Therefore the abort-helper is never run and the coverage lacks this one single return statement. The current reauth test will fail when the WRITESYSTEM scope is in place in the mocked entry. I was too tired to learn how to make an elegant fixture for that entry so i just duplicated a lot of code. The snapshot is fixed. Modify the first mock config entry in the test instead with hass.config entries.async update entry , before starting the reauth flow. We don't seem to have rebased correctly on latest dev branch. I don't understand what has happened. This still needs to be addressed. I dont see the problem from here. And I dont know how to address it. Please advice. The only thing that should change in this module is the mock config entry fixture, right? Maybe just copy those changes, then paste the module contents from dev branch on top and then paste back the changes for the mock config entry ? Ie we revert this module to dev branch state and then just re-apply the changes to mock config entry . I followed your suggestion and the result is exactly the same as in this PR We don't need this. Just add a mock config entry. Update it with the old scope in the data. Then start the reauth flow. We're missing the required fixtures here. Check the test above. We should use the same fixtures. Add the mock config entry to hass before returning the entry from the fixture. Bump. The updated config entry data should be asserted. We don't need to check current flows. We already have a handle to the flow via the result flow id. Please assert the step id of each result. It's much easier for everyone including yourself to see where the flow is at. This is incorrect. Please see the example I posted above for how to continue the flow in the auth step. Block till done before asserting the config entry since updating the config entry will happen in a scheduled task. Adding the config entry to hass should be done before updating the config entry. Add it already in the fixture for the mock config entry We don't need to set up the config entry. This should not be here in this PR. Same here.
Please check also the event data
This is not a great folder name, can we instead use the domain name as folder name? Also, if the use case you really want is gitlab, consider adding a specific importer for gitlab. : 1: Updated to use the URL host rebased. My specific use case is not GitLab, personally I'd like to use sr.ht. I also know of some people who might be interested in using Codeberg. Therefore, I think adding specific importers for each and every source forge might become a bit cumbersome, esp. in cases where people would like to use their personal homepage or blog. Yes, sure, the generic downloader added in this PR is fine It's just that the specific downloaders can be a little bit smarter. It's important that the generic downloader is tried last. Can we make it less likely that the order is accidentally changed? Maybe move the functions to a global and assert in a test that fetch blueprint from generic url is the last element of the tuple? I agree, makes sense : 1: I've given it a shot, not a python expert, lmk if this is an appropriate way to solve this. The error handling is not great, but it's obviously copied from the other importers. In a separate PR, I think we should replace the assert with raising a HomeAssistantError if data is not a dict? Do you want this separate PR to be done before this one gets merged, or should I do it afterwards? I'd suggest to do that PR first, add a link to it in this PR please. Let's improve the error handling after this PR is merged then.
problem is not a valid state for Home Assistant covers, have you tested this change, and it works the way you expect it to? I'm aware of that. As you have also noticed in other comment the same is for jammed state (which is closest conceptually to safety stop as it means engine has stopped because gate shutter driver discovered obstacle). It's a pity that neither STATE JAMMED nor STATE PROBLEM is in any way observed by HA covers. On the other hand, existence of this state here has no negative impact on integration. What if we leave it here as is and let me figure out if I can make the base cover somehow observe problem jammed state. This will be a bit more challenging to me as I need to look how such states are handled implemented in other components. I could then submit such change as a separate PR so other integrations could benefit from it? I see. The end result is that the cover will in states problem and jammed get the "open" state, right? Also, this change should be moved to a separate PR. Reverted, will submit separate PR jammed is not a valid state for Home Assistant covers, have you tested this change, and it works the way you expect it to? Reverted, no longer relevant. Why is this changed? Is it just to make the code more readable? Yes it was meant to improve readability. I was constantly confused whether it has position and stop features. What does this comment mean? Yes, it means that cover features in blebox uniapi 2.3.0 have dedicated async open tilt async close tilt methods that are better suited for closing tilts. I could update straight to 2.3.0 but it would introduce much larger backlog of changes to process and I wanted to maintain smaller PR for this. We've fell a little behind with following blebox uniapi updates. I'm working on picking up where my predecessors left and it is a bit tricky to coordinate all the changes around multiple features being worked on fixed so my idea was to make the change so that I can remove this if hasattr() once bumping to newer blebox uniapi version in subsequent PR. After some thinking I decided to remove this branching logic. Hopefully, once 118836 is merged I will have time to submit a "Code quality improvement" PR that introduces new dedicated method call for tilt open close actions.
Let's rename this to COLLAPSED What I'm doing here (I think) is for every test that uses blueprint 2, I'm creating an additional variant that uses the same blueprint, except that the inputs are put into sections. This shouldn't functionally affect the test, so the test code should still pass equally whether the inputs are in sections or not. OK, but for the final version of the PR, please add a new blueprint 3 or blueprint 2 sectioned instead of branching in the fixture. If I make an entirely new fixture, is it still possible to reuse the existing tests that currently consume blueprint 2? That's why I used the param so I can leverage and don't have to duplicate the tests. I'm not so familiar with pytest so the concept of how to run a test with multiple different fixtures I haven't grasped yet. I believe what is happening here is the inputs used to come from the yaml loader, so they were the special class NodeDictClass , but now the inputs are put together as a dictionary manually in the inputs function, as it has to merge them together from several sections, so that's why the snapshot need to be updated. The requests was to do the flattening in frontend, now the flattening happens in core instead if I understand it correctly. Will this have any side effect on existing blueprinted automations? I reread the comment thread but I never saw a request to "do the flattering in frontend", or at least I missed that if it was implied. I'm not quite sure what that would really mean anyway, don't I need to have a single list of inputs for core to iterate them for replacement? I'm also not sure what the concern is here for backward compatibility, for BPs without sections (all of them today), isn't this block of code just basically a no-op? Flattening in frontend is what bramkragten meant here: issuecomment-2018148737 unless I misunderstand. However, the solution you've come with seems fine too, I just want another pair of eyes on it. Never mind, I misunderstood what's happening here. Please add a comment here, or above, explaining that the correct schema is picked by the presence of an input dictionary. I think this needs a custom validator which fails if the input keys are not unique. Added validator.
I changed this, because multiple there was multiple identical values, it was not kiss enough Would you be willing to make other contributions help maintain this integration in the future? See I will, I got some IO devices at home (and I guess for a very long time), and I will want to improve their integration. Great! Are you on Discord by any chance? We have a Discord channel with more devs (very inactive at the moment). Same pseudo ;) Dependency bumps should be done in a separate PR (including a link to the diff between both releases). Would be good to split this from this PR. Not sure what you tried to say here? I think this comment should be simply removed It should but the work is not finished yet on this because for your device nyroDev there is a way to convert it to cooling and it's not handled by this PR, I may do another one for that but I lack someone with a working heat cool device like yours You should use OverkizCommad.SET HEATING COOLING AUTO SWITCH you should use OverkizState.CORE HEATING COOLING AUTO SWITCH you should use OverkizState.CORE HEATING COOLING AUTO SWITCH You should use OverkizCommad.SET HEATING COOLING AUTO SWITCH Reading these 2 lines, I think the classname (and thus all code insisde) should be inversed in order to have a match between the controllable name and the class. Not too sure about that since it's the combination of the two factors for this specific device, maybe iMicknl can give us his opinion on that edit: I think you're right, I'll keep the AtlanticPassAPCHeatingZone since its integration is incomplete, however, I'll change the AtlanticPassAPCHeatingAndCoolingControlledZone to AtlanticPassAPCZoneControlZone , it makes more sense Should we use PRESET COMFORT instead? Manual is not the same as Comfort, which is another preset, but the device API don't allow the switch to it. I'la allow to virtually select preset comfort or eco on another PR by using eco or comfort temperatures (different than manual temperature). Schedule can be either comfort or eco, depending on the time of the day (internal schedule of the device). Could you do this change in a separate PR? Tronix117 would be good to include both lines. Would be great if you can add this to a constant. See somfy thermostat.py . This makes it a bit more clear where this number is coming from. Can you elaborate on this? Don't you want to set them separately based on the current mode? I wanted to improve that in a future PR, there is some issues by setting the temperature to the current mode. For exemple when you're in Auto mode, Home Assistant don't let you set two temperatures but only one, so there needs to be some arbitrary decision there. Same thing applies when it's in Schedule mode (there is comfort eco to set with heating and cooling). In fact there is 10 temps possible to set on those device, but on Home Assistant the widget only support for one. Anyway, usualy you want your automations to control your climate, so it should be ok for 90 use cases, y
Should these be sensors or number entities instead of just adding the as attributes here? Yeah, these should probably be numbers. Will remove them from attributes. I don't know the product but is this pre-heating and not just heating? This is a really good question. The device has a heating unit inside that heats the air. Is it heating the air inside the hvac unit or is it pre-heating the air before it is blown into my bedroom? I don't know ;) preheating would be that it needs to heat an element air something inside before it starts operating and heating the room at which point it would then switch to heating . Heating would be that it's actually heating to heat the room. So in your case it seems heating would be the right pick as it's heating an element while circulating the heated air into the room and not preheating an element when their would be no air circulation. I agree. Let's change it to heating
We call dataclasses.asdict on ourselves, why don't we do that on the ice servers list? How come we don't omit null values from IceServer items? Also, Instead of the custom dict factory , would it be more maintainable and easier to understand if the three items we intend to serialize were just spelled out? This needs to be added to manifest.json if we really need to use it The PR claims to add support for two way audio , why do we have a video direction ? Do we need this now, or should it be added in the future if needed? Move this to a decorator to be used here and in ws camera web rtc close to avoid the duplication mypy does not agree with the changes
What's the difference between hrain piezomm and hourlyrainmm ? Why do we need both? the different sensors report there rain values this way - so you have to account for both ways Does it mean depending on which rain sensor is connected one, the other, or both will report the hourly rain rate? Sensors report different based on sensor - I don t know what happens if both are connected. The display unit might have a preference and likely only display one value- but both values might still be sent with the data request push. OK, I see. The title of this PR is "Add ecowitt sensors for hourly rain rates in mm and in", but that's not what the PR does. Can you try to better explain what the PR actually does and also confirm you've verified that your changes work? The rain bucket sensor reports an hourly rate just like the piezo sensor - so its value needs to be handled the same as the piezo rain sensor. If it s not it reports an error - I ve been using this code for months so I know it works. Thanks for confirming the changes are tested However, can you please clarify what the PR does. The title is "Add ecowitt sensors for hourly rain rates in mm and in" but it doesn't really do that, the PR changes the state class of two of the sensors? I ll also add someone else changed my original title Update sensor.py for Hourly Rain Rates mm and in to Add ecowitt sensors for hourly rain rates in mm and in So feel free to make the title to something you prefer. I m adding the tipping bucket but It s only one sensor - but the sensor can report in inches or millimeters based on a setting so you need to account for both. The way the current code handles the sensor is increasing total - however the value is reset hourly - when the value is reset ha writes a message to the log that s it s not an increasing total. "Update sensor.py for Hourly Rain Rates mm and in" is not a good explanation Please update the PR title to match the implementation and fill in the "Proposed change" section to explain why the change is needed. I can't do it for you because I'm not familiar with the ecowitt integration. For title I'd suggest to change to "Correct state class of ecowitt hourly rain rate sensors" There's an explanation here about why the hourly sensors should be state class measurement: issuecomment-1609943505, maybe link to that and explain the non piezo sensors were forgotten in that PR if that's the case? Once that's done, the PR can be merged Updated - let me know if something else is needed.
Done! We don't need a local variable if there's only one class. Done!
This requires 110294 and an availability check on vehicle.is remote climate stop enabled . rikroe added now, not sure how I can define possible states here, any hint, please? Thanks options [...] thanks joostlek , updated now, hope it is ok ! Please use icon translations What are the possible states of this sensor? The possible values are available in [this enum]( L11-L18). If we can convert these enum values to lowercase values for the sensor, this can be an enum sensor with according translations If the state is unknown, the snesor should return None since HA will register that as Unknown ok, thanks, pushed now, hope it makes sense Maybe loop through bimmer connected.vehicle.climate.ClimateActivityState? instead so we don't have to specify a separate enum? [s.lower() for s in ClimateActivityState if s ! ClimateActivityState.UNKNOWN] Or is this something we shouldn't do in HA? We shouldn't do this in HA. If that enum changes in a dependency bump, the integration is missing a translation key, so we have this kind of guideline to have these lists in the integration itself i have no idea what is the right way, just pushed your suggestion, thanks ok, will revert then, sorry, thanks joostlek joostlek rikroe reverted, rebased and pushed now. thanks Ah sorry I seem to have created more confusion. I see the issue with a dependency bump, but what would happen if a new enum state is added without changing the code here? Would there be a hard error vs a missing translation? Of so, I would rather have the missing translation than breaking the whole sensor. I am willing to argue with others that if you use a snapshot test to snapshot the whole state entity registry entry (which includes options) we can just use the enum, because if you then test the content of the options field, but we can maybe do that in a folowup to get this sensor in first :) Sounds reasonable! Sensors are already in the snapshot test with options. brave0d you'll have to update the pytest snapshot by running pytest --snapshot-update tests components bmw connected drive test sensor.py and then checking in the changed test sensor.ambr . It only didn't run (and therefore didn't fail) because this seems to be your first PR to HA (and therefore the CI run needs to be approved every time). I think we agreed on this code, if the updated snapshots are pushed, I'll kick off the CI tomorrow on my way to the office and fix any thing that fails (to avoid getting back again and waiting another x day week to get this merged) rikroe yes, it's my first PR and I am not sure what i am doing wrong - trying to update snapshots and getting the following errors : In case you haven't set up the full dev environment, you would need to do that (see I personally don't use the Dev Containers, but just a Python 3.12 venv and then inside the venv run script setup and pip install -r requirements test.txt bimmer-connected . Then pytest should run. brave0d just created a PR against your branch ( that has the snapshot c
I don't think you need to cast You're right, removed it. I would expect it would look like this This seems to be coming up only when iterating over config entries as done e.g. in the [ airly tests]( L32). I don't think it makes a difference. Why remove the rest? Might as well include it now and use suggested display precision in the entity descriptions Set the display precision, but now had to add the full length converted value, as HA will print the full float as string state value. MartinHjelmare Usually we discourage developers to do this because "what if the library changes?", but in this case the options are fixated in the snapshots, so whenever the enum changes and the library is bumped (without regenerating the snapshots) tests would fail. So the only thing left is that the reviewer should know that a string should be added to the strings. diff-3cb4a00db27894cb9e17559dd978b695621d9a673c6899905f94f839e97910ebR22-R35 I still don't think it's a good idea to take that approach. The same reasoning still applies. The integration should blow up if an option is missing in the translations. But that can also happen if someone just adds a value to "a random list in const.py" without adding the transition key? It both comes down to the alertness of the reviewer on this. (And imo, with these snapshots it's even more clear what this change is and that a key should be added) The integration should blow up if an option is missing in the translations. I implemented a separate test only for the translations to make it clear after a library update if translations are missing (see latest commit). Then users would not get error messages it is already part of the testing pipeline. If a translation key is missing (or malformed), pytest assertion would throw an error similar to this: Oh you added a full test for it, my point was more saying that having a way to fixate the options list somewhere would suffice instead of duplicating all enums. Wondering what I can do for this to go through? Just pinning the enum sensors? I have reverted (i.e. pinned) the Enum values so this PR can be (hopefully) merged. I might create another draft PR with a corresponding architecture discussion as I think that Enum values from a library should be allowed, provided there are tests if all translations are available. We can remove this test Done. Please use the snapshot platform helper. It will also give a right name to the platform, so if you change something (add a sensor, or rename one), it doesn't completely mess up the git diff (as this is a list, and the snapshot platform helper makes it more like a dict. Maybe it's a good idea to migrate to the helper in a preliminary PR Thanks, that makes sense! Added it here as well as in and Depending on what gets merged when, will rebase fix merge conflicts as they come up. Which one is missing? Not sure if I follow. The only Enum not in this list is ChargingState.UNKNOWN as this is not a valid state and (from previous comments) should be
Done Done Done Done Why do we test this? Didn't we test this already in the previous test? Copy paste error. Will remove.
Is it not possible to clean up old devices automatically when setting up the config entry? That would be possible. However I'm not sure if this is desired from a user-perspective, as by doing so the old entity data would be deleted as well (assuming I understand it correctly)? I've kept in line with two other integrations I use, namly fritzbox (which has this functionality) and deconz (which provides a seperate service for cleaning up). What would be the reason for keeping a stale device? Thought about it for a while and couldn't think of it any really valid reason. Adjusted the code to remove old vehicles automatically. Please instead update the device entries and remove the config entry id from them. If there are no other config entries remaining the device entry will be removed automatically. That's safer than removing the device entry directly as it's (theoretically) possible for multiple config entries (from any integration) to be connected to the same device entry. Example: L191-L193 Thanks - copied from the wrong integration :)
minor version is 1 by default LOGGER.exception already logs the stacktrace Don't set minor version here, pass it to async update entry The comment is misleadingly placed IMHO We need to guard against the user attempting to downgrade from a future version: This is not correct
Please remove empty entries. This is the preferred sequence, so that hass.data is only filled with the object when the first refresh was actually successful. Please move the names to strings.json , so that they can be translated. I would like to have this as a snapshot test, which would make this a lot smaller. See the webmin integration for a simple example of the test code. Parts of this which are reused in every test can be outsourced in a function as well. (Most integrations call it init integration or async init integration )
Please add a constant in the library for "NOT APPLICABLE" Why do we need to check the planner restricted reason? The restricted reason could also be WEEK SCHEDULE , if the Mowers state is restricted. So we need this information differentiate. Ok, so the switch in on-state means the mower will park itself and wait for the toggle to off to start mowing again? Wouldn't it be better to implement a service for such a feature? Together with a binary sensor to show the state: parked mowing? I can see the reason for using a switch but I wonder is this following the Dev rules? Ok, so the switch in on-state means the mower will park itself and wait for the toggle to off to start mowing again? Yes Wouldn't it be better to implement a service for such a feature? Together with a binary sensor to show the state: parked mowing? A button and a binary sensor would be an alternative, yes. But I think this gives the best user experience. I can see the reason for using a switch but I wonder is this following the Dev rules? Not sure... After checking the HA Developer Docs, I think a Select would be a better fit to what you want to achieve: The Switch platform is meant for turning something on or off. That's not what your switch is doing. Selecting between the options mowing the lawn and parked until further notice makes more sense. Wait, there is this which is the perfect fit :smile: Wait 2, that's already in use I see, sorry. And there is not a card available that allows you to select the lawn-mower function. With this in mind, I (again) suggest using a Select. With a select you can use an Entities-card to show the Options, like this: ![image]( In the select you can connect the action to execute to a selectable option. See for reference "my" work: What would the options be for a select entity in this case? Could we detect which option would be in use from the state of the mower device? Can we extend the select entity with more options and still detect what option is in use? The options could be: start mowing , pauze and dock , implementing access to the three "set"-functions in lawnmover.py . The property activity reports the active state ( current option). Why would we do that? They are already available in the lawn mover entity. I'm thinking Thomas55555 wants to provide easy access to the lawn mower set-functions services? I'm thinking there is no lawn mower card that gives the user access to the set-functions? Or is there? Does the Entities-card provide what Thomas wants to achieve? My interpretation of this PR is to give access to the setting to enable and disable the schedule as described in the architecture discussion: discussioncomment-5873265 Ah OK, that is the background of this PR, thanks for providing the info :) "should be represented by a separate switch entity per schedule": if there can be more schedules than one, a select with an added off-option would be more suitable? Looking at the code again, I would suggest switching the on off implementations: 
The reason this is not covered by the tests is that data without xml does not return None if the data is not valid XML, instead it returns the data as is: L72-L90 Is this really correct, it's causing the tests to fail, right? I think it's better to modify data without xml to let the ExpatError bubble up and catch it in this function as well as in RestSensor and deal with it there. Seems to be failing on test setup minimum payload template which is an existing test - but that's beside the point, let me try my hand at implementing your idea. I will ping back once I'm done. Ok, looks fine now, submitting Instead of changing the test, parametrize it: Thanks for the hint, done I think it's a bit of an antipattern to catch, log and raise. Maybe OK here though since this function is only called from the rest integration, up to you to keep it as it is if you prefer. I misinterpreted your recommendation to "bubble" - you seem to have meant that I need to remove exception handling from the shared method altogether and catch it in the functions that are using it. Yeah, that's what I meant
Raise a HomeAssistantError here since it should fail loudly to the caller. I realize you followed what the existing code is doing (which isn't following current standards). The existing function uses the variable entity id but passes the actual entity. I think this should image.entity id to be more correct here. (I realize this is following what the existing service is doing, but I believe its not correct) The examples need to be updated for the new variables because it was corrected to have the entity id instead of the entity or something else? Yes entity id is a string not an object This tests needs to be updated to expect the exception How about adding a test that exercises the entity template variables? Sorry, can you elaborate? I am not 100 sure what you mean by that Add a test case that in the template references the variables that are used in the examples. Like add a test that uses a filename of tmp snapshot {{ entity id.name }}.jpg This is not needed You've changed the behavior compared to the camera snapshot service; that service passes the camera entity instead of its entity id. I first thought it was a bug, but the behavior is [documented]( although not clearly: Variable is entity id, e.g., tmp snapshot {{ entity id.name }}. I think the behavior in this implementation is the wanted behavior, but I want to double check before we merge this PR. Thinking about this some more, we don't want to copy the explicit templating of the filename to the image service because it became very difficult to use after we added the implicit templating of all service data. There's a 4 year old bug report on the camera.record service: caused by that The workaround is to do this, which is difficult to understand IMO: Hence, I suggest to remove the explicit templating of the filename from this PR. to make sure I understand what you mean, we essentially shouldn't allow entity id to be used in the filename so the call to async render would not be used? From my previous suggestion here it was that I though the camera implementation is bogus and weird. Firstly, the entity is named entity id . Secondly, its very odd to actually pass the entity here as a template in the first place. I definitely think this should be entity id and it should be the entity id, if anything. Not having templating at all is also totally fine with me too, and it's is not really needed. Users can handle this themselves in a script so i don't even know why its needed in the first place. I like the proposal to drop. You're summary is good allenporter, there's some additional context here: It's not great that this service handler is now fully duplicated between camera and image I figure implementations could change in the future if some feature is added to one service but not the other. If that's unlikely then is there a good place in the code to consolidate this implementation so both services can use it? Let's keep them separated Please break long strings around max 88 characters per line. 
Translations keys may not contain capital letters.
This is incorrect Removed Thanks, I just copied from strings.json . I'll remove that. Whoops! Thanks.
I think we should follow this pattern instead for setting up the prerequisites, before setting up the integration. L59-L71 I have very limited experience with tests so this has been a challenge. However, I think it is done as you want it now. I have also copied test init.py from automower and it works fine within this framwork. But I guess that module should be in a separate PR. Is it important to have this mock token in jwt format? Maybe just set a fake value in the mock config entry data? Nope, took all jwt stuff away. I don't see the serial number in the mock config entry data. Where is the serial number redacted? Good catch! The serialNumber(s) are unredacted. The redact has disappeared somehow. I must have mixed up version of diagnostics.py. I'll be back. Fixed. This line can be moved up out of the loop. Done Thanks, this was leftovers from my trial and error exercises. Normally this should be a separate PR. But since it's small and just tests it's ok this time.

I'd rather make an entity sensor subclass for enum sensors with its own property for native value and an attribute for options , so we get rid of those two checks (the check here and the check in get description ). Then it's only one check for the enum device class when iterating the data points, before creating the entity. Looks like we can move this to the module level, ie outdent one level. If the device point enum values are static after entity creation, we could consider storing the dict that maps value to text in an attribute on the entity, so we don't need to create that every state update. It is reasonable to believe that enum values are static between HA restarts. But there is really no way to know for sure. The MyUplink help desk explicitly says that they do not provide any support for the public API. They just point me at the Swagger site. But that said, I think it is reasonable to do as you suggest. We could store the entity class to use in a variable and move the entity instantiation out of the if else block. Good idea! Changing... S series an F series have overlapping number series (at least with the old f series numbering) so this might not be enough. I kind of doubt that myuplink upgraded F series have adapted the numbering of the S series. Ive not looked at the numbering for S series on myuplink uet but it would sort of make more sense if matched modbus numbers, but maybe it doesnt? We are prepared for overlapping numbers. The numbers in the descriptor keys can be qualified with category name if needed. However I suspect that this can be a source of more work until everything calmes down... I would really like to know how S-series presents itself in the myuplink API to try to find the most efficient solution. The new firmware for my F730 was released about two weeks ago and i upgraded and migrated last week and quite a lot of sensors are missing in the public API. I noted that Nibe myUplink have made some significant upgrades to the capabilities in the ios-app and on the web for F730 the last few days. So far as S series and F series never have same number for anything. So i think it should always be qualified. If want to see the mostly complete databases, they are here We can probably ask some S series guys using the modbus setup test the myuplink integration of you dont have any such testers. Once the new release is public i suspect they will test it. elupus when you mention S serie, i have a NIBE VVM S320 E EM 3x400V DK - what do you want me to test? Without fully understand you point, i think it's fine to have these parameter id config, and fallback to parameter unit. pajzo what does your parameter 43108 represent Or 49994? Or some other parameter for 'priority' you have pajzo what does your parameter 43108 represent It is "Current fan mode" in the F730, [0, 1, 2, 3, 4] It is assigned as unit which is incorrect. 49994 is labelled Priority and can be Off, Hot water, Heating, Pool and so on. From the metadata in each device-poi
this gives a key error, has to be updated to i["itemId"] same here i["itemId"] Please limit docstring lines to max 72 characters per line in accordance with PEP8. Please end sentences with a period. MartinHjelmare Follow up PR:
This is not required as the library will always return other . Ok, this is something that I inherited from the previous PR and didn't check :) Why do we need to add this fixture in this PR? AFAIK there's not a dependency on the groups data for the intercoms. I agree it's a good things to add but it should go in a separate PR. update groups is called inside update data that is called according to L65C18-L66C1 All the other devices have location id: null , this is why that API wasn't called before the Intercom integration. Got it thanks. Agree we should leave it in. Same as above, I don't think this needs to be this PR. Agreed this should stay as per discussion r1481642758 This seems to be included from the baseline PR but doesn't do anything? Can you add a fixture for intercom history.json , rename doorbot.json to doorbot history.json and then modify the request mock to load the appropriate fixture. Then add a test to test sensor to make sure that in this PR the intercom history is not called and we can then update the test when we release the history capability to the library (or we may end up updating the library first in which case we modify the test accordingly) Can this go in conftest As I check if that URL is called once, I find it easier to have the Matcher in place (the one I keep in the mock variable) and assert on it. Putting it among the other mocks means I need to look at the history, and I'm not sure that's worth it. Also, the open door is called here and only here. Maybe if more tests will need to use the same URL in the future a refactor could be necessary. There are a lot of mocks put inside the tests. I don't know if this is an anti-pattern that needs to be completely removed. Can you leave it in both so that anyone in the future adding tests does not miss the fact that this is not mocked centrally? Done This is not required as the library will always return other . This is not required as the library will always return other . We shouldn't need to call setup platform twice and tick for 120. Try this:
Happy to get feedback on that point : that's the only way I found to have an entity id I can use in automations that's always the same ( calendar.switchgrid events ) no matter what language the end user selects. Just let the name be what it is, people can also change it, breaking it again ok Why did you want a stable entity ID to begin with licarth ? You dont have any YAML, can be removed ok This isn't fixed Why do we refresh twice? So, without this I was not seeing the calendar updating on HA restart. But this is because I was initializing the events prop to an empty array in the calendar platform. Fixed that, and removed the async refresh() . Please don't initialise lists at class level You could create a device for switchgrid service. Then you can name the calendar "events" Why do you need this? I don't ! Removed. We should test if we can fetch data and abort properly joostlek You mean check whether the coordinator is able to successfully fetch its data, and if not, then abort the process of installing the integration? I'm not sure how to access that information from there. Should I instantiate the coordinator here? Sorry, I'm new to python and the internals of HomeAssistant, too. Can we please rename this to something better? It's a client no? Yup, will rename this to SwitchgridClient and update the dependency. Remove empty fields Please don't use the coordinator in the config flow. Just use the library and have a check if we are able to receive data. The unique id only needs to be unique among all switchgrid calendars, there's no need to prefix with switchgrid The config entry parameter does not seem to be used I'm not sure eventual is the word you're looking for here? Move this to coordinator.py What calls this method?
This is the default already. OK What is this update entity updating? If it's the firmware, please remove this line and add the device class FIRMWARE. (This can be done outside of the constructor) Firmware device class is in the entity description. We can just remove this line, I think. Oh haven't spotted that, good catch Removing...
For every non-time sensor this code would need to check on timestamps as well. Sensors with device classes that are numeric will be treated in this part of the code: L230-L237 Sensors that do not have a device class or that have the ENUM device class will be treated in this part of the code: L238-L240 Therefore, only the sensors with the TIMESTAMP and DATE device classes are left to be treated by continuing the code: L241-L262 So I understand that non-time sensors will not pass this code. If I'm wrong, please let me know... The same check is also at L248. In this line (L242) I need to check if the value cannot be converted with parse datetime to apply the conversion with fromtimestamp and provide a new converted variable new value . On line 248 I convert the variable new value (from the payload or from the conversion of fromtimestamp ). So in each of these lines I analyze different things. Do you have a suggestion to improve this? Followed the suggestion made below with L241-L262 Float conversion can fail here. Added conversion error handling. This does not make sense. If a ValueError occurs, we log and return. Lets not nest not blocks. Maybe add some failing cases with 0 or a negative number float?
Hassfest generated this, even when a similar manifest.json for symfonisk has this set to true :thinking: Seems to work anyways Nvm, I was reading a wrong entry.
Please extract the device specific interface code and data parsing to a standalone library published on PyPI. 4-communication-with-devicesservices
spelling: state attr thanks, fixed it. onkyo media player has a dynamic range attribute, can we use the same attribute name here? Yes, thanks for the suggestion, sorry for the late response, I was on vacation. Can we also add translations for this state attribute? example: L44-L47 joostlek how to do this if attr name None and there is no translation key for the media player entity (since it is the only single entity of the integration)? just come up with a translation key, "media player", or "kodi" would for example work But the translation key takes presidents over the attr name. Or can I just not include the name in strings.json? the translation key takes presidents over the attr name No, it doesn't I added the translation and tested it. OK, that's great. Were the tests successful? Yes it was translated correctly.
If it's only about config entries we shouldn't extend the base class. What about? Please limit docstring lines to 72 characters per line. The first line is a header and must be a single sentence. Please break long strings around max 88 characters per line. Maybe use a walrus for this dict lookup since we use it both here, above and below. Please break the string. I think we need to handle ignore unignore flows with source SOURCE IGNORE and SOURCE UNIGNORE too. The best thing would be to not try to discover more flows at all when an integration only supports a single config entry. At minimum we still need to allow the user to ignore discovered flows. Fixed by We should probably return an abort result with reason "already configured" here instead. I don't think anything that calls this api handles HomeAssistantError at the moment. Yes, its going to blow up in a few places for sure if it raises here Fixed by
I think this could be done with abort if unique id configured just like you did in async step bluetooth . You're right not sure why I did it this way Maybe it's better to use homeassistant.helpers.device registry.format mac to enforce a common format for the mac address? Disregard, I didn't realize mac code is just 4 characters and not the complete mac address. I think you can simplify this by using bluetooth.async ble device from address . Disregard, I didn't notice you where selecting the device by name and not by mac address. These icons should be defined in icons.json . Will add them there thanks! This probably does not matter, but this could also be done when the config entry is setup and the bluetooth device is first discovered. That way you wouldn't have to search the device again using async ble device from address . The MotionDevice instance could then be stored in hass.data . Initially I didn't know how to pass data from config flow to an entity, but I could have indeed used this. However, right now I use hass.data to save the cover entity, which is then used by the other platforms to register callbacks. hass.data[DOMAIN][entry.entry id] blind Sure, I think it's fine either way. If you should change your mind about using hass.data you could of course always assign a dictionary to store multiple different objects. These methods seem to be unused and the callbacks are never set. These callback methods are used for the three platforms (button, sensor and select) which I'll make a PR for immediately after this has been merged. I could remove them but I prefer to just leave them in for now. Okay, I guess it's fine then. Just prepare for someone else to maybe mention this again in another review since many people here don't seem to like unused stuff that will be used once the other platforms are submitted (having the same problem in my own PR 109291 right now ). I don't think this should be a info level log message. The same goes for any other messages that are logged each time default behaviour is executed. I agree, I'll change most of the control messages to debug This should not be specified for core integrations. Thanks, I'll remove them! Most core integrations I see do have keys documentation and iot class . I did remove ssdp , zeroconf , homekit and issue tracker . Oh sorry, I only meant to comment the issue tracker key. documentation and iot class should stay there of course. homekit could be removed since it's empty anyway. please use debug logs instead Should I replace all info by debug, or what would you leave at info? debug. info is normally reserved for HA itself is the default better to use instance attributes here might be ABORT here, or how could you recover if you didn't find devices idem idem in case of non-terminal states, please finish the flow successfully afterwards, to show we can recover from errors
Stale docstring Stale docstring Would this be a better name? Of course, that would imply the logic is also reversed such that on mean sleeping and off means awake. Maybe that's confusing? I will update to Sleep switch Stale docstring Improve this docstring so it explains what it means, for example "Return true if the camera is awake" Instead of this, add a translation of the name to strings.json
Looks like we can just set this during init? No, because the preset mode can change. This PR is to move these out of init so they are dynamic to the preset. Maybe add a comment here and for supported features to avoid future review comments Comments added Read it wrong clearly so good to add a comment to it. I think in general it would have looked cleaner if you would use handle coordinator update() to update the attributes instead of all these ifs within the properties but I guess it's a matter of taste TIL handle coordinator update is a thing. Ill try use that where appropriate in the future gjohansson-ST I have ended up refactoring to use handle coordinator update as you suggested, and have started using this elsewhere. Much nicer way of handling things sometimes. Same here? No, this can't be in init either. This should be ServiceValidationError FIxed. attr preset modes and attr supported features shouldn't be set anymore because you are overriding the shorthand attributes by defining preset mode and supported features . It needs to be one or the other Its a bit faster to use attr preset modes and attr supported features and update them when they change because they are cached property Ill refactor to use handle coordinator update bdraco I have refactored to use handle coordinator update rather than preset mode and supported features . In a future PR I will also refactor many of the other properties to use the same function. Because we have both sync and async code in this codebase, anything that is safe to run in the event loop is usually prefixed with async or async Can this change at runtime? Should it be in the new functions? No, the preset modes avaliable should never change. In a follow-up PR I think adding translations would be nice Agreed, I also want to use handle coordinator update for more platforms and values
Don't we need to check if the HAVC modes are actually supported here? It seems like self.support hvac is populated conditionally?
We have an async turn on off implementation in Airtouch5Zone below, but not in Airtouch5AC here. Is there a default implementation we inherit, or do we need to add one? This adds turn off by default as you support hvacmode off and then tests to add turn on if any other hvacmode is added. Below we add both directly as on off methods are implemented. I see now there is a base implementation in ClimateEntity L742 Seems good
Not sure how often these are called but if it's often it would be better to make them constants to avoid doing the dict lookup in the event map for each one It is called a lot, unfortunately, this is the only place it can be replaced with constants. The other places, the event types are not known like this. This is the end of the line when it is generating the individual names. Media sources do require some level of user interaction though, so it is not like something that is running in the background causing performance issues.
imo it'd be cleaner if we used the properties here instead of the attributes, because then we only need one "function" I'm not sure I understand. Specifically the part about one "function". I agree with zweckj, you might as well transform the functions to properties. Please checkout other integrations which use this (there are many, don't have an example right now (I think flexit bacnet uses it this way)) why are you suppressing the KeyErrors? So that an invalid mode doesn't cause and exception (although, looking at the Entity code it looks like the mode is already checked before setting it so it might be worth just letting this raise an exception). only have code in the try that can fail remove empty keys please continue the tests to show we can recover from a failure I don't see how we could continue here. The error is that the user doesn't have any devices that match this intgration. As far as I understand FlowResultType.ABORT is a terminal state. oh right. My bad maybe put that in a method to avoid duplicate code Can you elaborate ? According to defining-your-config-flow it seems important if the schema ever changes. 1 is just the default of a ConfigFlow , so no need to set it again are you planning to reuse that method in an options for or something? Otherwise I'd just put it inline. regarding your question this is what I meant: by using the built in properties, you don't need to define a method that you then call to assign to an attribute, but can just put the code inside the property definition I tried doing that but it raised an exception from here : [raise TypeError(f"Can't override {attr name} in subclass")]( L386) so it seems you can't use property decorated methods for those attributes (IIRC I also tried def attr ... which didn't work either). Actually, after looking at it closer it seems that this exception is only raised if attr ... is a property decorated method, I could override the methods defined in ClimateEntity but I think I prefer keeping it this way because this way we use the way ClimateEntity handles those properties (specifically ClimateEntity decorates these properties with cached property. I really think it would make your code a lot cleaner (compare it to ecobee's climate implementation Not sure about the cached property but maybe you can just redecorate yours the same way. This should all be moved to async setup entry in init .py there's a const for that Unique ids are unique for domain and platform, so setting it to the serial number is just fine I think I know why you use bidict, but please just do it manually to avoid introducing a new dependency in the integration. If you still want to add it in the future, please try to add it in a follow up PR so there can be a separate discussion about this (As this is a use case more integrations have, so it makes sense to maybe apply to all places) Can these be moved to the library? I'll check with the owner of that repo Unused Can someone change the username?
remove the commented out code would HeatingProgram maybe be a better name? I used that before but there are also programs for cooling (not used till now). Then that comment below is not accurate as it says heating programs. Either fix the comment or I suggest to actually rename it like suggested In ViCare context there exists a heating program (which can be heating and cooling) and a ventilation program ([not yet exposed in the library]( So to avoid confusions with ventilation in the future, I will rename it back to heating program. I know you're not using it in this PR, but since you added it as enum now, do we need those? Can't you use Program("PRESET ...") and Program.COMFORT.value to do the conversions? Good idea, not sure how that would look like though. you can discard this, was just an idea, not even sure if it's valid. HA TO VICARE PRESET HEATING {v: k for k, v in VICARE TO HA PRESET HEATING.items()} Check program You're duplicating the names here so how is the user going to know what is what? Maybe add "heating" in the middle to diff from the ones above (or something else, maybe they have a good name in the app)? Devices support either one of them. Gas heatings have a comfort program where this in typically named comfort heating on heat pumps as they have also a comfort cooling program (see I thought it makes no sense to have the heating in the name as of today as we have no support for the cooling programs. I think we should mimic the native app control so if it's "Comfort heating" I think we should say so. Also later we don't want to change this if we implement the cooling s programs. Lastly if none of above use a link to the previous translation to not duplicate for the translators (example: "[ key:component::vicare::something::comfort temperature::name ]" ) Just checked my system again, there is just the ability to use "comfort" and nothing about "heating" "cooling" at all. So I will add a link tho the existing translation.
this could be a function Done, logic is now implemented in the library. where do you use those? Those probably belong to strings.json Those are the names for the entities that I had to remove for now since I am only allowed to add a single platform in this PR. I will remove them. Removed for now since these are not used by the climate platform. and those to icons.json Removed for now since these are not used by the climate platform. I think we're not supposed to do calculations in our entites, but only in the lib Done, calculation is now implemented in the library. those are currently empty then, aren't they? Yep you're right, will remove. I normally like to be a bit more expressive and have this in separate lines, especially since in the platforms that will be added in the future some entities are only created based on a flag set in the options flow, but I guess I'll simplify this in the way you suggested. what exactly are you doing this for? The thermostats can only be set to temperatures that are increments of 0.5, so we round the temperature to the nearest half and also check that it is inside the temperature limits set by the thermostat. I guess this could also be extracted into the library. personal preference: set it thorugh attr device info as it's static True, I only found out about that attribute today, will use that. is the default not used, but is there a way to validate the user entered configuration is even valid? The only thing that could be validated is the mac address. I could do some regex or maybe use an already implemented validation helper method if it exists to do that. I can not validate macs based on if the device actually exists though, since most often the bluetooth radio of the thermostat is turned off when the user creates the config entry and therefore the entry takes 1-2 retries until a connection is established. It would great to get a from dbuezas here before merging this Sure, I wrote him a DM and asked if he wanted to be listed before, told him to react here now. I'm ok with being a co-code owner Awesome work EuleMitKeule If these are both enums than identity checks are preferred If these are both enums than identity checks are preferred If this is an enum on both sides, please use identity checks
the entities are of domain todo, how can i ensure, they also belong to bring integration? You should put this section under async setup entry , to have the context of your todo list, instead of using async setup . Also, the service will need the api object created in the async setup entry to call the api endpoint. registered it as entity service but the method is never called. Can't figure out why Should we check here whether an item name for the notification type is required before sending it to the bring api? ValueError is very broad, are we sure it's only thrown when the item is missing? Maybe it would be better to check this ourselves? pretty sure, i wrote the notify method of the bring-api library. also rewrote the error message to be more consistent with other error messages. How is this possible considering the schema requires the user to pick one of the 4 notification types? you are right, the schema validator already catches this so this is superflous, will remove it
Please sort them went ahead and did so but is this a standard? If so, shouldn't we have something in pre-commit that enforces that? Please sort them
Stale comment.
Can we type this?
Maybe include which node wasn't found? We also shouldn't raise an exception from the library here, as those are not meant to be raised outside of the library. suggestion for an exception to raise ? Yeah, I was just checking and a bit below i the helper we actually raise ValueError if the device can not be found so maybe raise ValueError here as well to be consistent ? (helpers.py, line 75) If we want to catch the exception I'd raise a more specific error. I assume we want to catch the exception in the error handler decorator and send an error message to the frontend. The raised errors in the helpers are not expected but more developer bugs if they would happen. can you check what I did - I'm now raising ValueError with a specific error message and catch that in the decorator Yeah, that's according to plan, but I'd create a custom exception per above. yeah sorry, forgot to hit push. its now there I think we should make another decorator like async get matter adapter that gets the node. done Please add a test for missing node for each of these websocket commands (even if we move the code to a decorator). I'd not catch ValueError. That would mean that the frontend tried to work on a Home Assistant device that doesn't exist. That would be a bug. ah yeah, makes sense :-) adjusted it Side note: I think we also need to handle not loaded config entry. We don't need to fix that now though. It's an existing problem. Here's what we do for Z-Wave: L268-L286 OK, added that as well but was not sure how to test it as I cant even create a fake device with an invalid config entry id sorry, only now see your comment that it didn't need to be fixed right away (its getting late haha) - well its now added, except for a specific test To test a missing config entry, we can create a device from another mock config entry and try to use that device as input. To test a not loaded config entry, we can just unload the config entry and try the command again. If it's late, I suggest we remove the config entry error handling for now and add that later with tests. We also need to make sure that the config entry is loaded, to make it not raise an exception later when trying to get the matter adapter from hass.data . I have removed it for now so we unblock this PR (as frontend is waiting on this one) - We'll do a follow-up PR with this addition after having clear what needs to be done.
I think we could use a better name for the event types. They look pretty sane to me? This will exclude the useless buttons. Tests would be nice, but that's for a separate PR. I've tried adding tests, but its a pita to mock the full library Don't we need a corresponding unsubscribe if the entity is removed?
Please use snake case for translations keys You use a coordintor, this doesn't apply for the coordinator By the looks of it, this doesn't have to update the state, this will only update the entities, but there is no new state (iirc). what about just (request an) update the coordinator? I think I did what you suggested but I'm really not sure I understood your feedback properly. Also, It takes a few seconds after the request to the station to complete before the state is reflected in the API, which means that when a user turns the switch off, they will see it off for a second, then it jumps back to on until it finally goes to off once the device has fully turned it off. Do you know if this behaviour can be improved? Flexit bacnet has an improved version for the snapshot tests, it also check if the state is not none Done. Why is this added hmm, I can't remember why this would be added here and in sensor.py. I removed it.
Do we have a mapping for these states? Having a code for state is not really user friendly. I found a mapping for the tesla wall connector integration. I'm not sure if it's the same mapping using the fleet api. I went looking for these states and couldn't find them, so thank you for pointing me to that PR as I'll implement those values. I believe the fault states will still be unknown? Do you have a wall connector? I can test your PR with my wall connector to see what I have for fault state. May be there is different type of errors so that's why it's an enum Yes I have a wall connector. I set it as an Enum because I know it will have a set of numerical codes that probably relate to the errors in the manual, but I have no reference about what's what and am not sure I could force those errors. This is why I disabled these entities by default, since they will be useless for most users. Except now that you have states I'll probably enable the first one. I just tested with my wall connector. State codes are not the same between fleet api and local api... I could figured what's fault state because it changed with the vehicle is charging. Vehicle unplugged: Teslemetry state 2 Teslemetry fault state 2 Wall connector state 1 Vehicle plugged: Teslemetry state 4 Teslemetry fault state 2 Wall connector state 9 Vehicle charging : Teslemetry state 1 Teslemetry fault state 8 Wall connector state 11 I'm thinking out loud. Can we have "state code" and "fault state code" an entity name instead of "state" and "fault state" so we can add these sensor with readable state when we will have it? Ive added "code" to the translations Only call add entities once Done, using itertools.chain to join them up. Consider to make some disabled by default? That's a lot of sensors... This isn't even the full list of sensors I'm going to be adding. I'll see which ones are logical to disable. I think here with so many it might be good to be a bit conservative and make a good note on the doc instead that many sensors comes disabled or something to encourage the user to look at which makes sense to them. I have disabled a bunch now, I'll update the documentation accordingly. Just to be sure but the product can not contain both vin and energy site id ? That is correct. It can't be a vehicle and an energy site. Looks like there is room to make a base class here to not have to repeat init ? Won't that mess up the types since they accept different data objects? I will give it a go though as I actually have three coordinators in total. gjohansson-ST added a base class. Ahh I just realised this is redundant and I will need to revert it back in a future PR, but its fine to stay as is for now.
It's not working without that. Other integrations have it, too. L27 I think you're right, I forgot this was an oauth. one Keep in mind, an unique id is unique for both domain and platform, so it might as well just be To also include the coordinator entity available state Commented code You could do a To refresh the state after a command I've missed to delete that line, from a test. Actually it works pretty good, to just send the command and wait for the websocket to send an update. I saw a lot of integration refreshing the coordinator after sending a command. What's the preferred way in HomeAssistant? It depends. I think it depends on the integration, since your integration is a push integration, just waiting for a push makes sense. (Unless that push takes 5 minutes or something like that). If you think it can just work on push and that gives a good user experience, go for it! The push feedback come really fast. I leave it like that. Not sure why this is needed, maybe you can use something like I did in Withings: L46-L55 done We should patch the library instead of this method Maybe take a look at Withings tests Changed it. Oh you already do that, but why do we have the whole config entry oauth2 flow.async register implementation( then? Autouse solved the problem I think this is tested implicitly by the other tests I don't really see the value of putting in a real JWT instead of just a random string as the content of the JWT is of no use for us It's used here to create the config entry. So encoding is tested here. But I can also patch it. L24-L36 oooh, in that case it's okay, I thought we never used it I am missing the test to test if a duplicate entry already exists Added. L510-L513
Some code from mixins is no also used in discovery.py. This is moved to device.py to avoid complications with dependencies. This is a bit weird since most of what's in this file has nothing to do with devices. How about moving the schemas to a new module schemas.py ? Well all shared stuff is within the device context. But I can rename the module if that suits better in you opinion. This schema does not allow extra values, and is used to validate a device based discovery JSON. Note that for the component only the presence of the platform option is validated. moved to device.py const.py This function replaces all abbreviations. and validates the origin info. Validation of origin info was moved out. When an empty payload is received, this will renerate a config to cleanup all siblings children of the device., When you write siblings, do you mean children? right, The discovery id's of the device is has been extended with the unique component key, This way it is easy to find and discovered device components. We parse the device JSON (or generate the cleanup instructions) and validate against the device schema. This will allow to override some shared options at component level. Since we allow extra options, it should not be an issue in case an option is not in the component schema. Why would we want to override a shared option? Can you give some example? E.g. a state topic might get it's value from a different topic, In that case, if it is set within the component context it should override the share context. It was changed this way to address comment: It was the shared context that had priority, later I changed this based on: issuecomment-1915172290 emontnemery There are two circumstances. 1. You may have one device that sets a common state topic command topic, and a different device that sets a per-entity state topic command topic - this supports both (no overriding going on). 2. You could have a device that sets a state or command topic for the device, but then for specific entities (maybe virtual entities, or who knows), it sets a different state command topic for that entity, but not the rest of the device. The former is likely more common. But the code as written supports both. ONLY having per-device options would mean a lot of repetition if there are many entities. ONLY having device entities would make this impossible to use for things that do want different topics per entity. Since we want to support both, having the more specific (entity-based) option override the less specific (device-based) option just makes sense - provides a concrete way to avoid ambiguity. We parse the device discovery and forward the discovery for each component. At component level further schema validation is performed. In case of a single component we just add it to the list of components to process. The component key is used as a node id or if node id was in the discovery as a sub node id . The component is retreived from the platform option in de component config. T
This change doesn't relate to this PR. I'd recommend a separate PR that (a) bumps simplisafe-python and (b) makes this change. Then, rebase this PR on top of that one (once it's merged into dev ). I'm having trouble rebasing. I sync'd my core:dev with yours, pulled my dev, and I get a bunch of conflicts I did not expect. I seem to be getting conflicts with previous commits on my simplisafe-outdoor-camera-support branch. camera.py for example, is not even in dev. I am not sure what is happening. Can you suggest anything? Run a git status and this stage and share your output. You need to see what changes Git struggles to reconcile in those two files, update accordingly, and then continue the rebase. What state am I in now? When that occurs, that means that the current commit matches your working state in that case, I would just git rebase --skip . Did you end up making a separate PR with the version bump and this websocket event name change? Yes Is this necessary? Can we just return content ? Because if I just "return content" mypy says: error: Returning Any from function declared to return "bytes None" [no-any-return] And in simplisafe-python ( api) the function is declared: async def async media(self, url: str) - bytes None: So I don't understand why mypy is freaking out. This can be simplified via a comprehension: Where does this get called? Does HA call this at some point? I believe I found this sort of thing in other components, so I adopted it here too. If HA does not call it, then I'll remove it ... because I certainly don't call it. Is this ever reset? Are we always returning a cached image once it's been set? It gets set to None in async update from websocket event() when a new motion event arrives. This seems odd. Why not just construct the entire URL when you need it? This is what the urls look like from SS. I do not know the desired width (from a user's automation) until now. Loop through these service registration calls (since they're almost the same). Only DOMAIN is common. The other 3 (of 4) are unique. Seems to me the loop would be complicated. Should this really be an error? The user can't do anything to correct it. Ok, removed error printing Why are we disabling mypy here? Because if I don't I get: error: Incompatible types in assignment (expression has type "Any None", variable has type "Template") [assignment] Why are we disabling mypy here? Because I get: error: Incompatible types in assignment (expression has type "Any None", variable has type "Template") [assignment] All these nested functions are challenging to follow. What about just including them in the entity? Because they need the reference to self, and wouldn't get it when called from HA as services? I copied this pattern from other components, thinking this is the way to do it.
Please move this to the top of the class Can these change at run time? If not let's use the shorthand attr here so we don't have to calculate these every time state is written color-modes Please double check to make sure all color modes match the description in the table Ah, I see brightness is suposed to be standalone, and you should only return values in supported color modes. Would this be ok, is is there something else that needs to be fixed? It would be cleaner if we could determine the color mode from the device data itself without having to check self. attr supported color modes It doesn't look like WHITE should be set here color-modes If this mode is supported, the light must also support at least one of ColorMode.HS, ColorMode.RGB, ColorMode.RGBW, ColorMode.RGBWW or ColorMode.XY. Hmm thats odd, Is there someone I could ask about that? it seems to be working just fine when I try it, and I don't know why it wouldn't be able to support ColorMode.white and ColorMode.COLOR TEMP (See the W icon next to the color picker) Enabling white mode (warm dim) is a large part of the lutron lightstrips, so I would be curious to make sure there is a reason it's not supported, or just forgot to be added to the documentation in the list. ![image]( I'm not 100 sure why color temp doesn't qualify so I added a request for a second opinion in case someone else knows Also some times it takes a few weeks months to get a second opinion. So we could always merge it without white support for now and you could add it in a future PR so we are only waiting for the second opinion on that PR Please make this a const dict lookup by light type supports warm cool and supports warm dim never change. Please set them in the constructor Please type arguments Please type arguments Please type arguments Are these available as constants from the pylutron-caseta lib? unfortunately not linter will complain about this suggestion Please make this a constant instead of binding it to the class since we don't need to override it in children Please move this after init . We want init to be the first thing in the class than make a constant set above WARM DEVICE TYPES {DEVICE TYPE WHITE TUNE, DEVICE TYPE SPECTRUM TUNE} Please prefix functions that are save to run in the event loop with async or async since we have both sync and async code in this codebase You can import Lutron's color mode as from pylutron caseta.color value import ColorMode as LutronColorMode
Please create a separate list for the entity descriptions unused we don't use this in this integration afaik Please extend SensorEntityDescription and add a value fn property for the value. Do a global search for value fn for examples Sentence case What are you doing here Create the dynamic list of sensors to be added in the line after can be moved to the entity descriptions done done unused Can be removed can be removed What are you even testing? I'm testing that the entity is created correctly. As it does not have any direct logic but relies on the coordinator get status with the communication with the projector I do not need to test anything else. Yes you do, you're adding two entities, at least test the state Can be removed as is default Aren't these constants? The constant are in the jvcprojector library, if I put them I get an error, so I had to put the string. They are imposed by JVC so is ok to have litteral as they will never change Then why are they constants in the first place? What are you testing here? We could do better Please remove Unneeded Unneeded This code is now doing the exact same thing as above, except for the last line Off is actually not a valid state (only Standby). I would remove this to avoid confusion with users writing automations. You're right; I cross checked the documentation and it is not returned Can we have better icons for it? use the outline variant for cooling warming is wrong in my opinion as the user needs to know that the outline variant means cooling warming As the input is changeable, this should not be a sensor but a select entity. Please remove it from this PR and create a follow-up, where you add it as a select entity
Will you also be able to update in the future? Maybe, but I don't think so. Not for now at least. The mobile app offers OTA updates but the server to check for updates is not public, I would need to reverse engineer the mechanism. Is there a better way than binary sensor you would recommend? In that case this will do just fine :) This could be disabled by default imo I agree, updated. It's already imported as fixture True! I changed it in my sensor test too for consistency. This one should be the update platform Also when you can't install updates remotely? Or know what version you have can upgrade to? Also when you can't install updates remotely? Yes I think so Or know what version you have can upgrade to? Probably not as we need to know upgradable version to have a proper state. I just assumed we knew if we know an upgrade is available (or perhaps "fake one") as I think it looks nicer for the users to get it in the updates available section i in settings rather than just as a binary sensor even if it's not possible to update it from there. Looks like we only know the current version and if it's up to date L119-L130 Maybe right now but are we sure it can't be returned from the api of the device? For now, I have no way to know what version a user can upgrade to. I also have no idea how to get the next version. Should I just leave this info out of the integration until I have more details? All I can get from the device API is a bool that tells me if an update is available, but I'm not 100 certain this ever changes (there are not frequent updates so I can't test currently). I think the app does all the logic for updates right now. Let's leave it in then would be better to set a fixture in conftest to load the integration once. Not seeing why we need to load single platforms. For the snapshot test, you still want to have the tests separated per platform, but not have every platform snapshot every entity Sure, was only referring to setting up the integration. I know, but when I added Withings sensor snapshot tests I checked if they were the right platform when snapshotting, but I was told I should patch PLATFORMS instead I guess anyone's preference... This is a test for a sensor so why it's here and not in test sensor.py ? Sorry about this. This was leftover code. I tried to go too fast yesterday. Removed. Personally I would like to see setting the side effect before moving time Done. I also changed it in the equivalent test in test sensor.py for consistency. Why does all these state snapshots disappear? That sensor got removed, but syrupy doesn't actively remove removed snapshots (I think it's configured this way in HA) Ah. It wasn't removed but now I see it's all duplicated as the name changed.
I think this too should be marked as diagnostic Done, also cqi1 (the 4G one). Please remove these comments, they look like review comments, not something which is useful in the code. As an alternative, rephrase. Rephrased some, suggestions welcome if more changes are wanted. I don't think the comment should be removed, because it's a valuable TODO (which isn't marked as such because the HA linter config at least used to forbid TODO comments), and I don't think there's a better place than right there in the code where the thing to address is. Please remove this sensor for now if it's unclear if it works Even though not perfect, it does work as in shows diagnostic information. We have a similar one for 4G in txpower already.
Why does one of these set log api exception to True and the other to False? I'm not sure what you mean; all instances of the log api exception parameter are set to False in this file. You're right, I have no idea what I meant Why is this changed? Is it to ensure the Play Pause buttons always show in the frontend? Yes, this gives us separate play pause buttons rather than a single dynamic button (which won't actually work correctly because the Vizio API doesn't provide a playing paused idle status).
What's the default icon for climate can you use icon translations? Yup indeed, just copied from other integrations that explicitly have the attr icon . I think that for climate should be removed from all integrations. This can be a constant outside of the class (I think that's more efficient) removed preset support as not always configured I think this was a valid constant We dont raise update failed in these cases iirc I guess maybe just log and return None ok What's a MAN Manual I mean, the enum is to keep the code consistent and readable, why not change it to MANUAL :) renamed So we only set HVAC to ON when it's off, what if we set it to MAN? HVACMode doesn't have a Manual mode ;-) Why the 10 Because the api expect "178" for 17.8 C You have the same 10 when we read ;-) Isn't that a device specific thing? I'd rather see that resolved in the library As far as I know we do the same for many other integrations, for example fritz. AFAIK, we usually don't manipulated data returned by the API in the library. Moved to the library Please bump in separate PR I did only because the bump is needed for clima to work; will separate. 108862 I see different values: O, U, L, A. For O you already have a constant, would it maybe be nice to have the rest as constant enum as well? Ok will do later this evening once back home Done CLIMATE has a 2 item tuple: We don't want side effects like logging in entity state properties. Please remove it or move it.
Didn't you remove a lot of Active prefixes recently? That PR is not merged ;) Let's try it again. You removed all the Active prefixes recently. Hah that is absolutely 100 true. I totally forgotten about that and will pick that up ASAP Rebased!
Why don't we just use area id and copy the return value from that to a boolean? The comment in the previous PR was to make area id function as a filter. My goal is to make the template in the PR description work. Would be happy to see possible improvements. Please explain further why that wouldn't work. Already discussed in previous PR. I don't see anything saying we can't make area id a test or a filter. On the contrary, that's exactly what we're suggesting. If you don't agree please explain further. Why don't we just use area id and copy the return value from that to a boolean? First I only wanted to check entity IDs. You mean like this: I don't see anything saying we can't make area id a test or a filter. On the contrary, that's exactly what we're suggesting. If you don't agree please explain further. I don't know how without overloading area id() . I think it is a better approach to create is area id( area id ) instead. I updated the PR description for better understanding. What we suggested in 101171 was to allow using the existing area id function also as a filter. However, it turns out that's already implemented: L2795 The two suggested templates in the PR description can be realized with existing functionality: Sorry, but this is wrong. Please read the previous PR discussion, especially issuecomment-1742094759. I am annoyed to explain the whole situation exactly in a second PR. emontnemery Please have a look at the community [topic]( klatka In the PR description you give two examples of how the is area id test is useful. In my comment I showed that it's perfectly possible to implement the same templates using the existing area id filter and function. Instead of being annoyed, can you please show some example of a template which is impossible, or at least much more cumbersome, to do with the area id filter and function? Thanks, klatka, now it's clear Instead of adding tests, maybe we should make area and device data directly accessible from the state object, then it would be possible to do something like this: emontnemery I'd love that approach and it would make 80 of my area-based automation a lot easier. Should we be concerned about performance making area and device data accessible? Performance should not be a problem if the area attribute is lazily looked up, i.e. it's not assigned until state.area is accessed. Could you give it a try? You can contact me on Discord if you want to discuss the approach.
Maybe make TRIGGER MODEL A and TRIGGER MODEL B constants so you don't have to construct them over and over. Ideally we name them something a bit more descriptive Good idea. Changed.
The previous implementation left an empty title for cameras that took their name from the device. This seems to be a better choice, but if there's a better way to get the name I'll change it. I still want to see this change in a separate PR with its own description, etc. creating-the-perfect-pr as i mentioned before. Update test description Tests do not interact with hass.data and instead should by string name as is done in other parts of the tests in this file.. In this case i think the reason this approach is chosen is because there are different return values for the different cameras? Instead, patch once and have either the callable or side effect return the different values for each call. Also a small comment might go a long way here, something like: "One camera supports HLS and WebRTC, one cameras supports only WebRTC, and one camera fails." etc I think everything looks good to go here, but now i'm thinking about one more idea to further streamline this, but not positive it would work out: Could the scope of this function be to just filter out the not relevant cameras and leave the browse media source building all together how it was? It could just get the eligible cameras in one pass then build the sources in a simple loop together with building the root. We could return the camera instead of BrowseMediaSource , and then iterate over the results to build the sources, but I'm not sure I see why it would be better? Its possibly a style preference, but my thinking is: in general, reducing of verical lines of inline functions or reducing the scope as much as possible seems positive. Having the BrowseMediaSource building closer together together seems logical as well. One exception may be if there is shared logic on both parts but i think the existing stream type filtering looks more complex than it needs to be It's a bit tricky because we also have to recalculate the content type (or return a tuple). Arguably refactoring the creation of the BrowseMediaSource to a separate function would achieve a similar result (see my latest commit) Thanks, that looks good. What do you think about gutting all the existing vertical whitespace? It seems like it makes this harder to follow given it has so many branches and is in an inline function. Collapsing vertically will also help make this simpler to grok quickly. Does it work for this to be a single statement? (Given this is 3 levels of nested ifs in an inline function) I took advantage of the ability to return early in a successful case to refactor a bit differently. Let me know what you think. This seems like it can either be 1 or 2 lines rather than 3 Maybe just drop this while we're here
stale doc string Unless I'm missing something, this looks like a useless any expression Ahh. its a generator.... Instead of just return maybe we should kick in the reauth flow? That seems like a job for the frontend? Makes sense. Probably we should not show the option to reconfigure if an active "reauth" exists I think you can combine these Made the split to make the comment to kick in the "reauth" flow but if we should just return here then yes we combine them. Should the existing checks in async start reauth and async init reauth also be updated to check both reconfigure and reauth? I think this is changed because you use black instead of ruff to format code in vscode. Please revert this change. I think this is changed because you use black instead of ruff to format code in vscode. Please revert this change. Ugh, this really should not be in homeassistant helpers data entry flow.py but in some config-entry specific sub class. This refactoring should probably happen in a separate PR. Would it be possible to add it here: L137-L164 Ideally, this should be removed. This is not OK, because all tests executing after this test will now have an "assist pipeline" flow. assist pipeline has a config flow fixture fixture already which adds a fake flow and then cleans up. mock config flow is the correct way to mock a flow, why is this changed? I don't think this is OK, because there's a single instance of the ConfigManagerFlowIndexView class handling all requests. This is not OK, because there's a single instance of the ConfigManagerFlowIndexView class handling all requests. We should instead split up FlowManagerIndexView.post in an outer function, which is decorated with RequestDataValidator , and an inner function, FlowManagerIndexView. post impl or something like that, which child classes which have their own RequestDataValidator can call. Is this change needed? Is this change needed?
I think you can write state directly here but thats probably not needed since it will happen at the end of the update anyways We can make use of pytest.mark.parametrize here as these tests are nearly identical Ok that's parametrized now.
Please don't modify these I modified the recipes and made a new commit Does this use Oauth? Actually yes, but token is long life so don't need to refresh Wouldn't it be nicer if we could use the Oauth flow instead of storing the credentials of users? Actually don't store credentials of user but user Oauth cliend id and secret and after this the token generated. Alternatively we have to use a unique client id and secret for all the users and this is not good for us because we have limits on monthly call by client id We have an Oauth flow, checkout integrations like google, withings, spotify etc. People fill in their own client id and secret and will be redirected to the service to login. After that they will be redirected back to HA. The current approach would also work, but I think this approach would be a better user experience, and it would make HA a bit less dependent on the decisions in the company. (Maybe you will make new tokens short lifed, etc) Yes, we've seen the other integrations approach. OK, we will try to use that, is this a now decision or we can do in a second version of the integration? I asked around for a second opinion, maybe this approach is a good reason, but I want to be 100 sure what I am telling is true. If we were to implement application credentials, it should be in this PR It seems like this is an implicit flow. Do you also have a redirect flow available? It's not a implicit flow, is Password Credentials Grant type Hi joostlek , we've choosed to leave Password Credentials Grant Type because is legacy. Now we use implicit, we've developed the flow as suggested from HA. The integration looks now ready to be reviewed Please don't change the package constraints in this PR. Thanks!
I don't think we need this Let me reiterate. We should use this function to replace the setup function and use this step to import the YAML configuration as a config entry. If we can't import for some reason, we should raise an issue. For an example, please check the Pull requests that have been merged at the PR tab and search for streamlabswater. This would be an example you can use to import configuration. (I'm on the bus right now so I can't quickly find it) Got it, thank you! The whole idea of .setdefault is to set it to {} only when it doesn't exist ;) Only put stuff in a try block that can raise What kind of error can occur? Removed, since this is was copy and paste from previous setup process You can just pass a list to the setup. Changed to async forward entry setup s I think it's best to leave the has entity name and device info changes for a later PR so we can focus on the config flow in this PR Removed. I am leaning towards solving this in a follow up as well Removed. We only allow names to be set by helpers. We should set the name of the config entry to something the user can recognise if possible, otherwise just a default name Changed to: CONF FRIENDLY NAME Can both be removed Removed. Changed. These are all required fields so you can just do Currently we are only checking if its a valid host. Can we maybe do a little check to see if we can actually find a device? If we can check if the device is supported? The config flow is the best way to tell the user they f cked up. So we should do our due fill to check if this is a valid device to connect to and abort if not. Added connection check. General question: can we get any kind of identifier from the devices? Some kind of serial number or something along those lines? Do you mean the sensor or the alarm panel? I am probably adding a serial number in the future, but this will most likely be handled in the separate PR for device info Unused Removed Unused (afaict) You can use translation references. Checkout Sonarr for an example Currently you are not using this. I think we can add support for more instances with ease if there is no technical reason it's blocked There is no options flow
Can we unset these? I have mixed feelings about this part. It's very unclear what is happening when. I am leaning towards extracting this into a function, but that would require a lot of parameters. Or you would have to pass in the coordinator. (The biggest factor that makes this worse are the inline ternaries) Intent is to show phase features with the model. Maybe this makes it more clear: I think it looks better, but I do think we should put it in a separate function moved to seperate function Can part number be None? In that case omit the or "Unknown" , this will just hide it in the UI (Like, "Unknown" doesn't add value, so might as well just hide it) That section came from original code, only change is to show it in hardware version rather then model and change Envoy to Unknown. So it probably made sense in old setup and can be removed here. Unknown removed Can you maybe elaborate a bit more about why we do this? Is this a way to remove an assert (which we have too many of, I agree)? Or does this mean we only show unknown at devices which don't support this? When can this be None? (this question also applies for the Consumption one) (if this is intended, I think inverting it would be better) Yes they can be none and will be none for Envoy without CT or non-metered versions. I'll apply your reverted proposal and do the same for the one below to get rid of the assert But if someone has no CT, shouldn't we omit these entities from being added in the first place? This way they aren't fed up with X amount of entities that are Unknown Yes that is the intent. If none is returned no entity is created. refactored it We should not access internals during tests. I am not up to date on the test state of the integration, but these ideally would be sensor tests as in 1. We set up the integration with this as source data 2. Observe the created states and check if they are what we expect 3. profit I'll change to use state hass.states.get("sensor.whatever") May require more overhaul of current test. Currently the device is set up, but no entities, so no states. The flexit bacnet example does this, but is setup different as enphase currently. I think dataclasses.replace could be used here instead dataclasses.replace It has an additional item on phase not present in dataclass its getting the data from. Would that work? sadly no. it looks like we are stuck with something complex You might be able to do dataclasses.asdict and unpack with untested... but maybe this will work, Doesn't fly, complains about key and translation key having double values as they are in the asdict list as well. To simplify this, adding the on phase field to the base class (and not using it) would allow for the dataclasses.replace use. adding the on phase field to the base class (and not using it) would allow for the dataclasses.replace use. That seems like a better idea to me. (typing it to None when not used) Done Please separate words with Done (need to get rid of this old habbit) Can 
Should we return None if time 0? Any reason we don't use device class translations? cdce8p I hope it is fine to ping you directly :) I have a type issue with mypy. Without this code line I get the following error: homeassistant components ecovacs sensor.py:176: error: Definition of "entity description" in base class "EcovacsDescriptionEntity" is incompatible with definition in base class "SensorEntity" [misc] But I use generic in the base class: What do I miss? Try removing the entity description: EntityDescriptionT line from EcovacsDescriptionEntity . The issue here is that you're trying to make a variable generic which isn't generic in the base class. entity description: ... is basically a just hack to avoid having to make it generic in the first place and needing to update all integrations. It would be "more" correct and at some point we might even want to do that. I would wait for [PEP 696]( support though (at least). As for your case, I would suggest to remove EntityDescriptionT and continue to use the "hack" here. That should probably work. Thanks :) Each minute we get an update from the bot so not sure if we should use seconds as maybe the user gets confused as the values is not counting upwords... It would be a more accurate number but indeed updated less frequent. 1:30 would now be 90 seconds, and with the current code be 2:00. (Also depends on important those seconds are) What's the value of this? Which type of cleaning it was: - spotArea - edge - spot .... I myself I don't use the sensor et all and we can also not add it for now and see if really some users are needing it ENUM sensor I know that would be great but I don't know all different types... Different models have different types and no public available documentation This is already typed as bool right? You are still referencing self.entity description.key in the unique id EcovacsEntity is a subclass of Entity , which has entity description attribute Can I also use "[ key:common::config flow::data::ip ]" even when it's not used in a config flow? I think we don't allow that, not 100 sure tho Isnt this the default already? This also sounds like something someone might automate up on, is it worth extracting to a separate sensor?
Please just add the Binary sensor to this list instead of splitting stuff joostlek ok. I have to understand how to modify a file and add the change to the pull request. I continue to end up in a mess and have to cancel :( Just add the changes, don't try to revert JvcProjectorEntity already has this I thought it was requested for each instance I think this is a valid device class for this entity. ok, in reality I saw the icon and property was ok even without the line, this is why I commented it We prefer the device class over something custom. Hmm, I am leaning towards just removing this and adding the device class. This would make it binary sensor.jvc somrthing power which is quite nice. name should only be set to None when its the main feature of the device. And I think remote is a more valid main feature than knowing if it has power. what do you think? joostlek in reality I think the main feature is the Binary Sensor. The Remote is very dangerous, for example in my case I need to disable it as I do not want actions performed on a video projector remotely. Sending commands can screw up the setup and mess the configuration. The Power Status is needed before any communication to the porjector, needed in automations (i.e. open screen when on, dim lights when on, power on stereo when on etc...). So I think is better to have the main feature the Binary Sensor and additional the Remote (and the sensor when I will add it :) ) Can be removed when using the device class Yes, I added it to have the correct icon as I removed the device class Do yourself a favor and add something recognizable to the unique id for the future If you ever add more entities you don't have to migrate the unique id I was using the power for the Sensor (the other part I will add after this). Ok I will change the other Can be removed Can you make that list a set and put it outside of the class? That's more efficient coordinator is already set at self.coordinator so I can remove it? will check Yes Please revert joostlek sorry do not understand what I have to do, what you mean with revert? there should be no change here. Please revert joostlek sorry do not understand what I have to do, what you mean with revert? there should be no change here. There's an extra line. Sorry for the nitpicking but let's try to clean this PR as much as possible :) understood Can we also revert these changes. These change logic and have nothing to do with the binary sensor platform joostlek I can remove it but is a debug info that reports the projector status, at pooling time. To identify if there is any issue with communication that can invalidate the Binary Sensor status (i.e. in the last firmware update it has been added a power new status, without debug it would have been impossible to detect and diagnose) You could remove this field and then the device is named as the config entry title. So then renaming the device is even easier joostlek ok. I have to understand how to modify a file and add the chan
Don't add this as a sidebar, instead add it as a configuration panel. Background in PR Done We don't need this and the issue Removed Let's bump this, maybe to 2024.12.0? Changed The docstring does not seem to match the implementation? Changed Can the bump of pypck happen in a separate PR Yes, that's possible. The newest changes are not necessary for this PR. This looks like a race, can't we check if what we're waiting for has happened instead? That's indeed a relict from testing. I removed this. I guess it's not necessary as it never occured during my tests. Instead of an options flow, I think this should be a reconfigure flow (add a flow starting with async step reconfigure to the config flow) Thanks for the hint. I changed it to a reconfigure step. The integration already has tests, I think tests should be added for the websocket handlers. I added the tests. "get hosts" does not seem to match the implementation, the command returns a list of config entries? No, it sends a list of dictionaries with names and ids of the available hosts. I guess it's correct as it is. Can't you just use the existing command config entries get though? I just realized that the config entry id is passed from the integration-panel to the custom-panel via url-parameter. This means that I do not need the host-selector box in the first screenshot. I therefore removed the whole websocket get hosts method and handle the url-parameter in the lcn-frontend code ( Why is this changed? The CONFIG DATA dict is used to test the reconfiguration step. The original configuration for the config entry is read from the fixtures. To test the reconfiguration, the CONFIG DATA is used as modified data (port has changed). The deepcopy seems unnecessary, how about this: Same comment for the other places where deepcopy is used Changed and removed all deepcopies. Can we cover this case in tests too? I added a special case to the tests, so that at least the code gets covered. Why do we mock the HTTP server? When registering the new panel's path, we need to call hass.http.register static path in websockets.py . But hass.http returns None for the mocked hass object. I tried out a few things but I did not find a better solution, then mocking hass.http . OK, please add this explanation as a comment Let this check happen in a decorator instead. The decorator will then call the decorated function passing the config entry; like this:
Maybe look into icon translations This will have to come in a separate PR I'd move these to a separate test You have a finally clause in your try except block. You could try patching it again to something different to verify you actually fetch data after an error like this. Done!
What does the continue do here? Can we start with calling super? Why do we copy here? Why do we modify the config entry options here when we have the config entry migration? We should just reload the config entry in this flow to have it migrate, I think. The migrations makes a copy of the sensors and add them as binary sensors so we have both. The repair removes the sensor ones so we only have binary sensors left. Could make it more obvious in the repair flow by popping the sensors instead of constructing a new option dict? Ok. Should we remove the entity registry entries for the process sensors too? The corresponding entities will then be removed too. What does this test? It tests the generic ConfirmRepairFlow() diff-56692cd2c2c999c37c62870717f33c9a21943867a6d0d69835c33b3efabd82d2R66 Why don't we let the integration create the issue? The integration doesn't have such issue so it can't make one. That's to ensure the integration has the generic support for fixable issues in case such should be added down the line. It's added like this in all integrations adding the repair platform I believe. Ok.
This is protocol details that should be part of a 3rd party library.
If I assume correct, you will use this device fixture in probably more platforms. Can you maybe move this test to test init.py as its not specific to binary sensors? With snapshot tests I want to recommend giving your entity and state snapshots a name. Because If you add more entities in the future, the list can get messed up (as order changes). In this case you only have 1 entity to test, but for other platforms, please checkout tests like this: L13-L29 Done it also for the binary sensor This is an integration detail that we should not use in the tests. Try to patch the library instead to get access to the relevant resource, eg the event handling.
Do we need this ? Since it's only used in tests, I'd say we should not add this. async get floor by name will already normalize the name. We normally use the opposite pattern where the device registry would be responsible for listening to EVENT FLOOR REGISTRY UPDATED and remove the deleted floor id from devices. I think it's a good pattern because the responsibility is centralized, and I think we should do the same here as well as in the area registry. Instead of multiple separate indices, make FloorRegistry.floors a UserDict , then the additional index is the responsability of the UserDict instead of spread out over the FloorRegistry . We use that pattern in the entity and device registries, for example L390-L396 We should use that pattern here and in the area registry too IMO. PR for area registry: Make this a protected staticmethod of FloorRegistry With the latest change, I've not moved it. I found it odd to use it in both FloorRegistry FloorRegistryItems. Instead, I've left it where it is and marked it protected.
Users can already rename the config entry or device. We shouldn't add name here. Use the config entry title for coordinator name if there's one coordinator per config entry. Users can disable the remote entity if they don't want it.
Adding custom polling rates in the UI (also known as, scan interval) is no longer allowed. If you wish to use a different interval, you can define your own, based on your own rules and schedule, using an automation that call the home assistant update entity service. This problem should not be solve by manual control. Instead, the integration should take into account the number of entries when polling automatically.
It's the default icon, so no translation is provided. It's the default icon, so no translation is provided. This should be the default temperature icon, will change that in a follow-up PR. We can remove this in this PR Thanks
We typically try to avoid multiline ternary lambdas, as they're hard to read. Can we move this into a small function? Done. Please avoid multiline ternary operators That breaks the code coverage, I'm going to add tests and possibly a fixture just to meet this code formatting requirement. Yea, otherwise we shifting the multiline ternary into a function instead of a lambda
Add this in a separate PR. Not related Sensor entities should be in a sensor platform file sensor.py Might be best to add the sensor in different PR and remove it from this one Should also include Platform.SENSOR and separate sensor entities to the sensor platform Sensor should be in sensor platform. Something flaky goes on when setting up and paring the device the first time. 1) I paired and the setup "hung" at the pairing state. 2) Reloaded the integration and it found entities but they were unavailable. 3) Reloaded again and the entities became available. On a second try with the esphome ble gateway already "paired" I still needed to do a reload to get the entities to become available when adding the integration. Can you provide logs? I found pairing the official application unreliable for the first pair as well I don't think we want to "fail" the integration here. We have already "validated" the connectivity in the config flow. At this point, it's just not in range and should continue to try. Simply raise ConfigEntryNotReady() to let HA retry automatically. We should try: to connect to the mower and catch except: bleak.exc.BleakError) : Error ESP GATT CONN FAIL ESTABLISH while connecting: Connection failed to establish. try: around this section as well Bleak and or aioesphomeapi.core.TimeoutAPIError should be caught here. Stale doc string? Should name this something like HusqvarnaCoordinator to help prevent confusion with the normal coordinator - like other integrations do. Based on other examples, this is usually DOMAIN (not sure if it really matters) Each entity should have it's own DeviceInfo to put in the device registry. I think it needs to move the the entity setup for each. I dislike the use of snapshots here as you "hide" what you are actually testing Personal ick Please don't log on info level Why are you passing in a logger if you made one on line 24? If you like, you can also create an integration level logger with LOGGER logging.getLogger( package ) in const.py Please move this to entity.py Why the context? I agree with mkmer that it would be nice to create the DeviceInfo here instead We usually also incorporate the super().available in coordinator entities Why is this a parameter if it's static? Why don't we just pass in what we need and let the entity decide The lawn mower is the main feature of the device, so the name of the lawn mower should be set to attr name None . This way, the name of this entity is decided by the name of the device, which is consistent Also, for unique id, address should be purely unique I assume? Reminder that unique id is unique per platform per integration, so there's no need to prepend it with automower (if that's what you were trying to avoid) can be combined This call appears to return a bool L459
Can the services be [entity services]( entity-services) on the main entity instead? IF yes there is no need for get coordinator ? yes makes absolutely sense to add to calendar, but somehow I can call them in tests, but no code is executed, any idea? Also Done, but should I add it to the calendar platform PR, or keep it as separate PR? Please use a [time selector]( time-selector) instead Does this service not the same as the calendar entity in calendar platform is for display only, this is for setting only. As the app sets one schedule for mon-sun which applies to every week, editing one calendar entry, which then would edit all entries would be weird. Why do we need two services for one use case? because that is how it is in the app. You can enable disable the schedule for a specific day, but independently set the schedule for each day. If I have it in one service you would always need to set the schedule if you want to en- disable one day. and because I find it weird if you had a either put enabled, or all the other attributes, which then would be custom validation logic (afaik) which I find annoying from a UX perspective. I added the option to disable optionally to the schedule call, so you only need to make one call in that case.
Showing a serial number here is a bit too detailed. The most user friendly thing would be to show the name of the entity device here? Lets extract a now variable at the top of this function and use in the 4 calls. The logic for this function i think should be to return the active or next upcoming event. Is this currently skipping an event if it already started and already ended? It seems sufficient to just skip if it ended, but allow it to be a return value even if it already started and is still active, which represents an on state. that's excactly what I was already doing, I removed the unnecessary and from the if I think it may be possible for this to skip events in the range. Say you have a schedule of: "Every Sunday between 07:00 - 07:30 (only)" then this function is called with: - start: 2024-02-11 09:00 - end: 2024-02-18 08:00 Then I think it may not return the event on 2024-02-18 07:00 but it might return the event on 2024-02-11 07:00 ? I think this happens because it gets the days involved before checking the schedule. I imagine this doesn't have a big impact in practice for the calendar UI based on how this is called, but i could see this being a problem for triggers where this gets called with a small window and if its not correct then nothing will get triggered and its hard to debug. (For what it's worth, I have a very over designed solution to this problem for [rainbird sprinkler]( L79) using the same underlying libraries used by local calendar to generate a timeline based on a schedule and recurrence rules. You don't need to use this or anything, but i was just sharing since i ran into a similar problem there ) The only thing that could've happened, is that we missed any events on the same weekday in the following week that were already ended at the current time. E.g. it is Sunday 08:01 and the next event is next Sunday 07:30 - 8:00 we would've missed that. I added an extra day to the date range, that should fix that problem. If the event is only at 08:30 we would get it twice, but since we only take the next occurence here, that's no problem. The other thing to be careful of is returning an event before the range though too and omit those. This may not cause a major problem for this integration since it's once per day, but in general it will also screw up triggers since it assumes it can correctly iterate through events by scanning the time range and see them only when they are supposed to be seen -- and I don't want to have that pattern copied into other calendars. Not sure I understand what you mean. I'm already filtering out any events that are on the current day but have already ended. Such an example is already part of the tests (Friday iirc) I am referring to the example in my comment. The start datetime is on a day present in the schedule and an event is returned outside of the range. My impression is the steps are this: - Call async get events(2024-02-11 09:00, 2024-02-18 08:00) - Call get date range(2024-02-11 09:00, 2024-
I don't think we should add CONF ALLOW at global homeassistant.const as it's only used here. Add CONF ALLOW locally, as CONF TITLE do. Done, thanks! You can even do this. Integration tests need to be updated Quentame Had a stab at a test in Hope this works?!
Can be a shorthand Can use device class translations. So if there is no name or translation key set it will use the name of the device class Could this use device class translations? So wait, the dev is now for example v40 level max . And we loop over every entity description to find the right description with the key? Why don't you make the sensor types a dict[str, OSOEnergySensorEntityDescription] ? And have the value of the dict be the key as well and then just lookup? Is this cached in some kind of way or are we requesting data 10 times when initializing? The device sensor data is cached. A configured ammount of time must pass before the update data() mekas a request to the server to update the data. If that time has not passed the cached data will be returned here. Please remove the fallback and add an options field to show the possible solutions. idem Entities should not have the unit in the name (and preferably not the (translation) key either) Why does one have the circle and the other unicode? What's a FFR? FFR is a special mode that responds to measurements of the frequency of the electrical grid and certain points of time. It turns off the heating elements of the water heater when the measured frequency drops below a treshold for a small amount of time to reduce the load on the grid and prevent accidents breakdowns on the electrical grid itself. I will add the full name to the translations - Fast Frequency Reserve Please also use sentence case (personal preference, rename osoenergy device to device, looks better ;) ) Please bump in a separate PR For a followup PR, would be nice if this class could move to entity.py I will do the change in the next PR. Let's name this value fn since it's a function Please better explain in the docstrings what these functions do and complete the type annotations; get local hour is missing return value type, convert profile to local is missing both return value type and parameter type. Please share a screenshot explanation of this sensor I don't think device is a great name here, all the sensors provide different measurements from the same boiler, right? I'd suggest to call it sensor data or sensor state or something like that. If you want to use the same name also in the water heater entity, maybe name it endpoint data or endpoint state . There's no need to set this to None since it's unconditionally set by OSOEnergy. init . Again, try to come up with a better name than device . With the addition of the sensor entity, device is no longer a good name, see the comments on sensor.py . Why are these removed?
Please don't make a breaking change instead: - disable the old entity by default - start deprecation period - create repair issue when the old entity is used in automations and scripts After the deprecation period, please remove in a follow-up the sensor Breaking change removed, just need to figure out how to work in the disabled by default to BinarySensorEntityDescription Ah yes, entity registry enabled default . I think I might not remove it, but just leave it disabled. As Joostlek points out it may still be useful for automation. From the strings.json it looks like you know all possible values of this sensor. Can we set the device class to SensorDeviceClass.ENUM and specify the options? Oh yes, forgot about Enum types. I'll do that. Done. Why is the instance check and lowering needed? Translation keys can only be lowercase. You can't run .lower() on a Sensor Value which can be an int. (Even though it never will be anything but one of the Enum values in this integration) Translation keys can only be lowercase. You can't run .lower() on a Sensor Value which can be an int. (Even though it never will be anything but one of the Enum values in this integration) When an int value is returned as value, it will raise an error as one of the options is expected. I would suggest refactoring the code so that we can avoid the instance check and only return string values. Ok it looks like translation keys are case insensitive, so I can remove the value fn all together. Please use pytest.mark.usefixtures("entity registry enabled by default") so you can also test disabled entities. Please revert it The options here do not match the keys defined in strings.json . Please ensure that both are the same. Translation keys are case insensitive and must be lower case, the options list is case sensitive, so these do match. Discussed this point internally and we came the the conclusion, that state strings should always be lowercase snake case. Snake case? does that mean I have to build a translation later from API strings to snake case strings, making them lower case isnt enough? Ive added a dictionary to convert from the API TitleCase to this new requirement for snake case Why are the device tracker snapshots changed? I know why, there was a bug which was fixed since this PR was raised. I'll get this removed. This has been removed now.
Commenting so it is not accidently merged, as we discussed without changes entity category doesn't work in this implementation. Changed PR to introduce script switch only. Rework will be done in a separate PR Entity category is working... why shouldn't we use the diagnostic category? ![obraz]( This is the main device Switch output and not a config entity Changed PR to introduce script switch only. Rework will be done in a separate PR Fixed API changed over time, fixed. If I remember correctly we agreed that these entities should be disabled by default. If the user removes the script, the entity for it will remain in the registry. I suggest removing orphaned entities: Good point, added After some rethinking, I suggest these entities use the config category. Changing the script state is part of the device configuration. Back to the original code then
Please remove these filters since the backing API does not support it. Good idea. Does not make sense if this service should return all possible routes Since the options are translated, it's probably not correct to sort the options here. Instead, set the SelectSelectorConfig.sort flag to True which makes frontend sort based on the translated options. Same comment for the other selectors. I think it would be more logical if this logic is moved to async get travel times These should be removed, right? These too should be removed?
Should we translate them? Currently, we have eu,na,as,ww But I don't know if there is one missing and Ecovacs is not sharing any information, therefore custom values are enabled We don't really do this anywhere else That's not true. abode and adguard is doing it to mention the first two Can't you use config validators for this? (I mean I saw you are implementing a nicer error message for those) The error messages from voluptuous are not translatable and only available in English. MartinHjelmare What's your opinion on it? Should I use the vol.Length validator or leave the custom check above? Doesn't provide something for this? Removed continent completely Why do we allow custom values. I don't expect a new continent to arise in the nearby future. (Or if you are going to create your own, let me know, I'm interested) The problem is that I have no way to identify all continents used by ecovacs as they use CNAME DNS entries, which can not queried to identify it. Previously, this field was a normal string to which users could add different continents as the above ones. We could also allow only the above ones, and if another continent is used, ask the user to create an issue. Removed continent completely Depends on the outcome below. If we leave the class variable support it must stay at it is Why do we actually do it this way? Some entities (which will be added in a follow-up) will pass the entity description as an init argument. Some other entities, like the vacuum, have set it as a class variable as it will not be dynamic. I can change if you want to pass it always as init argument Should we set attr available True when this happens? Not required as that is the default value ah, this explains something Shouldn't these be HomeAssistantErrors? Removing the continent requires no migration, as no stable release included the config flow of ecovacs This makes the argument hard to read. Can we use keyword arguments here? Why do we check the continent above if we pop it here before passing the user input to the user step? The yaml config has no constraints on the country and continent. After a quick analysis of the old library, it looked like there are the same requirements (alpha 2 code for country and a 2-letter country code), but ecovacs is not sharing any information and changed the API frequently in the past. The new library included a reversed-engineered map from country to continent (for example there exists no continent Africa in ecovacs and countries in Africa need to use the worldwide). As these reversed-engineered map can contain errors I will check above if the country is the same as specified in yaml. If yes we can omit it as it is not used anymore. Are you fine with it or should I change something? Why do we need these as properties instead of regular attributes? I copied the code from my custom component and as I'm coming from Java I'm used to creating getters. Will remove it I'd check if there's a flow started for the domain instead and what 
please move it to a separate services.py I'm afraid I am not as knowledgeable about the inner workings of HA as you are. Are you able to help out? I'm afraid I am not as knowledgeable about the inner workings of HA as you are. Are you able to help out? You can use the [Fastdotcom service]( L32) as an example (you can skip the coordinator part). Basically the idea is that service logic is separated from the rest, including registering. The TadoConnector, per entry, is stored in hass.data[DOMAIN][entry.entry id][DATA] . Just make sure to pass it through correctly to services.py . nothing special HA here, I just think it'll be easier to read and more future proof, if we move that function to a separate file (called services.py ) and add a separate async setup services method. Look [here]( L17-L19) for an example The TadoConnector, per entry, is stored in hass.data[DOMAIN][entry.entry id][DATA] . Just to verify my understanding; the entry.entry id is a reference to the Tado instance that was added to the config. There will in most cases be only one but can be many. How do I make sure that the service call is performed only on the Tado instance ( entry.entry id ) that it is meant for? by making the config entry another input parameter to the service. easyenergy also does this. Thanks! I'll have a look at easyenergy Just to verify my understanding; the entry.entry id is a reference to the Tado instance that was added to the config. There will in most cases be only one but can be many. How do I make sure that the service call is performed only on the Tado instance ( entry.entry id ) that it is meant for? That's correct. We need to be specific on the entry, whereas we can't have it if people have multiple Tado accounts linked, all meter readings will be send to one instance. Take [a look here]( L92), on how to pass through the entry id per instance. please move it to a separate services.py Please resolve conversation at your discretion. just resolve everything you consider done I wanted to leave that to you so that you would have the opportunity to validate that it was indeed resolved. it is no longer allowed to register services in async setup entry , but only in async setup This init file does not (yet) include an async setup method. Can this be resovled with a simple cut and paste, leaving the rest of the async setup entry as it was? no, I'm afraid it's not gonna be that easy... You should leave the rest of the initialization where it is, but only move the service init to async setup . The problem which you are gonna face is, that the entry is not available in there, so it's gonna be a bit more work to get the entry.data to init the tadoconnector . I'd suggest you take a look at the lametric or easyenergy components to see how they handle this. it is no longer allowed to register services in async setup entry , but only in async setup Please resolve conversation at your discretion. You're not asserting anything here. Meaning, effectively nothing is be
Add some test cases for the negative checks. Added a test case I could think of. Also, I noticed datetime.date.today() does not work in restricted scripts because import is not available (coincidentally I'd debugged that here: Is that an issue that should be triaged? I don't know if anyone is really using this integration. I think most people will use the pyscript custom component which is far more powerful. Well, this PR came about by someone on a Slack wondering why didn't work, so yeah, someone is using it! I don't think this requires a test since I (think I) mapped all of the operators; it's just here to avoid an ugly, confusing KeyError (and .get if not is faster than try: except KeyError: raise ).
Let's pull this out for now. Once we merge everything this can be a future improvement We should log an error and return False here since the Home Assistant code will not know what to do with this exception. Ideally we can remove this and never get here because the config flow should refuse to create the entry if its not the primary hub. that makes sense - should i remove this completely and move the check to the validate input in the config flow.py now? exactly Let's remove the number platform from this PR. I'd like to merge this version back into dev before adding new platforms i thought the whole point of the 'powerview 3 integration' was to get all features added then merge the feature branch into dev ? Why would i not just target the dev branch for these PR's otherwiese ? With the turns and merge issues, I think we may have lost sight of their original goal (or I did a poor job explaining it in the first place) I was working under the premise that the goal was merge in small digestible pieces into this branch (since the original PR was too large to properly review), test everything on the old models, and then start adding the v3 new platforms after it's merged to dev. If it would help to do a call to align on this, feel free to reach out on discord I think the only disconnect here was that the initial PR had to be large, because of the degree of change in the upstream API. Then i went and made a royal mess of the git history. If you take a look at the individual commits I made you will see there wasnt much changed here. The last PR was to bring the base functionality, this ones focus was to bring the number platform and should have only changed 3 files. But we also fixed the scene tests here I'll strip the number platform shortly, and then once merged to dev i will resubmit the PR etc It would be better to make a new named except like CannotConnect and let it be trapped below so we can give them a better error in the UI. Right now they would get a cannot connect error have added UnsupportedDevice to the code I think we want to trap this in async validate or error instead and change the error string returned so we can add it to strings.json Please move this block outside of the context manager since it is not expected to timeout it would be cleaner to do this check out side the try: block since we don't expect it to ever raise HUB EXCEPTIONS Please reverse conditionals and continue to avoid long indents We want to keep the continue pattern where possible to avoid creating long indent trees Please reverse conditionals and continue to avoid long indents this is effectively added back in by this change r1476621073 shade.has battery info() replaces this statement and returns the required based on the hub version If we ever have more it would be better to write these as constant dict lookups to reduce time complexity fixture DEVICE JSON FIXTURE[api version] We want to avoid branching inside tests as it makes them harder to maintain and troubleshoo
A much better option is to have CONF ADDRESS be either an int or an array, no need for an extra parameter. Please remember this needs to be copied for FAN MODE. Hi janiversen thanks for the review. With regards to the suggestion, I followed the same approach already implemented for the other parameters, in example [HVAC Mode]( write registers), target temp and [hvac on off]( write registers) In those cases, the address is an integer and using that option the user can force the system to use te modbus function write multiple registers (0x10) instead of the single (0x06). So I considered this approach as the "suggested one". Why we should change it only for fan mode? Because it simplifies the code, and that is the direction we are moving towards....of course not all of the old code is changed at this point in time. And if you look at e.g. the service set point, it does exactly that, can be called with an int or an array. I understand. Before to apply the change, please, consider that in the future you can remove all the options "write registers" for all except the target temperature, where the list will have a different sense.. (if you approve my PR, of course). This mean that to keep the "write registers" option for all, will keep all the configuration coherent, else, you'll have different meanings of the lists used in the configuration. Let me know "Coherent" is not an objective in itself, especially not if it implies expanding the code. Please do not forget, your change is currently not working if you want to use modes....you need to do exact the same for each mode...and that explodes the code. Basically all these "mode" parts (in different parts of climate) it something that needs to change to one uniform way of doing it, without X extra parameters. The change could very well be (for all): - allow int or list in base address. - if list contains 1 element, it will use write registers - if list contains the exact number of variants (in this case modes) use the correct int as address - if the entry in list is a list with 1 entry use write registers. This is not at all user friendly, but as noted earlier yaml is not user friendly....important here is that it is something that can be converted to a config flow, which will be a lot more user friendly. if list contains the exact number of variants (in this case modes) use the correct int as address if the entry in list is a list with 1 entry use write registers. I really appreciate the condivision of your vision and I imagine that this proposal will make really complex the code. I know that my opinion is not important, but I miss something. Why do you want to move the code there? I mean, if we consider the Fan Mode example, the only need is to have the CONF ADDRESS managed as int or list of one single int, because do you imagine that also the values will be expressed as list? What is the real use case that I miss? my bad, I took took the modes as separate registers, as you did earlier for target tempe
I'd put the default here instead so you can take it out below async services() enumerates and makes a copy of all the services it would be would be better to do an any expression with has service or check each one in a loop and remove Taking this a step further, would it be preferable to not even register services that aren't applicable to the hardware configuration? ie. If a salt chlorine generator is not configured, don't register the super chlorination services. The pool controller does nothing with a command that isn't applicable so as it stands now, all services are registered regardless. But if we're looping through and running checks for each service, I could expand that pattern to registration as well. If we don't have any pools that support the service, its better not to register it I also have in flight to reduce the overhead for fetching services by domain hass.services.async services for domain is now available Integration services should nowadays be registered in async setup regardless of config entry state. See example in fully kiosk integration. See this conversation for the reason: discussion r1433754113 We shouldn't remove services when unloading the integration. The services don't seem to be device specific but config entry specific. Use the config entry selector instead.
Please remove this Please remove empty entries Do we need to go down to microseconds ? I think so, it's good practice to not align on the second boundary to avoid stampedes. L100-L104
Use dict unpacking syntax Can we make a parameterized test out of it as this test tests the three different message formats Yes, I can refactor those tests. :heavy check mark: done Couldn't this be added as another parameterized option for test send message ? Unfortunately I haven't find a way to check it using matrix bot. handle multi room send.assert called once with(...) because the function call content (example: tmpeno21kcu ) is a random-generated string: No need to prefix them with test Please adopt the values Done Can we add type hints for it? Are all arguments required? :heavy check mark: add type hints :heavy check mark: remove unused arguments Is test name only used for naming the test? At least it looks like it... Please use the parameter ids on pytest.mark.parametrize( instead Yes. I used the test name var only to see in the output which test is running. I can rename it to ids instead, if no better way to do it. done I meant the following in discussion r1469629632 List of? Same question here Does each test need these lines? If yes, can we make a fixture or common function for it? We should check here also if the matrix bot was called correctly Why can't this test be part of the above one?
Why do we expect a non parseable response is an error? What else should it be if I cannot parse the response json from the api server? I mean, Imagine the service returning a 503 because someone messed up a server config. This would be something that could be fixed in an hour, thus I think retrying is something we should do. Ok, I can change it so the JSONParse errors are rather retried instead of aborted. So we are returning a list of lists? Yes, you can have multiple shopping lists (first list) with a list of items (second list). Please remove the empty fields ok We don't want to switch contexts a lot, can we maybe make an inline function we run in the executor? You mean group both together? Yes: Why don't we just pass in the list? Because I thought it might be good to know where the list comes from. But on the other hand, the user can do that himself if he needs it. No I mean, can't we pass in the list to the entity instead of iterating over all lists in the entity and setting values outside of the object itself Ahh, I get it. Yes we should be able to do so. Can be removed, is the default for a coordinator entity Can be set outside of the constructor true On naming. I think you can add some devices (with type service). Maybe checkout Our groceries to check how they did it and if you like that approach (not sure what your future plans are). This way you can just set the attr name to the list name. Not sure what you mean by "add some devices". I don't see any devices in ourgroceries ? Why do we do this? To get the correct shopping list from the coordinator, which loads the data for all bring lists at once. Since this function is this little, have you considered just using a property? It saves you the async added to hass and handle coordinator update. Can't you maybe ask the co rdinator to refresh instead? You mean await self.coordinator.async update ha state(force refresh True) ? no await self.coordinator.async refresh() or something like that Ok I will see if possible
I think we should make our translation placeholder descriptive for the translator. Our translators don't have to be developers (or very technical) to translate. "Disk free {argument}" - I am guessing the location should be here, but I only know this since I saw the issues and the entities system monitor creates "IPv4 address {argument}" - is argument an IP address? An internet adapter? That's a bit the point. It's different for different sensors so how would one make it more descriptive? Name it {device} ? Or {interface} ? I constructed a solution so it puts a relevant placeholder WDYT?
If a state is unknown, we need to return None .
Rationale would be that you can start a single hose timer as well, and not only multiple at once. good point, will update. This was needed to fix mypy complaints you can use But there is usually a better resolution to refactor Do you think this still need to be changed to something else? generic-properties We generally don't add new extra state attributes anymore and create them as separate sensors on the same device Entities that generate a significant amount of state changes can quickly increase the size of the database when the extra state attributes also change frequently. Minimize the number of extra state attributes for these entities by removing non-critical attributes or creating additional sensor entities. Before you get too carried away I totally screwed up my commit history and I need to push another one to get back to where it was. Ok, so all of these should go? I'd drop them from this PR and add them as separate sensors in a followup PR if they are needed Since this has to do polling it would be better to use the DataUpdateCoordinator here coordinated-single-api-poll-for-data-for-all-entities Yep that was in the latest version that I just broke, stand by This looks like something needs to be refactored if we need an ignore here Probably faster to len each and add that together (or itertools chain) Maybe start enough, It's also possible they might want to target three different hose timers I wonder if we don't need this if they're implemented as valve entities As opposed to switch entities? I was trying to come up with a name to differentiate from the start multiple zone service, but single isn't exactly right either. Maybe just "start watering" since it can be used for timers and zones? We already have stop, pause and resume watering, and the start multiple zones schedule service is fairly self explanatory from the title. It also can start schedules if we make the duration optional, which would probably be a good idea, then it works on all the switch types. Sounds good to me Missed this, its not needed, will remove in next commit. Line 568 that is It would be nice if data was a named tuple in the lib as it would be backward compat and we wouldn't have the [1] everywhere I ll have a look a that, but I think this is the only place it s being used. Let me know if that s not what you had in mind. sorry I wasn't clear. I was thinking the change should be in library code as we could make all the [1] a lot easier to understand whats going on Ah I see. Is that something we could look into in a future PR? but it would be good to add typing on the Callable as well This could be base stations.extend with a generator expression
The coordinator will have a ConfigEntry in self.config entry as soon as you call super.init() so no need to pass it can we move that call inside the coordinator? CONF MAC can be taken from homeassistant.const move up to get the self.config entry metioned earlier can't we just add a custom key sensor type here and avoid all the special arrays and elif: s? (You will need to add kw only True to the dataclass ) use snapshot testing here to be able to test all your sensors and loop over an array of all sensors (I called it SENSORS in the below example) Why do we need this unacceptable-sources-for-a-unique-id Remove commented out code Timeout is something that should be part of the library preferably Last time you said you were looking into making different devices for each meter, what's up with that I added a 'sensor type' parameter to distinguish the different types of devices, and now the different types of data in the panel are displayed in their respective forms. Can we split them on a physical device instead of type? I hope to be able to split by type, because I found in the local test that after adding new devices, the data of the sensor is classified and displayed on the homepage, and the default display effect looks very good. No. You told me that every channel is their own measuring point and its own physical device. Thus one channel is one device in HA. This also allows the user to rename the device to maybe where they placed the sensor to give it more context. Can I change it this way? The identifiers are bound to the key of the sensor, which is different for each sensor, so that each entity will be a device. No. This is how our devices work as you can read in our dev docs. This will make this PR way smaller, consistent with the rest of the integrations and easier to manage Can you give me some hints on how to implement this in the code? If i understand correctly you have the main device, and sub devices. Give them all a different identifier and for the sub devices make sure you add the via device and set it to the main device. I think checking the Dev docs on this is the best way. And if you have trouble, let me know and I can think of an example integration for your problem, can't think of any now Please use CONF HOST (from homeassistant.const) where have the channels gone? Can you move these checks to the library?
Looks like travel count needs a translation?
Small suggestion, but if you restructure the if else logic a big then you don't have to check current temperature is not None and them in the elif current temperature is None. Thanks dcmeglio for the suggestion. I've reordered the logic to clean it up.
So what I was wondering, I think we can make these snake case and provide translations for them Where can I find examples of options translations? L319-L333 in combination with L319-L333 L319-L333 in combination with L319-L333 thanks, i got it I think we can be more descriptive in the description. "Repeat times" - "The amount of times the text will be repeated." Can home store be None? Can we also make these ones more descriptive? Good that you added this, I thought it was about the tone of voice :) We want integration services to be registered in async setup instead. Otherwise the service can be missing if the config entry isn't loaded, without a good explanation to the user. We want to raise an exception with a good message instead, if that's the case, from the service call. Example: L74-L79 We can get the config entry id from the device entry. We don't need model and manufacturer filters if we set integration filter. model can filter out most devices as this service only works with SpeakerHub devices Ok. Just remove manufacturer then. This blank line makes it confusing to read the service fields.
Please add the battery sensor in a second PR after doing a PR to bump the library
please put the coordinator to a separate file what do you use that for? please do a await bzucoordinator.async config entry first refresh() before assigning it to hass.data. this way we always have working components stored. only have code in the try: that can throw exceptions use BinarySensorEntityDescription instead. don't do IO in properties, the coordiantor should have updated this already what are you trying to achieve here? what are you trying to achieve here? i though of it as a way to configure the integration using menus instead of forms, the async step optionN handles the selection, is there a more efficient way of doing it? heres how it is running right now ![image]( Can you maybe give some more context on what this code is doing and what kind of purpose it serves? What kind of devices are you connecting with this integration? Can you maybe give some more context on what this code is doing and what kind of purpose it serves? What kind of devices are you connecting with this integration? to get data from the API and register a new entity on HA the integration needs 4 informations, login data, Device Chip Id, Device port and Sensor on that port, so the config flow follow the steps: Ask for Login data, authenticate it through the API, gets device chipids associated with that login data, show them in menu form for the user to select, stores the selected option in a configflow variable by clicking on one of the optionN menuoption, lists the available ports in that device (usually 4) and stores the selected port, then gets from the API the sensors on that DeviceChipid and that Port, lists them and stores it the same way as the Device and Port. Why can't we register all ports automatically? Why can't we register all ports automatically? When developing i did not like how it felt when displaying every available sensor from a device at once, selecting the specific port and listing its sensors was more efficient and cleaner. Can you categorize them? Maybe disable the less used interesting ones by default? Can you categorize them? Maybe disable the less used interesting ones by default? i am working on registering every sensor on a port of a device, so, instead of selecting one sensor of one port of a device, you select one port of a device and every sensor gets registered, do you think this approach would make it better? just use a class attribute to store those instead of writing them to hass.data the coordinator will automatically have a self.config entry after super.init() . If you extract those in the coordinator you don't need to pass anything here, making your clean cleaner appears unused I really don't like this. The first part can run into an endless loop. The second part just repeats the part that just ran into an error. Rather throw a UpdateFailed error and just wait until the coordinator retries. remove empty keys if you're adding nothing to this, you can just use the normal SensorEntityDescription instead second coordinator? why can'
Please revert the changes in this file Yep, should have exclude it, my bad Can we bump in a separate PR? I check manifest history and there's multiple PR on functions that include the bump. Hence I choose the same. Can we add this in a separate PR? I guess so, but was trying to make sure all would be avaialble for same functionality when released Removed from this PR, will post as seperate PR This allows you to remove the default Also, We now also have translation placeholders, maybe we can use that to avoid having 6 entities per phase 3 18 entities. We could just have 6 in which we replace stuff. What do you think? Removed default and implemented translation placeholder.
I think you can use self. attr extra state attributes - this is predefined in a superclass and is specifically made for defining the extra state attributes. Maybe this didn't exist when I originally implemented this integration. Since feed entry.properties could essentially contain anything (whatever the feed contains), it might be a good idea check what happens if the properties contain essential keys used by this integration, like for example latitude , longitude , source . Honestly, I'm not sure how state attributes and extra state attributes behave if they both define the same key. And when using self. attr extra state attributes you should be able remove this method altogether. Is there a reason to remove the external ID? I originally chose this because it's the only way to uniquely identify a geolocation entity from a feed. I am wondering if we should add some unit tests for this? Depending on how the feed entry's properties look like (i.e. what JSON structure it contains), this may or may not have undesirable side-effects. For example: vs. Why is the external ID deleted in the tests? Good catch - that should be added back now.
good catch here, seemed to have slipped through the cracks Was this meant to be here or was it meant to be an alternative version of the text in alternative speed turn off ? I would recommend you pass the result of client.get alternative speed status in setup client and feed that to the entity setup. The way I did it was to put this in the coordinator. And have these as my entity description That way the initial value is correct. Ok I see, I'll update this ! Thank you for the feedback . Sorry for the delay, lot of personal stuff lately. Updated with the change you suggested, can you take a look ? LGTM, but the qbittorrent lib should probably be changed unless the author decides to wake up. Should we make this a defined data structure to plan for more data being passed down in the future? Along with it being clearer what the bool is currently for. I'm not opposed to leaving as a tuple for now, just want to put the idea out there if you want to swap it to a defined data structure Sound more interesting for future additions, so creating a dataclass in there ? Yeah, instead of using a tuple. Probably actually worth checking if there a good practice that other integrations use? I would check but only have my phone with me I'll check this, I will maybe wait for the change of lib so we can maybe use the lib type in this : 1: Why is this changed? This was a key error, the correct key is current status used [here]( L74) Oh, I see. Then please split this change out to a separate PR. Ok NP, I'll remove this form this PR Please open a PR with this fix, it seems to be needed to have the right entity name. Why are we mixing quoted and non-quoted class names in the type hints? Import annotations to make sure type annotations work as expected, including forward references. How come the device is not named? He get is name from DeviceInfo with translation key I don't get it, there are no device name translations in homeassistant components qbittorrent strings.json , and you don't set the device name either here or in the existing sensor entity. Sorry, it's via the entity description that have the translation key [here]( L33) and you can find it in the string file [here]( L53), we use the same method for the sensors [here]( L99) refering to [this]( L48) OK, so the device will be named by the config entry, and the entity name is translated. That works
Not sure if this is the right function, but shouldn't we use something like this instead? That works equally well. Thanks.
Is this required? Yes, pylint will fail without it.
Const indicates its a value, but text indicates its a list of registers...one of those is wrong. janiversen no problem, I'll change also the const name as already done for the text. For each register, you need to secure it is not used in any other configuration part (as done e.g. with sensors). janiversen This specific routine avoids registers overlapping inside the climate. The testing routine is called 3 times with a different register overlapping, so I have tested hvac mode register, hvac on off and hvac fan mode. The only register is admitted to overlap is the target temp register, the default one. All options must be tested, also a test with duplicate options, and tests with duplicate addresses. This integration have 100 test coverage, so you also need to secure that all lines are tested. Thanks janiversen for the review. The code has the same coverage of the whole previous code. (100 ) Duplicated registers into the map cannot exist because I used a set. I try to answer to your requests point by point. Thanks again. This looks like a constant, so why have an instance in each object....at the very least it should be a class variable. This is better done in the validator, always convert the parameter to an array...then we have less to do at runtime. If it is always an array, then this method can go away. Remark, I just make a short review, and in principle it looks good, but there are a couple of changes which affect most of the code. It is prepared in the validator so the int() should not be needed. In general the function should be dissolved and the array indexing made directly, Hi janiversen, this morning I waked up having the idea to restore the try except block, but I see that you prefer to remove completely the routine. Are you confident that we can delete the whole defensive approach, I mean the try except and the cast? you should know that it's your PR. But you are defending against yourself? Combine with next line. is the list() really needed ? its just confusing. [bad idea - removed the comment] Why is it a bad idea not to do list(var) on a var that is already a list()....you have removed the int part earlier. Yes, I have already optimized that routine and the other check about overlapping addresses.. I'm trying to understand your earlier comment about "the init" before to commit the new code.. But, I'm not so good at puzzles.. :) It's not a puzzle ! it's quite obvious init contains voluptuous definitions ....you actually already added a validator, so you know it. Yes, but the puzzle is not the init itself, but how to change the execution order of the validation calls.. Debugger has been a friend.. The duplicate validator run last, so the value if present is a list. janiversen When I tested this piece of code on a real env, I obtained an error caused by the iteration over an int, so it seems to me that it run before the validation. Am I wrong? Well your validator changes the config, like some of the others, so it is important it runs
Does it not work if you add default values to these? The default values have to be set in async get triggers , otherwise the resulting yaml looks like this (even with default values provided in async get trigger capabilities ). Even worse, if the default True , this will be applied, but all the switches in UI are "off" so it doesn't represent what will be created at all. The current implementation results in correct UI switches (on by default) and this yaml I tried using a ConstantSelector too, but this doesn't show a checkbox (like shown in constant-selector) so it isn't de-selectable. Why do we need allow None here? See the PR description. There is also a blueprint example for this. If destination is explicitly set to None, the trigger is a no-op. This can be used in blueprints to provide inputs for addresses that are optional. With an input with default: null the trigger will never fire if no address is provided. could supersede this. OK If we could find a decision about the linked PR, this None handling option could be removed completely without further (breaking)changes or deprecations to this trigger to accomplish the same goal for blueprints. Instead of this, can trigger.py export something like: Then we can include it with TELEGRAM TRIGGER OPTIONS both here and in TELEGRAM TRIGGER SCHEMA and avoid the risk of changing in one place and forgetting to update the other. This would be possible for now. I was planning to maybe change the extra fields to selectors to be able to add descriptions once is finished. I think selectors would not be valid for the trigger.py schema, would they? I guess not, but we should not worry about things which may happen in the future now IMHO.
Not needed Removed Only have stuff in the try block if it can raise Updated Updated to match the suggestion Modified the used key from invalid api key to invalid auth in all relevant spots Why do we catch KeyError here? This was left over from a case where the returned data structure might not contain the key "devices", but this should not be possible anyway, so I have removed the KeyError handling. Updated to cannot connect in all relevant places. Removed this section Please import as vol Updated as suggested Updated as suggested - this seems to be in use in various other places in the codebase, but it definitely still works as intended with this change. I'd suggest moving this to a coordinator Updated the setup code to use a coordinator instead. This definitely seems to speed up data availability on startup. If we only store one thing, no need for a dict Updated this to only hold the new coordinator, without a dict. Please look into SensorEntityDescription s, they will make this a lot easier Updated to use a sequence of SensorEntityDescription , also bringing in the suggested precision through there per your last comment. No need for a custom entity id here New integration should use has entity name True . Read more on has entity name-true-mandatory-for-new-integrations Can we type this? Can be a shorthand attribute Has entity name will make life way better Please don't round values, prefer to set suggested precision
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
This means that if someone has upgraded and configured a switch as x with invert True and then downgrades it will change the option for that entry to invert False hence changing how that entity works (even if the user then upgrade again). It should probably only set this option if it's not already there? Fixed I'd think this should be an optional item with a default. Fixed I'd put the default as the else case and the special case as the if case. Fixed Isn't it possible to access the item by key in the schema? Then I'd just do that in the test instead of making this function that is only used once. Note that it's the key which has the suggestion, not the item , hence the sing-and-dance number to first find the key and then make sure the key has a description attribute with a suggested value I'd instead write this directly in the test: You asked: Isn't it possible to access the item by key in the schema That's not possible, but sure, the used-once-method can of course be inlined regardless of that I'd invert this in the service calls too.
just an idea: what do you think about using an IntEnum instead? Most other integrations I see just use int dicts, so this sticks with the status quo. Why is the name not translated? I just copied the the schedulepart VenstarSensorEntityDescription above and modified it for this. How would I make this a translatable string? You should set the translation key (and optionally also the translation placeholders ) of the entity description and update strings.json . For local testing, you need to run python3 -m script.translations develop --all for the (English) name to work. I already have translation key on this entity description and have the translations in strings.json . Is there anything else I need to do? The translations in strings.json only translate the states, there's no translation of the name. I don't think this works, I think you also need to: - Update VenstarSensorEntityDescription to allow name fn to be either None or a function returning a str - Update VenstarSensor. init like this: Let's sort the data
This too needs the exclusive marker This property is not needed, request data is accessed directly by async update .
The preferred interface for permitting with install codes is currently just permit with link key , with the link key derived within the caller. I'm hoping to drop support for permit with key at some point. Perhaps it would be simpler to rename this method def qr to link key(qr code: str) - tuple[zigpy.types.EUI64, zigpy.types.KeyData] and have the Bosch QR fall through as it does now, while returning a link key [derived from the install code]( L243-L253) in all other cases? That way, this is the only spot it needs to be special cased. This should also clean up the websocket API too, as we would only ever need to call permit with link key . Very good point! I updated this PR do replace permit with key by permit with link key . Now qr to install code and convert install code will supply directly KeyData.
Please only have stuff in the try block that can raise Config flow tests should finish in either Create entry and abort to test they are able to complete If the authentication is incorrect, it will raise ConfigEntryNotReady . Can we also catch the AuthError and return False or raise ConfigEntryError to stop retrying? Why are we doing this instead of just testing that the flow succeeds? Success flows are above this.
This test is unclear to me for several reasons: 1) I expect an arrange act assert structure for each test. This test asserts in between, it asserts on many unrelated things and it ends with an action that is never asserted upon. 2) I would also expect a test which checks that a default profile name also shows up nicely This makes sense, but I think it should be in a different PR? Shall i add that to the description of the PR? If you want to, i can remove the code changes. Please move this and the removed check for preset mode to a separate PR about improvin error handling in homematicip cloud Why is this check removed? Because i was not able to test it. This case is already handled by home assistant. If a set preset mode is called with an unavilable preset mode, there is a ServiceValidationError homeassistant.exceptions.ServiceValidationError: The preset mode dry is not a valid preset mode: boost, eco, STD, Winter Please add a type annotation to profile Done Please add a docstring explaining what the function does Done Nice
Turn this into a guard clause. if not no states error.area: return . Turn the other if also into a return early. I refactored the top guard clause to exit early if there isn't an area as well as at least one domain device class. Otherwise, this suggestion could fail on next(iter(no states error.domains))
Just a thought, let me know what you think of it. Now we are changing naming, can we also look at how the names look? Can we make it more descriptive: NAS xxx Network up (eth0) - NAS xxx eth0 up NAS xxx Temperature (drive 1) - NAS xxx drive 1 temperature I tried not to change the names but leave them as they've been before: img width "238" alt "Bildschirmfoto 2024-01-05 um 11 57 27" src "" I mean that's also fine, but now we are changing names, might as well review them. I also know disforw tried implementing translations, so maybe he also has an opinion. I was following that placeholder PR closely and saw it was merged yesterday, you guys beat me to it! joostlek if you're looking for a unit name or identifier, that's already being brought over using the device name. ![Screenshot 20240105-071535]( I know, but my question was more of the stuff behind it. Do we want to change that to make it more fluent or do we keep it like this
Remove this code and set the expected result as a test parameter instead. We can predict with the expected result will be. Please avoid branching in the tests. Set the expected result as a parameter instead. output is never None . I'd create a constant at the module level for a datetime instead. We aren't interested specifically in the start of local day datetime or using the today at template function. We want to test the as datetime template function. Then it will be easier to set a parameter for the expected result. I was struggling with this one. I want to test with a datetime object as input (so not a datetime string). But if create a datetime object, and use it as input, it will use the python representation, so something like datetime.datetime(2024, 1, 1, 0, 0, 0) and then the tests will throw an error that it gets an integer where a comma is expected. That's why I create a datetime object in the template itself. I did update the test. I fixed the date to 1st of January 2024 so the output can be expected. I could also use as datetime instead of today at but then I would be using the function I want to test in the test itself. today at and as datetime are the only options I could think of which give predictable output. now() will change while the test is ongoing. example with a datetime.datetime as input: Changed it to use as datetime for the input Why don't we just use the time string directly as input? The resulting template can simply be. The docstring for as datetime reads: I want to add support for datetime.datetime and datetime.date as input. To do that, they are parsed to a string. An annoyance of the current filter function is that it throws an error if you use it on a datetime.datetime. Now it returns the datetime.datetime back, it avoids the need to check on the type before you use as datetime This was even worse when there was no datetime test yet, you had to do someting as: jinja { set dt [now() now().isoformat] random } { if dt is not iterable and not dt is number } {{ as datetime(dt) } { else } {{ dt }} { endif } I have updated the docstring. Ok. I suggest splitting this PR into three PRs, one per description bullet. I didn't notice that we're changing three things. Well, the to accept datetime objects and that it will no longer error on other types as list and mapping are both the result of parsing the value to a string before using it in dt util.parse datetime() . So I can't really split that out. I can remove the default parameter out of this PR, and create a separate PR for that. Changed the scope to only add support for the default parameter To avoid breaking changes, a string input which can't be parsed to a datetime object returns None if no default is provided. In case a default is provided it will that for strings which can't be parsed to datetime. Please update the docstring. Noticed that, was awaiting the tests to complete so I was sure there wasn't something wrong missed by the local tests :) Please extend the comm
Feels a bit weird for the comment about having both to be on the branch where we don't have the colour temp? Yeah its probably superfluous. I'll take out the second part f077024710f8707cca791eb63a6a40c4ee6f5622 Is it valid for the user to call us with a temp and h s? What should happen in that case? Because if they do that on a bulb with no temp then this will throw away their h s in favour of ours? I suspect in practice won't matter much, but wanted to check. Its not valid to call with both, only one or the other 8983f397a0b1006f874315bce6f36d525a0a7dee I think its actually possible for them to send both but one has to win 9c7dc85053c8ea6d90fdd500e3388b8ae445dfb6 I tweaked it a bit more. I'm not sure this would ever happen on purpose though (of course someone will do it though)
![image]( I don't know what you're talking about
Can this be a constant? I think in this case you can pass update on add to the async add entities . This will execute async update before its added to the entities. This way you don't have to pass in the presets. The only thing you would have to add in async update is if self. attr current option is None: self. attr current option self. attr options[0] Are you sure about this? In the previous PR I was requested to use a tuple. This gives an error in the pre-commit hook on line 51 and 57 assigning str to None . ah check, ignorethen It doesn't look like async update is implemented so I think you need to write state instead. Are you sure? It s there on line 45. Wow. not sure how I missed that one, must have been looking at the wrong file when I switched PRs. Sorry about that.
Currently, it would allow the same device with different usernames. updated the code The configuration url creates a "Visit" link on the device page to make it easy for users to go to the devices' page, so it should be something like f"https: {coordinator.api.host}" or however the format of the URL to the device looks like. Currently, when you would try to add a second device, it would overwrite the coordinator of the first device. Would be good to put this as a constant in conftest.py , then you can reference it instead of repeating. is this auto generated code? i dont see it in my local branch or vscode and i didn't write it This is part of the tests you wrote. This should be enough to make it work. it was throwing erorrs with this change. not sure if i'm missing something in the code thats causing the failure AttributeError: 'NoneType' object has no attribute 'get' so i reverted it to return self.coordinator.data[self.entity description.key] or reverted it to if self.coordinator.data: return self.coordinator.data[self.entity description.key] there appears to be some condition in startup where self.coordinator.data is None so i guess the if statement is catching that i've updated it more after testing. not sure if i'm resolving this the correct way Regarding to further below in the file. Why are we talking about a speed test? Does this integration run a speed test? Please move the line(s) that can't raise up outside the try...except block. How do we know that it's a timeout? We're just catching the general client error. I'd just say "Failed to connect to".
Why is an update service needed? Can we not use [ homeassistant.update entity ]( service-homeassistantupdate entity) instead? The coordinator has builtin support for it Service removed and homeassistant.update entity service added to tests You were too fast :) Instead of removing we should deprecate the service for six releases and create a repair issue. So users have time to move to the other service. The best would be to deprecate the service in a follow-up so we keep this PR small. Sorry for the inconvenience. I wanted to ask why we need this update service. Hi, I re-instated and deprecated the service although I just realised you'd suggested to do the deprecation in a different PR. If it's a big issue I can pull it out but at the moment it's just a test case and an issue entry so hopefully not too big for this PR. Ok deprecation is now in draft PR This comment should be fully addressed. So we do it only once instead for each device Done Done Can we use a [TaskGroup]( task-groups) for both api calls instead? Done Updated as per suggestion Updated as per suggestion Should not be needed Removed Please remove any commented out code Done Why is the parent function not called? The parent function updates the device I think it was like that before there was a null check in the parent but it's there now so I've updated it to call super() Can we use here maybe an instance check? Replaced with an instance check and also in the light.py where there was a similar check. log msg is unsued. Is the test missing something? Ah yes, thanks so much. The log message check is now added. Why aren't we calling async config entry first refresh() on this coordinator? We should call it for each coordinator I think it was because it refreshes every 5 seconds I'd decided not to, but I now see there's extra logic in the async config entry first refresh . I've updated it to call that and it all works ok.
Can we move this to entity.py ? Can we give this Coordinator a better name? The config entry is set to self.config entry after the coordinator init It would require you to pick a better name tho Why do we do this? If I read correctly, we do this to sync the device with the config entry title. In that case, you can just remove the name property from device info and it will automatically use the config entry name I want to sync my modified name on the front page, having removed unnecessary code. We can just say "Unsupported device", no need for the rest I found that 'async abort' could not be used to terminate the user's process of adding a device.I'm a little confused. What is this timeout exactly? This is the timeout period used for device communication.If the device does not return data within this timeout period, an exception will be thrown. Only helpers are allowed to set a custom name. We should set the name to something the user can recognize You can use config entry.async on unload(......) to pass in functions it should execute when it unloads. I think you can use it at some places That's cool This change would make it enough to have the device have the config entry name I think we can move this to the entity Why do we do this? We plan to include other types of devices, such as lights, which have different data acquisition functions. What is the context? Please move this to the base entity DRY :) None of these strings are currently used This can be a shorthand attribute created in the constructor attr device info DeviceInfo(.. device-properties - Checkout connections and search the code for dr.CONNECTION NETWORK MAC to find an example
The GenericCamera isn't written or meant to be used as a helper for other integrations. If we want to allow that it needs to be refactored first to have a proper interface with keyword only arguments instead of passing a dict with config items. The class also needs to be exported from the generic package via all so it's clear that other integrations can import it. We did the same changes for MjpegCamera earlier. I'll check with the core team of we think it's good to be able to reuse the generic camera. Okay. We can take a look at what was done with MjpegCamera and try to make a PR to see what that looks like for GenericCamera . The conclusion from the core team is it's ok to use the generic camera integration but the camera class should be refactored or split so that it gets an interface that other integrations can use, per my comment above.
Misses await hass.data.[DOMAIN][entry.entry id].async config entry first refresh() , this way you have fresh data when setting up the entities No need to mark this as callback , as it is already async. callback is used on sync functions to mark them as safe to run in the event loop No need for this, if you call async config entry first refresh() in init .py Not needed when you use the native value property function below. No need for setdefault here Why not make use of the native value property function? Besides, I would move the if to async setup entry and just setup entities if the description key is in the coordinator data. This way you wont end up with unavailable entities. Also, the CoordinatorEntity takes care of attr available if a update fails Yes, you are right, thanks Please patch the package where used and not globally. I don't quite understand what you mean with "where used and not globally". It is needed for the async configure because of the validation. Sorry for not be specific here, hope the code explains it :) Ah, okay, I didn't know that you can patch functions on the place where they are imported :sweat smile: Same Same Config flow tests should end with ABORT or CREATE ENTRY , this way we can check that the config flow can recover from a error We do not want to collect names, you could use for example the host as title for the config entry. Not needed, this is handled by the core To be specific on this, I'm talking about the issue tracker :) This way you won't end up with entities that have no data. It is missing the mandatory attr has entity name ( has entity name-true-mandatory-for-new-integrations) and thus you could make use of the translation key in the entity descriptions. Shouldn't this be the coordinator? The question would be, how should I verify the user input? Currently I create a WebminInstance and try to connect to the device. Another option would be the create the coordinator and go through it. This is the setup of the integration itself, not the config flow. You want to patch the update function called by the coordinator, called in async update data . Not needed, you already test this with the fixture Idk if we are allowed to this, but probably this ok, as there is no other way
We don't want these measurements as state attributes. Please move them to separate sensor entities. ap mac is already a state attribute. from a templating perspective using attributes is much cleaner than separate sensors. Consider the following macro: { macro track device(entity id) } { - if is state(entity id, 'home') - } { - set ap mac state attr(entity id, 'ap mac') - } { - set signal state attr(entity id, 'signal') int - } ... { endif } { endmacro } a single device tracker entity gets passed in, then based on connected ap and signal strength macro can work out what room the device is located in. was hoping this would be simple enough to add signal and rssi attirbutes to the existing entity, but if not I can live with just patching my local installation. Please close the PR if you don't intend to address the requested changes. Thanks!
Why is this a template instead of a fixed string? Can you give some example of where it's useful to dynamically change the code format? This seemed to be the most straightforward way to support "require no code at all to lock, but a certain code to unlock". Or a well-known short code to lock, but a long (possibly dynamic) one to unlock. From a system design perspective, if so desired it is always possible to go to a "secure" state (locked) and you need knowledge to go to an "insecure" (unlocked) state. Or have it the other way around if the meaning of "secure" and "insecure" is swapped in a user's context. This works neatly with the frontend without introducing new attributes like [Template Alarm's code arm required]( code arm required). OK I see. That makes the PR work around limitations in the lock entity IMHO, something which is not wanted. Please replace the code format template with a fixed code format and hit the "Ready for review"-button when done. Naturally, I beg to differ I think this makes template locks quite versatile in their application. What is the actual issue here? There are other examples where the current code format for a lock is computed on the fly inside the method, for instance in the implementation of matter locks: L43-L60 Here the return value, at least without forward tracing the code, could change during operation, which is exactly what can happen with a template for lock code formats as well. My conclusion is that there is no actual limitation in the lock entity and thus code formats can be dynamic without any issues. Can you elaborate? (Marking this PR as Ready for review again in order to make this comment visible) Right, the matter implementation computes the code format, but it seems clear from the code the intention is to do so based on properties of the remote lock device, not based on the state of the lock. Is the main driver of your PR to implement support for dynamic code formats? The long story is that I basically wanted to a) virtually secure certain switches complex setups and b) have something similar to a switch that properly supports in-between-states. Meaning something complex is turned on (which I don't want to happen by accident and not necessarily by anyone walking through our hallway), and while this is turning on, which can take quite some time, the UI controls display an intermediate state (like the lock that is "unlocking" and then is "unlocked"). The opposite is not true, so while I whish the turning on to be secured, turning off can happen anytime without securing it. That drove me to template locks, which currently don't support codes at all, and to make this available and "templateable." As far as I see it, the main question is: does any existing code rely on the (undocumented, AFAIK) fact that a code format property of a lock never changes? I guess the answer is no, because there are places where this can obviously occur, Matter being one example. If no one relies on constant code format, w
There's no need to add these state attributes, it's enough to add the sensors.
Schouldn't we poll for the state of the switch every x minutes? Now if someone changes the value in the goodwe app SEMS app, it will never be updated in HomeAssistant untill you restart the integration.... I used the same logic as for grid export limit. these can only be changed via the PV master app (and maybe another app for different inverters), but these are not accessible in the SEMS portal (as of my knowledge). I will implement the async update starkillerOG Actually, I probably wouldn't poll (just) the switch state. There are already other "settings" (not sensors) managed by the HA (like DoD, export limit) and those are so far NOT polled from inverter. The approach was simple - one should manage the inverter either by HA or by its mobile app. If we add this polling synchronization just here, it would be confusing why something is and something is not synchronized. So I suggest to remove the polling from here for now and if we really intend to implement it, then we should do it for all settings, not just switch ... The proper thing in my opinion would then be to create a dataupdatecoordinator and start polling those settings at a low poll interval (once every hour or so) to at least keep it in sync. I think it is better to read back the value from the inverter instead of just assuming it has been set correctly. Use: await inverter.read setting(description.key) or even better request it through the update function I think we should implement or the update coordinator. will do See above So kw only True shoul be there too? added, thanks The "Number" is most likely copy paste mistake, right ? oh, I had no idea :) that is good to know, thanks :) I will close this PR and compare my changes with the beta repo
Other components should not directly use these. As a matter of fact, we shouldn't be crossing mixing components. Can you provide a concrete use case where this is used? .. Frenck Sure. Right now, I want to use a schedule helper to manage the schedule for my [Power Pet Door]( which is an integration I have written. For now, I have created a [Schedule entity]( L215) - which can read the current schedule from the power pet door, and update it on the device if I set one. HOWEVER, while this does create an entity that shows up in the helper list, because it's not actually stored in the backing store, the UI associated with Schedules (which uses websockets) can't edit it. There is no way for me to actually edit my schedule via. the UI of HA. The Schedule UI entity is actually perfect for my needs, it's clean, simple, and has a weekly schedule. I would LOVE to re-use the schedule component. HOWEVER, in order to re-use the Schedule component entity (and it's UI), I need to be able to: 1. Listen for changes to the schedule entity, and use that to send an update to the Power Pet Door device. 2. When I read the schedule from the power pet door device, I need to be able to update replace the schedule in the Schedule entity (which has to update the backing store), so that the UI via. websockets can see the updates and render them if I click on the entity. The only way to do this right now would be some REALLY kludgy work trying to invoke the websockets API directly from my component, etc. Or essentially copy paste the schedule UI stuff and create my own websockets API (which is unnecessary and something I don't want to maintain). The solution in this PR, while not perfect, allows me to re-write my custom schedule entity to use a standard schedule entity, then listen for changes on it, or invoke the update directly to the storage, which achieves my intended goal. If Schedule was a 'first class' entity, like Switch, or Cover, with the associated UI changes to allow for editing a schedule (ie. the UI that exists for the helper Schedule entity) - as was proposed [here]( this would not be as necessary. I could create an instance of a Schedule and it would be editable just fine - with functions I could override. Like any switch, cover, etc. No problem. But Schedule is not a 'first class' entity, so I'm trying to work around it, by being able to interact with the underlying storage directly. Which only works if I have a reference to the underlying storage. If you have a better idea of how I could use a Schedule helper with my integration so that 1) the schedule edit UI works, 2) when a schedule is edited, I can be notified of the changes and send them to my device, and 3) when I read the schedule from my device it can update the schedule helper, then I'm all ears. Right now, I want to use a schedule helper to manage the schedule for my [Power Pet Door]( which is an integration I have written. This is not an entity component platform, this should not be used by, or b
No real need to make these private Why do we do this? Not needed. Sorry, it's my first integration, I took a pattern from other integrations and I left it by mistake. Please only assign the coordinator to hass.data after this line Should this await hass.config entries.async forward entry setups(entry, PLATFORMS) be before the async config entry first refresh ? Nope. Create coordinator - first refresh - hass.data[...] coordinator - forward entry setups Okay, so now it looks good. Please only have 1 platform in the initial PR This should go into a PyPi library as it's connecting with an external service. Please only have 1 platform in the initial PR I left the Sensor platform as the only one for the initial PR. Should we change this into "unknown"? I think this is already set in the coordinator constructor A timeout is part of the connection logic, so we prefer to have this in the library Please only have stuff in the try block that can raise Consider using a data class or a typed dict for data transfer, it's more typesafe You're not allowed to catch broad exceptions here Oh and I prefer the name value fn as its more descriptive than attr Why do we even have this function? Name is filled with config entry.title, which is changeable by the user. This is a bad unique id. Please use the serial number for that Please use serial number Can we maybe only do the manufacturer? The user can find the right device via the device info I think this is a global const Since these will be in the unique id, having them snake case would be very nice
We shouldn't ignore coverage on individual lines. There's no reason to do that here. Probably test this by updating the device so that this function is called again for the same mac address. We shouldn't need to patch a mock. If it's a mock we should just be able to customize the mock attributes as needed here in the test. I'd expect us to be able to customize fh class mock here. If we can't do that we haven't approached the mocking correctly. The problem looks to be that we set new in the patch call as a real class instead of the default MagicMock. Why don't we just patch the two methods get mesh topology and get hosts attributes of FritzHosts if we want to use the rest of FritzHosts without mocking? I have just stumbled across this as well ... will rework this now i think for now the tests are good - nevertheless the fritz tests should be overhauled at all in a separate PR We have a fixture for this. L40-L47 It's a bit unclear what the change in state is after the device change. Maybe assert that this state was missing before the device change, if that's what we want to test? I prefer using Mock.call count to avoid the risk of using the wrong attribute, eg due to a typo, which will pass unless we spec the mock. mhhh ... using assert called once() seems to be quiet common ( used 650 times in our tests ) Yeah, unfortunately. I think it should be easily to be replace with a simple search replace regex ( sure, not in this PR ) but just for a better understanding of the possible risk - do you have an example of such a typo? Here's an example: uhhh ... that's really nasty :hushed: maybe we should discuss this in the members channel and try to get rid of assert called once() in all our tests? Maybe. It's a bit of an uphill battle since it's part of standard library. If there's a linter that could check it, sure.
Done in 1ee48f0c4f9b892b825ef4b43441bc1d4edded53
Can we move this to init .py ? Do you mean to move the entire code of async setup entry in the one in the init .py? We want to create the coordinator in the init file, not in a platform file Since we're only doing UDP discovery, isn't a config flow like Gree better? Are there reasons why someone has a different port for UDP discovery? Yeah, probably chainging the ports (or even the multicast address) is not necessary, since they cannot be changed on the Govee side. I'll check the Gree flow and update this one Regarding this, I'm almost done, but I didn't find a way to keep the OptionsFlow. Is there a way to keep it? It's not really needed but we will lose the possibility to change the discovery interval. Also, looking at the Gree integration, I had a couple of ideas: Would be better to use async dispatcher send when a device is discovered? Currently the discovery it is done using the govee local api library (internally it uses a call later on the same Home Assistant event loop) but, since this can be disabled, could be better if the update function is triggered using something like async track time interval ? Why would one change the discovery interval? What do you mean with the config flow can be disabled? Also, Optionsflow should be in a follow up PR. If with the gree config flow no options flow is possible and we still want one, I'd rather fix something in core so we are able to add an options flow after the super(). init () , self.config entry is set to the config entry. Please retype config entry to ConfigEntry tho. Checkout the youtube coordinator on how to do that why do we do this? This is an excellent question I remember writing this in an early draft of the code, but it makes little sense now CoordinatorEntity will set the coordinator to self.coordinator The default implementation is already returning self. attr unique id Please remove empty fields. Also remove the quality scale. I would prefer to have that done in a separate PR Please revert this Coordinator is not setup at this point, like never, so we can remove it here. This unload is lacking unloading platforms You can add entry.async on unload(coordinator.cleanup) in the setup, this removes the need to do it here as well Please check other unload entries, as this is wrong These 3 parameters are unneeded imo This isn't doing anything useful? This should go in the init file This too device info can be set in the constructor with attr device info . Then you can set attr name None and the entity will follow the device name It's cleanup. Please fix this in the code or it'll probably stay here forever I was able to get it wrong also in the library I'll also fix there
Create one coordinator class per measurement call type instead. Each measurement will have a different return value type that will correspond to the coordinator data type. I think we can make a base class with the default init method and keep it generic via a type var for the coordinator data value. Then we don't need to repeat the init method in every coordinator, unless we need to customize the init method. Note that I added a default executor job since all the measurement calls are sync. Need to split it up even further than current so makes sense. We can add the argument always to the base class so then we never need to repeat init Look at the renault sensor platform for how we can type the entity and entity description generic and have a single description method to calculate the native value. We don't want to create one coordinator per sensor. Multiple sensors will share the same coordinator but just take a different view of the coordinator data. Eg there are three sensors that should use the same swap memory coordinator. I'm not sure we want to request a refresh here. It would mean that there will be at least a second refresh after the cooldown time (10 seconds) if more than one entity shares the same coordinator. Probably refresh the coordinators before creating the entities and then pass each entity its coordinator. We should make it non protected if it needs to be imported to another module. I don't think argument and type belongs on the coordinator, besides the disk coordinator which needs the argument. For the rest the argument and type are specific for each entity not for each coordinator. The coordinators should just return the measurement from the measurement api call. Then it's up to each entity and its entity description to parse the measurement result and set a state. The psutil.net io counters(pernic True) call just needs to go in one coordinator and all the net io sensors can use that coordinator. I think we should remove argument and type from the common class and just add argument to the disk coordinator. Look at the renault sensor platform that passes an entity to the description value method. I think we can do it like that to be able to set entity attributes and store data that we need. Side note: Calculating state like this isn't really allowed but we should keep it for now. This seems like its going to create a lot more executor jobs which is one of the problems we had with the original design. Maybe its better to have each sensor flip on parts of the update when its added to hass ? After the first refresh the coordinator won't update if there are no enabled entities attached to it. Oh right, it probably won't matter that much in that case. We already have protection built into the coordinators to avoid accidental synchronization so we shouldn't have a thundering herd problem either This should not be a single function with checks for all entities. Each entity description should have a function that does needed parsing o
Please use parentheses for multi-line lambdas last thing, than this good to go if the docs PR is there Well, maybe that was a mistake on my part, sqft could be zero, without is not None this would return None and make the sensor unknown Could you please revert this change, sorry about that, my fault Yes will revert it. No problem. Use a walrus and store the value in a local variable so we don't need to look it up twice.
Can be inlined Maybe flipping the logic in this step makes it more readable and easier to manage, (So from if user input is None: to if user input is not None: ) Can the api token change? Can you revoke it? If so, this isn't a good unique id The token doesn't ever change - but it can be revoked. - A token maps to a "set" of devices. - If you add more devices to your account then they would be attached to existing tokens... - There doesn't seem to be any other way to uniquely identify a set of devices... - A token can be deleted but they never expire My thought process was I don't want to allow a user to enter the same token twice, but if say I had multipel tokens (my house, my rental, my parents) I'd want to allow for 3 entries into HA. Any thoughts on alternatives? Use async abort entries match() instead and make a reauth flow so the token can be fixed if neccessary. Agreed Like so or do I nix the self. abort if unique id configured() ![image]( Remove both unique id lines And add pass user input to the self. async abort entries match() Please only put stuff in the try block that can raise module wide logger shouldn't be private If you put this to the top of the file, self.config entry will be set by the constructor of the DUC. Please overwrite the type in the coordinator, check the Youtube coordinator for an example I think I got this working... whatever you return in this function will be set to self.data by the superclass, so please only return here Please be more specific, catching bare exceptions is only allowed in the config flow Please remove empty fields On naming: I'd suggest naming the device to the station name. Then you can set attr name None . What are we doing here? Getting the id from 1st outdoor sensor ... added a comment and a new method I think this is already set in the update coordinator init Can be set outside of the constructor Why isn't this just called weatherflow ? This tells me we should have a reauth flow as well and handle that in the coordinator coordinator is already telling when it's updating Title automatically gets added from the integration name async abort entries match() gives back already configured
Mapping of uom to device class is not unique for percent , so we skip it. Is there a way to translate these? How could I lookup if there are already translations for these in the defaults? If the value is Unknown, we should return None as sensor value instead Just like this? No I mean in the code, so currently we return "unknown" when its unknown (the native value of the entity), but it should return None Can this be done in the lambda? it could be a "return if ... is "unknown" None else ..." thing. But if it spans more than 1 line it should be a separate function see It would be maybe nicer to put in a separate function What does Nothing and Production mean? I am trying to put it in a question like: "What's the solar state?" - "Production" or "Nothing". Doesn't really fit imo. Maybe "Idle" and "In production" "Producing" "Active"? CHTHSCH DenisFFM can you shed some light on this as you own such devices? You could remove this one and the translation key for the device class translations What's a PCC? Point of common coupling , the point where the public grid connects to the home grid. Is this a common ViCare term? Would using Grid maybe make more sense in the naming? No, had to look it up, but seems to be common in electrical area. As per IEEE, the PCC can be defined as the point in the power system at which the electric utility and the customer interface occurs. Typically this point is the customer side of the utility revenue meter. : :text 3.1 20Point 20of 20common 20coupling,of 20the 20utility 20revenue 20meter. What about this? Sounds good, what about the power exchange? Please take in account, this is stuff in the try block that doesn't raise, If you could move it out, that'd be great This is based on self.entity description.unit getter which can raise an exception. Done
Should this log really say "Active source" or should it be changed like this: out is not a good name for the iterator variable, maybe name it mode or just name it val : Stale print. Again, src is not a good variable name here This is also poor naming due to copy-paste This should be imported in the from songpal import () block as it's exported through the main module (i.e., it's part of the public api). Alas, the setting is not (currently) exposed. I agree, but was not exported at the time I did it. I changed it for the SettingChange import. It's been a while since I have touched the library code, but should isAvailable check be done prior to the conditional above assigning active sound mode ? I just tested with my soundbar, and yes if an option was selected (Cinema) and I change the input to bluetooth receiver that doesn't support Cinema, the soundfield value is not Cinema anymore, and it became Cinema again if I change again to an input that support it. So you are right, better to do the check before. This could also be done inside the from songpal import block. Other than that, I have no more suggestions at the moment. Not sure to understand how? Because currently SettingChange is not exported, no the only way I see is like And in the code use notification.SettingChange , but personally I find the "double from" better. Did I miss an other way to do it? I meant directly importing SettingChange from songpal package, as it's part of the public API. It's a very minor nit, and there's necessary no need for action, especially as this is (just) test code. Re my other comment below, shouldn't this work? Yes yes, you are right, I failed in my demonstration, because it was about Setting and not SettingChange. I already have changed the SettingChange to import it in the songpal in the last commit, only remains, but this one is not exported. Yeah, maybe the upstream lib should export that and maybe more, but we shouldn't block this PR for that. I'm fine with this PR as it is, so we are just waiting for emontnemery to approve. If you want to improve this meanwhile, you could add tests for those error cases that are causing the drop in coverage. Could this be an issue as the list of sound modes is only initialized during the first update when connection breaks? You mention in the docstring below that the sound mode might not be available on all inputs outputs, so I'm wondering what happens when we populate this only during update() which happens only during the initial update or if the connection breaks?
does this actually get reported? The spec says it is a read attribute (the spec doesn't always correctly state reporting...) ![image]( Oops, I completely misread the spec. things like this should use the Zigpy types. Zigpy types don't seem to have the ability to convert signed integers to decimals, but there is no reason to make it that complicated anyway, so I just supplied the decimal. I think this should rather be "Max heat setpoint limit", and the same everywhere for the translations. See: Done Should this rather be MULTI MATCH instead? Since the entity category isn't set to diagnostic or config from what I can see. I changed the category to config, because it should actually have been that. Use UnitOfTemperature.CELSIUS Agree. minor, but you wanna remove the empty line in between here? (I don't think the empty line helps readability) Done I think this should rather use CONFIG DIAGNOSTIC MATCH , as the entity category is set to "diagnostic" below. I looked at other sensor entities in the category diagnostic and those were all matched using MULTI MATCH. I agree that they probably should be matched with CONFIG DIAGNOSTIC MATCH, but maybe that should be done in a separate PR? Uh, weird. That shouldn't be the case I think. Don't update the existing ones, but you can add this at the top: and only use that for your diagnostic entity. IIRC there's no real difference between MULTI MATCH and CONFIG DIAGNOSTIC MATCH , other than that they use a separate registry for the matches and that MULTI MATCH only matches on "unclaimed cluster handlers"(?) Done. Uh, weird. That shouldn't be the case I think. Don't update the existing ones, but you can add this at the top: and only use that for your diagnostic entity. IIRC there's no real difference between MULTI MATCH and CONFIG DIAGNOSTIC MATCH , other than that they use a separate registry for the matches and that MULTI MATCH only matches on "unclaimed cluster handlers"(?) Yeah it s the claiming semantics that are different. Thermostat.AttributeDefs.setpoint change source.id instead of 0x0030 Done Thermostat.AttributeDefs.pi heating demand.id instead of 0x0008 Done Should this also be a diagnostic sensor? I have been on the fence about that. It depends on the definition of diagnostic in this context. I did indeed write "heating power used", but the official specification says: "level of heating demanded". This information is not the primary function of the device. A door sensor would have the opening entity not as diagnostic, but the magnetic force would be. I think you're right. I changed it. (If so, also change to diagnostic match) Thanks, I forgot. uh, I'll need to have another look why changing from multi match to a diagnostic match causes this to no longer be covered supposedly. It looks a little bit like a bug to me in the coverage calculation, because it seems to think an empty line is not covered. I'll just try to rebase before anything else. Seems like the rebase fixed it. Looks better now.
Config payload is not sent from the device periodically, in the case of temperature hysteresis no information about the value change is sent from the device. How will this value be updated in HA when the user changes it in the device UI? When a config parameter is changed in the device UI, then a Event for it is generated and the config entry is reloaded. This makes the value update. So we don't have real-time entity state updates, we need to wait 60 seconds for the config entry to reload. In my opinion, for the implementation of such an entity to make sense, the device must send the temperature hysteresis value periodically. Without this, value synchronization only occurs in one direction. We need to ask the Shelly team again for this feature. Please try again, I did already twice. Indeed would be the best solution. Final decision from Shelly is that we need to re-fetch config once we get the notification is changed. This value won't be ever exposed as a status update. In such case, in my opinion we should drop the implementation of this entity. Its usefulness in automations is very low, the user will change it once, maybe twice during device configuration, so he or she might as well do it from the device's configuration panel. The device user interface uses the name Temperature hysteresis , I think we should keep this name. Good point, will change.
When you're always overwriting, you don't need to store your native UoM here How much more sensors will you add with dynamic uom? If this is the only one in the foreseeable future, I'd recommend going for the smaller implementation I put in that other PR to keep the code more readable can be removed Can also be removed Can we set attr native unit of measurement in the entity init method instead or may the unit change during the entity lifetime? Oh that's a good point, haven't thought of this idea
I think our general consensus is now that we want this to be in async setup , otherwise the service is dependent on the config entry. I am also not sure how this exactly works when you have 2 config entries for qbittorrent Lemme take a look at this and check Can we completely type this? This should raise a ServiceValidationError Please annotate the return type This too should raise a ServiceValidationError total torrents is a bit weird for something which is a list, torrents would be better. I think the service handlers need to catch this and reraise a translated HomeAssistantError Pass in the device id instead, for a more readable error message: Shouldn't this be translated, or can LoginRequired happen in many cases? I handled this how I found other integrations were but i can change this to be a translated string. I believe this is a very rare occurance as it should only happen if a user changes the username password of their qBittorrent software after adding to HA. As this is a local program running that would be very rare and there isn't a need to change that for security. What's the difference between the manual formatting and the output of the isoformat method? Why do we format it at all? Was making sure the format was the same as Transmission's integration but that looks to be the same except with 0000 on the end, so can format that way. I'm missing a service validation schema for the services. These are not state attributes. Please rename the constants. We don't need constants for strings that are only used once. Commented code. Please remove it. These instance attributes are never used. Please remove them. Why did we change the exception in this PR? That looks unrelated to the new services. The parameter is missing a type annotation. Please type the whole signature when adding type annotations. "grab the list" is too colloquial English and not correctly explained what it's referring to.
Please remove this, integration debug level is controlled via logger in configuration.yaml Please also add async unload entry Either change the integration to zcc or change the docstring to zimi Please remove this Don't directly open sockets from the event loop since this is blocking. Instead, hand this off to an executor job ( hass.async add executor job ). Also, this check would better be managed by your library. Please modify this function such that the controller's mac is used as source for config entry unique id Remove This doesn't seem reasonable. Shouldn't we make sure this connects to the correct controller, not just any controller? A user will only have one Zimi controller on their network. The discover() method searches for a Zimi controller on the user's network without knowing the device's ip address. It is not connecting to any random controller, but searching for their controller on their network. I don't think this should be a user setting. What does the watchdog do? The config flow needs to be 100 covered by tests, please add tests to ensure that's the case. When testing locally, you can do like this to monitor test coverage:
I'd make 0 and 1 named constants so open and closed don't get accidentally confused in future refactoring some years down the road Good Idea, Done.
Remove commented out code Fixed Already called down the line, can be removed We should use the Huum stored in Haas.data here Just to be clear, would this be what you are looking for ? So I don't need to get the status of the divide when settings it up? Well, I'm all for less code, so I can change it to the way to suggested The explanation is somewhere down in one of the hidden comments (github collapsed them because there were too many) Fixed according to suggestion New integrations should use the new entity naming. Checkout the entity docs on the developer docs. In your case it would be, setting attr has entity name True and attr name None and adding a DeviceInfo By "adding a DeviceInfo" do you refer to this documentation defining-devices So I would add a device info property function that returns a DeviceInfo ? or attr device info in the constructor, which might be cleaner to do But yes In this case, I can't get a unique identifier of the sauna entity. Is it OK to just hard-code the name "Huum Sauna" as the name, so that the settings would be something in the line of: Please then set the config entry.entry id as unique id for both the entity and the device Will there be more platforms in the future? If so, please consider a coordinator Huum does not provide other things that I know of at the moment, so I think we are good If you update on add, it will run the update function before storing the state so you don't have to pass in the initial state. Please use constants here (CONF USERNAME) This function is fairly small, I would inline it in where you use it Please remove all the huumtest files Ah, forgot to push the change, sorry, will fix This is not needed? Could very well be yes, I copied some of the tests from and modified. There are just so many things to keep in mind implementing everything I'll remove. Constants Please finish config flows in either Create entry or abort so we also test that the config flow can recover from an error Checkout pytest.mark.parametrize . you can make all these error tests parameterized so you don't have to have the same test logic thrice I agree that there are some redundant code here, but I personally like to keep tests separate like this to have better naming and better control over possible extra data that might be needed when possible future issues needs to be tested with regards to the same errors. Personal opinion I guess, hope that you are OK with me leaving it without the parameterization, but I can change if that is something that is required by the codebase. I mean, I am really a fan of keeping tests small and maintainable. With the requirement that config entry tests should end in create entry or abort, your tests will get big and parametrize is a perfect tool for this. Keep in mind, design code on what you think is going to change. The only changes I usually see with config flows are 2 things: 1. a big overhaul where everything is changed 2. an extra exception (maybe your sauna needs to be on when y

Ah cool, didn't know that this was possible! Please bump in separate PR The bump was already done, just forgot to rebase. Let's bump this since review is not ready yet It's kind of weird to use selectors here since the user will never see this. The media player platform schema had a default username and password, why don't we use those here? In the default configuration of Enigma2 devices, there is no username and password set, so this is not needed (and even when, the "root" "dreambox" would only fit to not many devices, because Dreamboxes are only a part of all devices with Enigma2). OK, I see. We create an issue in the import flow, that should be enough? Please don't use dict.get for keys which are guaranteed to be in the config In the YAML config, only the host is required, everything else is optional. That's because you modified the platform schema to remove the defaults, please revert that change. We don't need this check, it's checked in the import flow This is not correct, it should be like this since the media player entity is the main feature of the device Even when I want to add more entities afterwards? Yes, unless the media player entity will no longer the main feature of the Enigma device. I don't think that's likely though? That's true, the media player is the main feature. Thanks! What's this for? Forgot to clean it up. Nothing is calling this method, remove it if it's not needed. I don't think it's valid to remove the defaults here? This is given a default value by the schema: The mac address configured for wake on LAN is not imported, should that be mentioned in the breaking change section? Although based on the code it seems like that functionality was not working? It's not OK to have mutable class variables, please move this to an init method. After import, these can't be changed. Will this be configurable in an options flow added by a follow-up PR? Yes, options flow will be the next step.
engrbm87 I am a bit surprised that the GPU memory is registered as a string in Home Assistant state, while the sensor for RAM memory use looks very similar and does not need the string cast in the test here. Any idea what's causing this? I can see that the GPU sensors are mostly percentages. For the memory sensors there is actual memory and memory usage as percentage. [This link]( shows the UOM for the GPU sensors, please double check that they are the same in our code here. As for the string issue I am not sure, what error are you getting in the test if you don't cast as str. The HA state for the GPU sensors is a string, even though the input data ( HA SENSOR DATA in glances api) is int or float. Not sure why the sensor state becomes string, as the sensors above in this test seem to have the same sensor implementation but do have a numerical HA state (docker memory use for example). I did some digging and found that the sensors tests added in PR 93542 is not using the correct entity id . Because it is using an if statement to get the state variable the assertion is not getting executed which is why we are not getting an assertion error. I think the tests should be fixed in a preliminary PR. As for the str casting, I think this is required because the entity state will always be a string. this is what I get from the glancesapi library. Shall I put in some string manipulation to clean that up or request changes upstream? Hello, I think you should move the icon to file icons.json Thanks, done! Same here Same here Same here Wouldn't it be simpler to change the key formatting for gpu in python-glances-api and avoid having a special case for Gpu here ? L185 By the way I can submit the PR to python-glances-api if you want to got this way. I already have another PR open for network which will require a new version of the library. Thanks, yes please! I was being impatient and hacky, hoping to get the change in before I would have less time. Wrong mindset. It is obviously better to change the formatting in the package itself than add complexity here. Thank you for your offer to add the PR in there, I am still very busy. Hi fhoekstra , I have drafted a pull request here: The proposed format for the GPU name is: f"{sensor['name']} (GPU {sensor['gpu id']})" which translates to : If you can have a quick look, I'll submit it to the library maintainer. PR submitted to python-glances-api Version 0.6.0 is now available with the formatting change on GPU name Version 0.6.0 has been merged into dev branch Thanks for the quick action, I've rebased the branch. Also moving the icon definitions but have some trouble with my local dev setup. If I can't figure it out quickly, I could give you write access to the branch so I'm not blocking you any longer Good idea! Is the default
Wait, instead of transforming it to KM, can we maybe set the native UoM to the unit of the record? I did is this way as i deemed it easier and since none of the other sensors have a dynamic UoM. If i were to change this approach should i then also make a new Callable for each existing sensor description? What do you think of this? You could extract that dict out of the function, but now you get the full picture I think that's a very good solution thank you! I will do it that way.
Please keep it alphabetically (Can you also do this at the others?) Added in 323dffb78d9a05f17dd971b112e9da7f4e18ae07. Can we type this? Added in 323dffb78d9a05f17dd971b112e9da7f4e18ae07. Isn't this better? joostlek Yes, but mypy blows up if the return value is not Any . Check out my changes in 274b76d3ff0a8ee054b85f76338262ecca36d699 and see what you think. Not trying to make excuses, but I'm an embedded C developer and I'm still learning the subtleties of Python... Thanks for the guidance. I'm not accusing you of making excuses, you can just reply that mypy is annoying and I get that :). I just now see that this was in the switch.py. Does mypy also complain on the select one? Yes, they both need to declare a return value of Any to keep mypy happy. The suggestion you made was for select.py, but switch.py has the same declaration so I was trying to keep them in sync. I just saw a comment from jbouwh about modifying the switch.py declaration in a separate PR, so I'll remove that change from this one. Oh, when the changes are this small I don't mind a little code cleanup :) Fixed in a019ea53b7232b2ebcdf8c19d1c787f1a7f52ab1. Oh we already made a separate PR for it so you would not have to do it Please raise ServiceValidationError is the option is not in PROTECT MODE OPTIONS Note that a translation key can be added to support translations. Thanks for the translation key suggestion. I added that in 7a031bcff0c9631def3e3968b9fe045a5d322dc9. I'm glad I did that now because I had to push the values to lower-case to appease one of the linters, and that meant changing the API in my device firmware. Much easier before it is released. If I add an else: raise ServiceValidationError to async select option() , I can't seem to hit that line in my tests. If I call hass.services.async call() with an invalid value in a test, something else raises a ValueError exception before async select option() even fires. It seems like I should just remove the if option in PROTECT MODE OPTIONS: test altogether because it is always true. Thoughts? My fault. It seems SelectEntity does a validation check that calls value Error. This means you can remove the check to see if the option is valid here, and there is no need to raise. Thanks for verifying. I removed the check in 0a100876bb02c292b07cfc9135615e5f471255f7. Not sure if the typing is correct here. I might have missed that with the Switch PR. Left suggestions to improve the typing. Please open a separate PR to correct this for switch Please open a seperate PR for this. See: We can use Awaitable . Fixed in b259dd4d91e0cbad3a762f33c372769bd3327f98. Like you did for the other methods you can omit passing the default values. Ah, yes. Thanks for noticing that. Fixed in b5bba9d5f87109e9237337130cf5f4eb96986907.
The device should update the state instead. Good point, especially at QOS 0. Changed in 4e2f7e54d6cc6c5a8dbf10b96a6baafa996c15c9. Same here Changed in 4e2f7e54d6cc6c5a8dbf10b96a6baafa996c15c9. IMO we should try to set this during the coordinator update. To add, there are only 2 description types, why do we even fallback to entity description icon I used this approach specifically so I could get 100 coverage in my unit test. At the moment, all of the switches have dynamic icons, but I didn't want to make the assumption that would always be the case. By setting a return value and then optionally overriding it I don't miss the final return value with the two switches I'm currently implementing. I know it's slightly odd, but can I leave this one alone so I can keep my 100 coverage score? To add, there are only 2 description types, why do we even fallback to entity description icon We have plans in the works for adding additional device types that will have switches without dynamic icons. The fallback is just planning ahead for future additions. I'm certainly willing to simplify and remove the fallback knowing that I will probably need to put it back in when new switches are added. I went ahead and simplified the icon property in 8ad8014c75e5574b29cf506bd7a03f402b738ccc just so the unnecessary fallback case isn't an issue here. Please handle this from the coordinator update that is called instead. The code could be moved to the DROPEntity base entity class Here you can set attr icon , make constants for the icons. For binary sensors you could make a mapping. jbouwh Sorry, I don't think I'm understanding this. Are you saying I should create a new switch subclass in entity.py and move the icon property there? Something like this: ... and then use DROPSwitchEntity in switch.py? Would this also apply to the other properties (such as is on() ) in switch.py? You also mentioned binary sensors; do you want me to refactor the (already merged) sensors and binary sensors as part of this PR as well? I guess I don't understand why it is a problem to have the icon property in switch.py. It appears the most integrations do it that way and since it is using self.is on to determine state, it is already changing based on updates from the DROP hub via the API. It seems like a lot of unnecessary complexity, and I feel like switch properties belong in switch.py. Left some suggestion on your last commit. Lets use DROPSwitchEntity as you initially implemented. The state will be UNKNOWN . To test the state update simulate the response using async fire mqtt message or update the state result to STATE UNKNOWN . Simulated responses added in 3948169222a3743e712a49c113cc543ae06af544. Updated in 00255a784e537b659831511f69d179a6c646d4bc, though the ICON VALVE dict needed to be keyed on bools and include the None type. Changed in 00255a784e537b659831511f69d179a6c646d4bc. Can we have a keyed form here to like we have for ICON. Consider constants for the states to be exposed by the AP
Please move this one to the coordinator.py file I think we should create the coordinator in init .py like we normally do Not sayings its correct, but the tibber integration also creates its coordinator in its platform async setup entry. I can do this but I think its going to require a code change in every single platform Tibber isn't a good example imo. The coordinator can create entities directly :s
This domain is incorrect (and all other too). Spaces in names, should result in an in the integration domain. None of these used that.
Not sure if they are named arguments, but this is way better imo What do you think about flipping the logic? Checkout Suez Water for example Not used Can we fetch a list of all stations? I'll have to check the docs ... (Mark as TODO) So it does look like in the docs we have a - get all stations for a user. img width "998" alt "image" src "" So the question is: - A) User enters credentials - and forecasts get automatically created for all available weather stations... - some what of a redesign - but probably more user friendly at first - B) User enters credentials - and is then presented a list of possible stations to choose from - they select a station ... if only 1 station its automatically created. Keeping in mind that the next PR will allow a user to enable Cloud Sensors for a specific weather station - does one option seem better than the other? If briis has time to look over this as well - I'd like to get his opinion. I think the simplest option is to just store API TOKEN and calculate everything else at startup time by hitting the stations api. I think both would work. I think I would prefer the first. This way is the most simple and I can't really imagine why you don't want to add a certain weather station to your instance If you don't want to see it you can disable it. I have only 1 station, so I am not sure if you get an API Token per Station or per user. If it is per station, then option A is the only possibility. If it is per user, I would go for option B, as the users should have the freedom to select what they want to add per station. It's not what they want to add per station, but what station they want to add Based on the API I have to assume that 1 toke gives you multiple stations because of this endpoint: img width "270" alt "image" src "" (Happy Boxing Day if any of you are form England?) que? I donno seems like maybe we should just do it every 15 30 mins. briis why did you select a random 25-35 minute window? I'll change it :) Why don't we merge this with the coordinator? Remove empty fields We don't even store a name In the current code it is storing a name. Although I went back and forth on this: img width "545" alt "image" src "" At a minimum we could just store the credentials and at startup figure out which stations to add... Oh lol, I forgot this was a thing. But I actually prefer to store as less as possible. This way if the station name changes HA can pick it up without updating the config entry I'm hoping we can just store a SINGLE api token which would be awesome. There's no legacy anymore since this is core Where identifier? If its not available, why do we add it?
As a note, in the future we may want to use this here: greenpower.GreenPowerProxy.ServerCommandDefs.notification.name However, that would depend on the zigpy ZGP PR Right now, this PR is independent of that. (Relevant PR for other zigpy def changes: Thanks for your patience as we work thru the issues surrounding the tree that crashed into our house a little over a month ago haha. The intentions of this PR were twofold: - Allow this PR to be reviewed independently of the larger ZGP patch - Keep the code changes as minimal as possible to allow for expedited review If you'd like to wait for the main PR to hit first so we can use the name reference as opposed to a magic string I totally get that. No problem on my end.
This could be problematic when .get returns None . Yeah, in theory it never will, because this field always exists, but I did wonder if I should None check it, or not use get. Can you maybe add a build number to the fixture and test if this is split correctly? There is a build in the fixture already. L204 EDIT: I'll add an assertion Oh I was looking at the 2 changed lines in the fixture Yeah that does not have a build, hence why I wanted to normalize it. By the way, doesn't INSTALL say it also supports installing the software? Yep, which it does, but I removed that functionality to make this PR smaller. Ill remove that feature. Because, shouldn't I see an install function then? Yeah I removed it, I've also now removed the supported feature. Ill add them both back later.
Instead of adding this check, we can refactor the parameter to be a dict that we always use to update the service data. The two cases would be a dict with the conversation id and an empty dict. Would it be something like this then for data ? Something like this: We can replace agent id similarly.
Done. If you move this to the top of the constructor. The super constructor will set self.config entry. you have to retype it tho, check out the YouTube coordinator for an example Done, I moved it to the top of the constructor. Just for reference, I based my work on the WLED integration, which calls the super constructor last. Please split this from the PR Done. Can this become an enum sensor? Which has all the possible options in the options field? Please don't use numbers as state but make it a snake case value I did the change but I'm not sure I did exactly what you asked, especially because of the part "Please don't use numbers as state but make it a snake case value". The values returned by the API are numbers. Is your recommendation that I should I take care of the conversion in the TechnoVE python library instead of here? Yes, that would be awesome when the library has a Enum for the status, because in most cases an user can't do much with an arbitrary number. I think it's best to make sure that the state of the enum sensor is a snake case string. Enums are lovely! Thanks to both of you for the helpful feedback. I've implemented the status as an enum now. Can use device class translations, so you can remove this Done. Only uppercase a word when it's a brand Done. Errors is always set Without zeroconf this isn't needed right? If I understand correctly, could this still happen if a user manually enters the same IP address twice? Can also be removed Done. Is this doing anything? You're using self.coordinator.data a lot, maybe store it in a local var to make it cleaner and a bit more performant? I think you could move the unique id to the parent entity. Just create a constructor that can accept a coordinator and a key Sure, done. Oh no! That's embarassing. That's a leftover from a copy paste that I missed. Sorry, fixed. You're already doing this in the parent
Taking the difference between two constants gives another constant. Define that constant at the module level. would this be ok to just have SIGNIFICANT ATTRIBUTES ? if yes, i'll create a PR or maybe this one ( imo looks more readable ) Yes, but note that the difference is not the same as the symmetric difference of two sets. uhhh ... good to known than it should be like this, right? Yes. - 106727
Can be removed Ok, so let me try to explain what's going on. I am not an expert of the hass internals at all and unfortunately the documentation seems kind of poor when it comes to describing how all the config setup works internally. Here's what I understand: There's an old and a new way of setting up components and entries. The modern way to set up integrations for platforms is to forward the entry setup to the corresponding platforms like this: However, the notify integration seems to be the only one that is stuck with the legacy way of setting up things. This means that the above call will fail with AttributeError: module 'homeassistant.components.notify' has no attribute 'async setup entry' for notify. This is the reason why for example the slack integration separates the behavior for notify like this: L72 Note the if platform ! Platform.NOTIFY and the async load platform call above. This seems to be a common way to setup notify platforms, here they even have an explanation: L137 no entry support for notify platform yet, have to use discovery to load platform. Seems everyone else does the same. You can also check the discord integration or others. This is why I use discovery.async load platform . Now let's come back to how this is related to keeping def async setup : In the above method which you suggested to remove, I store the hass config in hass.data[DATA HASS CONFIG] . Later on, this variable is needed in the call to discovery.async load platform , see the requirement here: L154 Hence, it seems I cannot remove async setup . Let me know if I'm missing something here. Remember when I said that a notify integration to config flow isn't that different? I take that back. This is awful (not because of you btw, you're putting in great effort, I just don't like how it differs from the rest) Like I've seen some pass by but I did not know all these pieces were needed. So I guess I'm also still learning here. Can we mark this resolved? I'm on mobile right now, I'll drive into this tomorrow If we don't need to set anything we can also choose to don't set anything. But we do need the entry.data . This is used when setting up the SIPCallNotificationService , which gets the credentials from the config flow through that. But you're also passing the entry data in the discovery stuff, can't you use that instead? Ok gotcha now. You are totally right, let me fix this. I don't know how SIP works, but is it maybe possible to check beforehand if we can connect to the server? To check if our credentials are still valid and we know the server is online and reachable? This can be very nice in both the init and in the config flow. Well... It would be doable if my nanosip implementation also supported the REGISTER method which is used to receive calls. But the aim of all this is to make it as simple as possible. So we can only verify the credentials by making a call, and I guess we don't want to do that during the config flow. I mean yes we like simple, but we love
This shouldnt be needed? It could be just self. attr icon description.icon but the linter complains because icon could be None Yea but the standard implementation of the icon property first check if entity description is set, if so, it will get the icon from there. So I'm not sure why this wouldn't work here. (This would require removing both lines) In SleepIQBedEntity the line attr icon ICON OCCUPIED is overriding it. Without it being set here it doesn't get set This can be set outside of the constructor I do still have one remark. We should use prefer to use snake case for options. This way you can add the possible values to the translations file and have the values be translated. I'd rather fix it now than having to create a breaking change for everyone in a later release. Did you test this? I thought it had to be entity - select - foot warmer temp instead That's what I originally had, but the docs say to use the selector key: selectors I think that's only for selectors as in selectors, not as in the select entity iirc Ah I see, didn't realize those were a different thing Removed it since you're still including names and this PR needs entity translations as a whole to be implemented
Until now, TemperatureControlTrait has only been used for temperature sensors, and we also mention this in the docstring: We should rewrite the doscstring since this is no longer true, maybe: It is still a work-a-round for temperature sensors. Updated the docstr though Let's swap the order to match the order in sync attributes below in query attributes , please do that here too.
Please avoid putting complex objects in the config entry data Please check the latest commit. In 2024.1, minor versions are added, I think this would be a good example to add it to. Let me double check with someone if this is indeed a good example. Any updates on this please. They are still going to write a blogpost, but I just saw an example PR fly by: Documentation about minor version is available under config-entry-migration I think I prefer the structure as described in the docs. done In the new config flow you are also setting an unique id, I think it would be wise to apply this to the migration as well. done I think the default is already the home location, can you double check? I tried removing the default value but then the config flow no longer opens (in the UI). I am not sure if the location selector tries to auto detect the location or uses the stored home location. I prefer to make the default as the stored home location. That's fine by me! I think the coordinator would benefit from setting a lot of the properties in the constructor instead of accessing them every update done Don't patch our code in the config flow. Patch the library client. This is the correct patch target.
It would maybe be preferable to have 1 banned IP as part of test setup and then assert that only a single IP was removed from the ban list. Reason: a call to manager.ip bans lookup.clear() would pass this test. If I understand correctly this is now asserting that the each service is contained in msg["result"] , but there might be extra services or domains in msg["result"] and the test would still pass whereas previously it would have failed I'm wondering why this needed to be modified? async services() returns a dict of service , while msg["result"] contains the deserialized JSON representation of this dict, so this is not directly comparable. The test was previously successful as both sides were {} . Writing this, I think we could use snapshots here. Might be better to use save yaml here? L31-L33 Hm we could use this yes, but I try to have the same output as before ( n between the ban blocks) When write bans runs in a thread it will observe the latest state of self.ip bans lookup , which by that point in time may be different to what it was when line 298 runs. I don't think there are any serious problems (race conditions) that can come of it but thought I would mention it since it's different to async add ban , which passes the IP to add by value. These changes don't seem related to the newly added service. Should probably best be split off into a separate PR. Hmm yes, would indeed be better, even if this was noticed and needed by this change. Before the PR, hass.services.async services() returned an empty dict as the components being loaded in those tests (e.g. http) had no services. Since we now have a service in HTTP, the comparison fails because msg["result"] is a JSON representation and hass.services.async services() is a Object representation These changes don't seem related to the newly added service. Should probably best be split off into a separate PR. Should use early return pattern. E.g.: Makes sense, thanks :) I'm sure this was considered, but it looks like async add ban adds to the memory dict, and then calls add ban which appends the address while and the new write bans method writes the entire file. This means that write bans , which sounds pretty generic, is really only used in one circumstance. It probably doesn't make sense to use this for add because append should be more efficient, but probably worth a comment. True, append is more efficient then writing the whole file over and over again. dict s are unordered, so this is going to lose ordering of all bans in a file. I realize you're using a dict here because the original structure is a dict and then using yaml.dump , however order could be preserved by instead sorting and generating each line as it's own dict, similar to how add works. What do you think about using OrderedDict instead? ViViDboarder Python dicts are not unordered, are you referring to yaml dicts? Oh, interesting. Looks like as of Python 3.7, dictionaries preserve insertion order like OrderedDict . I wasn't aw
i think this could also be a function in homeassistant.helpers.significant change , because this logic is already used in other significant change.py 's - will move there in a follow up PR 106005
I think that is it isn't classified, it is hard to judge if the change is significant or not? maybe we should return None in that case? Shouldn't we consider it significant in those cases for any change? (as we don't known) In the sensor platform, we return None in case it is unclassified ... tbh this sounds reasonable, because we can not judge it's significance and as per docs None means "we so not know" Sounds good
Let's set this in the PR which fixes volume since volume control is broken currently. That wasn't meant to be there indeed. Fixed now. Can dunehd play just about any kind of local media? It depends a bit on the player model, but they do have very broad format support in general. For example the Smartbox 4K Plus, that I'm using, supports below formats: Source: OK, I guess it's OK to not add any filtering then. You have tried this with a local media library, and it works as intended? Video and audio files work. Image files do not work currently, but that seems to be a bug in the player OS that it can't handle a dot in the URL query string. I have reported that issue to the Dune support, no response so far.
This has impact on our models. This needs to be proposed, discussed and approved in our architectural repository before creating a PR for it. Please open a proposal there first. .. Frenck As you wish: Thanks! Let's add beaufort to the existing catch-all UnitOfSpeed enum This is not correct; 1 Beaufort is not 1 m s, shouldn't this just be removed since Beaufort has special handling? When line this is removed, I get the error: homeassistant.exceptions.HomeAssistantError: Bft is not a recognized speed unit. Any value here will be overwritten by the outcome of the conversion. So indeed, 1 is incorrect. But also never used as actual value. Are you sure about this? The error you mention will be raised if the unit is missing from SpeedConverter.VALID UNITS , not if it's missing from SpeedConverter. UNIT CONVERSION Just tested it again: This is the class: Error: Why do we need to limit the size, and if we do, where does the number 8 come from? This is basically a copy of the temperature conversion below. What do you suggest? OK, I see. bdraco can you comment on why we limit the cache size of TemperatureConverter.converter factory ? I don't think it should be needed considering the small number of permutations. I also don't think it's needed here. There is no good reason to limit it anymore Thanks, the cache size limit is removed by this PR: We should add this also to the docstring of SPEED above You're right Yes, so can you do that change please :) Sorry, only now I see what's missing Please remove this and update the test instead as explained here: discussion r1469234638 What happened here, why is it changed? This was auto-changed by the formatter, I use the Dev Container... Let's revert unrelated changes
I am not sure about these functions. I kinda feel like they should be part of the library, even tho they aren't part of the connection to the service it could be used in combination with an abstraction to return an object with full data What do you think bachya? Do you want me to put it in aioambient ? thomaskistler I'm aligned with them living in the library. Why do we need this? I added it as a user convenience. We create and suggest a 3-4 letter name mnemonic for the station(s) that are added. Instead of having the sensor names show up as sensor.bunny ranch weather station tempf, they will show up with something like sensor.brws tempf. It's not strictly necessary. I can remove it if you feel strongly about it. I prefer the first one actually and people can rename the device themselves if they think it's too long Ok. Removed. Removed. Why do we convert a static value? Fixed. So if I understand correctly, someone chooses a location and radius and we get all stations from inside that radius and ask the user to add it. This means 1 config entry - n stations. Have you considered 1 config entry - 1 station? I have this setup at WAQI. This way you can avoid people adding stations twice. Someone chooses a location and radius and we will display all stations that are discovered inside that radius. The user can then select whether they want to pick a single station (in which case we add one config entry that directly tracks this one station), or whether they want to track multiple stations (in which case we will add one config entry that "averages" the data from all selected stations). The latter is really important because many of the local private weather stations are not setup ideally and you can have significant outliers in terms of temperature, wind, and precipitation. But then my question is, home assistant has a lot of different features, why don't we let the user do this themselves? Then they can also exclude stations themselves etc scan interval is static, no need to make it a parameter Fixed. Fixed. You can overwrite the type of the config entry in the coordinator. checkout the youtube coordinator for an example Fixed. Fixed. No? Have you generated translations? Yes. Translations are set up [here]( diff-826a69d62aa78ee1eba2a0563411e60ab894202e56847985f6658b537f3b3e8cR40). haven't checked your tests yet, but I expect this would've been covered Fixed the tests and removed pragmas. please us an abstractmethod instead Fixed. Please bump in a separate PR Ok. Will do.
I'll start. Should I add a new assistant to distinguish between OpenAI and native conversation engine, or will it create more hassle because both are 'conversation' (I mean, 'Assist')? Should I create a new config parameter to enable or disable this functionality, or the Expose control is enough? Is there a way to update the default prompt for existing installations, or we should ask the user to do that? Do I have to replace those with respective constants?
not needed addressed with This should use CONFIG DIAGNOSTIC MATCH defined on line 38 addressed with stop on match group is meant to prevent different implementations for the same functionality from being matched. Do you need this for this entity? addressed with We should still include the model in this matcher so it is t matched for every device unless it is a standard zigbee attribute But this is a standard Zigbee attribute as described in ZCL 6.3.2.2.2.1 (Thermostat Settings Attribute Set attribute id 0x0010 'LocalTemperatureCalibration') What would be specified as a model in the matcher? all good I just hadn't checked the spec this is inherited. No need to redefine it " attr entity category", right? yes no problem
If you reverse the condition and return here when it is valid, you can save some indent

I think you can just omit the unit specifier if there are no units. Oh lol, apparently I have a draft review comment saying it should be "satellites" ![image]( Looks strange. I looked at the GitHub integration and it specifies custom units for each type of counting sensor (Issues, Forks, Stars, etc). What looks strange? GPS Satellites: 9 satellites Strange to duplicate "satellites" here I mean usually we exclude the UoM from the entity name, but in this case there is no real alternative (Like "total kWh" would become "total energy", but in this case removing satellites leaves us with an entity without a lot of context). I think there is no better alternative
this should not be included in the PR what is this for? The idea was to add general handler for binary outputs. Binary Output, as specified in ZCL, has ActiveText, InactiveText, Description and other Attributes. I've tried different approaches to use these Attributes to populate Select Input in the following way: Cluster description to be used as attribute name (which is achieved), ActiveText and InactiveText should've been added as an Enum properties. I couldn't find a proper way to dynamically populate Enum object with properties. I didn't want to change the "types.enum8" definition to add a method which will create new property during execution of the code as I was unable to analyse further the HA Core code and foresee any arising problems due to the change, due to my lack of knowledge. Finally I've just decided to define different clusters states in Python as shown. As a result, I needed to add some device filters, so these properties apply only to this particular device and not to every device that has Binary Output Cluster defined. I am willing to try my best to write a general Binary Output Cluster integration in ZHA, but I will most definitelly need some help from HA Community or Developers. It should render in user interface dynamic Select Input options read from the cluster attributes. Sorry I meant why are there 2 marchers on this? And why are you trying to match just manufacturer
This change requires an architecture discussion. changing-the-entity-model I'll create a discussion then. Let's leave this as a draft until a decision is made. Let's close it until it is approved.
Since this is going to get immediately shadowed on the first update, and there doesn't seem to be any need to share the value between instances, wouldn't it be better to just declare in the initialiser? Also the retry limit '2' is a magic number used in more than one place, so might be more maintainable to use a constant. Use constant instead of '2'? See above. Why not just continue using the previous patch since it is identical?
So the thing is, we should not use YAML anymore. Instead we want to import the YAML using an import flow which creates a config entry for the YAML config. joostlek Do you mean, it should not be possible anymore to configure via configuration.yaml ? Yes Ohh, that is sad... But removing it will be a breaking change and I would rather not do that. But I don't think this is up to me to decide. What you would say fabaff ? Well, we have an import flow for that. You can then import the YAML so it will create an entry for you Ok, have not yet looked at that. joostlek Did you refer to this when you were talking about import flow ? Nope: checkout diff-3f88feab5a41e23e0057f3117af8a8effc16d9a136c2dbb07e293286a9acb0ab (This is just to show how an import would work. I changed this code up a bit as its now a bit cleaner, so please checkout the version of suez water on dev) Thanks for this hint. I have a new proposition for it based on the Suez example. Can we initialize the api client here, do a quick check if the service is working and then store it in the data? Please define a PLATFORMS with all the platforms you use (which is only Sensor in this case) Only helpers are allowed to have a name for the config entry. Instead we should set the config entry name to something the user can recognize You mean, using the from and to config values for example, to build a entry id? Yep Can we do a check if the entered stations are correct? The api will match it to the closest station, even when I type X and Y for from and to , the api request will succeed. Not true Test added Can we maybe get a more descriptive name? Start station id start station name etc You can just put this function in async setup entry, it's not that big (and it gives a better overview of the setup) For the import issues, please check the current state of suez water at the dev branch. Also, deprecation period is 6 months The import issues now use the same implementation as suez water. I'm currently in the bus, let me link you a PR when I'm home. feel free to ping me when I forget Why do we store the config entry data here? This is also being passed on to the async setup entries in the other platforms, so is there any need to store it here? I think there are 2 things we should try and catch. Because we already check if the stations exist in the config flow, we know that in theory the stations exist and that this can work. But there are 2 possibilities where we can't get data. 1. The service is down. In this case we want to raise a ConfigEntryNotReady exception. This makes it retry a bit later again. 2. The stations don't exist anymore. (I'm just doing a guess this is something that can happen). In this case, our config entry just doesn't work. In the future, if you feel really fancy you could work on raising a repair issue to notify the user that they should repair their config entry. For now, please log that the call failed and raise ConfigEntryError instead. This is the ideal solution, but this als
teharris1 I think you might have forgotten to clean up helpers in this file which are no longer needed, for example add x10 device . Could you double check? Yup. I confirmed all unused items are removed now. I don't think this is very idiomatic, I'd expect something like this: Use any instead of the loop: Instead of the untyped dict, can we make it a TypedDict to make the code easier to understand? Same comment for the override functions. Why do we need this special case, the list comprehension below will still work even if there are no devices, right? What's the purpose of this guard, it means we don't allow removing the last device, is that intentional? Please use same variable name in the functions, it makes the code easier to read Why do we need the options config variable, we can just do: This is not OK, we're mutating the original list. Instead, do override config override config [override] I am confused by the concern. The first thing I do is copy the original list with options config { config entry.options} so any manipulation from there is changing the copy. Why is that an issue? NM, with the other comment below, I am removing the lines you are concerned about anyway. Same comment as before, why do we have a special case for this? Yeah, I see what you are saying. This, combined with the if new overrides: below was intended to avoid an empty list but that is really not helpful. Same comment as before, why can't we remove the last override? We can use the send json auto id helper so we don't need to include an id count.
We don't sort imports like this in this project, please revert this change Why is the formatting changed here? Please revert unwanted import changes
I guess this should be "median" Same here, should be "mode" or "Mode".
This doesn't look like the right patch target
Why does this happen? Should we differentiate? You can raise ConfigEntryNotReady when HA should try again later, or ConfigEntryAuthFailed when the API key expired (but this requires reauth flow so this one is out of the picture for now to keep the PR small) Are you the owner of the lib? If so maybe it's an idea to raise different errors on these events to catch them properly so you don't have to compare http status codes here Thanks for the pointers. I wrote the underlying library. I implemented better error-handling there and updated this code too. We only allow helpers to set names in the config flow. Noted, updated. To continue on not setting a name, is it possible to get an user recognizable name from the API? The API is pretty simple and has no specific identifiers but I implemented an identifier in the underlying library (based on hashing the API key, which is a fixed key for each access). Code is updated to create a name from the ID, something like "API-12345678". Edit: I also sent a mail to the API owner to expose the name of the Hot Tub which is available in their system but not in the API. Coordinator is already available in self.coordinator Thanks! That helped simplify things a lot. So you are setting self. status, which you expose at self.status. Whatever you return in this function will be set in coordinator.data. Thanks! That helped simplify things a lot. I'm fairly new to the Home Assistant source code. Is the device id a str or what else? Shouldn't both be made str? Good point. I moved the whole logic into the underlying library, and more importantly, I made sure it's already a string. Not needed Removed! Always happy to simplify! Edit: I removed the wrong entry first but in a subsequent commit, corrected the issue. Oh I now see the device id is this. Can we get an id from the API? if the API key ever expires all entities get doubled and automations will break. Unfortunately, the API is fairly simple and does not handle sessions at all. You always have to provide the fixed API key for every request. But a good point is made, I moved the whole logic into the underlying library. When they update the API to have IDs, it will be less intrusive for the Home Assistant codebase. This class should be moved to the lib Good point! The whole class turned out to be unnecessary. Removed. Please remove the empty fields Done! Done! Is there a reason for such a low update interval? Is 10 or 15 seconds not enough? Good point, I think I just wanted a more responsive interface during testing. I'm raising it to 15 seconds in the next commit. For what I can see, an API key corresponds to exactly one device? When raising this error you need to have a reauth flow. Since adding this would be a bit too big for this PR, raise a ConfigEntryError instead. (This way it won't retry again). You can implement reauth in a followup This function is fairly small. I think we can move this into the config flow step completely; this allows you to get rid of the custom
Can we maybe disable some by default? I can imagine these are quite specific (and since they go up the same rate, do we really need all of them available?) From a user perspective, I would like to have access to the total gas consumption by default. A more specific consumption like "fuel cell" or "peak load boiler" (which is missing here) could be optional. But you don't need the consumption this week, month and year all at once "Today" could be enough. HA Energy dashboard can do calculations for the rest. Can we maybe disable some by default? I think so too. I suggest we disable all but the today sensor by default. I already prepared a PR for the existing entities to do so. joostlek what is the recommended state, hide or disable? If the sensor is just hidden, one would already collect long term statistics for later use, right? I mean, what's the point of collecting LTS four times (as in, the increase is the same) Also, the stateclass is Total increasing, while it seems like it will reset at least every day month year week. I think the state class should be Total From the [description]( state-class-total increasing) total increasing perfectly fits in my eyes. Oh you're right added entity registry enabled default False borys-kupar what was the difference between this one and gas consumption total today again? Does it really make sense to have both? Total gas consumption consists of 2 items for me: "fuel cell" and "peak load boiler". Those are optional things, that helps you understand better how gas is being consumed. See the screenshot from the ViCare app: ![Screenshot 2024-01-31 at 12 53 06]( And "fuel cell" and "peak load boiler" are two different heating systems? I guess it would be nice to see that as well (maybe in another pr). Just had another look, peak load boiler is not exposed in the library. To me it's not clear what each value represents and what is a sum of what? - "heating.gas.consumption.total" - "heating.gas.consumption.summary.dhw" - "heating.gas.consumption.dhw" - "heating.gas.consumption.summary.heating" - "heating.gas.consumption.heating" - "heating.gas.consumption.fuelCell" Is the peak load boiler the dhw? borys-kupar Can you file a feature request with the [library]( it's probably dhw, I'll confirm and file a request if needed.
I think this should not accumulate. async call later returns a cancelling callback. Need to store it so when new set interface state request comes we cancel any pending deferred update This call will remove the state. But if the interface later becomes available again nothing will resurrect the state instance since its name will be already in tracked variable (inside async setup entry ) therefore update items will ignore it.
Please only patch out the library Do you mean with patch("tessie api.set seat heat", because that does not work.
You can't control individual windows? No, you cant :( The function call lowers or raises all windows Reference: How come we need to change 4 different states? The car opens and closes all 4 windows with the one function call. But we can't manage each window separately, but we have to still give the separate state of every window for it to work? Odd Yeah I know, we get the state of each window, but cannot control them individually. I could expose binary sensors for each window, but I am not sure how much value that has. Maybe I'll add state attributes in the future. Vent? So it doesnt actually open the windows fully, it only opens them a little bit to "vent" the air. The API call is literally vent-windows . Aaah
Please sort them alphabetically Done You use a coordinator, this doesn't work with PARALLEL UPDATES Removed I think for the strings we want all snake case, for keys it doesn't matter, but for translation keys it does iirc So you want me to use instead of - right? This has been changed You're also not checking for entity description translation keys Ok ill revert this change. I dont think I need it anyway. Please keep the names in Sentence case instead of Title Case Add new strings have been renamed. Can be a generator expression here Must have missed this one. Thanks Please adjust the entity coordinator sensor in a separate PR. Once we merge that one, this one should be limited to binary sensors This was feedback from joostlek. I'll try smash out a seperate PR now. I agree with his comments. It should still be a separate PR. Finally been able to get that changed raised seperately: Looks like unrelated changes? Yes, has been removed from this PR. The second one could be cleaned up more. It looks like some sensor changes accidentally made it in with merges self.value got removed in this PR. I have pulled this change out into Thanks, this PR doesnt touch sensors anymore. In a followup these should be changed due to a recent change This will come up a few times in the other platforms, but ill look at addressing them all once I fully understand the repercussions. OFFON isn't used. Ah yes, that was an idea I gave up on. I'll raise a PR to remove it.
None is already the default value Please create the repair issue here depending if there is an error or not. See the Ecovacs integration as example In the config flow, this means an invalid id, and here, it means we should retry later as it is a temporary error. What is correct? Please use a [Coordinator]( coordinated-single-api-poll-for-data-for-all-entities) instead Not used Should create in the import step as we have different errors Please use references where possible. Also cannot connect is missing We should deprecate the entity with a 6 month deprecation period instead of directly removing it. We should use the name of the station for new config entries Can you give a short explanation why the name shouldn't be user configurable? Is it best practice to choose a name automatically and let the user deal with renaming devices and entities afterwards manually? Is it best practice to choose a name automatically and let the user deal with renaming devices and entities afterwards manually? Exactly and I assume most of the user will use the station name I see, I removed the optional parameter in the last commit. Adding a new platform should be done in a follow-up to keep this PR as small as possible. Please remove this file You currently don't need to reload it
self. reauth email doesn't appear to be set to something else than None when in the user flow. We can initialize it to None as a class attribute above.
Might want to guard it's an actual number. state.state.isnumeric()
Just in case unifi might introduce new values, wouldn't it be better to default to UNKNOWN in case we don't find the state? The enum should default to unknown by itself.

please use constants. (Not sure if this one exists but I'm guessing so) Please add reauth in a follow up PR Is this a requirement? It doesn't add much complexity and I'd really prefer to have it in this PR if possible. But if this is a blocker to merging then I'm ok with moving it out of this PR. When I [previously submitted an integration]( having reauth in the initial PR wasn't an issue. I think I am going to put this as a requirement. Google Tasks also didn't come with a reauth flow. I think this PR looks quite done, I'll take a look at the tests now. After this PR you can add the reauth flow and I'll happily take a look at it Removed reauth from this PR. Will submit in a follow-up PR. This function is quite small, I would inline it into where you use it Move this to init .py as you're not using it here Can we type this? I added a generic type parameter to the DataUpdateCoordinator so now this method is implicitly given a return type. Ah cool! But can we still add this type as - .. ? I really enjoy well typed code as it also enables others to see what's happening. Fixed. I'd rather see the coordinator data to be a dict[str, device] than a list[device] Can we also check super().available Please remove the empty fields At this point, all devices are already present in coordinator.data, no? wdyt You just iterated over them, can you maybe use that list? I'm not sure what you mean with this suggestion, can you give more details please? Oh I thought you could've used the operation list, but vacation mode gets translated to off and that's filtered out Shouldn't the timeout be relocated in the library? Also, can you change your email? Don't think you need this one (I also removed this from the config flow scaffold recently) Can we make the config flow tests end in either Create entry or Abort? This way we test if the config flow is able to recover from an error. (This can simply be just adding the successful path to these tests) Maybe checkout pytest.mark.parametrize so you can merge this test and the invalid Auth one Oh i see you know about the function, i think it would benefit here Device registry is available as test fixture, let me know if you can't find them as I'm on the public transport right now Maybe look into snapshot testing, that would make this test way cleaner Please use the freezer for changing time Freezer Snapshot testing would work wonderful here
Can we maybe just update the options dict we pass in if its a file instead of duplicating the creation of the object Or use options {"cookiefile": cookies file} its not incredibly obvious how to use options {"cookiefile": cookies file} but I did the former requested change Please don't use info, debug would be more fitting here no problem, fixed. I got the advice to use path lib for this, I am currently in the train so can't really check I don't see any advantage in this but if that's the prefered way I'll use it. It means creating a complex type that has to be converted back to a string to be used.
Instead of serializing the calls and timeouts, can we do one timeout and one gather of all the coroutines? Could you add some context for this change? I copied the existing LyricEntity class, so I want to make sure there's a good reason for this entity to be defined differently. Also I'm a bit confused that this comment is suggesting I set attr device info to self. key while the next comment is suggesting that I set it to the result of get lyric device info . Set this in init instead: py self. attr device info get lyric device info(self.device) Same here: I'd like to keep this as close as possible to the existing LyricEntity class unless there's a good reason for it to be different. I also personally prefer to use properties for data that is derived from a member so that you can't have members that get out of sync. Why is the name composed like this? What's the device's name? Great question: these entities represent the state of individual sensors that are placed in each room. However, the data is not being reported from those sensor devices directly; it's being collected and reported by the thermostat device. So the device might be "Living Room Thermostat", but the entity might represent a sensor in the Kitchen. I don't want these entities showing up as "Living Room Kitchen Temperature" because that doesn't make sense, so I'm omitting the device name and using the room name that is configured in Lyric instead. If you can think of a better way to do this I'm open to it! Does the dependency bump need to happen together with adding the room entities, or can it be separated? I submitted a patch to that library that is necessary for this change to work, so the dependency bump could be done separately, but it would have to be submitted first. Happy to do that if you think that's the right approach and you're willing to stamp that PR for me! Same question about the name "Overall motion" read a bit funny, why not's just "motion"? You're right, it does read funny, and it might not translate very well either. I used the actual term that the Lyric API uses (the field is overallMotion ). They use that term because the value is an aggregation of one or more motion sensors. If you had two sensors in one room, for example, this would be true if either sensor detected motion. Similar reason why the above sensors are "Average temperature" and not just "Temperature". It's not accurate to say "average" for the motion, though. With that context, if it still sounds too weird I can just call it "Motion".
Consider moving this to the backend. I invited you as a collaborator. I've moved the code to the backend and pushed a new release and updated the dependencies Why is this statement needed? Good spot, it's left over from the auto discovery logic that I removed from the initial commit, where CONF HOST becomes an optional field and I was setting the default based on the value from user input if available (otherwise it's empty). But it is unnecessary for the basic config flow implementation. I will remove it This line is now removed We should provide MODEL NAME in the model field of device info. In the name field we can also provide MANUFACTURER NAME MODEL NAME or we can use device friendly name . In case of export, we need to use the name from YAML to avoid breaking changes. See example: L24-L28 or L291-L295 We also should set attr has entity name True and attr name None in the MediaPlayerEntity . See We should provide MODEL NAME in the model field of device info. In the name field we can also provide MANUFACTURER NAME MODEL NAME or we can use device friendly name . In case of export, we need to use the name from YAML to avoid breaking changes. I was already generating a CONF NAME but wasn't exposing that through - so I've now switched that to using just the friendly name and there was already a check to check to use the YAML name, which should now be picked up. We also should set attr has entity name True and attr name None in the MediaPlayerEntity . See Done Let's add host field description. Example: L6-L11 This has been added When I re-added the device, after entering the IP address, the integration asks to enter an access token, but the TV does not show it. To see it I had to enter 0000 . Maybe we should do this automatically like the Bravia integration does ( self.client.pair trying to connect with 0000 PIN which causes a popup on the TV)? L163-L166 When no access token is provided it is sending an auth token request already, however I have seen similar issues to what you've described. I think it's related to some timers in the TV as it is seemingly random. The way I had intended to handle this was by submitting an empty access token to force the auth to happen again, which in my testing usually works. But I note that this wasn't obvious this was possible. I've now implemented the ability for the flow to regularly send the auth request every second whilst we're waiting for the access token to improve the user experience, which should handle both the prompt not appearing (or briefly appearing and then immediately disappearing), but also removes the time sensitivity that was there previously. If you find that you still need to send an invalid token I can modify this to do so. Can we add a function async def async unload entry too? The way in which we distinguish between these two cases is not correct, because it makes no difference to the user. Instead, we should distinguish between: 1. The import is done, and the user should remove YAML 2. Somet
Why not make this self. min state duration min state duration.total seconds() and get rid of min state timestamp ?
I would move this list into consts.py Does this do blocking I O? Yes Typo in function name We don't need to get the disk mounts more than once. Same for network interfaces and cpu temperature. Break out those calls from the loop. Side note: The sensor update seems really inefficient now as it updates all sensor registry items even though the corresponding entities may be disabled. Maybe we already have plans to refactor that later? Yes, we should refactor that after this PR as it will now create a lot of sensors (even if they are disabled) I think we should import the config and enable the configured sensors by default. Otherwise configured sensors may get disabled. This could happen if the user would add the YAML configuration during the deprecation period, ie the user didn't have the integration setup before. The result would be unexpected as the configuration doesn't create enabled entities anymore. I guess we can add that without too much effort but seems a bit strange to "support" this as there will be nothing hinting anymore to setup from YAML. I think it's better to be safe than sorry. We can remove all that logic when we remove the import after the deprecation period. I made some comments to it in the code so it should be pretty easy for someone to cleanup once deprecation is over It would be good to allow the user to specify processes which are not currently running. Currently it seems that with each adding of a process, a {'process': ' process name '} is added to the options. Maybe it would be better to have a single process key and the processes as a list in the value.
Groups of binary sensors still have the domain binary sensor . It's legacy groups that have the domain group . I don't think we should allow those groups.
I am not seeing this option in the platform schema, was it removed in an earlier change? It is included in BASE PLATFORM SCHEMA , which is extended in line 33. Ah okay

Isn't this one obsolete because of the SIGNIFICANT ATTRIBUTE check below? uhhh ... you're right 7aa5e47
This is not needed. async write ha state is called after we call async update . L680 well but async update is only called for entities that need to be polled. ' on matter event' is called when there's a push update from the device itself ah... now I get what you mean... good morning. Probably use the debounce helper instead. Currently the loop.call later call is not a debounce, it's just a delay. Each event will still schedule a new poll and state update. If we want to debounce the events we need to have debounce logic. Example: L106-L117 We should test the logic here with a matter event. Example of how to patch the debouncer: L140-L158 Sorry, the comment is wrong here, we just want to delay it, not debounce Why do we want to delay the poll and state update? to read the energy meter value after the relay was toggled, consider it an extra service to the user otherwise it looks weird when you toggle the relay you wait up to 60 second to see the wattage change What Martin is saying still holds: how to avoid scheduling 5 polls when 5 events come in within a second. Use helpers.event.async call later . Make a constant for the time to make it easy to patch in tests. The async call later only seems to take a coroutine function and not a regular function ? I want to pass it "async schedule update ha state" including argument "force refresh". I could pass it "async update ha state" instead without any side effects ? Make a callback helper method on the entity that calls async schedule update ha state . The helper should accept one parameter for the time of the event and return None . Thanks, first time I had to use this async call later helper. Anyways, I've adjusted te logic a bit to use the helper and define the delay in a constant. We need to patch the debounce time to 0 too. Maybe update the code so we call it with kwargs in all places to make this a bit easier? The callback parameter, the first positional parameter, isn't optional. So if we're using kwargs it's always there. Yeah, let's do that as this is a bit cumbersome like this. I'll just adjust the implementation. done.
Are you able to add the other models of humidifiers? Models are listed here: done Great work! I was just about to start working on this today! Are you able to take a look at this attempt and incorporate where makes sense? In particular the modes and other models. You may actually be able to use the majority of this file: This came from a previous PR that was too large to merge: diff-4537c0d070b59657c8d13492856bea3d35a4f04be9fde4468634b82276316162 hopefully done Please make a separate PR where we import all the available modes here. L4-L12 I'm not quite sure I understand correctly. Instead of just MODE SLEEP I should add all missing MODE (in a separate pr) Is that right? Yes, please. All of these modes are documented in our dev docs and should be available in the humidifier package for other integrations to import.
It would be better to let stdlib do the validation by creating a UUID object uuid.UUID Done. Also added another test to reach the codecov target (we were below by some tiny number). This is likely to break in the future since there is no guarentee that the mobile app will continue to use this convention. If we want to do something like this, we would need to add a published api (in another PR) to the mobile app integration to get the list of UUIDs instead so we could be sure it keeps working if the mobile app changes how it registers these in the future. I'd pull this out of this PR for now since there are multiple new features in this PR which should be two (or more) PRs: 1. allow list for specific uuid 2. mobile app integration I'm all for clean APIs, but is there someone willing to make a PR on mobile app and have it merged quickly? (I don't have the cycles) If not I suggest we keep this feature for the following reasons: - We'd lose a good-enough fix for an ongoing problem (original issue is more than a year old) breaking functionality for many users while waiting potentially another year for the perfect fix. - We're not doing any crazy hacks with the internals of mobile app, just reading public entities, the risk of breaking is arguably tolerable - Even if it breaks in the future, the worst that can happen is to ignore beacons, which is exactly what happens now. So we'd be keeping a currenlty broken system out of fear of having the exact same broken system in the future. Your call, let me know if you insist on droping this. I think bdraco is right for this specific part. We can also see translated of renamed entities that would mess with this specific "magic" feature. I would advise to just remove that part, the allow list is already a giant step forward and still relatively easy for end users to voluntary whitelist (allow) what they want, and finally be able to track nameless beacons. Personally, I would even remove the 40004 trick, even if it's already merged on mobile. I think this could cause privacy issues because this means that I can be tracked or inadvertently track other HA Mobile users when they are around my house. I am not saying this is something new, but it would become more obvious that new HA mobiles are automatically tracked. Honestly, the basic allow list is the perfect and simple solution. We just need that and documentation (web site in the sensor description) for the fact that BLE Transmitter ID needs to be manually added to HA to track the mobile app. bdraco : how do you want to proceed? Btw this PR was meant to replace the 40004 trick, but we could also combine the two if we want a no-config solution for companion users. (Concerning privacy, the real problem is the unique constant UUID, changing the minor doesn't make it more trackable.) Let's take out the mobile app async refresh companion uuids related code here and only do the allow list. Integration with mobile app can be added later if an api is merged to the mobi
As discussed on Discord, I'm not a fan of the fixed interval. We should push updates to the receiver when the image entity is updated. The interval seems to be coming from the client side in the camera platform - I'm still trying to figure it out We don't need to explain coroutine functions need to be run in the event loop anymore. This should be a module level constant Why can't we write r n--frameboundary r n here, what do the extra -- do? Please explain it in a comment. Instead of this, I think working on a [ bytearray ]( func-bytearray) object makes more sense. This comment should be in camera.async def async get still stream too. Should we also explain here we consider the bandwidth waste a non issue because of the intended low framerate of image entities? Will address in a separate PR Why do we need to call drain , is it to ensure we write to the socket now and not later? Should we explain it in a comment? async track state change event accepts a string Please explain, in a comment, the error handling happening here. We're guarding against errors raised when writing to the socket, and we want to make sure we call remove() , correct?
You're using a coordinator so data is already present when you add entities, no need to do another update What does this return? We want to avoid putting a lot of data in these state attributes as they can blow up the state machine It's for getting games data to display it elsewhere (frontend, notification ...) See ![image]( While writting I thought that making a service also be a great solution. Emmm, can we call service and use its result in templates ? (as we can't in automations without a script) Yes we can! Since this PR can't make 2024.2, I think we can make some nice services in a follow up to have it ready with 2024.3 Fixed in 73c20f34803b0a0ec242bf0740494f17a68f6f59 Apply fix again in f3d475385aa2fb8e6c994237e000270e4ab095f8 I think what we are ultimately catching is a KeyError right? TypeError or KeyError , more a Type as on test tests components epic games store test config flow.py::test form cannot connect wrong param See But this case should not happen now as of new version of lib, so I refactored it in c0a3429e6063c38f7f67d0d56159df7f5077b2fd fixed in 14ca00a3c56cea41965ac676943957d035a86f37 unused Fixed in 040cf945bb5346b6d42b3782b5061a13fb7b1f6b CONF LANGUAGE is available in homeassistant.const . Done in 724ce255805e57ea05a7040f6e19d2b945ff67c7 Done in 724ce255805e57ea05a7040f6e19d2b945ff67c7 We don't need to check this, the base entity validates this constraint Done in 8b1d9ba Done in 8b1d9ba Move this to const.py Done in 10d0083 I don't think "zh-Hant": "CN" is correct, traditional Chinese writing is not used in mainland China. It is however used in Hong Kong, Singapore and Taiwan. I'd suggest to double check where the epic game store is available, and add options for that to the config flow instead of trying to guess it here, for example, maybe add zh-Hant-sg if the store is available in traditional Chinese in Singapore and so on. Fixed with 7a53234, the only thing the country change is the currency price. Tested with weird combinaisons, and working fine. I put the selector is the config flow so Chinese people living in France (or anywhere else ) could get the local currency price, with his native language
Fixed Done These 2 coordinators really look a lot like each other. Can't you maybe create 1 superclass with all the logic and then 2 subclasses which implement the update data function Done Makes pylance unhappy These aren't constants anymore so please use lowecase Done I think these functions could be one. If you make that superclass thing work, maybe you can just add a method to close the coordinator Done Can we use constants for this? I don't get what you looking for. I don't know what home p1 means. Something like AREA ARMED STATUS HOME or something like that would be clearer to read. What does this mean? If the Alarm device is in a non working state, the entity is marked unavailable. Can we maybe use a reverse map for this? so it would be like ALARM AREA STATES[self. area.human status] Dont' know how to handle AlarmAreaState.ARMED as there are 3 sub-types. You can at least change these 4 to using the dict Makes pylance unhappy Since the superclass ComelitCommonApi contains both .logout() and .close() you can make this one function again and then only check what type the entry is to define which platforms to unload Done Are all these three used right now? 2 out of 3, "Zone" will be used by sensor. Can we implement this in that PR?
While not required - I think it is typically better for these to be in const I checked a few other integrations and this always seems to be in init. anymore context we can give with these exceptions? UpdateFailed should typically explain why the update failed as it is user facing. I could be wrong, but since since I create the exception from e it should get its context from the upstream error. Turns out the update coordinator logs better error messages for these anyway, so Im going to leverage them. Why are you setting domain as a class variable here? I don't see why this is needed I dont know either, I did it in my other integrations (which I copied to make this one), ill check if its required. I dont think the if CONF ACCESS TOKEN in user input is needed, as it is required in the schema user input can be null, for example when the form is first opened. Oh I see what your saying, let me try that. This probably belongs in const This is probably opinion, but does it below on const if this is the only file that will use it? Not a bad idea regardless. Moved for all of these, name is not needed when you specify translation key Thanks, I've done that now. I would add an icon here to make it clearer what this is, since it will not automatically get one like you other sensors typing Done, Thanks you need to add an entry for each of your translation keys Oh right... From what I have been told in the past, you should just always set up all platforms, just to make sure one platform doesn't cause an issue with another. Personally, I'd recommend splitting this out into it's own class. It will give you more flexibility in the future and helps with readability. But I don't think it is required. I was skeptical, but I tried it and I do agree its nicer. coordinator.py has been implemented now. I believe this should only ever be raised in init. Since you are passing this in the coordinator, this could get called anytime the coordinator updates, which i'm not sure how it will be handled. I'd test this to make sure. I started rewriting this, but it turns out the update coordinator catches ConfigEntryAuthFailed and triggers the reauth flow. It looks like reauth will be a problem as the unique id should not change for the life of the config entry Is there a better unique id available such as the account id ?
Why is this necessary? The service is linked to this method so the only reason this should be called is if the SERVICE PLAY ON SPEAKER HUB service is requested. Unnecessary code removed There's a recent blogpost about entity descriptions please check it out Also. Look in the code for kw only. It can make you remove the mixin i will create a new PR for this
This can be a walrus. This too. Should we test creating items with the added data too? Done.

Should this rather avoid a default value to make sure all future PRs will not forget defining it? This would require converting this to a mixin and inheriting the HuaweiSelectEntityDescription from it and from the SelectEntityDescription . Yeah, why not, done in 8544e2451f5498ca0838b611930b49e0cd4340ca Just a suggestion, but maybe create a module global for the select entities and loop them over here for creation? Will avoid need to refactor in the future when new selects are added. I thought about it when working on this and in a sense agree. But I've taught myself to resist such refactorings until actually known that they'll be needed, an how. For this particular case it would seem future selects would fit in the way we'd do the refactoring at this point with the data at hand, but one cannot know for certain if some other things are called for at that point, and then we would have refactored twice. Certainly not a biggie and I can do it either way though. Your call, this looks good to me :-) We can use kw only True in the dataclass decorator to avoid the mixin for required attributes. We should assert the state of the entity in the state machine too. Please sort :abcd:.
This would break any configuration which uses CONF HVAC MODE VALUES, that is not allowed ! You can deprecate a configuration keyword, but it must be supported for at least 4-5 months, and users using it, must be given an issue, so they are aware that they should change. Happy to address this, but just to double-check my understanding of what is and isn't allowed. Since I've not changed the user-facing configuration keyword nested under hvac mode register (which remains value ), I thought this was permissible and not really a user-facing deprecation? I have created a second static CONF FAN MODE VALUES "value" to keep them both independent and leave the CONF HVAC MODE VALUES static class variable name untouched. Why should it be a list, are there fans that needs multiple values send to multiple registers to be set. Your documentation also do not explain this. I had only made this a list to ensure consistent configuration options to CONF HVAC MODE VALUES . I agree with you, I can find no real-world examples where this would be needed. What happens if this is false, and the values are defined as lists ?? What happens if one value if an int and another a list ? In short this is opening up for a lot of wrong configurations, the right way is to have CONF WRITE REGISTERS and values only as int. I'm totally convinced. Do you know of any real-world examples where HVAC MODE requires a list? Is it possible that that is just a legacy from when some part of this had less good multi-byte support? Happy to propose a deprecation as a follow-on PR if you'd like that changed to match this. With the current configuration, you will actually call with [[value]] I've removed the CALL TYPE WRITE REGISTERS (plural) code paths for Fan Mode and all support for lists. Why do we need a loop, it should just be indexed. I have copied the approach 15 lines above. I think the objective here for HVAC may have been to support many-to-one mappings where the external system had multiple modbus values that would map onto a HA state.
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries.
This should not log on a warning level. The same for the ones below actually. We should only log 1 time, of which the DataUpdateCoordinator takes care. Just raise an UpdateFailed (instead of logging manually). Thanks for the review! Ok, I understand that no explicit logging is needed here. If I raise an error, it won't retry immediately - I was hoping to prevent gaps in data caused by communication glitches which seem to happen with this device. I don't see a way of raising an exception and also retrying. If the solution is to wait for the next update interval then the retry logic is probably unnecessary. The issue of raising an error vs warning came up on the previous PR. discussion r1305557202. I'm trying to not generate errors during normal operation (sunset).
This endpoint doesn't return any data, right? Why would you need a DataUpdateCoordinator for this? Perhaps you can use async track time interval from homeassistant.helpers.event to call update dings on a time interval. (or maybe I misunderstood what you are trying to achieve here? The endpoint does return data which is stored internally in the api objects dings data variable. The entity then accesses the data via the active alerts() method which does some filtering based on timestamps expirey. It's a bit confusing but it's the logic that was already in place. However the next PR is going to drop this polling coordinator altogether and replace it with realtime push so it doesn't make sense to change this much now. Resolving conversation as iMicknl gave a thumbs up Have you checked if you can inherit from the CoordinatorEntity here? That would be the preferred way for entities that are based on a DataUpdateCoordinator. See L18 for an example. This would make your code also cleaner since you don't have to implement handle coordinator update everywhere, but you can just focus on your entity logic. Could be part of a follow-up PR as well, if this would add a lot of changes to your current implementation. All the entities are inheriting from the RingEntity which does inherit from the CoordinatorEntity . I've renamed RingEntityMixin to RingEntity in case that was causing confusion, so it's more inline with OverkizEntity naming now. Regarding the handle coordinator update implementations I think I'm only implementing them when I need to, i.e. when there is logic specific to the derived entity but let me know if you think I'm missing something. Resolving conversation as I've clarified that we are inheriting from CoordinatorEntity . Would it be an idea to add typings to cade you touch as well? Not a requirement, but would make the code a lot easier to read. And perhaps eventually (in a follow-up PR) you can get rid of the broad import ring doorbell as well. Done, I've added typing to all touched code. Regarding the broad import of ring doorbell I do that because when I then mock patch for testing I've always patched in the right place, i.e patch("ring doorbell.SomeRingObject") always works and I don't have to patch each module that imports a ring doorbell object directly. What do you think? Resolving conversation as typing added to all touched code.
I don't like this solution. I've a PR pending that exposes the circuit name ( that can later on be used here for circuits. For Burners Compressors I would at least omit the number if only once is present. I agree, we should try to solve this upstream. Not sure why we're appending a random incremental number anyhow to these? They devices doesn't have proper names? The heating device can have one or multiple burners compressors and one or multiple heating circuits depending on the model. Each of these components have sensor values in the api (like circuit temp, operating hours, ..), so similar entities are created multiple times. Currently they are all assigned to the heating device itself and to distinguish them entity names get the component id (0, 1, 2, ...) appended to the name. Thus I currently cannot implements translation keys. Not sure why we're appending a random incremental number anyhow to these? This I did to not list "burner 0" but "burner 1" as the first device. I meant that you are appending the number since I assume these actually don't have proper names provided by the api? Given the user can't diff between burners and compressors anyhow why not just name them without the number? Changed to use simple names "Compressor" and "Burner". device.getName is not async safe. Can a constructor be async or how could I solve this? No, the constructor can't await. Probably get the name before creating the entity and pass the name to the entity when creating it. I'd keep the name as it's called in the library. Is there a reason to rename it? Renaming it makes it harder to look it up in the library. Please see my explanation in this PR: r1406576321 Right, but that's a problem that the library should solve. We shouldn't change the name here unless it's clearer but I don't think it is clearer. Do these components really qualify as separate devices according to our current guidelines? Aren't these components just different parts of the same device in the same location? what-is-a-device Yes, that's correct. I would agree for burners compressors. But for heating circuits I think this is justified as the circuits usually supply different areas of the building. As seen here issuecomment-1786002580 it could get pretty confusing with multiple circuits, burners compressors on one device view. Grouping the entities together would also ease a proper (re)naming. We need to follow our architecture guidelines. If the circuits qualify as separate devices, it's ok to add devices for those. But we shouldn't do it for the other components that don't qualify. We're adding translation placeholders for entity names which can help clarify the context of different entities. We're adding translation placeholders for entity names which can help clarify the context of different entities. That's great! I consider this to be true for heating circuits. I will remove the feature for burners compressors. A device that offers multiple endpoints, where parts of the device sense 
Why is the mac address added as an identifier, is it to make via device work for the sub devices? Correct. The class name suggests plural, but the variable name suggests singular. Which one is it? Its singular. Looks like its misnamed in the aiolyric library that his object comes from. Please explain in the docstring that these entities will be subdevices to a thermostat Good call. Clarification has been added. One question that I have, currently an Accessory is bound to a room. Are there more types of accessories? Are all accessories bound to a room? I'm not aware of any other thermostat accessories for this device, but they all appear to have the same data structure from the Lyric API. The only values I have observed for accessories are Thermostat (which is a duplicate of the parent thermostat) and IndoorAirSensor , and looking at their product pages I can only find the one model of air sensor and no other accessories. IndoorAirSensor is the only value they use from within their API reference as well. Air sensors must assigned a "room" from the Honeywell app in order to be operable, yes. Unless there is a reason why accessory.temperature isn't Trueish in some cases. This also prevents a bug where the sensor isn't added if the accessory temperature is exactly 0 (since translating that to a bool makes it false) Nice catch! This has been fixed in my most recent commit. Nice catch! This has been fixed in my most recent commit. Maybe it would be more performant to await all promises altogether? asyncio.gather I agree with t3hk0d3, please use asyncio.gather instead, something like: Updated per suggestion; thanks for the code snippet. Re-tested locally and it continues to work as expected.
If config version is 1 then definitely these keys won't be in data So you would suggest by removing that check altogether because it is practically meaningless? Same here Entry migration happens under async setup entry inside init .py . The tests should reflect the same. I'm not entirely sure what you mean by this, do you want the test itself to be renamed or moved to another location? Should this go into test init.py ? engrbm87 I did not get notified on this reaction, so it took some time for this to happen; I moved it to test init.py, let me know if there is anything else that needs changing You should not call the class method directly. Instead await hass.config entries.async setup(entry.entry id) and ensure that the integration loaded successfully and that the config entry version is updated. Please implemented the above suggestion I've changed it in the way you suggested! its loading the component and after that it checks the migration Please increase only the minor version and leave the version as it is as this change is not a breaking change. See config-entry-migration Ahh ok, I missed that there was a minor attribute in the version for components when I created it, I'll try to work on it soon when I have some time! Thanks for the feedback btw! :pray: Updated accordingly! Please add the attribute sorted correctly Hey edenhaus do you mean alpabatically sorted? Because if that's the case, I need to sort also entries that I did not add. If there is another sorting method being used, can you share me where to find this? Because the docs don't seem to mention one Yes, please sort all items, existing and the ones you add, alphabetically Did this! Please specify the version directly in config flow.py Changed it and its now in the config flow Used your suggested change! It's not clear what path this is. Please add a data description dictionary with a path key explaining to the user what this setting does. emontnemery Would it make sense to also add it to the rest, because if I add en explanation to one, it definitely looks weird (see the example) :') I went ahead and only added the change you requested for now so at-least this issue should be resolved ![image]( With a full example here: ![image]( Yes, of course it's beneficial if you add the description to all the fields
A coroutine function isn't a callback. We can remove the decorator. We should not need to access the controller since we know the host and site from the config entry data. I think we've talked about this before. :smile: Probably , thanks for your attention to details Martin! I will add this to my list of improvements :)
I simplified the initialization in 0b5411d4ea64a5bd9f76186ae596dbd5d0e60348 as such: hass.data.setdefault(DROP DOMAIN, {})[config entry.entry id] {} hass.data[DROP DOMAIN][config entry.entry id][CONF COORDINATOR] DROP DeviceDataUpdateCoordinator(hass, config entry) Your suggestion was good, but fails because the [config entry.entry id] key needs to exist before the [CONF COORDINATOR] key can be created. Any reason you are prefixing the DOMAIN constant with DROP DOMAIN? Not necessary imo, and in this case it only confused me at first. ![image]( we should not use such short "magic" word for an integrations name ... how is about drop connect as the website calls itself and all the apps, too. I agree the 'DROP ' prefix is unnecessary and have removed it across the board in 1a3b630b474c551054932330a8763dabed553c04. It was just a pattern I saw in other integration projects as I was getting familiar with HA. I also agree that changing the drop domain to drop connect is reasonable. Our product line is just called 'DROP', but marketing started using 'DROP Connect' when we couldn't secure drop.com many years ago. Since then, it does get used for disambiguation from time to time. I'll make that change after I've worked through the rest of your (appreciated) suggestions. Changed across the board in d5a6dca2cbfcecb1030fb0bbcb64b020f3c48412. Are you sure this is required? My belief was that having mqtt as a dependency would be enough when using async setup entry . The Tasmota integration is not doing this either. But a core reviewer with more experience can verify this probably. I think it is cleaner as-is. If I disable or remove the MQTT integration I see the expected 'MQTT integration is not available' entries in the log at startup. Without this test, I see stack traces instead as the MQTT subscriptions fail. nit: you could also move LOGGER to const.py and import it where required. I actually started with the logger defined in const.py but later moved it to each module so that log entries include the module name, which I found helpful. A cursory survey of other integrations shows that this approach is very common, so I'd like to leave it as-is if possible. Do you need a constructor here? Should be fine with having them as class variables. You could also think about setting them to str None and setting the initial value to None instead of an empty string. It works fine without the constructor and initial values were changed to None where appropriate. Changes in 653064f6c4ebe83b575342e0dd428cd0436a34d8. Is there no way to set this up manually, in case discovery doesn't work? No, there really isn't. The MQTT discovery payloads include a device ID number used by DROP to address individual devices. (e.g., you can have 50 leak detectors on one DROP system) There isn't any way for a user to be able to predict that device ID number, and it's used to construct the MQTT topics used by the device. Addressed in d5a6dca2cbfcecb1030fb0bbcb64b020f3c48412. Have you checked 
Do we need to reload the integration? Where does that happen? The device is removed now for this case, and if the device will be added again by the driver there will be an event for that and it should just work without reload, I'm thinking. to be honest I am not sure why I changed this notification. I don't think this change reloads the integration, it just removes the device. So I think I can just revert this and change it back, let me know if you see any things I missed where we actually reload the integration Yes, I don't think we need to reload. I'm missing some new assertions for the changed notification message and behavior, if that should change. and I think if this revert is accurate, this is also not needed? We should assert that the Home Assistant device was removed from the device registry.
Why don't we set the device name here? self. device.device name Device name would then be "HvacFnct21y A" (for my unit). Or should we try to get the model here instead. I.e. in my case that would be "Flexit Nordic S4". As long as the user can identify it Fair point! I will set the device name. I am no expert on climate entities, but have a read at Okay, it seems that auxiliary heater on a climate entity is deprecated? So then we should add "a switching entity and add it to the device" or simply remove the aux heater in this PR for now? Removed This function is fairly small, I wouldn't mind if you inlined this Fixed Maybe move these to conftest.py? Do you mean like: ? Done Checkout pytest.mark.parametrize you can easily throw different parameters at your test. checkout the Lastfm config flow for an example Fixed! I think the device name would be friendlier to use here I don't think I really understand, can you give me an example? Oh! You mean to return device.device name instead of device.serial number in validate input? So that title becomes the device name instead of the serial number. Fixed Done Can be put on top Done Removed Removed Fixed
Is it intended that this is the same key as in the description above? Yes, because only one of the two can be present. It is basically the same feature: Animal detection is the extended version of Pet detection. This is done so users on older firmwares that have Pet detection will not need to change there entities when upgrading there firmware to get animal detection instead of pet detection. Okay, perfect, I just wanted to be sure, but I suspected something like this Same as above Same Please use a parenthesis and indentation or break out to a separate function to make it easier to read. Lambdas that span more than one line without parenthesis are hard to read. Thanks for the feedback, I fixed it in this PR:
Outside of constructor What do you mean? It's in init ? It's set to a static value, so it can be set outside of the constructor Right, so the opposite ;) Tried to not touch the existing stuff but mypy complained to much btw: with this the Name becomes "Time Date Date Time" (as example for a date time sensor. The naming of device sensor on this one looks really strange. Any idea? Same This could be rewritten as a list comprehension: But I don't know what the preferred way is here. I'll change that. Why do we overwrite entity id? This allows integrations to suggest an entity id, at the same time I'm not sure why that is added in this PR. I know, but I don't really see the point why we should add it It's to avoid having entities like sensor.time date date time which makes no sense That's a good point lol We still need to fix the naming issue on this one. We can't have Names like "Time Date Date Time". I'd like to have the device but I'd like to get rid of it's function for the naming but haven't looked too much at it yet. Hmm, there's an architecture discussion for exactly this issue: Yes and no I guess but if we could get placeholders I could at least put - in between the device and entity name or such to make it somewhat better looking. At the moment not having that is a showstopper unless I abuse the entity internals. This integration can only exist once and will always work this way afaict. Is there a reason to add the entry id as well? Not including the unique id means entity registry UUID as well as entity id will be stable if the config entry is removed and then readded. That's probably a good thing, and we can omit the entry id. WDYT gjohansson-ST ? Seems legit. It's just a habit to add entry id from my side. idem We need some kind of identifier though. Maybe just (DOMAIN, DOMAIN) ? I've seen that before, that works I'm assuming we'll get rid of the direct entity tests and move to tests via the state machine in a follow up PR? In a follow up PR we can use snapshots for this This title should be translated, but maybe that's not possible? Not possible to translate the config entry title as far as I know Let's not make it a helper, similar to how sun and moon are not helpers. Maybe service would be better? Hub doesn't really fit as well.
This is already the default provided by the CoordinatorEntity, and thus can be omitted.
This seems like a personal mount. btw, if you open 2 dev containers but use same disk, you can just access the other files. This is already validated by the previous validator used, cv.datetime . Validation happens sequentially and the output from the previous validator is input to the next validator. OK, I went ahead and just removed the validator and replaced it with a direct usage of dt util.as local in the schema. This seems to be a duplicate of the line above? Removed line above. I think we should name these similar to the existing ones. Eg: SET DUE DATE ON ITEM . Renamed. These aren't really configuration, I think. It's more attributes.
There is already a service for setting temperature so this only makes sense if end datetime is not optional. See async service set preset mode with end datetime() which had the same comments in a previous PR That had confused me a little as to why the end date time was required when it is not for the API. I understand wanting to differentiate between climate.set temperature and netatmo.set temperature . It made more sense to me to have it as set temperature as that is what it is primarily doing, just with some additional optional functionality which the netatmo ecosystem provides. This is currently only a single additional argument but that might not always be the case and there may be many combinations of available parameters in future. Having it optional also provides the user with the guidance that it will use the netatmo default if not provided. The set temperature service currently does this silently (3 hours). I can change it if you still prefer. I certainly don't like it being inconsistent with the set preset service. It just felt like the more sensible name to me for future maintenance and possible expansion. I've looked through the other PR. As far as I can tell the naming is the only issue so far. I'm not clear on the process so I've marked it as ready for review again for this comment to be considered. Apologies if that is wrong. I also realised my use case (and I expect many other automation use cases) would require the use of jinja to determine the end date time. It seemed to make sense to have a service to handle time period as well so I've added that. I think we should probably try to mimic what's in the "official app device". Do you select an end time or a run time? We could of course do both services but I wonder if it really makes sense. For setting the value, the app shows the time period as a slider and defaults to 3h. For displaying the current manual boost, it shows the time it is active until. The API works by timestamp. I added the extra processing required for time period to avoid having to use as much jinja in automations, but I can see a use case for either. e.g. Set temperature for 3h while clothes are drying or set temperature until 5pm when finishing work. To set until a given time today, jinja would still be required to work out the date, but it would be much simpler than calculating the time period (e.g. {{ states('sensor.date') ' 17:00:00' }} ). Likewise, having a service to boost for a given timespan would potentially satisfy most use cases in the UI. Working only by datetime would involve some complex jinja to calculate the correct end time. Maybe HA could handle this automatically in future by having the datetime selector work with times relative to the point when they are triggered, but that is a very different feature. I guess with either one implemented, the alternative can become a blueprint script. How would you like to proceed? For preset we implemented it with and end datetime. What's there in the app? F
Can be removed Should not be an extra function done If I see correctly we allow more instances of this integration right? Should we store data in hass.data[DOMAIN][entry.entry id]? I use the devices property to store the instances. Just like abode and owntracks. This also means the heartbeat won't be stored for every entry, only the last one if I see this correct? Why do we make this so complicated and not just a list set with the types? This is for the new devices that will follow. A device may have multiple functions. But isn't this the same as: { EHUB: sensor, ...: sensor, ...: sensor } ? I don't think this error message makes a lot of sense as this is only checking against a list. I don't think it will suddenly lose an entry. Integration may not yet be supported when users use a new type of device. Yes, but the "If it worked before" doesn't make sense. Also, we use GitHub issues for bugs and not for feature requests, so I'm a bit doubting with this one (like, yes it's not working thus a bug, but it was never in the scope, thus a feature request) We don't need to import here done It's still there? Should we log something? Does this mean the device is off forever? Why don't we raise ConfigEntryNotReady? Please move reauth to a follow up PR Do we know what the possible values can be? Why isn't this a coordinator Entity? I'm sorry for the trouble I caused. Please check:
This seems to be outside of the scope of the PR. Is it related? The code suggests the function tests if any camera is in use, is that the case? If so, update the docstring to: Please rename this to value fn since it's a function, that should be done in a separate PR though.
If you feel extra fancy, maybe you can do (but in a separate PR of course) the fields in there are device info and name right? Is there a reason we call them Device and Name here? The backticks will make them look like they are code, but apparently they are not Personally I'd use more constants here, because you're also going to reference these fields later on and it avoids typos and stuff. But not a blocker What's GA? Side note: do we have multiple places within hass.data where we store KNX data? Ideally we only use the hass.data[DOMAIN] How often will both be true? If it will be for most of the time, rather group the entities and call async add entities once Why only set attr has entity name True when there is device info present? Not sure if we have guidelines with test coverage and websocket calls If its an object: if its an array Typing? Stale

Be more specific e.g. bool float I guess I think it's better to overwrite this in the platforms if we need it to be more specific (Number, BinarySensor). ? Use translation key. Should not be done in separate PR (that can cover the other platforms afterwards) The entity names are based on the number of heating circuits that are installed and get the heating circuit number appended to them. To using translation keys is not possible as far as I know. An idea would be to have circuits in general as own devices provided by the heating device and to so also for burners and compressors. The entity names are based on the number of heating circuits that are installed and get the heating circuit number appended to them That sounds like that should be part of the device name and the entity name should only be Normal temperature which is appended to the device name. I would suggest to make a preliminary PR to fix this prior to this PR Addressed First step done with Don't like spaces or such in keys Why isn't this just inside async setup entry() ? I just copied the structure from the other platform and didn't change it. There it it done because there are some blocking function calls in there. Will check if we can refactor this here. Why isn't this just inside async setup entry() ? We can just set this once during init addressed with Can we do something better here than flooding the log in case there is repeating errors? We probably could raise PlatformNotReady instead, but I suggest to handle that as a whole for the other platforms as well. This should probably have a DataUpdateCoordinator anyhow but was more thinking can we log once instead of repeating every x seconds when it tries to refresh the data. By accident translation keys have already been added with Why the addition of float? This should return a number already or None (which would not work)? The lambda returns a float, that's true. But [the getter]( L39) is defined in the interface to return a bool. Then I suppose you should overwrite it here or probably fix the base entity description as it can clearly return not only bool. Actually the library is not really types and the function just return Any . Is it now better to use Any as well or assume the types based on the api description? Probably on the long run the library should be typed. We should set the right NumberDeviceClass and then we can remove the icon I think as frontend would set the right one.
Will pull this into a separate PR I added test coverage for all integrations because they all have slightly unique ways they update state. Question for reviewers: This does not seem like a common pattern, so wanted to double check there isn't a better way. Essentially, we want to send an update every type there is a potential state change or refresh of data that works across all the todo entity integrations, given the list of items is updated via state change. I think it's ok. Platforms or other parts of integrations should use an event listener to track state changes, but if we would do that here, I think it would be unnecessary overhead, performance wise.
suggestion if not self.status["enable"]: return HVACMode.OFF return HVACMode.COOL if self. thermostat type "cooling" else HVACMode.HEAT Can you add a test for this guard? There is an example in Gen1: L119-L130 Done
Only use dict.get(key) if we don't know that the key is in the dict. If it's only used for typing we can import it under a TYPE CHECKING check at the top. Should we consider to make this a decorator? Currently, this code is used only once in the entire code base. We could make a decorator out of it when we implement it a second time, or are there other features pending that should be available only on a local IP? Let's convert it into a decorator as soon as we have more use-cases. additional data is never reset, so any auth provider after trusted networks will have the keys added to the result Nice catch :) Fixed with [ed5fdc9]( No need to create a new dictionary. You can assign a key to the existing additional data dict for this loop iteration.
Can we use translation keys? Not sure just a personal preference. just a personal preference. Is there a better way to get hass than handing it in the entity here? self.hass will be set on the entity once its been async added to hass Totally forgotten that Python already has a built-in ConnectionError . So you would need to rename this. Ok, nvm, you already did this These values are picked from my heating device, but the vary a little bit on the min values for other devices (e.g. [VitovalorPT2]( L439-L463C10), [Vitocal300G]( L335-L350), [Solar]( L17-L40), [VitolaUniferral]( L1910-L1933)). But will add the functionality to read this values from the API. Is there a way to avoid the get before setting? I had no idea how. The api exposes only the ability to change both at the same time. Would it be better to have that operation inside the library? I think that's fine. Workarounds based on the states or similar would be too error-prone, I think. Ah, just one small thing I learned lately: use parenthesis for multi-line lambdas Like this? Nearly, when running black it looks like this, which is more readable: Oh I just saw this, you can use set native value here instead of the async one. The await self.hass.async add executor job isn't needed as well. We're not allowed to use the async API from sync context. Use self.schedule update ha state to update state from sync context. Thanks for spotting that!
The sensor has a limited set of (non-numeric) states. The options property must be set to a list of possible states when using this device class. I think we should have the options defined here as well. only I don't know which values to expect here, so far I have only seen "ready" on my heatpump, others have seen other values if we don't know all possible values please remove the device class I wonder if this should be added to [ UnitOfVolumeFlowRate ]( L776C37-L776C37). not sure, since native unit is "liter" according the vicare api (which should be "liter hour" offcourse) and UnitOfVolumeFlowRate doesn't support "l h".
You can use entry.async on unload here to remove the listener on unload -- 44ffcb0 All this code is duplicated from the original call to add entities. Better to have a common function for both. There is always the additional ckeck if ain in event.data.get("ains", []) included, to just add new devices. So it needs a common function, which can differentiate between "add all" or "add only the new one" They will always be new the first time around. Just have the set of added devices always available Don't use the event bus for intra integration communication. We have the dispatcher helper for that purpose. You could keep a local list in this platform with added devices. Now its somewhat racy for coordinator to know when to clear that list. the coordinator clears this list at every data update run, the platforms only check this list, after the update run has completed, so this list should always be up-to-date and platforms should only "see" really new devices. hopefully i do not miss something The signal listeners may not execute right away. So the signaller will run async from this and might end up updating again (somewhat unlikely but possible) Missing callback marking. Right now its executing in executors. Just have devices set() locally here instead. Or pass the new devices as an argument to the signal. you mean something like this? hass.data[DOMAIN][entry.entry id][PLATFORM DOMAIN] would be initialized during entry setup added devices [] is perfectly enough. It does not need to be shared between platforms. you never stop learning i assumed that i've to "store added devices somewhere" to have it persistent for upcoming calls via a signal call callback is still missing a set would have been better here to avoid linear search. I missed this. You will trigger this on each data update. It will iterate ALL devices in each platform on every data update, this is too much. Your old new devices solution was actually better. Sorry :) The alternative would be to have add devices take a parameter with a list of ains to add. Then have coordinator keep track of when a new device shows up and trigger a dispatcher event for this. (I thought you already used a dispatcher event). But.. since you are piggy backing on the coordinator listener your old solution could have worked. We generally dont use that for non entity updates, but i dont see why we cant. So might be better to revert to your old version. what do you think about this solution: e511040 ( only applied for binary sensors as showcase, when agreed i'll add it to all platforms ) This is guaranteed now. So just remove that check. Just calculate the new data here instead. I'd inline this code. We can remove the brackets to make it a generator expression instead of a list comprehension. 104267
For this code base we want ternaries that span multiple lines to be converted to if blocks Ah yes they are way easier to understand ) unreachable since its guarded in base climate entity Guarded in base entity class Aux heat had been deprecated. Should we revert this PR? CC jesserockz bdraco
Does this automatically localize the name of the holiday? Good catch, thanks. Now it does. When is country not set given that it is required? Seems like this is always true so the if statement can be omitted. I got some mypy errors in between, so I added that. I'll remove it. Is there a case where list supported countries returns something different than whether or not this supports subdivisions? I was wondering if only using list supported countries and seeing if its empty is equivalent, then both the provice list and this check we know are consistent since they are using the same source. (also we already call list supported countries once for the schema here, so there is an opportunity to only call it once and get all the data needed for the entire flow) The description presented to the user for this step are "Name" and "Country" and i'm not exactly sure what we're asking the user to enter here. Is name needed or can it be omitted, and just set the title automatically based on the country name? I was thinking about that, but I wanted the users to have the possibility to set names so they can e.g. set it to the names of friends or collegues who live in different countries. I thought this would be more flexible for users, but it's fine for me to omit the name completely and set it based on country subdivision. OK, in that case my thought is that given the integration is using unique ids, users are able to use the built in features from Home Assistant to rename the calendar or the entity id like they can with any other entity. Your use case makes a lot of sense, though it is not unique for this integration and can be achieved using the already supported method. Early exit could improve readability by removing the indent. Flip the if around and return early? Same as above, I got some mypy errors in between, so I added that. I'll remove the if statement. This returns events that are outside of the range requested which breaks the API semantics. See get-events for the expectations. The parent class already sets a location attribute from the CalendarEvent so I don't think this needs to override that. Set it via the CalendarEvent ? See calendarevent for the supported fields on the dataclass. Is this here and below handling timezones correctly? I think this ignores the home assistant timezone so it may be off. I think event can be removed from this class? e.g. This seems to me something that belongs in the config entry setup flow, and not in the options flow. You mean like STEP USER DATA SCHEMA ? How can I pass self.data[CONF COUNTRY] then? How can I pass self.data[CONF COUNTRY] then? Make it a two step flow. Sorry, I still don't understand. Can you point me to some example or documentation? Just wanted to say I'm also not sure what the gap is here. I currently read the code as being a two step config flow and not part of the options flow. My impression is options flow means the flow where you change configuration options for the integration after it is
Move here and below out of the try except to minimize the except scope to just what is needed. Perhals an else: . That's done. Also done in async step user for consistency. Can you also test where the user fixes the error and goes on to succeed? Helpful just to make sure the combination of flows still gets the user to the right spot. Done While you're here changing this, it could switch to mock ring auth too That's done. Also done in test form for consistency Can you send this as a separate dependency bump? Makes it easier to review when the PR is doing fewer things. In this instance the dependency bump needs to go in at the same time as the code change. This is because the new exception types in the ring doorbell library are raised in the case of authentication errors and the oauthlib exceptions that the ring integration currently catches are no longer raised. If the bump goes in without this change the existing authorisation flow in async step user will break. My assumption is that doing the bump and swapping exceptions is a little more mechanical (and can still preserve existing behavior) then actual reauth support is added second. I may have misunderstood though. Understood, that's now done, see It seems like the 2fa user and 2fa reauth flows could be combined, where differences are fairly minimal (just the schema?) and be handled by checking for the presence of self.reauth entry . I would suggest just inlining show reauth form and show user form -- while the overall method would be more verbose, its easier to understand what is happening if its in a single place without jumping up and down in the file. Both these suggestions are now done. I'd say inline this Done Here and above: The preferred approach is just have the patch method as the parameterized method, avoiding conditionals in tests. (Then If the behavior varies too much, then just copying the test and code is preferred) Fixed It's good to use a constant for strings that are used more than once. I'd use a constant CONF TOKEN for "token" . Hi Martin, yes agreed. I started to introduce constants with this PR and thought about replacing all the existing instances of "username", "password" and "token" in the integration then decided to do that in a separate PR. I should have brought the CONF TOKEN in at this stage but will definitely get to it. (I'm hoping to get the integration to platinum level soon and I know this is a base requirement :) Good, thanks!
This is only ever run once, so you can use hass.data[DOMAIN] unique ids are per domain platform so you can drop binary sensor L36 You can set this as self. attr entity registry enabled default I'm also not clear why you would create one if it would be disabled? the source will already be SOURCE IMPORT so I think this line is redundant Oh, I see you are combining device tracker and binary sensor I guess this makes sense Yes, I combine them and only want to activate the sensor that the user has configured in YAML. I'm pretty sure this platform supports shorthand attr as well Yes, attr unique id and attr entity registry enabled default are supported. I need to use the property attributes ( the shorthand attr are not supported. I'm not sure we should import them at all since we want to allow both like Also this would avoid this problem: unacceptable-sources-for-a-unique-id Reverted the import completely. Generally we try to avoid collecting a name if we can. Another option is to use the config entry title to generate the name so when they rename the config entry, it would generate a reload ie entry.async on unload(entry.add update listener( async update listener)) We use this pattern in a few other integrations to still give the user the flexibility to rename and its also nice not to have to manage the name in two places There is an example of this in flux led . I think wled might do this as well Thanks a lot, will have a look Have changed this now Since we have both sync and async code in this code base, please prefix function that are safe to run in the event loop with async
This test is for SHMOS-01 , there is no change log for this device so the result should be None . But I agree this is misleading. I just added more parameters for this test.
Can use device class translations
We can leave this out, it will pick up the name from the config entry as a fallback automatically. This is mostly mean to connect devices, not services. This last addition doesn't make much sense to me. Even connected through the internet, these are still cameras. If this was done because of providing images, then the answer is: This domain should no longer be used for that (we now have an image entity for those). .. Frenck Oh yes, I didn't have the "image" entity in mind anymore, that makes perfect sense then. Will revert this.
Suggestion accepted, thanks. Suggestion accepted, thanks. This is now part of the manifest Suggestion accepted, thanks. Please move this to your init .py. The logic for connecting should not be part of your cover.py. See (and many other integration) for an example. Thank you for your suggestion. My understanding is that since a leviosa shades can spawn multiple entities, this curtain controller is essentially a wifi to IR device, but it can control up to six groups of covers, so it will derive up to seven entities, such as group1 - group6 and group ALL , so we need to call the async add entities method inside the async setup entry method, but obviously the async setup entry method in init .py doesn't have an AddEntitiesCallback parameter, so it's not possible to call async add entities inside async setup entry in init ,py anymore. I'm currently stuck at this point and don't know how to proceed from here, again I'll ask you for your advice, thanks! By the way, I looked at your sample code and I see that your scenario is logging into a cloud account and then being able to register multiple devices , not entities , And the situation I encountered is that one device supports multiple entities I refer to: L22C13-L22C13 greg-ha-1990 in the example you link to, the hub is instantiated in init .py and retrieved via the hass.data . This is the same as my suggestion. Set up the connections etc. in init and create your specific entities in cover.py. Please don't resolve conversations that you didn't fix. This makes it hard for reviewers to look at the open issues. Best to remove this from your initial PR. It is not required as base functionality and can be added in a follow-up PR. In the future, it would be good to add comments here to clarify what this does. See service-descriptions. There is ambiguity here, what it really means is for the motor of the cover to advance the cover to the next position , I will update the naming of this service to make it easier to understand and avoid ambiguity. What kind of discovery is this? Normally we should not use the user flow for discovery, but the existing SSDP DHCP discovery. We use the SSDP protocol for device discovery, and I know HA already supports SSDP-based auto-discovery, but I still prefer to put it inside leviosa shades instead of reusing the public SSDP discovery functionality because I want to customize the presentation of the device discovery page in a way that can help users understand the difference between different leviosa shades, and I don't want to scatter discovered leviosa shades in a massive list of chanting HA auto-discovered devices; in fact, I'll even hit the ignore all button And sometimes the public device discovery function cannot complete all device discovery well. Can I keep it in my own integration? No, you should use the built-in SSDP flow for this. You can set a name description for any discovered device, thus you are able to customize the presentation of your devices. You can still 
Does it work to call on message received to avoid the message parser and just pass in the RoborockMessage directly here? Yes that works - there was a problem that made me not originally do that - but I must have solved the problem because it worked perfect this time. Thanks appreciate the review - this looks a lot saner now
Please set these in the constructor, having mutable dicts outside of the constructor can have unwanted side effects In fact we don't need to init them here, since set fan speeds is already doing that, so I will remove the {} from here. Sorry, I just copied this from the airzone integration: L118-L119 In fact we don't need to init them here, since set fan speeds is already doing that, so I will remove the {} from here. Sorry, I just copied this from the airzone integration: L118-L119 Done in cdbe317185844534075504d610aec0a92beb640e I don't know if its possible, but can we give the names some more context? We now have speeds , speeds , self. speeds and its kinda confusing Done in cdbe317185844534075504d610aec0a92beb640e I have the feeling this function is probably a tad too complex, but I have no better way. But if I understand correctly, we will create fan modes depending on what the fan can do. Is this maybe something to move to the lib? Is this HA specific? This is pretty similar to L152-L171 but as opposed to the local integration, in which all devices seems to support 0 (auto) speed, some older cloud devices can only be set to manual speeds... Also, for me this is more Home Assistant specific, since this function allows us to expose common fan modes such as LOW , MEDIUM and HIGH , but it also adds the rest of the speeds as a percentage. This is done so these speeds can be exposed to Alexa, Homekit... See issuecomment-1542049704 Done in 1feff044ffb5fa9a53c77b06e531587d3216da4d I think the way this is written is almost unreadable, I suggest to just write it out; the total is even shorter this way: emontnemery I'm OK with the change proposed. I just did it as suggested by bdraco on the local integration: discussion r1191977727 L56-L70 Done in 1feff044ffb5fa9a53c77b06e531587d3216da4d The docstring says we're initializing, I think that would work better in the method name too Done in edea3571bba63f7041003dede1eb5225caca5302 I suggest styling it like this instead, i.e. with a space before the -sign: I prefer to keep it without a whitespace, since that's how I implemented it in the local integration: L169 Why do we want the list to be: Instead of: If there's a good reason, it wouldn't hurt to explain it in a comment. Because only the default speeds are exposed via Homekit Alexa, and this is the only way of having N speeds and also getting the default ones exposed. Done in 0f4566fd7b73df8542737d0ae8a6c9adc66bc820 only the default speeds are exposed via Homekit Alexa The Alexa integration does not support fan speeds for climate entities. For homekit there is such a limitation though L313-L317 I'd like a second opinion on this design, integrations should not have to solve limitations in voice assistant integrations. gree adds additional fan modes with a list like this, but maybe it doesn't work here if there can be many fan speeds: I'd like a second opinion on this design, integrations should not have to solve limitations in voice assistant integrations
Please sort this alphabetically I think might work better as you're also using opengarage as variable name at some places Personal preference For certain platform you can add a device class and it will take the name of the device class. So if you remove the translation key here and from strings.json, the button will be called "Restart" (which is also in line with other integrations) Apparently you can give the OpenGarageEntity an entity description and it will set the entity description and the unique id. no need to do that here as well
Wouldn't it be better to check if the process is found, if not, raise an HomeAssistantError (they can even be translated nowadays). We dislike to log on info, but I see that you do this on more places, can you maybe fix this in a followup? Will do, I've changed the ones here to debug level I think this should be a ServiceValidationError , because the user supplied an invalid process ID and there's no reason why we should spew a stack trace in the log when that happens. Background in Changed
We won't accept more code that includes protocol details in this integration. Those should be extracted to a 3rd party library.
Since you're the dev behind the library, maybe add a py.typed file in the library to avoid these imports I don't really like the way this is set up. Can the MotionMount lib maybe create a function to add a listener afterwards instead of during construct? This can raise, but we don't handle it Hi joostlek, This is not the same: the mac address can be either None or EMPTY MAC to be invalid in this context. oooh, my mistake! I don't think we need to store the name in the config entry data For the callback, can't we instead ask the coordinator to do a refresh? I'm sorry, but the exact working of the DataUpdateCoordinator is a bit mysterious to me. You mean I call await self.async request refresh() in this callback and merge get data from motionmount() into async update data() ? Hi joostlek, I tried to get such a thing working, but since the callback is a synchronous function I can't call await self.async request refresh() . Due you have a suggestion here? This can be a shorthand property ( attr device info ) (if doing that, ignore my comment about removing the constructor) Can you elaborate on 'my comment about removing the constructor'. I don't see a comment about that. Sorry, I missed the hidden comments.... Can we use entity translations? Can we use entity translations? Just asked someone else, can you give this a shot? That gives me "'NoneType' object is not callable". It works if I move this new code into the motionmount callback() , but it makes the system rather slow in updates as the update request is delayed. This might be a feature, but it is nice to see the sliders respond almost instantly to updates. I think there is also an async refresh request waits a few seconds to group any other requests Indeed! I've updated the code. It still uses the motionmount callback() to avoid the 'object not callable' error. What do you think of this setup? This way you keep the logic to get the native value at one place and don't duplicate it. Other solution would be to extract the setting of attr in a separate function. Checkout Airzone (or cloud, don't know out of the top of my head) Are you going to add more entities? Maybe take a look at the entity descriptions. This way you create 1 generic NumberEntity, and then use descriptions to make it specific for that one. I couldn't find any documentation about the entity descriptions. I'm going to make more entities, but not number entities. There will be 1 binary sensor, 1 select and 1 sensor added. Will it then still be useful to use the entity description? In that case I think this is fine. It could make the code a bit cleaner but that's no requirement for this PR imo. (Checkout youtube sensor.py for an example for how the entity descriptions work). But I'll leave that up to you. The coordinator already catches their own exception, can be put outside of the try block Please specify what Exception you are catching
Please don't implement tests of the remote entity in test media player . Instead, refactor the relevant media player tests to extract a common helper for testing services, and store that in tests components androidtv common.py Done as requested (with some PR in the middle ) Isn't the naming here confusing, the patch is not the service call, it's the API endpoint we expect to be called by the service call? Yes, fixed We should also assert: - The number of calls - Call parameters Added checks It's not clear to me how the tests shows how the UnicodeDecodeError is handled. This was because the decorator normally set the entity as not available, but for sure was missing a cap log check. Anyway I changed the logic to raise a ServiceValidationError and so I changed the tests Shouldn't we raise a ServiceValidationError instead, since the UnicodeDecodeError is a result of the user passing in invalid data? Yes, done. I also changed the decorator to allow the raised exception to be thrown.
Why must this key be required? I think optional is fine. When we use optional for this new option, we don't need to change the version and therefore we don't need a migration. You're right... I removed that. Why are you setting this to None as the default value? We should avoid if statements in tests. Please create a own test for it Removed, this is already handled in test state always available . Same here. Please create a test for yaml and one for config flow. You can create a protected function for the shared code, so you don't need to duplicate it The pattern used in testing this integration is to test the sensor coming from the yaml configuration or configuration entry in the same test (see test state ), I just kept this pattern. Do you want me to separate the test state always available test into two to handle the yaml configuration and configuration entry in separate tests? I would like you to confirm this before I change it. Okay we can leave it for now and we should refactor the whole file in the future. Please add a new config flow test about the new field Added to the existing test options test Could you please add a test where you are also setting always available during config flow? Included the test always available test for this.
Does this need to support unregistration when the config entry is unloaded or the entity its supporting is disabled, etc? My impression is that this returns an unregister callback. at the moment ( only the Proximity entity is there ) there is no configuration entry, nor is the Proximity entity configurable via the UI, IMO those this support of unregistration needs to be added at least when the configflow ( those the config entry ) is introduced to the integration. Is this valid? The default is None but not represented in the type? should be more clear or better resolved with 9c0bdb3 Given this is not polling, and registering its own callbacks for tracking state changes, i this really meeting the spirit of a DataUpdateCoordinator ? It seems like it may just be its own object for tracking state so i'm wondering if perhaps its not getting value from subclassing this, or if its not a good idea to subclass. i considered to go with DataUpdateCoordinator because it already brings everything needed, so registered entities get notified and values updates as soon as the data update on the coordinator was successful. this is also to be seen as prework for adding the sensor entities. What does it mean to have new state? I'm wondering if it means the data is unavailable and should return None vs preserving existing data. Curious to learn more about when this can happen and what it means. this all is moving existing code, so tbh i'm not sure in which circumstances the new state could be None , but it seems to be foreseen, as the async track state change use it as signature for the to be called function: L170 Agreed, I see that now, thanks. Are these devices or entities? Given its pulling hass.states i'm assuming they are entities, so wondering if the variables should be renamed, or if there is something else here specific to home assistant devices. I realize this is moving existing code so it could also be future cleanup. you are right, these are actually entities of type person or device tracker ... but as you mentioned, this is moving existing code, therefore i tried to change only the needed parts and leave the rest as it is In these cases where the return values are creating new data, I don't think it's worth updating all the fields in a local variable. I'd suggest removing data then returning a new dict like this: Same below as well. -- 258d5b3 Consider defining a dataclass with the 3 fields as the return value instead. It can help enforce types (like elsewhere I saw there were some calls to convert the return values to strings) and it can handle the default values cases. i already tried to define an own dataclass for this, but TBH did not get it work nor get mypy happy but yes, this should be done ... will try again -- 005ba6d i think this check could already be handled by the async check proximity state change above, to avoid unnecessary state change triggers to registered coordinator entities in case data are not changed anyway ( same counts below ) --
Hey bajansen, do you still want to be a codeowner? That would be great. You can put your name first if you want if it means anything to you. Nah lets keep it alphabetical Please run hassfest as it should also add you to the tests as code owner hassfest did not do this for me, but manually added it now Now hassfest rejects.. That's interesting Can we add reauth in a follow up PR? Removed Reauth handling, token renewal is still included as the token expires after 7 days. Can you maybe tell a bit more on how the authentication works? When does one need it? User can get publicly available market prices for electricity and gas without signing in. When authenticated, the user gets price data personalised (e.g. different 'inkoopvergoeding'). And billing information (invoices and cost until now) Technically is it just retrieving a JWT to authenticate for different API endpoints. Personalised API's are not available without. Right, in other integrations where authentication is optional (Forecast.solar and opensky) we do authentication in an options flow. Let me check with some people if this is a must or that this solution would be good as well. What is raising UpdateFailed here? Ah this was when we did the API calls directly from HA. Removed! It's the only object you're currently storing, so no real need for a separate key Personally I think the comments don't add much value here, up to you if you want to keep them Why do we have errors as parameter? Double check, users can't change username? I have seen this without the exc info ex before, mind giving it a try? Oh right, I now see why you had errors in the parameters. Suggestion: maybe you can turn this function around py errors: dict[str, str] {} if user input: logic to verify it works and create entry, else we set errors return self.async show form(........, errors errors) Does this API maybe use oauth that we can use? I mean, the tokens are JWT right? We should be able to recoginze when a token expired and act before requesting data Also since you're requesting every 60 minutes, that would leave a gap of an hour every so often. You don't have a reauth flow yet, so this would raise an error. I think you should raise ConfigEntryError I think we should not put json data in state attributes as this isn't user friendly as it's shown in the UI. If a user wants this data, can we maybe use a service call? You can remove the square brackets, this saves a bit because it doesnt have to create a list The coordinator already provides data for the sensors, so we don't need to update them on add
This is the default. Empty string doesn't seem like a good summary. In the dev docs we write that uid is required for the entity state. Isn't it required here then? Thanks, missed that. Will add more tests for cases that need uids when we get to mutations. Can we use an f-string instead? I'd do one iteration over the results to create the final list instead of two iterations. Updated. I didn't realize i could do the alligator and list comprehension together.
Please sort this list Why do we first declare data before getting api, why don't we get api directly This can be inline (without creating entity first) Will you be adding more buttons? Currently this platform is using 2 ways of declaring entities, I would prefer that we choose one of them to increase maintainability. I currently don't plan on adding more buttons, what do you mean by "2 ways of declaring entities"? You're using both entity descriptions as just creating a specific class for an entity. I would say use one or the other. Ok, I've changed ButtonEntityDescription to EntityDescription That wasn't the change I mean. Usually we use entity descriptions to quickly create entities. For this we create a generic entity that holds the description. When you have less entities, or very specific ones, you create a class per entity. Currently, you have it 50 50. You have a class specific for the boil water button, but you also use a entity description for the rest of the button. in this case I would prefer to choose one or the other. Since you won't be adding more, I would suggest moving the entity description fields as shorthand attributes in the class itself I'm inhering from Tami4EdgeBaseEntity which accepts an EntityDescription parameter and uses it to set other attributes. Tami4EdgeBaseEntity is being used in other entities. Should I change Tami4EdgeBaseEntity to work without EntityDescription as well, or would something like this be okay? If you change the super init to super(). init (...) I think we can make it work It still needs an EntityDescription Please add this file to .coveragerc
I think this function is that small that you can just inline it Both are already handled by the coordinator I guess test coordinator.py isn't needed in that case either? That was the only thing it was testing Not really. A coordinator test is always a bit meh in my opinion as you want to test what the result of the issue is. So if the request times out, what is the effect on the entities. Please remove empty keys I think you can remove this one Please make sure this test ends in either a CREATE ENTRY or ABORT to show the config flow is able to recover from an error I would say in the case of InvalidLoginException, raise a ConfigEntryError or return False. Otherwise it will keep retrying to log in with invalid credentials New integrations have to use attr has entity name True . There are some docs on it but I'm on mobile right now. I thought that's only relevant when there's a device. Looking at other Todo implementations, they don't seem to be implementing devices. Hmm, that should not be happening (must say that the Todo stuff was added quite late in the release so it might have slipped, I'll double-check this when I'm at my desktop). In this case I would just enable it. Add a device with entry type service and call it a day Please don't use if statements in your tests I think you can move these tests to the Todo tests for style. This isn't a blocker tho, just personal preference can creating this raise? If not, move it out of the try catch block I think that maybe 1 device for 1 account would work best since you don't create 1 device ( service) per list for only 1 entity. would love to hear what you think The problem with one service is naming it - the best candidate would be the email used to login, but that ends up as a prefix to the entity name, and you can't even see the actual list name in the to-do lists screen. Given no other todo integration creates devices, I really think we shouldn't either. oooh right, that's true. OK, I removed the devices and addressed the other comment already configured string isn't used. If we want to use it we should use the already configured service reference. This can be a module level function or entity method instead of a nested function. In the delete todo items service handler we gather the work. Can we do that here too?
They shouldn't be able to change the unique id user id via reauth Ah, good catch. Fixed! I guess the form needs a schema for what to fill? I think it would look cleaner to have these additions for reauth in async step reauth confirm . Not sure it gives any value with mixing it with the user step. Should this not return the errors if any? It modifies the errors dict that's passed as an argument. Right, don't like but I guess that's fine. I changed it to return the errors instead of taking it as a parameter. Could use the same schema I guess and even allow to change the username? I'm not sure changing the username makes sense? That would be a different account with different locks, and it would change the unique id associated with the entry (since the user id would change). The reason I asked was because I wasn't sure the user id is the e-mail address or not so it could then be possible for the user to actually change his e-mail address. But I guess that's not the case so that's fine. We don't have an abort with reason unknown I think? Good catch! Fixed. Missing the field for password. Done.
You should be able to avoid multiple comprehensions here. Done
Why would we add this attribute? I oriented myself in other parts, so I added that. Should I do this instead? No, I mean why are we adding this attribute? What would a user do with it? You can display the name of today's holiday, e.g. in a markdown card. I was thinking if there was a use-case for actually making it a sensor and not only adding it as an attribute. Wouldn't it make more sense than to have a "holiday" integration like which provides e.g. a calendar entity? Yes. I have thought about it before but never came around to do it. I agree that would be a better fit jrieger you want to change this PR into a calendar entity instead? I'll have a look. Thinking a bit more on this I probably would say both the attribute, a sensor and a calendar entity would be out of scope for this integration as it targets workdays and not holidays. Should probably be it's own integration with only a calendar entity for holidays. See
It would be good to start adding translation key The Withings integration also has a "Height" string. Should I add this to the common ones in homeassistant strings.json? Or maybe to sensor strings.json No Could should we add attr suggested display precision to suggest the number of decimals as default? done This will make an extra state update besides the default state update at the end of entity addition. We should separate the native value attribute update from the state update if we need to update the native value here.
We should remove all duplicate lines if possible. In this concrete example we don't need to specify the off state as it will fallback to the icon specified in the icon key, which is the same Even if the class is currently protected, we should still mark variables that should not be accessed from outside the class as protected. This is no the same, this will create a new cache instance to pass into the method everytime this part of the code is called (while it is being omitted constantly, as it already existed). This is a side-effect from passing it in an an argument. To reduce code duplication we could use partial for cv.schema with slug keys( with slug validator translation key validator, as it is used multiple times here Is an empty json file intended? Please mark also these two variable protected Are these two not so common that we should add them to the entity component? Swing modes are free-for-all strings, there is no standard in that Same as default Should we mark it as protected? Should we mark it as protected? Should we require that an entity component has at least (for fallback) defined? Good question, we don't require it for translations and we do have a generic fallback icon as well Maybe we could also declare it outside of the function We should get the schema after loading the json Why didn't you add type hints for ws client ? Easier to read imo To make it consistent with the actual result type
Should this indicate that the default, if not specified, is to only include items with a needs action status? Yes, agreed, done. In 102534 and 102481 we currently have the suggestion to name the services forecast and events respectively. To match that I think items might be more fitting. EDIT: I do however think that list items is more descriptive albeit not "aligned" As I understand it, new services are being introduced with those slightly different names because the old versions will be deprecated for a period of time, and the old services should be available under the same name for that time so that existing automations don't break. Should this dictate the names of services going forward? I understand why the change is made, but personally think list items is much better than just items . IMO, services should have a "verb," especially since there are other services that act on todo items in this case ( add item , remove item , etc), so items breaks this pattern and would make users ask "well, do what with the items?" My two cents as a user :) I changed the PR for other two services so that they would be called weather.get forecasts and calendar.get events . To align this service could be called todo.get items Sounds like a great solution. Updated to todo.get items I think we need to remove the default here from the service schema, and only add the default to the service description. That way, the default will be set when using the UI (filter by needs action), but providing no status filter will return the complete list. Calling the service with any filter, should not just go and filter by its own. Additionally, if you want all, you'd now have to provide a status filter to get to that (which is odd). I get the intention of the default, but we should set that as a UI feature instead. Great catch, thank you for the thorough explanation. I have moved the default to services.yaml .
Don't both log and raise error. The exception argument will be logged automatically. Are we going to deprecate the is offset reached for the legacy entities or deprecate the legacy entities? If so, I think this is ok, but otherwise our standard nowadays is to set the state attribute to None when we don't know it for the entity. Yeah I would generally like to make it go away slowly, given its weird and hacky and triggers should be the new way to handle this. My thought was to no longer support it from the UI but preserve it for existing yaml users. We could technically support it here since its just pulled from the titles of the calendars. I was thinking this needed to be announced when making yaml go away, but perhaps i need to start shifting the docs since I kind of punted on what to do about existing yaml for now, assuming it will be possible to deprecate in the future. (I think we may need a better solution for search still like a calendar helper to fully make it go away) We probably need to at least say in the docs if it's not supported when setting up the integration from the UI. Thanks, i've added a documentation PR (which was missing in the first place) and have addressed this. Move this line that can't raise down out of the try... except block. We should probably abort if the user enters the same url and username as an existing config entry. L1489-L1493 CONF VERIFY SSL doesn't seem used. Thanks, i added support for this everywhere. I am not sure this is high priority to support in the UI, but figured it wasn't hard to add. Other option is to not support it. It's ok to add it. There's no unique id at the moment.
On this line I think you should have a pair of values like : ("uptime", "uptime"): GlancesSensorEntityDescription( This line should not be useful as the previous "for" loop already handles all sensors I would suggest isolating this code in a separate function as it is specfific to the uptime sensor Missing unit of measurement Do you need to update the data in the source structure ? I would move this whole block after the generic "value .." and only update the value, like this : value self.coordinator.data[self.entity description.type] if self.entity description.type "uptime": value convert uptime to timestamp(value) Should not have these kind of "calculations" in the properties. Why not just adding the starting time instead as I would understand is the base here? I believe glances sends uptime as a formatted string like "12 days, 3:42:29", not the original startup time, so converting to a timestamp needs calculations. The other issue I see is that the calculation will not be very precise, so the computed Timestamp will change slightly at each update. Maybe passing along the uptime as a string without computing a timestamp would be fine ? Ah. Didn't look that careful but just assumed. We should provide it as a proper timestamp. But the calculation should be in the DataUpdateCoordinator and not here (would also remove a few comments as below) Thanks, I will move the calculations, but as wittypluck already mentioned glances doesn't provide a proper timestamp, but instead a human readable form.
You need to patch where this is getting used. i.e. homeassistant.components.octoprint.coordinator.OctoprintClient.shutdown Or something similar You should avoid doing global patches Is this needed? Looking at the init integration function, it by defaults set to default printer, which has these attributes with a bit more. You also should not do anything to the coordinator inside of tests. You instead should patch when you need the coordinator to change values You cannot access hass.data in tests Why can't I? I have now removed it because it's not needed in my tests but it was working. I've copied it from the other existing tests in this file. So are they wrong too? What would be the correct way (e.g. for the other tests)? We don't want the tests to directly mess with integration internals, in this case you're testing the button platform and you should need access to the data coordinator to do that. Instead, your test should, as a general rule of thumb, check the state in the state machine, call the button's press service, and by mocking the 3rd party supporting library check that pressing the button has the intended side effects. You should also freeze time and then check that the buttons state is equal to that time. Buttons states are equal to when they were last pressed, so by checking that, you can be sure that it successfully ran. I'm pretty sure this is the default behavior and is not needed? This goes for all of these No that's not default behavior. The default also checks if the printer is connected. But since this button is only for controlling OctoPrint and not the printer it would not make sense only being able to e.g. shutdown OctoPrint if it has a connection to the printer. Apply my above comments here as well These both should get the RESTART device class. I'm not sure if anything gets weird if two entities have restart device class, so you should test it Make a new base class OctoprintOnlyButton , or something like that, so we don't need to implement the simpler availability check three times. We really should not keep adding natural language names like this, octoprint should be migrated to translated entity names. That's for a different PR though.
remove unused properties please set attr has entity name True ( has entity name-true-mandatory-for-new-integrations) can we move block out of here? Maybe to tests? needs to move to external PyPi package ( needs to move to external PyPi package ( should probably also move to pypi package What do you use that update listener for? You don't seem to have an options flow Thanks for that, that was some left over from a copy paste Will you add more Platforms later? Then I'd definitely add a common base class, if not I'd still think about it to reduce some of the duplicate code in the inits. Have added a common base class in entity.py (Saw other integrations did this, lmk if this isn't correct practice) I believe you don't need those if you also inherit from CoordinatorEntity same here is it possible to use translation key here and move the nae to strings.json ? Would allow for better localization support (applies to all sensors) sorry missed that one: please remove that empty key No worries - Done :)
Are defaults allowed here as this is giving the password in plain text? At least for the client ID it is convenient for me to have that printed out to double check. It's up to the integration to show the password or not Ok. How could this work with your suggested changes? I need to set the default just for this usage. Ah, missed one suggestion that covers this, I'll try that. Is there a way to use the localized invalid auth text here? Not yet. There is a PR open to start implementing translatable errors, but it still needs to be merged. We can add translations for it at a later moment. Correct once 103111 is approved. Is this working as you expect it? If my suggestion below is fine we could remove it Since you are using unique id , you could do the following: Or just simply set "entry id" on the MockConfigEntry If you set "entry id" as mentioned above, you need to set "entry id" here as well. Can be simplified as the schema includes at least one required key
Please remove any commented out code. n this specific case, the logger can be set to debug via Thanks! Will next commits of this PR Remove empty keys Done. Why do you need this? For new integrations, we require the following: - Support for [the new entity naming]( has entity name-true-mandatory-for-new-integrations) - Services must be [translatable]( - Entities and their attributes should be [translatable]( Please adopt your code to add support for it. Thanks. Will include it in next commits. Vs code should not create any files inside your component. Why do you need this? Old stuff. I can remove it, if you prefer Why is this comment out? Just clutter. I will remove it and resubmit. Sorry. The level info is reserved for the core. Please use debug Will fix in next Commit Will fix in next commits Can we use a Coordinator instead? We can certainly. Is there a specific reason to do so? Anyway, will address this in next commits The coordinator does the scheduling and co already and we should reuse it instead of creating all by our own. Please add a coordinator Also if the user disable a certain device, it looks like this API is still polling the information about that device, which can be omitted by using a coordinator This file needs to be removed Ack Above, you set attr name None to use the device name. Why are you creating this property? Clutter. Will remove it Can never happen Can never happen as you set it in the init file Ack Why is the sleep required? Can this ever happen? Lines 35-36, were already removed to address another comment. If you mean line 38, I will anyhow remove it
Instead of using magic number 4 everywhere, we should make a constant DEFAULT TIMEOUT or something, but that could happen in a separate PR. Also, it doesn't seem like anything is catching the timeout errors, which means that users will see stack traces if it happens. The timeout errors should be caught and nicely logged IMO. Again, that can happen in a separate PR since it also affects already existing code. Opened a new issue to deal with this later, thanks! There's no need for the mixin class, instead enable kw only True on the StarlinkTimeEntityDescription Does this apply to other sensors too? I can open a PR to update the rest of that's the case Yes, it applies also to other sensors. joostlek may have already done that though. Could we gather the calls to status data , location data and get sleep config or do they need to be called sequentially? I'm not sure what you mean by "gather", but if there's a better approach to calling these then let's do it I mean use [ asyncio.gather ]( asyncio.gather) to run the three corutines in parallel Done, thanks! Don't create concurrent executor jobs. We're not allowed to create more than one executor job at a time. Please run all sync work inside a single function that we schedule once on the executor.
Needs to use translations As my setup is English (only), I cannot test translations - is adding a translation-key sufficient? Adding support for translations is mandatory for any new addition to our codebase. support for translations was added What is mist? Is it described somewhere in the API documentation? Does it have known values? I updated the PR description to answer your questions: "My fan has a "mist"-feature, that means it has a water tank from which water gets vaporized via ultra-sound and injected into the air stream to cool down the room" "As this is completely undocumented in the Tuya docs, I implemented it as a simple enum since I don't know what other devices might report" I implemented it as a simple enum Right, but what does it mean? Shouldn't it be a number entity instead? As in, seems like you can select levels? Do they need textual representation? Well, the mist-feature of my fan probably should be a number entity... It's just the amount of mist that get injected into the air stream, it doesn't have a textual representation - in the tuya app and the vendor's app it's also just shown as [0..3]. As the feature is not documented, I chose an Enum to also support devices having non-numeric values. It would really be nicer in the UI to make it a number entity, but would rule out devices having a non-numeric value here. What do you recommend? Switching to a numeric entity?! I took another look at it, I suggest to accept the PR as it is because of: - Tuya returns an Enum, implementing it as an Enum seems to be the safest and most logical way (as possible return values are unknown because this feature is not documented in the API) - The Tuya-integration does not support creating a NumericEntity out of an Enum - Other fan-features that are "Enums returned by Tuya" (like "countdown") are implemented exactly the same way it's done in this PR
I don't think this file is needed. The majority of other virtual integrations I checked do not have this. It was required the last time I added a virtual integration. pullrequestreview-1663799125 Ok! Thanks! Ok! Thanks!
Does only the delete API return errors with an error key in the returned dict, or could this also be applied to some of the other api calls here like list or insert? The others apply this too, for example in execute below on line 137. Delete is just different because it is a batch API, but it is sharing that part. Manually applied after merge conflict (resolved in the wrong order)
Would it be possible to enumerate all the settings and get their current state and create entities instead of a custom service? Yes, that is possible. Is that generally the preference? It would be more user friendly. It looks like it will return 27 speakers and their settings, even if you don't use them all. I for example only have 8 speakers in use. I would say this is probably less useful for people, mine isn't a unique use case, but I don't know if there would be many others - I use the 360 Spatial Sound Mapping, but I have different settings based on the input used. My receiver has profiles, but there doesn't appear to be a way to select a profile via API, so I just update each speaker. Changing set sound setting to get the current state with associated entities would make more sense to me, as it would be more useful to users. Can we distinguish the speakers that are in use from the speakers not in use ? I had assumed no, but looking at the API response it is possible. It indicates if the speaker is a candidate (assuming speaker configuration ie 7.1) and if you are using it have it connected. Eg: 7.1 configuration has different patterns, so 11 speakers are available, but only 8 would be in use. So some options. The Sony 'Music Center' app shows all 11 for me, with the 3 I don't use greyed out. That makes the option more viable. Not sure what a soundbar looks like for speaker settings, but it would have been ugly to create 27 entities when it is probably just Left, Right, and Center, maybe a Subwoofer. Maybe create one Home Assistant device per speaker in use and connect the settings entities to the corresponding device? Mark the entities as entity category config. There is an unfinished PR 63145 which aimed to add separate entities for settings, but it was abandoned. Maybe it's worth checking out if reviving it would make sense? Wow, that is a big change but would improve the integration. I will close this PR and when I get some time look at PR 63145. Thanks. Yeah, maybe it was a bit too much in a one go indeed.. It's probably better to make this by refactoring to use the DataUpdateCoordinator with one platform, and then improve platform-by-platform to speed up the review. Some of the code introduced in that PR might also be better suited to be included directly in the python-songpal. I'm not sure if Flameeyes is still interested on working to get these changes in, but as my old soundbar seems to be still working, I can help you with some testing code reviews as needed. Yeah, I would break it up into many smaller changes, so that it can be chipped away at. My biggest issue is that I will now need to learn the ins and outs of Hass, instead of a small copy of something that is already there :) I also don't really need this as I can already do it another way, but could be useful for others. I do like making things better, and more useful for people :) I don't know, that PR is almost two years old.
Can you add a comment about what this is doing? Want to extract a constant here? Seems worth extracting a constant for 90 and giving it a helpful name (MAP REFRESH INTERVAL or CACHE INTERVAL something more accurate) It would be good to also exercise the image fetch side of this since it has interesting code in it and it can get the coverage numbers up. I was playing with this last week, something like: Then it could also be possible to start patch ing things and playing with the should update logic as well. Partially implemented - haven't added anything for patching should update yet - not 100 best way to tackle that yet tbh I realize this roborock API is probably a little "unique", but perhaps you can explain to me what is happening here. It loops over maps and returns an entitiy for each one loading each map. But then it also loads the current map (is this again or the only time else?), but doesn't add any extra entities for that last map call? I think adding a little more to the pydoc about how this works as well as elaborating on why it has to be synchronous (e.g. because the server can only load one map per device at a time?) would be useful documentation. Exactly - only one map per device at a time. I'll add a bunch of comments Given the name "update" has a specific name for entities and this uses an update coordinator, would a name like is cache expired be more accurate? My impression is that ImageEntity. init calls this function. Is this needed? Don't think so - I added it when I was first debugging and running into some issues. Check out image which says that the frontend will only fetch the image when this property changes, and it is not expected to update this from within this call. I don't think this has been addressed to follow the developer guidance. Ah I thought I handled this - my bad. But to be honest, I don't really get what the docs means is best practice in this case. I think it is saying that the data fetch should not be happening in the image serving path, but instead should happen when data and state is normally updated (e.g. async update etc). So as a concrete example of what it is saying could be appropriate could be: - from handle coordinator update start another background task to fetch the cloud image, then as that finishes it sets the image update time. Maybe the logic in is cache expired needs to run there and adaptively fetch? My understanding is that you're trying to only update the map when it has interesting changes when the vacuum is running. Perhaps this means some of the caching logic isn't needed, and it just turns into logic of when to fetch new data. - fetch from the coordinator. this could put all the fetching in one place, but then maybe you have less control e.g. to disable the entity to stop map fetching if you don't want it Yeah is cached expired only updates the map when it is interesting. I'm still a bit confused But the issue is - the frontend will repeatedly call async image if i refresh or open up
Naming should be rethought, Active Sensor makes it sounds like it is a property of the sensor, but in fact it's a property of the schedule comfort settings. Maybe set participating sensors ? That would be closer to what ecobee calls the functionality. I am open to changing it to whatever makes the most sense. I like that better other options set sensors used in climate This PR does two things: - bumping the dependency - adding the new service The two things can be split, so they should be split into two PRs. Please move the dependency bump into a new PR. Leave this PR in draft until the other one is merged. Have removed from this pr and added to Will be automatically added by async register entity service Removed the erroneous line. Please move this step before you access the device registry Changed to msg format (sorry about that... should have noticed it was dumb to do it that way). Moved this check before the device registry lookup. Same here This check uses information from the device registry lookup. I do not know how I would move it before it? Unless you are just talking about the msg format. In which case, I changed it. Same here This check uses information from the device registry lookup. I do not know how I would move it before it? Unless you are just talking about the msg format. In which case, I changed it. please adjust variable name to new naming ideal Good catch, sorry I missed that. Updated. Adjust naming Updated. For some reason, chaning it to the if not x: format failed mypy. I left it the same. The raised exception will be logged Please use a ServiceValidationError instead and it would be nice to add [localization]( exceptions) for it. Please also adopt the other places I am not sure what the difference will be in this instance? I will update with commit, but if you could let me know for the future why using elif in this case would be better. I think we should rename climate name to preset mode or something similar as it would be easier for the user to understand it Will update with commit. Please mark internally used functions as protected Can be removed as the value is a valid preset mode Are you sure, you want return None in the list? Are sensors and name not always present?
For new entities, we require the following: - Support for [the new entity naming]( has entity name-true-mandatory-for-new-integrations) - Entities and their attributes should be [translatable]( Please adopt your code to add support for it. Is it correct that the picnic todo entity doesn't support any modification? See TodoListEntityFeature Sure! Also please see We can add items and maybe delete them. But keeping the PR as small as possible. I would suggest making the name translatable We don't accept any test written with unittest . Please see the pytest style instead Just used the same test structure as used in sensor.py to be consistent I will see if I can convert the the other format. Test in test todo.py have been updated to pytest style. Tests in test sensor.py can be done in a followup PR. Please note that none of the To-do have this one covered. Ah The only question I have is about the price. Should we really add it? What is the advantage to have it? First thought was why not . But removing it fixes the incorrect price handling when selecting special offers. So let s remove it? Please invert the inheritance order. Also add a type annotation to the generic CoordinatorEntity what coordinator type it holds. Please move the comment above the line to decrease the line length.
patrickhilker are you fine to be a codeowner if I move this to core, or should I remove you? Awesome - I'm fine beeing a codeowner. I'd like to have an opinion here please: Should I leave that endpoint authenticated only (which requires to send a long lived access token unencrypted every time, which grants access to the entire HA instance), or should I make it unauthenticated (it is only used to update status information anyways)? Please assign the coordinator to hass.data after you know init was successful I personally have no preference here, but it was requested like I have it from another reviewer in my other PR. Actually, not true. Not possible because setup would fail, as the platforms are retrieving the coordinator from the entry. fixed Personally I would prefer this Also, what actually would happen when no token is found? I think I test for "" because it might be the empty string coming from the options flow. If no token is found, then the websocket part is not initialized and we only rely on polls for updates. Not sure if this is exactly the same, but IMO it is more readable if it does not the same. My code ensures that if one of CONF HOST , CONF LOCAL ACCESS TOKEN is set, the other must be set as well, but if you leave both of them empty that's fine (you must set the INIT CLOUD then though). Your code would make any of them mandatory. Not needed Yes, let's automatically break all other entries when you reload one :p Can be removed for now honestly this function can be inlined in the config flow If we can't connect to the device or have invalid auth, will this function behave the same as tedee client.get locks() ? Why not use this function call for validation? Can be removed Your whole flow is in 1 function, can be removed I dont think we need this Only put stuff in the try block that can raise We never even set this value In this function self.config entry will be set to the current entry, so if you move this function to the top you can remove the entry parameter of this class Please raise ConfigEntryError for now as you don't have reauth flow in this PR Only have stuff in the try block that can raise What kind of special unique ids will be added? If nothing special, there's nothing wrong with just a plain old f"{lock.lock id}-{entity description.key}" . This whole setup btw requires every entity to have an entity description, is that the case? Why do we string the lock id, what's the base type? The lock is the main feature of this device, consider setting the name to None so the entity name will follow the device name.
We're introducing a new intent. Shouldn't we just aim to do the right thing and set the state as-is instead of making fake states Yeah, I agree. I've fixed it here, and I will make sure to migrate the sentences before marking HassClimateGetTemperature as supported in the intents repo. We shouldn't need to assert if we raise above.
Scan interval shouldn't be configurable. You can disable polling and call the home assistant.update entity service to update sensors. Why not reload the entry?
What does it mean to not pass the previous uid? It means move to first I'm in the list (there is no previous items therefore it's the first) Is it standard to set a default argument or none for something like this? I think it's ok to have None as default but I suggest we document what it means in the docstring and in the dev docs. Can we make the previous uid a test parameter instead? We don't know it until it is created since uids are created on the fly. We could seed with a fixed database, or mock out uid creation deep in the library, though my thought is that might be too tight of a coupling with an internal detail. However ical does this for it's own tests so there are some util hooks for that. (I was replying for ical though same techniques could be used across both) Hmm ok. I guess it's ok like this then.
With tests ! Cant ruin all the hard work you did to get the coverage up ) validated against the docs looks good
Maybe you can add native unit of measurement "ignitions" as well The ignitions are just a numerical value, is there any unit measure for that? I mean, it's counting the amount of ignitions right, you can put custom values as unit of measurement
I made this flexible so we can add more combinations later without having to add a lot more complexity May be you could use a named tuple? collections.namedtuple Since we never access the data in the tuple as its only used for the hash key, I'm not sure if that would be worth the additional complexity.
can this happen ? I don't know if it can actually happen, but mypy threw a fit until I did this. The definition of entity name includes UndefinedType : L470 ah check, yeah ok. Using async match states now I've been thinking about this. For backwards compat today we could just target the list that is created by the shopping list integration. What if we add an optional domain hint slot to the intent that defaults to shopping list ? This causes the todo entity search to prefer a specific domain, both with and without a name. This would let us support sentences like "add X to todoist" (with domain hint set to todoist by the sentence data) and it would add X to the first todoist list. It also provides a way to target lists with the same name from different domains. I guess that results in the same backwards compat behavior, so I guess ok? I don't see how the domain hint would get set in other situations (as one cannot say "todoist" and expect STT to pick that up)
Maybe the function name as a filter should be "hebrew date"? It matches better the Jinja semantics. Same here "zmanim" should suffice. I think these changes are unrelated.
Shouldn't we add this directly to HomeAssistantError ? HomeAssistantError is may be too broard. But the way it is implemented now could also be applied to HomeAssistantError . In that case may be add an option to suppress the stack trace? Added translation support for HomeAssistantError and sub classes (like ServiceValidationError ) including ServiceNotFound (also a subclass of HomeAssistantError ). I was suprised when I saw this, that we set the translation key in the place where we handle the exception. If that is needed I'm wondering if the exception is the correct place to hold the translation info. Alternative this could be set in the class definition. But it seems we have 2 variants with different descriptions. This seems the only places where we raise a ServiceNotFound error. L1980 And it's called from: [homeassistant components websocket api commands.py]( diff-ae1571378111595f87a494f6e575eae8865050a436257b01d336b96744c30a03) Not sure when if err.domain msg["domain"] and err.service msg["service"]: is not true BTW. As discussed on Discord, this should be implemented in frontend. Instead of translating in core, core should send translation key etc. in the error messages. Removed, this will be planned to be processed in the frontend. Why do we need these default values? If translation domain is not set (e.g. for ServiceNotFound ) it defaults to websocket api . I do not want to import the domain const to the exception. Do you think I should do that? Placeholders are added if the translation key is set, may be this is not strictly needed. Added a comment to explain why a default for translation domain was added. I don't think it's a good solution to have to copy translations of exceptions to the websocket api integration. Either we give some special meaning to a None translation key so frontend knows to pick them from common::exceptions , or we move the standard exception translations to the homeassisant integration. This doesn't seem to be used? Right, it is a leftover. These do not match what's sent by websocket api They do afain. It seems there was a repr method that differed, hence the message set when initializing ServiceNotFound did not match since it was was overridden. Why is this marked as resolved? These strings still do not match what's sent by websocket api; websocket api only uses translation key other service not found , but strings define two other keys: service not found and service child not found . Sorry, I kept the original error text's. I have synced every thing now, also the repr variant and places the translation strings under the homeassistant integration. Also added placeholders. Why do we need to guard? May be we don't need to do that Tried to remove it, but reverted that, it seems a lot of CI tests assert on the whole payload. If we leave the guard, we need to adjust all the tests. I suggest that if this is needed we do this in a different PR. We shouldn't complicate the code to avoid updating tests. Check with fronte
Please don't access hass.data in new tests. Instead use the async fire timed changed test helper Done. As above Done. Useless pass? Removed. As above Done. Please patch the pypi code and avoid patching the integration (except for async setup entry) Please patch the pypi code and avoid patching the integration (except for async setup entry) Please patch the pypi code and avoid patching the integration (except for async setup entry) Ok to patch the Bluetooth public api Looks like there is no need to make a list and a generator expression can be passed to async add entities I definitely didn't steal this from another integration without thinking twice about it :laughing: Done. Doesn't seem updated, did you forget to push? Please use f-strings Done. Please use f-strings Done. This looks unreachable through the normal flow AIUI and as my experiments show this gets called - at the BT discovery step ( async step bluetooth ). Given the entire integration is reverse engineered and there's no documentation for the device I think actually communicating with the device like we do here is the only way to find out if it is what we think it is. I'm of course happy to take advice on the matter as my experience with HA design principles and best practices is... limited. Please don't set anything in hass.data until after passing the first refresh successfully Done. Please see has entity name-true-mandatory-for-new-integrations The entire naming section is a great piece of documentation I was looking for and didn't find. Can we reference it from somewhere underneath the "Integrations 101" section? Applied for the PR. Please add entity category so diagnostic entities don't appear on default dashboard Done - can you please double check the classification makes sense? The ones that aren't marked as Diagnostic can technically be updated (not through HA yet, it's coming in a subsequent PR) but Config can't be set for them (" L278"). Should I leave them as-is, or mark everything as Diagnostic for the time being and revisit when they're updatable? Please move specific uuids to the pypi code and import instead Looks like this isn't using f-strings Different local workflows apparently. I tick off all items I've addressed locally and consider PRs in draft mode as a scratch space which should only be reviewed when explicitly marked as such. Apologies for wasting your time if you're used to a different paradigm. Let me finish this round of comments my way and I'll behave better next time :).
Besides adding a fixture, you also need to add an actual test that verifies metric values, similar to the one we have for input number : L272 I believe I already did that, but it was in a different commit: L296-L317 Instead of copy-pasting the handler, may I suggest moving shared code to a separate method and calling it from both handlers? Something like this: (this applies to the code of the integration itself, it's fine to have duplicate similar code in unit tests) Thanks, what a blunder on my site. Fixed in the latest commit.
Fetch time outside of the loop Unpack hass.data[DOMAIN][entry.entry id] into a local var so you don't have to keep doing dict lookups here I have a separate PR to make it a dataclass
Add the event entity in the event platform. This isn't straightforward. The media players in roon aren't static - the roon system creates them dynamically as devices become available (and deletes then too). So the media player creating code tracks what players come back from the roon api as things updates - and creates any that don't yet exist via a callback. You can see the code here: If you feel strongly that event entities should only be created inside the event platform - then I'd need to create another callback inside async setup entry in the event platform. Not sure this would be clearer - but happy to do so if you think it's better. Yes. Platforms aren't allowed to depend on another platform. Thanks so much - and sorry for my foolishness! Don't create the entity directly. Set up the integration while patching the library and assert the entity state in the state machine. writing-tests-for-integrations Call the callback via the patched library call arguments. MartinHjelmare The roon integration hasn't previous had proper tests . I think from your comments above I'd need to look at patching parts of the roon library - and working out how to mock some of the async updates thet the library provides (which trigger creating HA entities) In development terms I think this is going to be more involved that what is currently in the PR. It it now a requirement that new entities (like the one her) require this sort of test? Tests are not required but if you want to add tests they should be written according to what I described. Thanks. Given the challenges I'll remove for now. At some point I may take another look . The best place to start would be the media player. Please sort . Remove these type ignores. They shouldn't be needed. These constants are never used. We can remove this. Please type the whole signature when adding type annotations. Don't log at info level unless targeting users. Use debug level. Connect this entity to the same Home Assistant device as the media player by setting device info . defining-devices Shouldn't we use the roon device id to id the device in the roon api? The entity id is Home Assistant specific. It's just a reference key so that you can update the callback if you need to - so entity id seemed like a good key since it's related to this entity. I'd still use the device id. It's weird to pass a Home Assistant API specific string to another API. Or better, pass the unique id. The user can't change that and it's currently the same as the device id, right? And if we would add more entities to this platform in the future it would still be unique for this platform. Follow up PR should preferably take care of this comment: L162 entity-naming We can set self. attr device info in the init method instead. Where is the unique id set? It wasn't - sorted. Do we need to unregister the callback when removing the entity? There isn't currently an pyroon api call to do this. Pyroon is reverse engineered and when I investigated I couldn'
If you plan on adding more buttons in the future it might be easier to use ButtonEntityDescription and add a press fn There are a few examples in the codebase already of this. Let me know if you need help finding them Done, I think. Let me know if that is not what you had in mind It looks like the pattern is going to be common so it might be nicer to have a base entity class in an entity.py that took care of setting the properties that are the same With the ButtonEntityDescription change, this is not duplicated anymore, so I think it is fine to leave it in button.py for now? Its fine for this PR, next PR should be to create an entity.py for a shared base class ie IdenDeskEntity before adding any more platforms bdraco I was now looking into this for another PR, but I am not sure what the IdasenDeskEntity class would have. Only a single line for the self. attr device info device info ? Because everything else is not common for the current platforms. If there isn't anything common yet then it might not worth be doing until there is. Usually at some point there is has entity name-true-mandatory-for-new-integrations You can use has entity name instead If unset uses this already L442 oh, nice! If unset, uses this already L565 We usually sort these in order A future improvement would be to make the button unavailable when its already connected or disconnected Good idea. I'll add that to my ToDo list!
Please also assert that there's still a climate entity state discovered. Please address the comment by Keith above.
Move the coordinator to its own file coordinator.py for ease of use Thank you, I moved it. Probably worth ensuring that coordinator.last update success is True. unless I am mistaken, UpdateFailed() being raise d in your coordinator will not interrupt this part of the flow Thank you, I added it. Why make these global variables on the object instead of member variables of the class? And last client refresh doesn't seem to be used Thank you, I made the proposed changes. hass is set in super() init so this isn't needed Thank you, I deleted it. remove the unused keys to make this easier to read Thank you, I removed the unused keys. I don't know if it is strictly required, but you should add translation keys and remove name to these descriptions. Probably icons as well. Entity Categories as well are best practice Thank you, I think I made the proposed changes: added translation key, removed name. The default icons are ok. Instead of using separate lists, it may be worth considering adding a supported lambda, then evaluate that when adding the entities below. I don't think theres anything wrong with this as it is, but that is how a lot of the integrations do it. Probably worth raising PlatformNotReady here? Not sure - but just something to look into Thank you, I added it. If you plan to have more platforms than just sensor, I would add a LektricoEntity class that all the others can be subclasses of. For any init logic that will be repeated such as device info. Thank you, I created LektricoEntity class as you proposed. CoordinatorEntity[LektricoDeviceDataUpdateCoordinator] Thank you, I made the proposed change. Why is this optional none? You seem to always do it Thank you for your help. I'm having problems with this proposed change: If I replace value: Callable[[Any], float str int] None None with value: Callable[[Any], float str int] and I remove None from def native value(self), I get this error: 2023-11-02 09:00:06.149 ERROR (MainThread) [homeassistant.loader] Unexpected exception importing platform homeassistant.components.lektrico.sensor Traceback (most recent call last): File " workspaces core homeassistant loader.py", line 836, in get platform cache[full name] self. import platform(platform name) File " workspaces core homeassistant loader.py", line 853, in import platform return importlib.import module(f"{self.pkg path}.{platform name}") File " usr local lib python3.11 importlib init .py", line 126, in import module return bootstrap. gcd import(name[level:], package, level) File " frozen importlib. bootstrap ", line 1204, in gcd import File " frozen importlib. bootstrap ", line 1176, in find and load File " frozen importlib. bootstrap ", line 1147, in find and load unlocked File " frozen importlib. bootstrap ", line 690, in load unlocked File " frozen importlib. bootstrap external ", line 940, in exec module File " frozen importlib. bootstrap ", line 241, in call with frames removed File " workspaces core homeassistant components lektrico sensor.
Can be removed because you are not using a YAML configuration, so this would be empty. Removed. This can be removed since you are not using it. Removed DATA HASS CONFIG , but cannot remove DOMAIN and PLATFORMS since its using in async setup entry and async unload entry methods. I completely missed the unloading at the end. Can be removed when L17-L23 in init .py is removed. Removed DATA HASS CONFIG . Can be removed, as you don't store anything in hass.data . Removed it. Would make more sense, as you don't store anything in hass.data[DATA HASS CONFIG] or use it elsewhere. Changed to {} as suggested Same Removed Same Removed No need for this Removed Removed Can we use a built in function? HA may have a function for this, but I'm not 100 sure. In fact, i wanted to use any built-in helper functions. however, I couldn't find any matching function as per my requirement. I have asked about in discord dev channel as well: I have removed the method from notify.py and implemented it in python module. You could utilize pytest.mark.parametrize here instead of coping the code. It makes the file cleaner and it is easier to add new errors later. Also, we like config flow tests to end with either FlowResultType.CREATE ENTRY or FlowResultType.ABORT . Fixed Maybe we could also use pytest.mark.parametrize here, the file is quite long and contains a lot of duplicate code. Fixed Same as in is valid url . Is there a particular reason why you pass in is allowed path ? Otherwise this could be removed along with L78. Removed Would device make more sense here, since you only connect to a single device per configuration entry? integration-type
Why bother with this vs just making the entity description a required field? This would return unknown for a color. How about you return the RGB value in that case? The name doesn't feel right, perhaps would hyperion visible priority be better? The constant name should be more specific, it's not really a "base" unless you implement the idea below about making a generic base sensor class. Since you went with the base class idea, I'd suggest: ... and then use that below as part of the unique id. ... and here you'd include the base in the unique id, Should should not be set in the base class. Other Hyperion entities don't log, suggest we not don't either. Ditto, superfluous logging. This assumes English language. I'm not sure if there's a way to use translations in the state value (one of the next reviewers may know, but it's probably not a good idea anyway). A simpler fix would just be use the Hyperion keywords. I think the owner field probably still works okay for other components (except color, e.g. for V4L owner is V4L2 which seems like a fine state). i.e. I'd suggest you treat color specially, and for everything else use owner. Needs a new test sensor.py file that verifies the new code functions correctly. Nit: Comment is not really conveying anything that is not obvious from the code. Nit: Comment is not really conveying anything that is not obvious from the code. Why bother with this line since state value is set below anyway? Where is self. state used? The entity description is constant. We don't need to create it every time we create an entity. Just define the description as a constant at the module level. enabled is the default. We can remove entity registry enabled default . Please sort . What is it we need to slugify? I only see slugs. If there's only one sensor to append we don't need to use append. Just put the sensor inside the list when creating the list. Combine these two checks, invert them and continue if true. Then we can outdent below. If we don't know a state attribute or it's not applicable we default it to None nowadays. All attribute keys should always be present. Please use f-strings instead of string concatenation.
Remove empty keys rccoleman Are you willing to be a code owner? removed Rob for the moment to avoid blocking this PR. Will gladly add you back if I hear from you! We don't allow to catch the bare Exception outside the config flow. Please only catch specific exceptions Where is this value used? It looks like it is unused. Please remove all unused variables code those are used in platforms services, which are not part of this initial PR - should I remove them anyways? Easier to read Why are you doing this? The coordinator polls the data on a fixed interval. true, if someone executes a command, say "turn off", that state will be written to HA immediately. Then since commands can be sent through the cloud, I'm checking after the UPDATE DELAY if that state update actually happened on the machine, so I don't have to wait up to 30 seconds to get the actual state to reflect in HA. Please use short hand notation as class variable similar to attr has entity name True Same here This PR is huge and introduces many features, which are currently not used. To reduce the PR size and we also don't accept unused code, please remove all feature, which are not used in this PR. These features can be added in a later PR, if required can we really remove all of that? Isn't line 16 a requirement for all integrations that are only configurable through config flow? I got some checks failing if I don't have that line. You can keep the line but the only thing it will do is create a repair issue if you use yaml. Move this outside the try except block Here, you set the unique id to address, which will be overwritten in async step machine selection with the serial number. This makes no sense. Please explain when the Bluetooth discovery will be used? Selecting a device from multiple makes no sense to me when Bluetooth initializes the config flow.
Updated, will do the same on light.py :no good:, fixed :no good:, fixed :no good:, fixed
The config flow has to be 100 unit tested I have no idea what is missing here. Please give some doc links of what I should do to 100 unit test the config flow. I can't run pytest tests as it fails while finding dependencies on upstream components. Well, you have to write unit tests for the config flow. Please checkout any test config flow.py file and you can see what happens. You can run the tests by running pytest tests components climaveneta imxw I think you still need to run hassfest as the file isnt complete Can we retry this? You can do that by raising ConfigEntryNotReady Can this also raise other exceptions? Can this be moved to coordinator.py ? The docstrings in this file can be improved Can we add types? Can we type this? Right, this integration doesn't use a library to connect with an external device as required in 5-communication-with-devicesservices. Although I am not sure how this works together with modbus, so I already asked someone if he knows an example for you to look at. This integration was largely based on Flexit integration. We want to avoid users setting custom names in config flows. Instead, please use a device info object. Users can then rename the device info. attr name should be set to None . Can we initialize these outside the constructor and with types where possible? I think you need to overwrite a different function here for it to work since you're using a coordinator. Can we move this above the Climate entity? Seems unused Everything here is in one step, so I don't think you need the init at all your schema is already checking this This is only used in init .py please move it to there I think this one might be already set in homeassistant.const You can use references here
Since ViCare uses has entity name True I would suggest to remove the name, it will fallback to the device class name This would mean I need to rework the base class. Or can it simply be "" ? I am guessing you made this a separate class to make sure its always available, but when I look at ViCareBinarySensor , available is only False when self. attr is on is not None so would the trick be to make sure the value getter function never returns None ? I think available should consider the isOnline status of the device config in the end.
This was actually sending the wrong object, but it had the properties that were needed so it worked
coil is a bit that only have true false command on should not be a byte.
Why do we need this? Hmmmm not needed anymore. I thought I needed it for something with discovery, but I don't anymore. Thanks for the comment! Can we move this to init .py and use Platform.LIGHT ? Yeah I don't even think this is used. Will remove. When you want to use package , please move it to const.py Got it, thanks! Actually, I'm not sure I fully understand this. Python is not my normal language. Should I be changing the init .py LOGGER as well to use name instead? local loggers ( LOGGER usually) have to use name while global loggers ( LOGGER ) have to use package . Global ones are usually defined in const.py Please make this a shorthand attribute Don't use ternaries (or however you call them) when they span multiple lines Please make this a shorthand attribute New Integration have to use has entity name True . has entity name-true-mandatory-for-new-integrations Thanks! Didn't catch that. Why do we check this? pydeako returns a state dict and so getting the "power" key returns type Any which mypy complains about. I'm planning a refactor of the state management in pydeako that will return correctly types, but not sure when I'll get around to it. I think it's safe to just typecast Currently you are requesting the state for every property every update. I would suggest moving the whole update into update or async update depending if the call is async or not. You can then set all the properties using shorthands. Good point thanks! Expected? This could be more descriptive If we're using zeroconf, why aren't we setting up the devices with 1 device 1 config entry? (note, I don't have much experience with zeroconf, but please explain a bit more on how the device works) Yeah for sure. Good question. We have some devices that can discovered with mdns. We pick one to the be "bridge". It can be any of them that are on wifi at the time. That device is then responsible for bridging tcp to ble as not all deako devices are on wifi at all times. Once a device is selected to be the bridge, it will stay on wifi as the local integration device. All other devices periodically get on wifi to check in, send logs, etc. Since we only really connect to one device, one config entry. All other devices are then exposed through that device using the local API. This is only used in light.py now. const.py is used for constants used in more files so please move this to light.py . Can be set outside of the constructor can be set outside of the constructor
We should not add device-level sensors like RSSI for child sockets, add a new field to the description for this case?
I don't see how this should be used. For valves that can open half way (not all of them do) there might be a reason to start opening or closing a valve and then stop at whatever the current is (e.g. The when you're satisfied with the current flow rate of water in your garden's waterfall) It's not an use case I have myself, but from my understanding of the discussion over in the architecture repo, it was supposed to work as covers do. I left a reaction in at the architectural discussion. Mainly a valve looks like a cover, but stopping a valve does not make sense to me, may be a valve can get stuck . I don't mind removing it. If emontnemery can chime in to confirm I'm happy to remove it. There are very few things I like more than deleting code. I suggest we leave this part out. Please don't add device automations in the first PR. That can be three follow up PRs. Same with group, intent and reproduce state. Why is this file added? Damn, sorry, I must have switched branches and this shouldn't have been committed. I'll remove it. It seems the file is still there It also causes the CI tests to fail Please remove the device automations, actions, conditions and triggers for now. This requires adding a valve.py platform here: Remove this. It's not used. gone I suggest we remove the defaults and let the implementing platform decide the supported features. Just do it like this: L93-L96 Well, I'd say that open and close are the very minimum for a valve to be able to act as a valve, so maybe we should signal that by making those the default? Maybe it can only set a position? I suggest we don't set defaults. Do it like this: L78 Please test this case. We always want to set the state attributes. If we don't have a value we set it to None I wonder if we should add a default implementation of is closed property that represents this logic so the platform can just set the current position if it knows that and have the closed state be calculated by the default property. Would it be weird that even for valves that don't allow any intermediate positions but fully opened and fully closed that we set the position? I was thinking we add a default for is closed , not a default for current valve position . Don't add deprecated code. Remove the kwargs. Keep the DEVICE CLASSES SCHEMA .
I think it's mandatory to define these with default values to avoid mypy's error: Attributes without a default cannot follow attributes with one [misc] . I'm open for suggestions, as it's not really nice as this will require checking these later for Noneness. You can instead use a "Mixin" with double inheritance. Great, thanks for the tip! This was moved from below here to allow passing it as value fn for the sensor definitions. This None check would be nice to avoid by forcing passing a value fn in the definition, which does not work due to the aforementioned issue with "Attributes without a default cannot follow attributes with one". Ideas to make this cleaner are welcome! I just realized that this information is only available if the device is on, so we may need to add a parameter to force the creation of sensors even if their value is None at the time of the initialization. Also, I suppose this might also apply for the emeter sensors, too.
This would be better implemented in aiohomekit This can be done in a future PR though added to my notes to clean this up later in aiohomekit I made this a callback so we don't have races when adding removing The subscriptions now happen 0.25s later and we group them together. Brilliant. I always hated that this was async and gnarly.
Please remove the brand as it has only one integration The description and co should go into strings.json so the can't be translated. Please see translations We no longer accept the possibility of changing the scan interval via the config flow. Please use a fixed update interval. If the user wants a different update interval, he she can create an automation that calls homeassistant.update entity on their specific needs. See also polling-api-endpoints In this instance, it is needed, as it depends on the amount of devices the user has. If they have many Olarm devices, they will need to set this to a higher value or the integration will experience issues where some devices will update and other devices will not. This is due to Olarm having a API limiter in place that cause a lot of issues. Please add only files which are added in this PR Forgot about those. I will fix them now.
Since this never changes, this should be moved to class level: attr fan modes [ FAN MODES TO OVERKIZ] Please reformat this to a short summary, followed by a blank line, then multiple lines with detailed explanation, maybe: Please line break this and all the other long comments My preference would be to not add a lot of constants for these parameters. These enums are not used a lot, and are very readable already. Introducing another constant to just point to the ENUM makes it not very readable in my opinion. Would you mind removing all these extra variables? The ones for temperature you can keep. Makes sense. I would like to keep FAN SILENT , though, because it is missing in the Overkiz library enum, and I want the code to look consistent where we use the FAN HIGH , FAN LOW ... etc. Best is to set FAN SILENT to a string. It is not directly coupled to the Overkiz command name. Why isn't this set in the entity? No need to cast before creating a new int with it if you are only checking if they are not None, it should be this is not good as it overrides the existing dictionary. I am not sure if I fully understand. We set a default value in the entity.py, where we first check if the device has a specific vendor name, and otherwise fallback to the hub vendor (e.g. Atlantic or Somfy). For this device they don't provide the vendor name in the device information, and falling back to the hub vendor name doesn't make sense. Hence we overwrite the current value with 'Hitachi', which is the vendor of this specific device. This pattern is used more broadly in Overkiz, so I will make more changes depending on the outcome :). Ah jus checked the other code, looks like it's fine. I thought it was overriding a key in a global dictionary but it's generated in the constructor.
This is existing code, but it doesn't seem covered by a test. Would be good to follow up with that. better to do it here because I found a bug!
This method should mirror async close cover (e.g. the isinstance check can be removed and an exception should be raised if the command fails). To avoid hardcoding magic numbers, these attributes are accessible as: What does this branch add? It seems like it changes the functionality of lift. If it's not required for this PR, let's omit it for now and then address it in a followup PR (probably 99646) I think this can be removed thanks to super().async update() calls cluster handler.XXX.async update() , which (in this case) also reads attribute values and updates the state. Unrelated fix.
This belongs in the 3rd party library.
We should return the datetime as an iso-formatted string in the attributes I've made the requested change, but out of curiosity I think I saw datetime objects returned elsewhere in extra state attributes . Is there a reason to prefer converting it here over (what I assume) having it automatically converted handled later? For attributes it's not handled later so therefore we need to make sure we store it properly here.
This doesn't matter anymore since pyhap will clamp them anyways, and if the underlying value changes we now rebuild the accessory anyways so it never gets here.
You can import this from homeassistant.const Would it not be cleaner to convert to UTC, then you don't need to use the replace function? Is there a reason to store the time zone in the object? I modeled it after [this code]( L144). mypy is complaining about this needing to be a string, so I'll take a closer look. If objects are acceptable, I see no reason not to pass a datetime with tzinfo , but if it has to be a string, I'll check to see how that's normally done by looking at some other integrations. (This is my first PR and I thought things were passing locally, but maybe I need to double check it since it's failing here.)
Do we really need this special translation key? Doesn't Problem already cover it? Yea, let's go with the standard device class name here. Why did this remove a key? It's a base fan, no point in calling it an IKEA fan. And why did this gain one? Imho a group a fans is different from a single fan. This was odd before, seems the group would done some weird device name default. device class Lokalise UI doesn't really like translation references deeper than 1 key
When can the case that the climate entity no longer exist while the device still does happen?
This is too much protocol details. Those should be kept in the 3rd party library.
This is incorrect. We should use entity ID wake word ID as we cannot guarantee wake word IDs to be globally unique.
Instead of this code, please something like L178 The advantage is that you don't need to modify the WallboxNumber , when you add another number entity I think I changed my approach to something resembling the unifi component. Please let me know if this is what you had in mind. yes, that's better indeed I think we can make this inline as well yes, can change that Can we maybe get the if statement out of the cast? sure These can be inline as well I don't think I can do a lambda function when its async right? I think you can, let me check ok, I made changes for the other suggestions Hmm, you're right. I think this might be able to do nice, but I would have no clue It is possible, see my comment :) Not sure if this is a right suggestion, but it looks a bit better. I mean, can we get the code to look like We don't really like multiline if statements as they decrease the readability hahaha, misunderstood. Sure, done. I made it slightly different now (also wasn't content with the first attempt), can you have another look In a follow-up PR please refactor all the protected functions as the all need authentication and have the same error handling. Probably you could solve it with a decorator: Could be something like this (untested) Maybe we could use a decorator here too. Please evaluate this in a follow up PR. nice solution, didn't know this was an option What's the reason for dumping and immeditaly loading it again? I am guessing a copy, since this is how you do that in javascript I use this to load a nested json result quickly. Might be an ugly solution, but its the quickest for me and gives me valid datatypes in the result. If you have a good alternative I could change it (maybe seperate PR, I use this in more tests)
It would be nice if the lib provided this so we don't hard code it here Done! In a future PR, it would be nice to make this a dataclass It would be nice if the library handled this in the future instead of having the sleep in HA I will do so in a later version of the lib. I also work on new features and this PR is the last hurdle to continue The linear search here could probably be avoided by indexing the categories in the future with a dict that points to the coordinators for each category I think this would work well with the dataclass
You can use syrupy for these assertions. Checkout for example the youtube snapshots. if you make the code like that you can run pytest . tests components minecraft server --snapshot-update and it will generate the .ambr files I'm not familiar with syrupy, but I'll have a look at it It's awesome, trust me :) How does this even work? It's like magic Done. Told ya :D and you can directly return this dict instead of creating something in between Can we maybe parametrize this test? Done (I hope I did it right?). Do we need this? Looks like None is the default for side effect -- Removed
Please remove all empty keys Please avoid assert in production code. Please specify a schema for this kind of validation. Please adopt other places, too. Please add a schema for all services remove all comment out code Please make the options translatable, or are these always the same names in any language? See selectors Please avoid multiline ternary operators. Please use an if statement instead If you translate the options you can the set the keys directly to these values and we can avoid this step. Use constants for the keys so you can reuse it in the service call Opening a file is IO and this should not be done in the event loop to avoid blocking it. Please refactor it, that the IO is done in a function, which is run by the executor Same here What are you doing here? base64.b64encode returns bytes, and this looks like trying to convert it to a string in a hacky way. Please search online for the proper way. This is creating an embeddable version of the image to be used in the img src return value of the detection and classification services rather than depending on filesystem paths. Still all replaces look hacky and I still think you are converting bytes to string in a hacky way or please give me the reason why you need all these replaces Please adopt the other places too Use SelectSelector and SelectSelectorConfig instead Check if for the other keys also constants exists Please recheck this code part as I think the image will be from the camera or None. The fiepath-image will be always overwritten. Also the ternary operator makes it hard to read, please avoid it here Please use the constants here too I think we can remove the hub class and declare the content directly here as it is used only here. You should always call the client close and not only when you create the entry Use constants here
Please use attr has entity name True instead in your MonzoBaseEntity and put your names in the strings.json The names of the account type are being provided by the external API so that new unexpected account types are handled or can be added easily, while pot names are created by the user in the Monzo app. Unless I'm mistaken, that makes it unsuitable for strings.json Fair enough. attr has entity name True is still a requirement ( has entity name-true-mandatory-for-new-integrations), but leave your names where they are then Actually, reading that you were right in the first place. The device name comes from the api but the entity names are constant, then HA can produce the friendly name. I'll fix it now, thanks! Can you maybe explain a bit on how the webhooks work? What data do we get from them? The webhooks are used for the event triggers. When registered, Monzo will hit HA with a transaction.created event which can be used to trigger automations and contains lots of extra data you can use such as amount and merchant . A full list of the data provided can be found in [Monzo's docs]( list-webhooks) Consider extracting the coordinator into a coordinator.py . I will greatly improve code quality I'd agree if I was creating my own coordinator, but there's nothing to extract here really. Checking around, I'm only finding integrations which have their own derived coordinator with coordinator.py files, while integrations that just use the basic DataUpdateCoordinator don't. Correct me if I'm misunderstanding though! Please add reauth in a separate PR Not needed Removing it throws an error Remove commented out code Please initialize this field in a constructor Sorry, I'm a bit confused here. There's nothing to init it with until it's set in async oayth create entry I agree, the current code is preferred over initializing it. Please split off device triggers Can be set outside of the constructor Remove empty fields Data classes should now be frozen. You can remove the Mixin by using kw only True checkout Withings on how that works Move services to a separete PR after this one is merged native unit of measurement should be GBP to ensure Home Assistant places the currency symbol in the correct place. Should this be using the constants from .const ? Definitely, thanks! Make this a dataclass instead: The class name is a bit weird IMHO These only seem to be used in application credentials.py, if that's the case, move them there. This doesn't seem to be used, please remove it.
Need reload Can be private Can be private Can be privat Can be private Can be private? Can be private Needs reload Reload on changed atteibute This isn't needed anymore since we just reload the accessory This gets detected higher up now and we reload Should this docstring be updated? d3b7d8e3675f933e4be7f986503b050d4a81b286 How come this is changed? Should it be in another PR? I wrote the test for this and than I realized it didn't work because the check for the device class was missing. I'll break it out into another PR
When gets merged, it might be better to use endpoint.device.quirk id here. It's None or a str with the quirk ID. (There's a difference between the ZHA endpoint and zigpy endpoint, as well as the ZHA device and the zigpy device.) Thanks, I changed the code a little to work nicely with that assumption.
We can check already here in the schema with vol.In Great catch. Thanks. Not optional If we do the check in the schema this would not be neccessary preset mode and kwargs.get(ATTR PRESET MODE) is the same thing right? Maybe expand the descriptions slightly more than just the name? or black will fail
As discussed on Discord, implementing a getattribute with a special treatment should have a higher chance of success. Maybe something like this will work: This moves to getattribute instead as int with ClimateEntityFeature always results in a ClimateEntityFeature so we need to make the check and log before. We already called this above, I think we can reuse the result here? The entity implements a method, not a service The PR which adds the toggle method adds turn off turn on to the base class. Should we maybe do it already here, otherwise that PR will have to be careful to not break the checks here. The condition means we'll log a warning for all entities which support HVACMode.OFF , that can't be correct? In the decision it says: So if mode off is supported then we should set the off feature flag and log a warning. The integration does not need to implement a turn off method as it can be handled by ClimateEntity.async turn off . I think there is no other way as effectively if an integration supports mode off it also supports turning the entity off. However I think perhaps we should make a slightly different message in the log then. What you quote talks about automatically setting the new feature flag. My concern is that the implementation in this PR logs a warning regardless of if the implementation itself sets the new flags or not. I noticed this so that's fixed and also a test added to ensure no adding or warning if it's already there. The condition means we'll log a warning for all entities which support more than one modes, that can't be correct? The logic does not appear to be correct, we should automatically set ClimateEntityFeature.TURN OFF if either (inclusive) of the following is true: - The derived class overrides the default implementation of climate.turn on or climate.turn off - The required HVAC modes are supported Same comment, the logic does not appear to be correct I think this would be more pythonic, but it's a matter of taste I guess:
This changes our entity component, for which an architectural discussion and approval is required before changing it. I suggest removing it from this PR, as it seems unrelated. .. Frenck This looks like it could be a dict lookup with a default value instead This looks like it could be a dict lookup with a default value instead This looks like it should use the fan platform??? bdraco Oh there was a Fan platform! The documentation for the climate platform says: Climate Entity A climate entity controls temperature, humidity, or fans , such as A C systems and humidifiers. Maybe we should edit it? I got tricked lol Do you want me to make a separate PR for the fan on the fan platform? Do you want me to make a separate PR for the fan on the fan platform? Yes please. This should come out of this PR, and the next PR can be to add the fan platform Reading more in details, the fan platform has less features. It does not handle vertical and horizontal oscillations... Well I say that but does not handle it by default either lol If it doesn't support HVAC modes it shouldn't be a climate entity Reading more in details, the fan platform has less features. It does not handle vertical and horizontal oscillations... If the fan platforms oscillation support is too limited you can add a select entity to adjust the oscillation in more detail We should only iterate the devices once and put them into the expected buckets. As this grows to support more devices we want to avoid a pattern where we iterate all the devices in a way that performs poorly because we iterate O(devices device types) Does the device not know the current temp, and current target temp? It does not know, it is infra red so no feedback... Let's set attr assumed state True Also please add a comment that explains that its using IR so we don't know the state Maybe make 4 and 1 a named constant to better show intent here Can we pass these as kwargs instead of constructing a string? The send command is generic for all devices in Switchbot and the Air Conditioner is the only device asking for building a string so I would rather to push that in the library for a specific case. I agree it looks ugly though... There's no discovery info parameter in the async setup entry interface. Please limit docstrings to max 72 characters per line. The first line is a header and should be a single sentence. Then an optional body. Do we support setting 0 degrees? In that case we need to check for None explicitly here. For Air Conditioner, it usually does not go bellow 15 degrees: Ok. Don't we need to update state here?
Ut would be better to use from homeassistant.const import Platform and Platform.COVER Thank you for your suggestion, I have taken it into account and modified it. Can replace the loop Thank you for your suggestion, I have taken it into account and modified it. Is there anything you can replace by a constant from: workspaces home-assistant-switchbot-via-api homeassistant const.py ? Thank you for your suggestion, I have taken it into account and modified it. I think it would be better to use more often translations from homeassistant strings.json and more generic messages when possible to decrease the amount of translation needed. Abbreviations like pos should be avoided too I believe. Thank you for your suggestion, I have taken it into account and modified it. What happens if all is not good ? The implementation of getHubInfo is as follows this part of the code is in leviosapy : You can see that this method just tries to update the hub fw v attribute, i.e., in order to go and update the version number of the hub, so what happens when this attribute is invalid ? Let's go back to leviosa shades . You can see that if hub.fwVer is invalid , then it triggers CannotConnect error. Above, is the explanation to your query. I understand that the CannotConnect error can be raised in the config flow, but the async setup entry in cover.py is run every time Home Assistant starts I think so we need to handle the issue here too. getHubInfo should raise an error instead of using a side effect. There is also the possibility that self.get raises a LvsaApiConnectionError error but it is not handled. I've updated the getHubInfo method to handle various exceptions inside, so it will be safer to use externally It might be possible to set each property with 1 line of code instead of 3 as class properties attr XXX in the class itself of the constructor sorry I don't get you. Are you referring to programming style issues? Or do we have to name private attribute definitions in subclasses starting with attr ? Sorry, I mean that instead of defining properties like: You can instead use in the constructor: I think most of the properties have a corresponding attr xxx attribute, maybe should take a look at: [homeassistant components cover init .py]( L222C14-L222C14) and L240 It is just a programming style issue but having a briefer code would help readability I believe. Your suggestions are very constructive, but I'd like to focus my time on all the code style issues (not just this one project), so would it be possible to allow this pending style change to go through first, and update it later, I don't want to spend my energy on just this one code style change. I think we should avoid abbreviations when possible, devs 2b made me bug a little. OK, I'll changed it to devs to be removed
We only create brands if we have more than 1 integration. Please move it.
This line is not covered by tests. We require 100 test coverage on our config flows. .. Frenck Using both the exception logging method and exc info isn't needed. We normally don't log the stack trace if the exception is known.
any hints are highly welcome about making mypy happy about this 91d2a6b Where does "not set" come from? It's from the constants DEFAULT NEAREST etc. Would "unavailable" or "unknown" be better in those cases? The "not set" is part of the legacy proximity entity and will not be used further for the new sensor entities. i did not want to change the behavior of the legacy proximity entity for now, so users are not tackled by an breaking change for existing proximities, but have the change to smoothly migrate their automations etc. to the new approach What does "not set" mean? If it means we don't know what the sensor state is, then we should use "unknown" instead, yes. There's two slugify calls? What happens if the tracked entity id changes? Including a name in the unique id isn't good. When we allow the user to set the unique id it is an explicit setting for unique id. If we take the name the unique id setting isn't clear anymore to the user. If we're going to add a config entry to this integration I suggest we wait with adding unique id until we have a config flow. When we have that we can use the config entry id as unique id. There's two slugify calls? fixed What happens if the tracked entity id changes? Including a name in the unique id isn't good. When we allow the user to set the unique id it is an explicit setting for unique id. If we take the name the unique id setting isn't clear anymore to the user. the user sets explicit the tracked entity ids in the config ( later via config flow ) so they cannot change by accident ( eq. user renames the entity ), but explizit by the user when changing the proximity configuration. If we're going to add a config entry to this integration I suggest we wait with adding unique id until we have a config flow. When we have that we can use the config entry id as unique id. i don't think this will work, because we can have multiple tracked entity ids per config entry, so config entry id would still not be unique. SO i'm not sure what unique source for a tracked entity we could use ( maybe the unique id of the tracked entity - in case there is one ) My point is that it's not clear that the user is setting a unique id when they set the zone to be monitored. I meant that we can use the config entry id instead of the name of the zone. We'd still need to append the entity id of the tracked entity, or some other id for each tracked entity, yes. Yes, the tracked entity cannot be changed implicitly, but what should happen when the user changes the tracked entities? Should the stale sensor entities be cleaned up? Should sensor customizations be migrated to the new sensor? Or should we not allow changing tracked entities for a config entry? My point is that it's not clear that the user is setting a unique id when they set the zone to be monitored. ah ... i misunderstood it ( I thought you meant the id of the tracked entities ). The coordinator.friendly name is not the monitored zone, but just a name the user gives this par
Does it differ that much that it needs its own (duplicated) class ? Not possible to create a Base model and inherit the sub types from that ? yeah it's possible and I thought of doing so but then forgot. Will look into it again turns out while ZwaveLight has a bunch of extra logic not needed here, because of the way it is written, we are still good to use that logic for the Basic CC light! The terminology "basic light" is a bit misleading imo. Better use "basic cc light" which is more describing I would use Basic CC or basic cc here to make it more descriptive as now it more looks like a "basic light" instead of "a light based on Basic CC"
Can we move this code down to the existing if-check on result. Moved If you don't know which one will be the wake word and which one isn't, your snapshot checks can fail. Should we return an error code to indicate to the satellite that a wake word was found but it was a duplicate? We can do that maybe in the future.
I don't think we should extend the search config option feature. I rather think we should deprecate the whole custom calendars option in caldav. We have the calendar trigger that can be used to trigger automations that searches for matching events in a condition. If we need better GUI options for calendars to customize the display that should be solved generally for all calendar entities and not per integrating integration. (via architecture discussion) Agree, i think there may still be something here around the calendar helper: but it needs to be revisited or a little more thought. We can also consider adding "categories" to the calendar event model since it is part of the rfc.
Please raise ServiceValidationError instead, and it would be nice if we could make it translatable too. See Sidenote: Catching the bare exception is only allowed in the config flow I think it would be great to extend the third-party library to allow passing the incl vat as setting and restoring is hacking and there could be some race conditions klaasnicolaas is this the correct way to solve this issue: Yes, but superseded by a PR of mine I will create a separate PR for the dependency bump. If it is allowed, I can also just include it here as I need the updated version anyway? You can update the dependency locally, just don't commit it. Once the PR ( 105080) has been merged, you only need to rebase your branch so that you are up to date with all changes from dev. Why is this being removed? So I think we have more options here: - Or make the attribute not a boolean but a string enum like the EnergyZero package - Or keep it a boolean. Then I think the name ATTR INCL VAT is more clear on what it actually means. Which one do you prefer? Perhaps it is best to use the enum and a select list in Home Assistant UI? I've been playing around a bit with the services in the UI, but I don't get a default value in a dropdown list. I would say give it a try yourself, but...Perhaps it is better to implement the boolean option, but set it as required and default true. I don't think you use pytestmark anymore Use references for all duplicate strings I think the example is not needed here Use partials instead of calling the extra function above, [example]( diff-8162f13dcf871fea4e83ae6cb8fadf9adfe6ddcaa58e6da14edb5478041106a0R105). I think this function should be async Why? It does not do anything async, only pass async functions around? Or should the hass.services.async register be awaited? The hass.services.async register is not a async function so it cannot be awaited? ![image]( No you only should await the async setup services , it is used somewhat mixed in other integrations. Personally, I'm used to these kinds of functions being async, but maybe someone else can answer that better. I cannot see the benefit of creating an async function that is not doing any awaiting, but sure.... See for explanations
Should this be a function. Looks like the same pattern is used above mqtt data.open config issues is an object ( set[str] )set thought a dataclass using a default factory. The intention is pop an item (containing an issue id) and remove the registered issue. I was just thinking that could be a function since you do it in two places Ah, okay, now I see what you mean. Good point. done Note to self: check this block to see if there are any opportunities to make it more dry bdraco In (the light follow up PR this code part gets some refactoring) Isn't this breaking since the user can no longer test specific options with dev tools check yaml config before restarting? I'm not sure that's actually valuable though as the issue is way more helpful but they will only see it after they restart Good point. I'll add a not in breaking change section. done. Please rewrite this to use the issue registry to list open issues, there's no reason why MQTT should keep track of issue registry issues. This is basically a copy of async setup entry helper . Will async setup entry helper be removed once all platforms are migrated? It will remain for tag and device automation, but some parts of the code will be cleaned up at the end: [Clean up code]( If async setup entry helper will not be removed in the end, please refactor async setup entry helper and async mqtt entry helper to avoid the duplication of code. Also, please give them better names, I guess one is for setting up entities and one is for setting up non entities after these changes? Agree, but can we do this at the end of migrating the platforms as it would spare a lot work. I'll add a commit to de-duplicate the code of the two helpers in 101649 I think this is more idiomatic: Why is this a coroutine function and not a callback? I don't see any await inside. They could be callback's for the entity platform. The non-entity platforms: tag and device automation are set up differently and need coroutines. If we don't need to await inside we can make this a callback. Same here: might work for entity platforms but not for the entity-platforms. The grammar isn't correct here. It should be "Invalidly". Maybe rewrite it to something else though? See manually configured
I think it would be better to compare if the version changed before we try to update it, since thins update happens on every status from the device, what I noticed in Gen1 that calling this method does many comparisons internally. Example in Gen1: L381-L382 Good point! My intention in my previous comment was that we do this comparison before we call device update info , but doing the check inside this method is better, but I would move it to be the first thing (we can supply the current FW as a parameter), before we try to get the device from the registry and we can also remove the check from gen1 after we do it here (now we have a double check for Gen1)
We should not add a unique ID to this integration, instead this should be moved to an configuration flow.
That's already handled in xknx L191
As this code is called on setup and therefore on each startup, we don't need to persistent the repair issue. I would also remove the invalid holiday name from the suggested values I suggest validating the options here too, like in the config flow. Can be removed as the schema has only CONF REMOVE HOLIDAYS Only double checking... Can we leave options empty? Will the user has than any possibility to select something?? They can't choose from anything but they can add custom values to the list. It's the same logic as in the regular config flow to potentially remove holidays from the object.
We should check the registry to see if the mocked device is removed instead of checking a total. Yes, sure, will update the test later today. Updated as suggested. - I don't think dummy was supposed to be here? - Also, it shouldn't be needed to track these? Feels weird? On the use of "dummy", the init needs to have the strings in place, I could change it to {("","")} that works too. But {()} doesn't work, mypy is not happy with this. Not needed to track these: you mean track the self.current entities ? This self contains the set of actual entities created during the initialization of the integration. This set is compared to what is present in the entity registry, if there are more entities present in the entity registry then in the set, it means some cleaning can be done. frenck I'm seeing that ISY994 uses this as init: I can follow this idea and create a better but still a dummy entry in the set. The dummy can be there, it does not harm anything because the difference-function in this set(entities.keys()).difference(isy data.unique ids) only leaves the entities that are present in the entity registry and that are not present in the set with current unique ids. Some improvements have been implemented. frenck looking forward to receiving your feedback on the latest changes :)
Can we make this a fixture? Would be nice, but options :) Maybe for a future PR Post merge, following up on the fixture comment since i'm happy to explore it in a future PR. This is used with mock events list items which is a fixture. That is used at different points in the test to change the next response when events are listed, so the API is now something like: or if testing a special case, something like this: or for tests that are not using freezer: So its definitely used as an input to a fixture, but its just a variable to help with creating new events for composing them. So at best we could make another fixture that is a simpler fixture that already takes in the TEST EVENT as a default and the caller passes in the deltas for the test, but I didn't think having multiple fixtures was worthwhile, and so that is why its composition via TEST EVENT If you have other ideas happy to explore them, but also this isn't a pain right now. Thanks!
This change is out of scope of this PR. Please keep the PR to the scope defined. out of scope Out of scope Out of scope Out of scope Why wouldn't a fan swtich go into the fan platform rather than the switch platform? Out of scope Out of scope
Optional suggestion: Outside of this PR, you may want to consider using composition rather than inheritance given the number of double subclasses going on in this integration. Optional suggestion: Outside of this PR, you may want to consider using composition rather than inheritance given the number of double subclasses going on in this integration. Ok, I will look into it for future PRs. Thanks for the suggestion allenporter :) Done in 76940724d61cfd07afc5f515f7d90d91acbec322 Done in 76940724d61cfd07afc5f515f7d90d91acbec322 Please use [] here as the key should not be missing Done 76940724d61cfd07afc5f515f7d90d91acbec322
Forecasting cannot carry a state class, as it is meant for current data only. We should not use the translation key for it. The translation key should only be used for translations.
Device class translations Indeed, I forgot about those. Thx! Can we use translations for these? Indeed, I forgot about those. Thx! Can we use translations for these? Indeed, I forgot about those. Thx! Can we use translations for these? Indeed, I forgot about those. Thx! This one can be removed as the device class gives the translation :) Yeah, noticed right after the commit ;-)
I don't think this is a good name, get forecast extreme might be better? Wrong spelling. Please don't use magic strings, but ATTR WEATHER-constants instead to avoid that. I guess we should all of the float ones, as example wind gust speed would be missing Maybe allow any attribute which is included in forecasts? Why not 10 days ? I got only 216 forecasted hours as output. I am implementing a check to avoid array out of range exceptions, so it doesn't matter I think it depends on weather integrations and or location to provide different forecasted hours range. So out of range should be handled nicely to prevent errors. And I think we prefer a calculated value to easily see how long the limit is 9 10 days (216 24 9) Why is this only supported for hourly forecast? Because of the hours based filter Right, but we know that the other forecasts are 12 and 24 hours respectively. Maybe the service handler should pick from available forecasts in the priority order hourly, twice daily, daily? gjohansson-ST WDYT? I don't see a reason to limit this. I think we should support all forecast types but probably we leave it as an option in the schema but default to hourly Implemented FORECAST TWICE DAILY and FORECAST DAILY The schema marks this as required: The schema sets a default: When can this happen? The service only allows calls on entities which supports forecasts? Since we call weather.async forecast hourly() we should check if the entity supports it I looked at def async get forecast service Right, but the get forecast service can be called for an entity which supports hourly, twice daily or daily forecasts. The service added by this can only be called if the entity supports hourly forecast so we don't need to check it again. Obsolete by implementing daily forecasts This is already checked in the schema, it only allows 1..216 I'm not sure we should include calculations in the service parameters. I think calculations should be kept in a template as different calculations may be wanted by different users. Calculations are not dependent on the service result, but could be anything. Filtering is more dependent on the the service and service result, so is more acceptable as service parameters. Agree. The output can contain both min and max. Possibly also avg. WDYT? No, I don't think we should have any calculations in services. My idea was to retrieve the extreme values via a service and make all my sensors with templates redundant. If we do not use the calculation in services, this service is useless. We could implement the hour filter in the normal forecast service instead. I think it would still make sense to extract a single attribute with a time-limit. Removed calculations and renamed service When can this happen? We require at least one of the supported features when registering the service. Min max isn't used. I also still think the user should be able to select which forecast to pick from limit hours should be renamed to be a fit for all three types. Wha
I see you love migrations, but they still aren't backwards compatible. Since we're now only adding a server type, can't we just make the code use Java as fallback? Thanks so much for your VERY fast review :smile: Why aren't they backwards compatible? I think I didn't get this point. The problem would be long update times, because the API currently tries to fetch data 3 times with 3s timeout each. That's why I thought it's the best to store the server type to get fetch the data faster. Well, the new config entry has version 4, if someone reverts to 2023.9, the config entry version is 1, which is not 4, so it won't load. I agree with storing the server type, but that doesnt have to be inside a migration. checkout: L103-L114 Aaaah you meant incompatibility when downgrading. Yes, that's true. Yeah maybe I can fallback to "Java Edition" in case the key TYPE is missing in the config entry data. I'll try that out. If you check the code I linked, you can do something like, Done. Reverted version 4 and moved migration from async migrate entry to async setup entry. Why not just make it return a list: That sounds like a better idea. I'll try this later, thanks : 1: Done Please make sure your config flow tests ends either in a config entry created or abort to show it can recover from a failure In each test I already check for FORM or CREATE ENTRY . Do you mean the order of the asserts? Should the check for flow result be always the last assert in the test function? Or do you mean something else? you only check for form, but we want to see that after an error message, the flow is able to succeed Sorry, I'm a bit lost here. I checked a few other integrations and didn't see much of a difference. The config flow of Minecraft Server either is successful ( CREATE ENTRY ) or it cannot connect. In that case the same FORM is shown only with a difference, that the error message is shown additionally. In that form the user can correct the user input and retry. It's something that we like new tests to have, to avoid code that could stick around and put the config flow in some kind of lock. So the trick is to finish the FORM, so it will become either a CREATE ENTRY or an ABORT My problem is, that I don't abort my config flow, therefore (if I understood correctly) I can never reach the ABORT state. Let me try to make this more clear with screenshots. This is the initial form. I entered an invalid input and after confirming we come to the second screenshot. ![Bildschirmfoto vom 2023-09-27 10-19-02]( After the config flow detected a connection error, the same form is shown with additionally the error message. ![Bildschirmfoto vom 2023-09-27 10-19-40]( So the config flow doesn't abort the flow, even if a connection error is detected. Understood, but then we would like the tests to first reach the state where we show the user an error, and then retry again with valid info, making it succeed. This is to make sure the config flow doesn't end up in an unsolvable state. This is s
Is there a translation string to clean up? Good point Shouldn't we unregister all the listeners when unloading the config entry? You mean the cloud listeners? All the event listeners, like async call later . Probably use this helper instead: L73 We shouldn't use this signal directly. It should be triggered from the cloud integration somehow. Do you have any tips on how to trigger it? I think we could make a common test helper that uses the dispatcher signal. That way we don't need to mock out the cloud integration in the tests of other integrations and we don't use cloud integration details in the tests of other integrations. So we still use this same piece of code but we encapsulate it in a helper? Yes. What would the best place for this helper be? Probably tests common.py .
Since the device you set as device info has the same name as this entity. This will name the entity to the device. Please sort :abcd: . We don't pass the unique id of the config entry. Either we pass the wrong thing or the parameter is incorrectly named. Thx for spotting. Will rename the parameter. We try to avoid guards like this in service handlers in polling integrations. If we would have the wrong state, we'd be unable to call services. The only valid case for guards like this in polling integrations is when the device can't handle the service call during certain states. Unfortunately there is no native stop command for Comelit. Instead the way to go is send the opposite action: if closing send open; if opening send close. But this means that I have to know the device is moving before doing so. Otherwise it won't stop but instead start moving. Ok
If the incoming request does not have the "X-Telegram-Bot-Api-Secret-Token" header, this will raise a KeyError. Let's check for that Why do we need to check this? An ephemeral secret token is unconditionally created when the config entry is set up. In the current setting, yes, the token is unconditionally created as a non-empty string. This check is to ensure if any changes were made to the creation of the token or the initialization of PushBotView , we are still verifying against a valid token. I can remove it if you think this is unnecessary. We should not patch the code we're testing. Instead, do like this, calls to secrets.choice will now iterate over mock secret token : I think this was just added for testing? If so, inline it again. Yes. I have rolled it back to inline. Please use f-strings instead of string concatenation.
We now have an optional selectSelector. See also So we don't need to convert the MappingProxingType to a dict We should match the error message to be sure the correct one is raised
This doesn't match the docstring. This is a weird check. I think we should change the last part of the config entry setup like we have done in the matter integration: L107-L114 Then we can guarantee that the driver attribute is set when the config entry is setup. We can change that in a follow up. this was actually an extra commit that I was using to figure out how to get another unrelated test to not fail. I will refactor this in another PR to be cleaner and will try your suggestion This constant should probably move so we don't need to depend on the logger integration. Events go through the core and should not require a dependency. let me know which order you'd like to merge these in. We can merge this and then rebase the other and fix, or vice versa
It would be better if the library handled managing the connection and the switch entity told the library to disable the connection logic, or re-enable it. We want to keep at little logic as possible in Home Assistant itself. That's a good idea indeed! It will remove a bunch of complexity from this switch. I'll move it and the tests to the library then! It would be better to flip a flag and let the coordinator handle this as its a bit of a seperation of concerns issue to have it inside the entity Makes sense! I plan to add better support for the device disappearing and coming back in another PR. This PR is getting a bit large, I would move the coordinator changes to another PR (with it defaulted to on) and introduce the switch here with the ability to flip it from on to off Done: Same comment from the previous PR You might want to store it as data.name so you can avoid the dict lookups and typing run around You might want to store it as data.name so you can avoid the dict lookups and typing run around I think I had that initially, but removed it to avoid duplicating the string. After looking through this, I realized this is a virtual entity as it doesn't represent the state of the device, but instead represents the state of Home Assistant config entry integration. We currently don't allow virtual entities to be added to integrations. An alternative would be to make it a config entry option via an options flow, but the downside of course would be you couldn't use an in an automation, but I'm not sure if there is a use case for that here anyways. The reasoning for the switch is the limited number of active connections on bluetooth radios (ESPHome only allows 3, for example). If you have multiple devices (not only desks), you can have an automation to only connect to the desk when you want to move it. An alternative would be too add homeassistant.disable config entry and homeassistant.enable config entry , as we already have homeassistant.reload config entry Looks like there is a feature request for that It looks like a previous PR has was not accepted that implemented that In in ideal world the desk broadcasts it state via the advertisement and you only connect to it when you need to make a change. I don't have one of these so I have no idea whats in the advertisement Another option would be to add a button entity to connect the desk and one to disconnect the desk. That would avoid the whole virtual entity problem. Unfortunately the desk only sends data to the device connected to it. Also, it only connects to a single device at a time, so the user needs to be able to disconnect it from HA to use the Linak app. Is the only reason this is not allowed the fact that the state of the switch does not reflect some state on the device? That is why buttons would be accepted instead? Is the only reason this is not allowed the fact that the state of the switch does not reflect some state on the device? That is why buttons would be accepted instead? That is exa
Duplicated Duplicated I guess that was due to a misunderstanding on how that function works exactly. I thought the first list is for (realtime) sensors, and the second for forecasts. Are they all equally available? (Why the differentiation then?) That's correct, but you have duplicates in this list. Also, move the added items to the bottom instead of adding at the top. Replace the list with the following. Change the field order to match the order the fields were requested in init .py or the order they are present in the weather component's forecast entry type.
This is really ugly. We should name the test list , not is list . Same for the other tests. I was following the is number convention. Agreed it's ugly, but the advantage is that it distinguishes between the test check and the functions to convert the value to the given type. So there are two options: 1. Leave it as is, and have two different names for converting a type vs checking a type 2. Use the same name for converting and checking. That means list is a test that checks the type, but is a function and filter that converts the type Which is more desirable? the number test was already in use as a built in test, which only returns true if the value actually is a number (so not when it is a string) Point 2 is similar with the built in function filter string which converts the type, and the test string good point. Thanks! What's the reason to have all the is as globals? it's just a convenience thing so you can do is list(x) or x is list The name is somewhat misleading since it returns False for other iterables than strings. Should we name this is iterable and just document that it returns False if the object is str, bytes or bytearray? I see your point, however I don't think the is iterable name is useful either. Is there a name for this class of types? bytes and bytearray aren't strings but they are string like per the suggestion below I changed it to string like To continue the discussion on non string iterable ... I also don't like the name, and I think we should not create non tests, when jinja has bultin not support. To keep consistency over all tests I would suggest something like: So users can write What do you think? works for me, updated Do we actually type these? From other tests I saw that only things provided by HA are typed. I am OK with typing them just want to make sure we aren't breaking standard In my opinion, it is always better to provide more type hints if you can know the types. With the type hints the IDE and all our checking tools (mypy, ruff, pylint, ...) can give you hints if you are using a variable wrong. This is not called from outside this module, it should be is list , not is list . Same for the other functions. Existing template functions should be modified in a follow-up PR.
It needs to be made clear this is supposed to be a youtube-dl query It still needs to be made clear this is supposed to be a youtube-dl query, maybe just change to: Should this default to the CONF DEFAULT STREAM QUERY instead? Otherwise it's weird that the CONF DEFAULT STREAM QUERY influences the play media service but not the new service. I don't think extract media is a good name for the service. The gist of the service is that it returns a dictionary with a URL with the wanted format, can we try to make that clear in the name too? Maybe "get media url" or "get stream url" or something like that?
Little longer but at least we avoid writing advertising interval TRACKER BUFFERING WOBBLE SECONDS twice Yeah I went backwards and forwards on that line a few times This is also used in prefer previous adv from different source pytest.approx would probably be better here pytest.approx would probably be better here pytest.approx would probably be better here pytest.approx would probably be better here pytest.approx would probably be better here pytest.approx would probably be better here pytest.approx would probably be better here pytest.approx would probably be better here pytest.approx would probably be better here
Store this in hass.data instead. The container should also be updated when the device is removed, either directly or when the config entry is unloaded. Make this a callback callback function instead. We don't need to await inside. I think we should rename this class to MySensorNodeEntity and inherit from Entity . Rename this class to MySensorsChildEntity . We can remove this property. This should move to the parent entity class.
Can we maybe make separate sensors out of these attributes? We try to avoid putting too much in the attributes sure thing I'm guessing this is a sensor for temperatures. I think we should add the native unit of measurement and the device class Temperature it's actually not, it is a sensor related to this red section in the app: ![image]( whith humidity comfort in horizontal and temperature comfort in vertical. Values are text only... Note that freshnees is the yellow part ![image]( ooh right, what can the values be? We have a SensorDeviceClass for ENUMs, you can then add the possible values and them to the translation file, making it easier to make automations for. Example: L76 i don't know the different values :'( I can try to run some stress tests on the sensor I mean this would be the best option, this way when you create automations you can see the possible values: ![image]( I'm guessing this is a sensor for humidity. I think we should add the native unit of measurement and the device class humidity see above I mean we have the sensor definition static here, there is no case where someone accidentally added one of these Is Air Comfort a brand name? If so: else: Oh right, this is a binary sensor, we should move this one to the binary sensor.py file, we can do that in another PR done If the return value is a date, please use device class TIMESTAMP If the return value is a date, please use device class TIMESTAMP Also, I think this is the same as datetime.from iso or something along those lines
You don't need both translation key and name. So remove name. Is power the amount of modes the integration has? The power identifies the target power of the device, it can be set from 1 to 9. Is power also used as name for the setting in the app? I am thinking it might get people confused with power as in kW. (As the name will be translated, I think it might get translated to the power in kW variant in some languages, so I'm trying to avoid that) I understand it might be difficult to have the full picture on how the device operates, would be good to include in the "standards" a markdown file with device information and capabilities, I believe this would be good for reviewers to have the big picture of the device. That being said, I also spent some time thinking on what would be the best approach and namings for the device. This device is a fireplace that have the following capabilities: Operation mode: On of the following modes are valid: Temperature or Power Potency Target: When in temperature mode the target could be a temperature and when in potency mode it requires to be a integer between 1 and 9. In the API CGI of the device this is set by 2 different parameters (in spanish consigna potencia and consigna temperatura). on and off switch: the allow to set the device on and off, while the device is starting or shutting dow it will iterate over a state machine, it doesn't go directly to on and off state. but this parameter in the API CGI allow us to set on and off. The switch is set to off only when the state is off otherwise it's on since the device is working. Ideally while shutting down and powering on the state shouldn't be changeable either. After this what are your thoughts? How does it switch between temperature mode and power mode? Does it automatically switch when you update one of the two? Or will you add a select entity for that in the future? Maybe "power level" covers it. It doesn't switch automatically but it can be done in the API CGI so in the future a select can be added. For now only power will be supported. Power level seems fine to me, also considered it, also though on power target and temperature target, but feels awkward. I'm leaving that for you (although I do want to mention target temperature sounds better ;) ) You already have this in the super class It's generic ;)
I do not like this but I can't think of another way. The unit is not predefined and can be everything, but in practice we see only 'm3' and 'GJ' for external devices. Another problem is that is is theoretically possible to have an invalid unit for the device class. (Gas can have 'GJ' or 'Cats' for example.) -- We also can return the most likely unit for the device type, but that can trigger some issues when the unit is unexpected (which is also possible with this implementation). E.g. If we return GJ for 'Energy' and a device decided to use 'kWh' as unit. You set the device class in the entity description, so this is clearly not OK. You have two choices as I see it: 1. Don't add sensors where the units are not allowed, you can use the DEVICE CLASS UNITS map for that 2. Don't set the device class in the entity description, instead add a "suggested device class" or something, which you validate (if the unit is valid make the device class property return that, and if it isn't return None) Implemented a bit of both, seems to work nicely. Whay do you think? Description now as a suggested device class, and will only be implemented if unit is accepted by DEVICE CLASS UNITS. TBH, this is a bit filthy. The ExternalDevice list in diagnostics return a list where the unique id's are used as keys for the dict, we should hide that. But.. This hides all the values in this list, which can be used for real diagnostics. In the meantime it seems a list is redacted recursively, which fixed this issue. The keys seem to be natural language, whereas the existing sensors don't have those kind of keys. Why is this? Have things changed upstream since your original PR? I misuse the key in device name ("Gas meter (G0017591236671715)"). We now maybe can use the name field, but that also feels wrong. Do you maybe have a suggestion? We now allow composing entity names of a translated base and a placeholder. In this case, you should set the translated name to "Gas meter ({serial number})", and then set the serial number in the attr translation placeholders Or this doesn't help you because you use this as base for the device name, not the entity name? If that's the case, maybe add a device name to HomeWizardExternalSensorEntityDescription so you can change it later without affecting the key? Good one, picket the device name works nicely! Instead of this, can you add translations? Done Why are these removed? Does it mean this is a breaking change? - total gas m3 is now exposed as sensor in the added device. So no breaking change expected. - gas unique id is added in the name. This value never changes (a new device is added when the gas meter is replaced). We can mark this as a breaking change but it is a small one IMO. gas unique id is added in the name That I think is not a good idea. It is not really user friendly to squash IDs into names. Besides, once renamed, you loose track of it. I would encourage to revert that change. .. Frenck Change has been reverted, by adding the uni
Please also change this at the rest. Only Title case, unless its a brand name or something I would suggest to rename unknown to something like Unknown alarm since Unknown is also a state when the sensor itself is unknown
I was planning on deprecating the true false attributes since you can figure it out fully from the operation one. I would say we probably shouldn't add new ones but it won't cause a lot of database churn since they are mutually exclusive and it's best to do away with them in a future PR when we can give 6 months for users to adapt I agree that the operation should be enough. The true false sounds more like debug info, but for this PR I just followed the other attributes. Minor: fetch the state once instead of calling hass.states.get() twice Please fetch the state once instead of calling hass.states.get() multiple times Please fetch the state once instead of calling hass.states.get() multiple times Please fetch the state once instead of calling hass.states.get() multiple times These are used the same way in all the old tests as well. Should I change them there at the same time, or should I leave that to another PR? It would be great to clean up the older tests in followup PR I'll do that once this is merged
So two new entities per device here as well? Yep!
In all of the other platforms we keep the Block (Gen1) related definitions before Rpc (Gen2) definitions, this keeps easier tracking Gen1 Gen2 and is also sorted alphabetically. Good point, thanks. Same as above, better to move before RPC EVENT Same, before ShellyRpcEvent I noticed during testing that this should be description and not type
Can we do a validation here like in the config flow? Just to check if we can receive data? Isn't that covered by the fact we call await coordinator.async config entry first refresh() ? I am still getting into the core internals, I have followed ipma and enphase envoy integration as example for the structure. I can also make the same call as in input validation of config flow, but in this case what is the way to handle errors? Hmm, I just checked some code and not every integration does this, and I think I remember this as a good practice to do. One reason I can imagine is for example auth. If someones password has changed, we don't want to start up everything and retry the old password every poll. If we can do a simple request at start to check if the credentials are valid, we can continue, if they are not, we return False and we just tell HA that the integration isn't ready but won't be coming up without user inteference (but later we might replace this with the reauth flow) Default can be omitted, everyone's network is built differently, and I would imagine that someone working with HA at least know what a host is. The reason why I considered adding the default was to provide a hint for the https port, but I will add this to the documentation, it seems a better place. I know that this is from the hassfest scaffold, but I think you can just move this into the async step user there isn't a lot of added overhead. what are we trying here? Can't we move this inside of the user input is not None block? why would self.unique id be set at this point? you can remove this check Less hassle, more short :) The whole trickery you're doing here: we have something for that! self. async abort entries match({CONF HOST: user input[CONF HOST]) This will do exactly what you want You're not using host anywhere, you can omit it I use the coordinator.host as way to pass device host information, in this particular case it's used by the entity to set the device identifier. Maybe we could find a better way but I felt this way this info would be shared using the coordinator only. Do you believe this is blocker? You can remove this comment as we know :) I personally, like the added info since might be helpfull for other that are learning just like me. Any way, I am removing it as you requested. This comment is right as well, except for the fact, you don't have reauth yet. So best way is to add the initial data check in init .py like I commented before, so if the auth is invalid, we don't start the integration, but if something happened during a HA session we just keep looping (It's not nice but I think it's the best we can do) You can make this shorthand via attr device info in the constructor Remove the empty objects IPMA ?? You're already asserting this in the entity. If you want to make sure the coordinator actually got data, use that check in init .py and prevent it to actually setup the platforms Is already present in EcoforestEntity this is not a test... I have foll
Wouldn't this be clearer in the intent? Maybe list notifications would be clearer? Especially if I remove the force parameter. See other comment. Renamed to list notifications I'm confused by the whole coordinator being here? Why are we using a coordinator and not just fetch the latest always? Flume API has a limit of 120 queries per hour per account. We are already fetching notifications via the coordinator every 5 minutes. In fact I should remove the force parameter. One can use homeassistant.update entity or even homeassistant.reload config entry . This is quite similar to the calendar.list events service that returns previously synced data and Google Calendar syncs every 15 minutes. The advantage of keeping the force parameter is it's clearer the service returns cached data and makes it easier to force fetch fresh data. I think the latter is a documentation issue. Let's remove it. We can always add it back in the future if a use case and bigger need for it raises. Removed This doesn't need to be a coroutine function as there's no await inside. Done in Same here. Done in
Const shouldn't be needed here. You should also think about adding test for the others Give a clearer error inside config entry not ready. It's typical for people to put stuff like this inside a models.py look at lookin as an example Make sure you run pre-commit, I believe this wont pass linting when checks are approved to run I Make sure run pre-commit. pre-commit-config.yaml Too broad of an exception You should catch the possible errors seperately and have human readable errors inside config entry not ready re-evaluate if some of these should be private return value No need to set attr name twice self. attr name device.dev name if channel 0 else f"{device.dev name}-{channel}" Also is dev name already a str? if so no need to do a f str can just set this once with attr should poll since it never changes Comment should be different than just the title of the function - you do this a few times You should only create an entry if you can confirm you can communicate with the hub Same as before - you need comments that aren't just the title of the function this check isn't needed. When device.channels has a len of 0 in the for loop below, it will essentially continue anyways It's not really a wrapper, it's a subclass. Just call it RefossSwitchEntity Seems to me like this should be debug, not info Seems to me like this should be debug, not info import this from const instead I tried to understand, but why are we storing location data? Please only have code in the try that could actually raise an issue Do we have Refoss specific exceptions we can catch? There's nothing special here, only the exceptions inside the socket. I define an exception to identify the exceptions inside the socket Can be moved outside of the constructor New integrations must use attr has entity name True , more info at has entity name-true-mandatory-for-new-integrations Do we need this? Isn't this something that should be in the library? This will utilize has entity name True better
Don't store anything in hass.data until after we possibly raise ConfigEntryNotReady . The library client should use this auth instance. It looks unused now. We just instantiate it but then don't use it. When the library client wants to get an access token to use, ie before every request, it should use async get access token defined in this class. The library doesn't seem to have been updated to allow this. I recommend reading our library guide on how to structure the library and client: I've reworked the library according to the documentation. I actually like this approach. Everything works fine now except of the websocket connection. It's not possible to establish it and I don't get an error. I've tried very long, but wasn't able to get it working. Could you have a look at the library, please? L371 I don't think you should make a loop when connecting the websocket. Just have a connect method that connects the websocket and stores a reference to it on the client. L148-L160 Then have another method listen that fetches incoming messages and iterates over them and handles them. It's this method that the library user should create a background task for. L374 The benefit of separating the connect and listen methods is that we can make sure we can connect the websocket with a timeout before we create the task that should listen for websocket messages. If we can connect the websocket the chances are high that the websocket communication will work. If we fail to connect during the timeout, we want to raise ConfigEntryNotReady and try again later automatically. Side notes: 1. It looks like there's a double call to update data callbacks: L380-381 L342 2. I'd remove the schedule immediately parameter. The library user can call the callback themselves if needed. L74 If we create a connect method in the library for the websocket, there should also be a disconnect method for the websocket. There is now a close method Is the token and user id optional? If we know that the key is in the dict, we should use dict[key] and not dict.get(key) . No, it's not optional. I changed it. Is the user id friendly for the user to read? If so, we could use that as title to let them distinguish between config entries. It's not user friendly. But we can get some user information out of the JWT and make an individual for each config entry. See: I looked at the library. It currently doesn't consistently use the aiohttp client session that is provided when instantiating the abstract auth class. The library should use that provided client session for all requests made. It's ok to create a default aiohttp client session if no session is provided by the library user. I also suggest dropping or making optional the task that gets the status. The library user can do that. In Home Assistant we can use the update coordinator here to do that. We can also use the coordinator and set updated data when the websocket callbacks with updated data. There's this coordinator method: L400-L402 Then we
If you short circuit out here if there is no configuration, will it remove existing entries if you completely removed the config? It looks like it would leave those intact. The existing config remains intact in case of failure here. That is similar to the implementations in the Rest , and HomeKit components. I believe if all entities are removed, the root domain would still be present in the configuration, so removal of all entities should be fine. Though I doubt the necesity of the suppression here. Just because the same pattern is used in homekit does not mean it's correct. I agree it's expected that all services are removed if rest command is removed from the configuration, and I think that should be the case also for rest. It should remove all the services but not the reload service itself. The pattern exists in HomeKit and Rest so if you make a mistake, the reload service is not gone and you can still recover. If its not actually removing the integration instance though, thats a bug Thanks bdraco The pattern in rest is different, we don't exit early if DOMAIN not in conf , and there's a specific test testing what happens when the rest configuration is removed: test reload and remove all - everything is cleaned up. What's happening in this PR looks like a bug because the services won't be removed. Oh, it looks like this was intended. Is this standard practice already? Not sure if standard practice, but copied from inspired by the Rest , and HomeKit components. This pattern is used in mqtt, but I'm not sure it's wanted. async integration yaml config returns None if the configuration can't be parsed, for example if there's a yaml syntax error. I think it's better to return early if async integration yaml config returns None and otherwise clean up. I mean something like this:
Can anyone point me in the right direction to test the service calls? I'm getting pytest socket.SocketBlockedError: A test tried to use socket.socket. errors and from looking at other components I don't see what I'm missing... Can be removed as validation is done by the schema We should raise when a user inserted date is invalid The library sets it default to True and we should keep it for constistency. We should remove the type "all" as two requests must be made, one for gas and one for energy. If the user really wants both prices, the service should be called twice. We should add a hint for user, what happen if the date is omitted. I think it's a good practice to make these fields constants ATTR I have my doubts about BTW, as it's a very dutch term (although energyzero is also a dutch thing). Would you still mind to change it to taxes ? or just VAT? However, I also use incl btw as a parameter in the package, which is on my list to change this month. Oh right, that is the english term A user doesnt have to know what a datetime is. Can you make these parametrize return partial dicts? for example In here you can do data incl btw Reason behind this is that we want to avoid branches in tests so we don't test a "maybe" Can we rename the attribute as well?
Can it be this list is empty? If that is the case may we should only add ClimateEntityFeature.FAN MODE if the list is populated. I added a conditional in supported features . Now ClimateEntityFeature.FAN MODE will only apply if the list is not empty. Is the debug message correct here? Updated, thanks! We should only set this attribute if we enable the feature Instead of a property, can we set self. attr supported features at init () ? Yes - I moved it to init . Need to translate "Circulate" from the Resideo API to to FAN DIFFUSE for HA mapped Need to translate from HA's FAN DIFFUSE to Resideo API's "Circulate" There is a couple of predefined modes. If possible then use these. Using predefined fan modes will enable translations. mapped You could split out KeyError when a not existing fan mode is requested and log a clear error message. added The default value is None and not needed to add. fixed changed
What do we do if OFF is NOT in the HVAC modes? The existing async turn off does nothing in that case, but I think we should add a ClimateEntityFeature.TURN OFF flag which is automatically set if either HVACMode.OFF in self.hvac modes or either of async toggle or toggle are overridden implemented. emontnemery should we perhaps make a preliminary PR to implement it for the existing turn off before adding on this? I'm not opposed to extending the turn off functionality, but I do think it deserves its own PR. This PR is intentionally narrow, its focus is to just provide more consistency, where if the climate has both turn on and turn off, it follows that it should have toggle as well. Making turn off function better is in my view orthogonal to this, and can be done later if the decision to pursue it is made. What do we do if OFF is NOT in the HVAC modes? We raise and fail the service, as discussed. If an integration want to implement a better version of the toggle service, they are free to do so. Agreed it should have it's own architecture issue PR Architecture issue: PR: We could also have a base implementation in the base class, maybe that makes it more clear it can be extended? I think that in general we should promote the async pattern more and consider the sync versions more of a legacy thing, so I would be rather against this change. Also the current async turn on and async turn off use the same pattern, so if this was changed, those two probably should as well. I think that in general we should promote the async pattern more and consider the sync versions more of a legacy thing, so I would be rather against this change. That's not really the case. The sync version is needed to integrate with 3rd party libraries which do not themselves use asyncio An alternative is to do the same implementation as ToggleEntity : This seems like a valid assumption, we should document turn off , turn on and toggle here and for turn off mention the HVAC mode should be set to HVACMode.Off Do you agree with discussion r1353410885? If so, I could add something like that to the docs. Why do we need to allow overriding these, can't we make them final ? Integrations interact with devices that often have some form of native TOGGLE command, it then might make sense to use it to the integration author, instead of relying on checking state and then sending TURN ON or TURN OFF. As for the achieved functionality, you are right that it probably should never be actually necessary to override it. But the exact same argument applies to async turn off . There is an obvious use case for overriding async turn on , namely if your device provides a way to turn on without explicitly setting mode of operation (usually setting the one it had before being turned off). But there is no obvious necessity to ever override async turn off - its operation should be the same as setting mode to HVACMode.OFF , which is exactly what our base implementation does already. The only reason I see someone
Good catch, changed !! to be honest I actually thought your change would yield a boolean as result. You can do the same here missed that done, but in a slightly different manner, that at least to me adds less confusion. This is also on option, the only difference is that it will alway evaluate entry.get(CONF DEVICE ADDRESS, 0) even when it is not used. The or method will go on if there was a result. Will only evaluate entry.get(CONF DEVICE ADDRESS, 0) when so slave is set. Which is correct, since they are defined as being exclusive in init .py I am not saying the statement is in correct, but only that is more efficient using or Changed to your way, I have no strong feelings about "or" or the other. Thnx!
Could use the or operator here too. Of course, done, good that you are awake
What is the definition of "is not full" vs. "is not empty", they seems like duplicates, and surely will give cause to a lot of confusion. I am used to having "is between" which means neither "empty" nor "full".
klaasnicolaas I know this has been originally removed from the integration: discussion r1059137921 Maybe by adding a new sensor that has the price in a JSON encoded string? There is a limit of 255 chars for a sensor value, so we can't use that. So the only way to add the prices is through the attributes. This seems pretty vital information if you want any form of graph with prices for the day. Careful here. The string "false" is considered a truthy value and would pass if incl btw: It is typed a string and a "feature" of
Only store in hass.data once you are sure the integration is going to set up Please remove items that aren't supported yet. They can be added in the future if when they become supported Please use address instead of name unique-id-requirements I assume this was copied from airthings-ble Actually, the name of the device contains the MAC address, so I think this meets the requirements for unique IDs, doesn't it? I'll ensure that if "identifier" is not defined, then address is used as a fallback. Don't use the name because if the name changes the unique id will change and than all the entities will get recreated. You don't need to include the domain or platform because they are already considered for the unique id. {mac} {key} is a good stable unique id Updated! Is self. attr unique id supposed to end up being the entity's unique ID ? Or is it just one of the parameters used to determine the eventual unique id ? The full unique id is handled by the entity registry L423 You can access this directly there is no need to make a copy since its not being mutated We generally don't want to reference other unrelated integrations in comments since they can change and than the comments would be wrong Use pytest.mark.parametrize instead Do you have pointers on doing this? There are a lot of config flow tests that use this already git grep 'pytest.mark.parametrize' tests components test config flow.py Please remove all unused code StateType can likely be narrowed since there is currently only one sensor I was thinking this would be more flexible if I add support for other devices that support more sensor types? Otherwise I can definitely narrow down to Float for now... While its good to be thinking ahead, we want the code to reflect the current state of things. We can always change it or make it more flexible later if its not an architectural or foundational code block. See below - there are also USB Serial devices made by Medcom, hence the ble integration Unless there is plans on adding non-BLE devices we should use medcom since the namespace is available. We only postfix when there is a namespace conflict Medcom also makes non-BLE devices - USB or serial connected - which is why I used the suffix. So far it's better to use two different integrations for BLE and non-BLE devices even of the same brand, correct? Should be fine to leave the domain as-is but I'd call the title Medcom Bluetooth since most users won't know what BLE is Is this better as far as using pytest.mark.parametrize is concerned ? Yes, but you don't need to parametrize MEDCOM SERVICE INFO since its always the same It doesn't look like you need parametrize here since you only have on set of data r1334759367

You can use Syrupy for a nice way of testing an tracking changes :) Checkout the youtube diagnostic test. You can use that code and then execute pytest . tests components twinkly --snapshot-update and it will create snapshots I have tried to wrap my head around that, but I am just not getting it. I guess I don't know all the inner workings of HA well enough... There is a problem here: L31-L34 Since the ID is auto-generated every time, and device name is set to id the snapshots will differ. Now, I don't know why the device name and entity id is supposed to be different for each test, but it will be a showstopper for this... I am able to fix this, but that requires some minor changes to some of the other tests as well. Hope that does not block the PR. Will be fixed. Thanks. Fixed How did I miss that. Thanks again. We can redact this in one go:
Remove removed: e7101c1066926b3da1a08c578a4567dea0c5c87e These could be constants changed to constant: 34198d314c5750a8c545234375076f33fe346e83 These look unused? removed: 0234b0301391e9dc0f955df46698b47f9fe47f47 How often are these used? I'd suggest putting them where they are used if its only one file. Personally helpers and utils files are in general are bad pattern. removed helpers.py and moved the functions to the correct files: 81ed50a29d91d1ecd71c489f258095868d2fd4ce Remove zeroconf and ssdp removed: 30ec2044247e56aff10994d90b8929b423284e29 Remove Seeing lots of strings thst should be consts Changed some of the strings to constants. I left some strings that I think make sense since it's a dict key. If they all need to be constants I could change it.. b552bbe1e811f3c05c66f2ee5b6b454484d83e08 sorrry, this changed in another commit again which also contains some other changes. c5edcf87c7a1a20bf4b95b3fca4bd16a5505cf72 Remove this file removed en.json: 243a89757b309dbf67ebbc1486d08d9ed833da82 Change back undid the changes to scripts setup: 59e9c6c5e1dca46513101088e55753e00c73ced9 I believe this should be UnitOfPower.KILO WATT instead. changed unit to kW changed unit to kW I believe this should be SensorDeviceClass.POWER instead. also changed to power instead of energy We should include the unit of our HA sensor in schedule input and deal with it in the client. I opened for this. I don't think we should add variables that will not be used for the API call to the client functions. I've made a pull request to the fm client to add the unit conversion as a static method: In the integration the return values can be converted using this method. Okay. But just to note that, at some point, the API will accept the unit field. I think it is even in the API documentation already (but it might be broken in API v3, whereas older API versions have been sunset). I don't think you need to exclude these from coverage, they will be covered just by importing them? What's this for? It doesn't seem to be used? The integration only allows a single config entry, we don't need to index by config entry id here. Also, this is stored, but doesn't seem to be used? This dict is created but never used, please remove it
do we need to update before add if we're doing a first refresh of the coordinator in init .py ? Removed. I think you may want enter here. Why do we set a unique id if we only allow one config entry? And the inverse question, why only allow one config entry if we can set a unique id? Second question first: I first set this up with a unique id then saw the service call adds tasks without referencing a config entry or entity, and so that looked like a problem. (The config entry however does reference a project name, so it could be possible perhaps to infer but that seemed sketchy). First question: However, I thought it might be possible to add more config entries in the future if the service changes or is deprecated so I left the unique id. I didn't think it hurts, is there a down side? As we talk through, I also realize this could potentially be updated in the future to support re-auth updating the API key so maybe this isn't a valid in unique id. I was thinking of it like an oauth client id but realize how it's not really like than. Given that, perhaps needs to be removed anyway. I'm not sure what, then, could be a unique id but theoretically I'd like this to be able to support multiple accounts since once the service is fixed there's no big reason it couldn't otherwise. Ok. Yeah, I don't think token is a good unique id since we want to be able to re-authenticate without changing unique id. I'd migrate the service to an entity service. The service call targets a specific project which equals an entity, right? Then we don't need to worry about unique id for the config entry for the sake of the service. Will remove the unique id... Yeah entity service sounds right. When I did the same thing for Google calendar, it needed to be a new service with a new name etc and s deprecation period before removal of the old service? That is, it can't be immediately moved. I'm thinking here that using a new Todo entity service may work... Am I thinking about that right or is there a shortcut? Yeah, it will need to be a new service so we can keep the old one around and create a repair issue when the old service is called, telling users to use the new service instead. The entity service will require an entity target so we can't reuse the old service name if we want old service calls to still work.
We don't allow changes to this part of the code as it belongs in a 3rd party library. It's protocol details.
This would remove any current elevation. Should be changed so parameter is only set if service call data includes elevation Don't think we need to update config data twice. Check first and then call async update once. I would move this assertion before line 308 and modify it slightly: Now, we can assert here that the elevation was not changed if we don't set it. Done, thanks. Shouldn't we use a number selector in box mode with step any ? number-selector Same goes for the latitude and longitude, where we can also set min and max values. See
This code should be updated to exclude disabled components and capabilities. Why is this conditional statement necessary? All of this logic, including the check for disabledComponents and disabledCapabilities should be moved inside broker.get assigned . This method, and the supporting logic should be modified to operate on a component. That's actually how I started, but it turned out to be a large refactor and I moved to this method instead. But I'll give it another go. Is this conditional line needed? I think status data for main is only on the primary status object, not nested in the component status objects, therefore we need to branch every time we try to fetch the current status. Alternately, we could modify the base library further to refactor how the main component stores it's statuses, but that is a breaking change.
Could be better at the top Config flow needs 100 test coverage Not used, should be removed Removed Why adding an handler ? Removed Creating your own DataUpdateCoodrinator will avoid adding fetch logic in your init .py
Done Are these the only options octoprint is supporting? Yup As there are fewer config entries for a device, this should be quicker. Done Imo the command is wrong. I assume it's from a copy paste Done I don't see this as a showstopper for this PR. Unless there's some coding standard this violates for HA. This should be a ServiceValidationError , ideally with a tranlsation in strings.json explaining what went wrong. Like this: L305-L311
Please first create the coordinator, then execute the first refresh, only then you may add it to the hass object. Only having async unload entry as function should be enough to enable reloading the integration so you can remove this one auth... what? We want to avoid having people set names themselves in new integrations config flows and are slowly removing it in current integrations as well. People can set the name by renaming the device and or config entry. Doesn't really need to be private imo Instead of name you could use the coordinates as name We like our config entry data structures flat, so it should flat out the CONF LOCATION so the latitude and longitude are on the same level as the rest Can these be made constants or moved to the library? (not sure whats best here) This could be already initialized above This would trigger a reauth flow, but you don't have any. Can we check if we can actually get data in the init .py 's async setup entry and raise the ConfigEntryAuthFailed there? Only if "Apple Team" is a brand, otherwise ignore This can be a shorthand attribute in the constructor attr unique id ... New integrations must use has entity name True . My advice would be to add attr has entity name True , add a device (service) (without a name) and then set attr name None . Check IPMA for an example. This way the name of the config entry is used as name for the entity, so if someone changes the config entry name, they automatically get their weather renamed has entity name-true-mandatory-for-new-integrations Idem Idem Consider adding tests as they reduce the amount of regressions It would be cleaner to put the data in the coordinator so you only have to pass around one object You could make a Than you can replace all the self.coordinator.data calls with self.data Its a tiny bit slower but makes all the properties a lot more readable You might also want something that like this to avoid writing out all the currentWeather gets
Why dont you make this a separate binary sensor? Is this the last ring? Shouldn't that be an event entity? Binary sensor?
Unused Can you maybe elaborate why you chose to initialise the coordinator here? A coordinator is usually used for having one central place for updates for multiple platforms. In this case I don't really see a point of using a data update coordinator here unless you give some context I can create a better opinion on how to use it My brain is too childish for this Please add typing New entities should use has entity name True . Please check developer docs - entity for more info. Remind me to post a link to it. Static, can be moved outside of the constructor Please use a better name Can this return None? This can be a short hand attribute attr device info Please use the DeviceInfo object Where is the "logger" ? This is a small function, you can integrate this into the stel itself Never raised Title is always static, why do we get it from info when we already know the answer Data schema is one field, can be moved here Not used Not used Please use CONF API KEY from homeassistsnt.const Config flow should have 100 test coverage
No need for this line and add the entity to strings I believe this is the correct way to do this. e.g I've removed the translation key . Because the mower (as main entity) should just have the name of the device. And there is no translation required. attr has entity name True is already in entity.py Please move this to coordinator.py I am not sure how at this point, but want to mention it, I think this is data that should be in the entry itself, I'll have a second look later. If you're missing a scope, wouldn't starting a reauth with the new token work better? General thing, I think having all this session setup code would be better in the async setup entry and then pass the session to the coordinator. TimeoutErrors from asyncio are already catched in the data update coordiantor Why would a general Exception cause a reauth? Wouldn't having no internet trigger this (as that raises a CannotConnect error or something along those lines) That should raise UpdateFailed instead. I mean that's the whole point of setdefault ;) What could raise? In the YouTube integration I did not get any errors for this, so maybe your env isn't fully set up, or you forgot to remove this :) Shouldn't need this If possible, let's move reauth to a follow up PR so we can focus on the rest and make it as small as possible. The reauth still might need some work when looking at logging in with the right account (for example, you create the config with account A, and reauth with acount B). But let's keep that out of scope for now, and instead of ConfigEntryAuthFailed, just raise ConfigEntryNotReady for the time being This will raise an issue if the unique id is already set. This way you can't login twice with the same account. You can merge this step with the step above as there is no real reason to split it out We don't need this anymore as core will be the issue tracker to go :) We love a well typed integration 3 Why do we actually use a number to differentiate on the mowers? Could we maybe use some mower id instead? This way it's an property and can be accessed with self.mower attributes
emontnemery Can you give your opinion on having device class in the options flow as there was this discussion today for another helper having device class configurable whilst that was possible via the entity registry. Oh yeah right, then IMO this should be removed. Right, we should not have this in the options flow I've removed the device class from the options flow now. I dont see the need for this mark. Its using the fixture as a parameter amready. Oh, indeed, thanks for the review This would only use sensor name as the name but according to the old config it would primarily use ATTR FRIENDLY NAME as the name I used sensor name here to keep the old entity IDs, if ATTR FRIENDLY NAME would differ from sensor name than we would end up with different entity IDs Right. Probably the easiest way to deal with it. You could just use .get as if it's not in options it would be None Which would also "resolve" the missing test coverage Not sure why you're only testing the name and not just the complete config? Why not just use a schema with the one for options flow extended instead of using a function and the usage of partial to check for full or partial settings? I guess this should be a service? Personally I think it would be cleaner if this moved to conftest as a fixture This should continue with changing something and then end up with create entry We are missing a test that it's not importing twice e.g. ends up with abort This should be tested via changing the config entry and not just update the config entry directly from here. For helpers we keep the YAML support normally, so I suggest we do it here too. Re-added the YAML support No need to use if's here as they are None by default Either we remove the string or we implement a check if already configured
This change would mean that none of the entities will have a phonebook name. Can one phone (which is what fritzbox phonebook.fph.modelname is, I think) have more phonebooks? It can, you have to add another device and chose another phonebook there: img width "694" alt "image" src "" I did not find any information how to append the phonebook name to the entity name, though. Currently we can't and there are some discussion on adding more variables to entity names. But I think with this change, you would get sensor.something call monitor and sensor.something call monitor 2 unless you rename the device. Maybe cdce8p has an idea for now without placeholders that would make this correct. Otherwise you might need to wait with this PR :( Yes, second one is sensor.fritz box 7590 call monitor 2 . Changed to use new translation placeholders. I think this change would be better in a separate PR as this PR is only scoped to adding has entity name The States should also move to the separate PR. Until there is a solution for the phone book name, you can create a PR to make the sensor an Enum with these values. See
Should connect be a service to support connecting with different printer profiles? Not sure what the behavior is if there are multiple profiles. I thought of that, but figured that most usages of this will only have 1 profile. That and I'm not quite sure how I would best solve this. [Example of adding services]( My original attempt at adding the start stop services that ended up as buttons Ideally the service would support 0-1 arguments, so you wouldn't be required to pass it in for cases like yours where you only have a single profile. Dont think my Python knowledge is up for that task But would you say that this change that only uses the auto connect feature is not good enough to merge? I can understand that in the future we would want a service that can support multiple profiles and settings, was just hoping this would be a good V1 Why can't the integration automatically try to connect if needed during the coordinator update? I think this would make more sense as a service as well. There are also additional parameters to consider, such as baud rate and serial port. Buttons cannot also provide any feedback, unlike services. If an error occurs, that error could be provided in the service call's response. IMO, button entities should be reserved for items which represent physical buttons that don't have any feedback. Had a few minutes tonight and coded up the [connect service]( Would still like to see the disconnect button from this PR pushed forward. MartinHjelmare This is to trigger octoprint to connect to the 3d printer, not for home assistant to connect to octoprint. Right, but can't we do that automatically if needed? Doesn't octoprint know if it's connected to the printer or not? We could check that and connect automatically. I'd argue that kind of logic should not be Home Assistant's job. And we don't know which settings to automatically connect with either. I feel like it should always be a manual action (aside from starting up the OctoPrint server). It looks like the coordinator updates every 30 seconds, and I would certainly not want Home Assistant to constantly try re-connecting the printer at that interval. Home Assistant should only be concerned with automatically re-establishing the connection between itself and OctoPrint, not OctoPrint and the printer. In other OctoPrint clients (the Cura plugin, the OctoPod app, etc) there is a separate button to manually connect to the printer, and I think we should follow that convention. Why? Please give some reasons why we shouldn't make sure that the printer is connected to Octoprint. If the printer isn't connected, isn't the integration useless? Mainly due to the same reasons this should be a service and not a button. Different printers need different settings, the coordinator would only be able to connect on defaults. So if I am a user in the octoprint UI trying to swap which of my printers I am connected to, HA would force the setting to the defaults every 30 seconds, which would get old qu
I don't think we need an options schema. Can we create an event entity instead? We don't need this if we add an event entity.
Probably better to be named switchbot cloud Please store data in hass.data[DOMAIN][entry.entry id] as a dataclass Please use the helper from the scaffolding stale doc string Is the device id globally unique? I think it is as it is a MAC address for physical devices, but let me confirm for remotes. I asked a question in Reddit: Initialize the object with the api object and save it self. api so you don't have to keep looking it up It looks like it might make sense to use a DataUpdateCoordinator instead I see, I confused devices and entity when reading the documentation, I will see how to use it. Hum... I am not sure if I used the coordinator correctly, please tell me if there is something I need to fix. unique-id-requirements This doesn't meet the unique id requirements Ok, I will use the token hashed then as it is not changed when resetting the token in the app. these are never raised Oops, sorry, messed up my imports Only use .get() if the data might be missing Don't create a config entry with missing data Resolved by suggestion in the next comment This doesn't look like it meets unique id requirements unique-id-requirements bdraco The token seems to be an account id as it does not change even when clicking on "Reset token" in the SwitchBot app, only the secret key changes. The reason I am hashing it is for privacy reasons, I would do the same with an e-mail but if it is better to not hash it, please tell me. This is leaking the abstraction into entity.py . This base class shouldn't know about Remote Create a new subclass in switch.py for remotes or set it there. You shouldn't need update before add with a coordinator
Please create a separate PR for the dependency bump This can be omitted as Update entities get their (translated) name from the device class. Isn't this always None? This can be moved outside of the constructor as they are static Not actually release notes, but it 'looks' good. We also can just add an URL to the HomeWizard support page. I tried to patch this one so we can update the version without having to adjust the test. This works when calling python test components homewizard test update.py , but not when calling python test components homewizard somehow.. Then the original value is used. try patching homeassistant.components.homewizard.update.LATEST FIRMWARE VERSION Yess, that works Is there a way to get the latest version from a remote service? No (not yet). This is the best we can provide at the moment. Feature request is added to the backlog at HomeWizard. If you add this, it gets the name of the device, I would say that you can remove it, but I leave that up to you. Difference would be update.asd and update.asd firmware . If I would, I get the warning that I have to set 'None' explicitly Did that also happen after you rebased? That change was added 1 or 2 weeks ago Eh, before.. will take a look Yepp, works :)
set cover position and tilt is only supported by vertical cover. You should add a supported features here with a value of set cover position and tilt and add this to the list of supported features on vertical cover This variable seems to be not used. You can use it to add it to the supported features list I think. And if it's possible, add it only if the device has the command OverkizCommand.SET CLOSURE AND ORIENTATION
Is there a reason you are using a match with a single case and not just an if statement? yes, because we provide more platforms but for first pull request we removed the others platforms as required above home-assistant-core Same thing here. we provide more platforms but for first pull request we removed the others platforms home-assistant-core i recommend you use hass.helpers.aiohttp client.async get clientsession() so you dont need to create a new one use HA client session here too put this url in .const Not needed This is the first implementation so there is always one set Please keep the version in here I see it's current set to 0.1.0. In this context, a version should be set to an int. In this case just 1 Okay so when looking at the config flow and the init, how many entries do you allow? From the first line I see you only allow one (as the unique id is set to a static value) but later on in the config flow we set it to the current user.id. Question is still open What does this class add? This is the connector with our library, of course doesn't add nothing at the moment, is for future purposes If we don't use it, we shouldn't add it in this PR ok, we're going to remove it and add in future PR done URLs should be passed in translation placeholders Oh but I think this isn't needed anymore right? Why do we have aiohttp here? Please remove empty fields Let's first collect the data we need before assigning it to hass.data This one is the only one you need to assign your data to hass.data
The parent class is already setting it. Why do you need this line? Setting it on line 49 should be enough. Good point. Removed. Please collect the entities in a list first and then make a single call to async add entities .
Also, can we create a separate device for every room as described in what-is-a-device using the via device option. I also noticed the device info above here doesnt have identifiers. Should we add it? It would be nicer to move this around so this only returns bool (meaning please change the return type of is on to bool) and place the logic at where you create the entity description The entities use a coordinator, I don't think we need to update the entities on add right? This should return the unit of measurement from the device, not from hass itself. Please avoid casting to state type, the return type of the function should be StateType already Please create a mixin so you dont have to set a default
Probably mark as diagnostic Probably mark as diagnostic
This is not really a use-case where the data update coordinator is required imo, since you don't receive any data here. See for my initial try 3 years ago. Code is very outdated, but shows you another approach. You could use async track time interval to call a function every x minutes. Allright, I'll migrate it to async track time interval . Great, let me know if you need help! This issue ( looks related. Could we make this more specific? I am not sure if an UIClass (or widget) is specific enough. There are many many Overkiz devices and perhaps we should scope this on the controllable name ? Sure, makes sense.
It does not appear that this can be translated when displayed in the Trigger Actions UI. A few other integrations have comments indicating the same thing; should I add one here? Other integrations call a base implementation of async get trigger capabilities ; however, doing so here adds a "duration" or "timestamp" field that the existing Nanoleaf device triggers do not support. If I can cache the panels during (1) device assessment and (2) nanoleaf layout update events, I think we can get rid of this entirely? It would also remove the need for get nanoleaf connection by device id . (aionanoleaf caches this)
could be a const PLATFORMS [Platform.DEVICE TRACKER, Platform.SENSOR] maybe move this code into a PyPI pkg Was going to talk to you about how to split it up. "Is this an RPA?" Felt like it belonged in the Bluetooth component, perhaps even a filter for it when grabbing all service infos? Wasn't sure there was enough else to justify a separate package. It would just be creating a cipher from a string. Could be added to maybe move this code into a PyPI pkg Could be added to source should always be defined writing-tests-for-integrations I'm pretty sure this counts as interacting with any integration details in tests of integrations. You could steal some code from the ibeacon coordinator tests Ugh that's awkward. I was careful to avoid poking internals because of that rule. I can move some of the checks into the device tracker tests and not lose coverage. But I just can't get full coverage through the entity tests. The entity tests always use both async track APIs and I really want to assert those APIs aren't accidentally coupled to each other in some way. I suppose I could make a fake entity that only uses one API? I don't know if that's allowed either though (what would it's domain be). Ok, dropped that test file entirely and only had 2 or 3 uncovered lines. One was because of removing sensor.py. One was but i've managed to avoid it. TODO? Stale comment. Fixed that and forgot I'd left a comment there. left over from sensor platform removal You could likely exclude all the ones that aren't private random address types I guess we don't expose the bit that tells if its random or public in a meaningful way. L46 We kick out any that aren't RPA in the resolve address function. But I would like to plumb the address type into the Bluetooth component to avoid the callbacks in the first place. That could be quite invasive tho. maybe we should standardize that Yeah. I was thinking all the matchers in the Bluetooth integration could be expanded to have an address type filter which would be a list of a new AddressType enum. Doing it there would mean that we could ignore AddressType.RANDOM UNRESOLVABLE for most integrations (except iBeacon). We could also kick out unresolvable and resolvable from the ble tracker integration, as it can't use them. I could look at that in a follow up? Like you say, would need to expose the static random bit everywhere to do it properly to do this. I think is outside scope of this PR, but definitely want to come back to it as like I say I think it could be a useful filter in other integration as well. Its definitely out of scope. We would have an UNKNOWN value for the first iteration as well since not all scanners send that data all the way through right now It's not allowed to implement the state property directly. One of ScannerEntity or TrackerEntity should be used. If something new is required an architecture discussion needs to be opened.
This has to go before writing the state or it will not apply until next update cycle Same for places below. i see, thanks Would be better to "calc" this once during init so we can simply return if it's there or not Same comments as preset modes good idea, thanks good idea, thanks Missing typing Can we type init above too so it's complete? I added typings to all methods in the class. Thanks for the feedback Even better to move this to init and set it once. why? If I do this and the smartthings API returns unexpected unit, the code would fail. Isn't it better the way how it is now? You can leave it if it can change between c and f but if it can also return something unexpected I would be slightly worried about it. ok, you've got a point. Changed This should return None and not an empty list if there is no presets ok, thanks
Code coverage was affected because of the refactoring, But it seems config can never be an empty dict because the schema has two required options name and entity id . Any instance was validated against ALERT SCHEMA . This makes this code unreachable. Remove empty line. I don't think we should add storage collection support to this integration as our long term plan is to deprecate this integration. See issuecomment-1785204128 Okay, that is clear. Is there any acceptable approach to allow reloading the yaml? Maybe, if it doesn't add anything but a service to reload the YAML. But I think we're wasting time when working on this integration as we want to steer users to automations instead.
I am unsure about the naming of this object, feedback is welcome This change doesn't seem part of the current PR. Let's move this to another PR. True. My reasoning was: - PRs get reviewed merged very slowly - the actual satellite which made the call is useful to have in responses, especially for custom sentences custom intents If you feel it's too much, I'm OK with taking it out. This feels weird to bring this in via the websocket API. If the device exists, how come it is communicating via the WS API and not a native integration ? Isn't that how the companion app communicates? I imagined that if a conversation process endpoint exists, then it should also benefit from satellite identification. Am I wrong? Nevermind, I've misread your comment. Can be collapsed in 1 statement: The mobile app already knows the device ID of the incoming request. It shouldn't be passed in. Is there a reason why one has the id prefix but the other not? Yes, there is. {area} is already a default slot that's passed by HA to hassil, so I'm reusing that notation. In regards to device id , I'm not using device because I feel that's a lot more useful for a future functionality which I want to implement: what is the {device class} of {device} - e.g. what is the energy consumption of the washing machine , where washing machine is the name of a device which exposes at least one entity with device class "energy" . However, for consistency, we could rename device id to satellite . Thoughts? The reason I had initially skipped over this one is that your mobile phone is not stationary. And so it cannot correctly reflect the area. True, but: - I may have a tablet fixed on a wall running the mobile app - I may use a custom integration that continuously updates my phone's area If I use my mobile phone as a satellite, it won't have an area assigned to it, so it can't break anything. I'd vote for leaving this information in for the mobile app . I also think that this is not a good approach. It should be offered as a fallback to intent handlers, it shouldn't override and be presented as user provided info. As that will lead exactly to the breaking change in the PR description. I don't think I understand. The entire end-goal of this PR is to provide context to the recognizer, so that it can act locally, depending on the satellite that was used. As far as I understood from synesthesiam (I can't find the message rn), there won't ever be a priority system for sentences, so I don't know how you could guarantee that a fallback is a fallback and not the first option. My approach to writing sentences was to always have a single one match a given prompt. If a fallback mechanism is a possible solution, I am totally unaware of it. There are some sentences that will act differently if an area is defined. With this change, there will always be an area defined. This means that asking "What is the temperature" will always be scoped to the area, instead of HA looking up the current temperature reported by
Should probably use OperationMode.OFF from upstream library here. Done
Isn't there a better way to get the modes instead of the members .kets() ? If you have a suggestion I can change it, but I do not have a good idea Would just list(SensPreset) work as it's an enum? I don't think so Do you want the names to be there hmmm What I see at other integrations is that they have a dict to transform between the integration specific modes and they use it for transforming it when getting the preset mode. we can do this, but this will require a bit more maintenance, when new presets are added we will need to add them to both locations, pyDuotecno and this integration. With this system its only inside pyDuotecno, so upgrading pyDuotecno will get the new presets fanspeeds automaticly in hass. So i like this system better, but if its a dealbreaker i will change it Right, I asked some other people and we do like to have this mapping in HA. This way we can also add translations for the speeds (so I would suggest making the names use snake case). So yes I would advice to do the mapping here Are there enums we can use here? I would say move these to the climate.py as they are platform specific. Other integrations create a second map from all the options, this enables a quick lookup, for example Tado: L148 This way we don't have to loop over the list everytime, afaik this would cost less and is more efficient. (and yes the example I showed you doesn't align with my last comment, imo Tado should change) You could also create that reverse map for hvac modes to enable you to use list(HVAC MODES) . In this case you never do a quick lookup, but you are assured that every hvac mode you support, has a duotecno state in front of it. Isn't a blocker, but would be nice stylewise Make the modes snakecase and add translations like L50
So far as I known, integrations using GPIO are not allowed anymore; I think you should use ESPHome or deploy this as an custom integration. As you can see in this [line of code]( L23) the underlying light driver makes use of pigpio, just like [remote rpi gpio]( L3) code does. Connection is made with the local pigpio deamon, or can be configured to connect to a remote system, so the IO is not GPIO but via network socket. Because of this AD0019 does not apply on this code.
I'd go with "unnamed device" or similar instead of empty string. async.... nope still not working OK figured out a large chunk of it, it was user error stemming from a wrong return value, will update soon
We shouldn't modify to correct the data coming from the api. If it needs adjustment it should be done in the device library. Is this a device that can both be powered by USB and battery and power supply can change during the entity lifetime? Thanks, I will change on API library, When the device has a battery installed and is powered by USB, the battery power obtained is inaccurate. I think just remove message convert is fine, When a battery is installed in the device, if device changed to USB power supply, if device battery level displayed as unavailable, which is unreasonable. Is this the current behavior, that the sensor becomes unavailable if the power supply changes to USB? Where is the logic for this? At my first commit, I tried to change siren battery entity value to None (unavailable) when device power supply change to USB, I think that is incorrect, When a battery is installed in the device, should not change siren battery entity to None even if the battery information is not correct(circuit design leads to) So I think just remove message convert is fine. No API library changes required. Setting the value None as the sensor native value will be translated to unknown state in the base entity class, not unavailable state. Ok.
Only double-checking. This renaming doesn't have any functional consequences, right? The rest is fine, and I'm happy to merge :) Correct. It's a descriptive text only Doesn't this also need a native unit of measurement? There is none for the other uptime sensor. As it's a daytime object I think he means temperature which seems to be missing a UoM. In that case possibly Added native unit of measurement
Update the comment Comment update You have to clean unused comment code Empty properties should be cleaned To indent most of the code: move that to the top with if not user input: if not user input: You can try a fetch here an raise a config entry not ready error. I'm not sure that applies. This only setup the client instance for later use. Yes, but what if the host is unreachable? Only helpers are allowed to have configurable names. Please set the name of the config entry to something the user can recognize There isn't really anything other than the API key, therefore I believe we should let the user configure something that makes sense to them. More than one component can be configured and distinguish by name. In that case we just set a generic name. The user can rename that entry themselves Why don't we just initialize all devices? You might not want to add all devices. The service provide demo devices, which isn't usually what you wan't to add to your HA. Is there a way we can detect these demo devices? No, not really. Other than the name containing "Demo" or similar. I guess we can filter them out then right? But you might still want to add the Demo device, I believe it should be up to the user. Not used Why do we thottle? Mainly not to expose the service to unnecessary requests. Receiving sensor values more frequently than once every 60 is not relevant. Wouldn't a coordinator be more ideal A lot of components use this approach, which is from where I draw inspiration. Please see tibber etc. Yes, Tibber also uses a coordinator. I'm trying to discover if there is a reason why you shouldn't use it as your use case seems the same. In this integration, there is not yet any shared data for multiple entries from a single request. Therefore, I believe we don't need a coordinator. Will you add more platforms? Nothing planned right now, no. Check. But I still don't get why we should throttle when we can just set the SCAN INTERVAL variable I'll try that, thanks! Please don't reference hass.data in entities itself, just pass it as parameter
Do we need this if we add a sensor? came to the same conclusion in the comment above. If we decide to not include this from the frontend, we should probably remove the node status from the device info card too. I can submit a PR for that if that's what we decide Sounds good. I suggest we move this out one level so we only need to do it once during platform setup. The state is always written at the end of entity addition. Store the state in a local variable first, and assert it, so we don't need to look it up more than once per round of events.
Please import DeviceInfo from homeassistant.helpers.device registry . cover seems to be the wrong entity to me for this. I think number would be a better fit. The cover is the one that best represents the desk from a UX perspective, because of the up stop down buttons. I'm OK with changing to number , but personally think the cover is nicer. I understand, maybe this is a good case for a new entity model. But this is an architectural decision that needs to be discussed in the [architecture]( repo. Please import DeviceInfo from homeassistant.helpers.device registry . Please import DeviceInfo from homeassistant.helpers.device registry . Please limit the PR to one platform, also the switch seems to be used to connect to the desk. This should be done in the init .py , AFAIK. Or you connect to the desk when you adjust the height and disconnect afterwards. I had that initially (connecting automatically on init). But then had no way to disconnect. In my case I wanted to use the original desk app (the desk inky accepts 1 active connection), but a user may also want to disconnect since some Bluetooth controllers have a limited number of active connections. Connecting disconnecting in height adjustments won't work well because: - it will delay the change since connection can take a few seconds sometines - it will make the cover not track the desk height changes when the user uses the desk physical buttons. Ah, I see. I just don't know how that matches up with the core requirements unfortunately, maybe one of the core developers here can give a recommendation when it's ready. Yeah, I am also not 100 sure this is the best approach. Maybe I can set the switch entity to be one of the Configuration entities for the device? Well, I've removed the switch for this PR, and will add it later in another PR to make this one smaller. Do you need the extra function? Not needed indeed Set as attr icon above init This should move into a PyPI package This is mostly just "converting" from the python lib to HA (for example, the height from meters to percent) and handling callbacks. Is this really required to be in a separate lib, since the main code is already on another lib? The smaller the PR the faster you'll get this merged. It will also make future PR reviews smaller and faster as we can usually turn lib bumps quickly Anything you can do to shift code into the lib is generally to everyone mutual advantage as review time is a premium and we don't have to enforce ha standards for code in the library, only that it doesn't violate async IO principles or cause instability I will create the idasen-ha lib and update this to use it instead. We aren't allowed to access hass.data in new tests as its considered integrations details internals writing-tests-for-integrations Make sure to not interact with any integration details in tests of integrations. Following this pattern will make the tests more robust for changes in the integration. All the requirements for silver (platinum as 
Also, please use a comprehension with a new DEVICE KEYS A D constant, similar to device family "1D" .
Did you intend to remove the mac ? Its still nice to have it to link devices together in the UI Yes. As it's primary a software service hosted on a machine. Might use via device later on to connect the service with the host hardware.
Maybe async call later? If that is better sure Changed to async call later
self.get airzone value(AZD FULL NAME) returns "WebServer 11:22:33:44:55:66" (with MAC address), which helps identify the Airzone WebServer for users with multiple Airzone webservers (example: multiple Aidoo Pro devices). The current tests didn't and I couldn't figure out where to fix this I'd prefer to use something like f"Zone [{system zone id}] {zone data[AZD NAME]}" if we really need to drop the "Airzone" prefix here. It's ye boy unit tests back at it again with a strange situation. I would expected that if I add in the HVAC WEBSERVER MOCK in util.py, that it would fill the name. In fact, it does not. And to make it even stranger, adding that line to that object, even messed up the snapshot since it for some reason doesn't want the wifi-ssid in there anymore. Any ideas? It's ye boy unit tests back at it again with a strange situation. I would expected that if I add in the HVAC WEBSERVER MOCK in util.py, that it would fill the name. In fact, it does not. And to make it even stranger, adding that line to that object, even messed up the snapshot since it for some reason doesn't want the wifi-ssid in there anymore. Any ideas? In that case, the aioairzone library is just returning the same for both AZD MODEL and AZD FULL NAME, which is the device type: L111C11-L113 L223-L230 img width "351" alt "image" src "" So what change should happen for the mock to have a device name? API WS TYPE: API WS AZ,
hesselonline Could you maybe give your opinion on the name change for the lock and the switch? They used to be locked unlocked and pause resume, but for me it didn't really describe what did it lock or what did it pause or resume. In this PR it would change to {wallbox name} lock and {wallbox name} pause charging . But I don't own a Wallbox so I would value your input on this one :) I believe this is a good alternative for the lock title; fine by me. why did you remove the Wallbox - prefix here? It makes the name more descriptive, now its only the type of the wallbox being displayed. Every entity would be .wallbox {name} {entity} , so I just removed it here. Originally I skipped this integration since this had a device name mismatch (old entities were prefixed with the entry title and the device was called wallbox - something). So with this change the device name will be the prefix (so if you change the device name, it will directly change the rest as well). I thought this was the most logical name, but like I said, I don't own one, so what would you prefer? currently the device (for me ) is called 'Wallbox - Copper SB{serialNumber}', the entities are called (for example) 'Wallbox Portal Charging Speed'. From a functional perspective I would consider removing the 'Portal' part in the entity title, apart from that the current names are very clear (my standpoint). ![image]( Do I understand correctly that the device name then should be just Wallbox? Keep in mind that this is just the default name and that you can edit the name for all entities in one go if you want to rename it. no, its quite common to have mulitple wallboxes, so including the type and serial in the name is useful (that's how it works right now). I like the pause resume we had before more. First because it is more that just a pause button, it also allows you to start charging when you are connected but waiting for a schedule (or something similar). Also pause resume are the terms used by wallbox in there portal app, this makes the usage more clear for wallbox users.
Hey, could you replace the formula by the actual result, or some simpler representation of it? When the test case uses the exact same logic as the main function, it's a self fulfilling promise :) I am honestly surprised math was not needed so far :) sampling size isn't needed for the test case Is there a way to avoid it? For me the test will fail due to Invalid config for [sensor.statistics]: The sensor configuration must provide 'max age' and or 'sampling size'. Ooooh nevermind. I myself was the one who made the change that shows your error message :D Sorry about that
key should always exist. oh, opportunity for a walrus! Don't do I O in the event loop. Wouldn't it be better to just do this when first pipeline is activated? Given that many devices can use the same pipeline, should we consider storing it in a device directory instead if that is available ? I've reworked it to use the pipeline name and device id when available. So the directory structure will either be: debug recording dir pipeline.name run.id or debug recording dir device id pipeline.name run.id This is doing I O in the event loop. I O I O I O Shouldn't we use timestamp instead of ID, so we know what the latest generation is ? And do we need the pipeline if we are using device ID ? The id is a ulid prefixed with a 48-bit timestamp. Do you think it's better to use monotonic ns ? I think we'll still want the pipeline since some devices (like JLo's walkie) can switch pipelines. We could delay this until we make the wav writer, saving a trip to the executor. Moved into the debug recording thread This is very inefficient. It will do a lot of trips to the executor, potentially making it run slower than that the audio comes in. Can't we make a debug thread that we spawn, which listens to a queue and also allows for a specific value to be passed to the queue to delete it at the end? I'm using a thread now with a queue, which is cleaned up at the run end. This does a join and should be executed in executor. Only catch exceptions that you expect to be thrown. If I don't though, any exception won't leave a trace in the log because it's in a separate thread. Unless something has changed in more recent versions of Python?
This looks like a change in icon This looks like a change in icon
Shouldnt this be plaxserver friendly name to match the old logic in sensors? Previously it was f"Scan Clients ({server name})", now I am reversing that and the name would be {server name} Scan clients . Does that answer your question? Previously a sensor was named as here: diff-2ac2f6e7fdc724f6c62c8e637030199e553652384a417e7c5d49658921894a88L77 Thay is based on the friendly name stored in the server. Now the sensor will base its name from the HA device. However the device is not named after the server friendly name, it is named from a config entry stored name. Hmm this is an interesting one, I will dive deeper into this
I also just saw that I am creating a new device here, while the code is already doing that in init .py marciogranzotto, can you give some insight on what would be a nice solution?
This should not change This should not change. This would be better here? The idea behind this change is to add a device to the integration. With this change, the resulted entity id's would be {name} Next Launch . In a follow up PR I will add the translations. And since there can only be one instance of this integration on a system, why should we rename one entity for the old YAML people, whilst now everyone can rename the device to whatever they like and all entities will change? To not add unessesarry breaking changes for legacy users. Those are hard and confusing to document describe as it would only affect a small subset of users. But the entities have an unique id, how will this be a breaking change?
What provides the "Purity" name here now? It seems for me not all sensors have been applied with a translation key. joostlek will you add those missing, otherwise please do not remove the self. attr name attribute. Yes, will do, I already shut down my pc, so tomorrow I will fix this
Does this mean we don't remove the old damping? The evening damping is set with a pop, so it returns the damping and removes it from the object Great!
To my understanding the Coordinator should be in its own coordinator.py file Fixed. In my opinion you should use a dictionary for all the icons instead of multiple return statements. That's a good point. However, some icons do not have a suitable translation to a weather condition in Home Assistant, so my idea is that the return statements act as a fallback. Admittedly it is pretty messy, do you think there is a better way of doing it? Moved icon mapping to const Use a SelectSelector instead There's no need to check this since the schema ensure it can't happen to my understanding? Correct Please don't use magic strings, make this a constant instead, or better yet, import it from the hko library. Considering how simple the config flow is, we don't need a separate function to validate the input; do this directly in the user step instead This only sets unique id of the flow, it doesn't prevent creating multiple config entries with the same unique id. If we don't want multiple config entries of the same location (we don't since the entry unique id is used as source for entity unique id), please add a self. abort if unique id configured() call and add the corresponding error code to strings.json. Please also add a test which tries to add the same location twice. Please read up on [entity naming rules]( has entity name-true-mandatory-for-new-integrations), adjust if needed (it looks good to me, I don't think any change is needed), and set the attr has entity name flag to True. Also include DeviceInfo (service) We don't capture the timeout exception it seems. Probably put in a broad Exception capture Skipping the name it will take it from the config entry title From here remove the side effect and continue the flow so it ends with a create entry so we can see from the test we can recover
Why not add a fan entity instead? This doesn't operate as a normal fan does. It's still primarily controlled by the HVAC control board (if the fan is in "Auto" or "Circulate" mode). There's no way to set it to "Off" and have it stay off permanently (nor would you want there to be). This service just sets the speed the fan will use when the control board turns it on. A Number entity seems like the middle way here then and not a custom service. Setting this back to draft in the meantime until adjusted. Thanks That makes sense to me. I can make that change! Changes implemented! missing typing Please sort these Need an additional test that sets the value Added new test test set fan speed to cover this
The existing names are: Is the extra "Component" worth it vs sticking with the existing shorter names? As far as I have seen, the current name was composed by instance name "Component" that component name from that list so that's what this will result into. But I'm happy to change if you have a better idea I checked, you're right! Favor keeping the names consistent unless we have reason to change them, and I think since these are human-facing little-endian in English is probably slightly better! i.e. How about we use "USB Capture Component" (etc) in the translations, and it'll then sound slightly better and exactly match the prior names? I don't really mind about names, if you agree with doing "... component" on everything I can change that tomorrow or Monday. If you have other names (I mean "all component" doesn't sound nice) please create suggestions If you have other names (I mean "all component" doesn't sound nice) please create suggestions I was simply saying lets try to keep the names identical unless we have reason to change (incl. capitalization). I agree "All Component" is not nice, but I couldn't think of anything better then, and also can't think of anything better now! Just checked on my running instance, the names are like: Sitting Room Hyperion Component USB Capture This highlights an issue with this PR -- I think we end up losing the instance name. So if a Hyperion configuration has more than a single LED output instance, the switches would end up with the same name (i.e. we could have 3 Component USB capture switches without an obvious way to tell them apart). Perhaps there's a way to keep the translations (which is a big improvement!), but prefix something in front of them ... The instance name is now replaced with the device name. So now the entity is created like " device name translated entity name ". The only way to create dynamic stuff is via customizing the device name. The instance name is now replaced with the device name. OK, that's probably fine then since the device name is the Hyperion instance name, so I think it should be possible to get the names to exactly match before vs after this PR without too much trouble. Oh and since everything has unique id, it doesn't matter what we rename it to, so if you still have improvements, please let me know Oh and since everything has unique id, it doesn't matter what we rename it to Yup, only matters for added devices. I'm happy here once the names exactly match what they were. I think the only delta left is probably the capitalization -- but just verify on your end that they show up the same before after, and I'll approve! Hehe, fun fact, I don't have Hyperion, I'm just on a quest to get every integration with entity translations. Theoretically this should work. I think Hyperion also has tests so if something major changed we would've seen it. The capitalization should be only the first letter capitalized (except for brand names or abbreviations) The capitalization should be on
This is curious, does it change as result of these modifications? If it does, would it not be a breaking change? Nope, since the unique id isn't changed
Why do we change how ServiceNotFound is handled? because we can't determine whether or not the service supports responses without accessing the Service instance. In order to access the instance, I have to assume it may not exist, so rather than duplicate the check, I just moved it to here I'd make all these call arguments keyword arguments to make it easier to read. Should we name the response item just "response" as it is now or rename to "service response" or even "service response data" ? We already use response in the execute script function. We should be consistent, and if we want to change this to be service response then we should change it there as well, at least IMO L782-L788 Ok, let's keep it then.
Why is this PR adding climate entities? It's adding sensor entities for the indoor temperature and humidity. While the test is in test climate, it is testing total entities set up when the climate entity is created. Maybe it should have originally been set up differently? Looks like it's testing that no climate entities are actually added. Maybe we should change this so it asserts which entities has actually been made rather than the number of entities. I added additional assertions for the specific three entities I am expecting to be created. This looks like a better test than what was in there. I believe the assert len(hass.states.async all()) 3 can be removed - it's not really the right thing to look at... I made the change suggested by mkmer and also improved the indoor sensor test to validate it works even when there are no outdoor sensors. I'm not sure this device is necessary, the first default test device has no outside sensors, just use that one (device 1). I removed device4 and recoded the test for device1. We typically want these to be in the platform they are used if not multi-platform usage Moved the new platform-specific constants into the sensor file. Reopened the PR for review. Remove this and we use the device class to set the name Remove this and we use the device class to set the name I guess if we are making changes to the const.py file, CONF DEV ID and CONF LOC ID are only used int init .py But that's probably something for a different PR. I considered moving some of the other constants but wanted to limit the scope of changes to just what I'm trying to do here. Otherwise, we will never get this merged! Yes, I ran the tests locally and also re-verified mypy and ruff results. We should (finally!) be good to go. Let's see what the other reviewers say. Thanks for helping with the back-and-forth.
I think this is not related to this pr but a correction but is the wifi-signal a float? Correct, it is not related but I just noted it, no actually the wifi-singnal is a int, should I make it float int? Or just int? I thought int would be a subset of float, but now that I think of it that is stupid in code (in mathematics it makes sence). If it's an int it's returning it should be an int... I guess there is no typing here coming through as there is no complaints. I changed it to int, thanks!
Can't we add value fn to the others too so we can skip the if-statement here? Good point, thanks Is that really the only two states it can have? There is no documentation for the API (reverse engineering) and for my two dogs these values are always good or ok . Right. We should implement ENUM device class and use the options. Problem is of course if further options are available it will raise but I think we should do it anyway. Honestly I started this change with enum and removed it I ll add it once again. value fn is still missing from already existing sensors value fn has a default value lambda state: state and this default value is added to each sensor entity ![obraz]( Right. Didn't notice it has a default. Thanks No worries
This is close to the edge of my understanding on unique IDs but I think this approach might not be reliable enough in certain situations. - if you remove and re-add the entities device, it might not come back with the same unique id, resulting in automations scripts all having to be fixed. If dexcom only ever has one active 'device' per username, then the username might be enough. In that case the HA 'device' is really the user account rather than the physical glucose monitor. This could even be preferred in the case of having to replace a broken monitor (new monitor but same human). Check the discussion down below I know this was a review comment, but... can the user name change in any way? If so, this cannot be used... .. Frenck According to the code owner it's the only unique thing available. Other solution would be entry id In case of a service like this, I would consider reverting the last change and stick with the entry id. If a username is changeable (or becomes changeable), it would not be valid.
This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository. changing-the-entity-model Thank you for the notice. I created a new discussion.
Do we want to allow no supported feature is set? Ack on the 0 - AlarmControlPanelEntityFeature(0) change, makes sense! That's now done. Do we want to allow no supported feature is set? I don't see why not. That's the default in the base component, as well as, as an example, in the template alarm panel integration. If anything I'd argue that "disarm" should also be a feature that can be disabled, to also be able to support read-only alarm integrations - such as the case of systems with an event bus or programmable outputs. But that's not supported in the core integration, so kinda besides the point :) May be we can assign self. attr supported features in self. setup from config and remove the property so it is not iterating every time. Oooh makes sense! Will do. I do not think we should make this option required, because of the default value this is not needed. I debated that myself, wondering about the differences between Optional w default vs. Required w default. From a user configuration perspective they seemed equivalent. However, I opted into Required because technically it is actually required for the code to work: we do self. config[CONF SUPPORTED FEATURES] later on, rather than self. config.get(CONF SUPPORTED FEATURES) etc. Static analysis like mypy isn't smart enough to pick this up, but it could in the future. (git grepping Required. default results into 384 matches across the tree, so it's definitely not unheard of either) Introducing a new Required option is weird as it is absent in all configurations from the user perspective. Because it has a default value, it is not required in the user config or discovery payload. Technically you are right that it does not make a difference. Could you help me understand why it's weird? If you can elaborate on what you fear would happen, or any references, or prior discussions. My instincts suggest this is better for the reasons I stated, but given I'm a new contributor, my instincts are not fine-tuned for this codebase :) But when I tried looking to get a better feel of how others have approached this, I found lots of callsites doing it this way, even in very popular or core parts of HA, such as for example the Integration helper (CONF ROUND DIGITS, CONF METHOD, CONF UNIT PREFIX, CONF UNIT TIME), Bluetooth (CONF PASSIVE), ZHA, ZWave-js, etc. Would love to hear more to make this a learning experience for me. It is not clear to the users to make it required while it is not. It should be consistent with current configs that it is not needed to add the option. I cannot make it more clear than that. OK, let me try again: my understanding is that vol.Required " this code requires this attribute to function ", rather than " the user needs to specify this option ". In fact given we provide a default here, a user-provided value is explicitly NOT required here. Is my understanding incorrect? As for consistency, I already gave several examples in the codebase of options that are not explicitly needed, that ar
It does'nt seen to me the elif is needed here. Further I suggest you early return the fan mode indeed not necessary , removed We have utilities for converting fan speeds already. There are examples in the fan base entity and fan development docs used the utils Rotation speed needs to be scaled to min and max value The HomeKit model allows the device to set almost any min and max The min could be 100 and the max could be 10000 and iOS would show 1000 as 10 done This looks like debugging code that was left in. Can we get rid of it? removed , my fault (was for debug) Do you mean minValue here? of course! fixed Do you mean minValue here? same as above,fixed This could be a function since it's duplicated code with the above ok fixed According to codecov, this line is uncovered by tests. I don't think it is possible for it to be covered, because it's only called when the FAN MODE feature is present: L279-L280 The situation is the same with swing mode - we only check self.swing modes if the feature is present. Based on what swing modes and others like it do, I think the right thing to do to make codecov happy is just: But I would like a 2nd opinion from bdraco there I think. indeed i copied from swing :) let me know bdraco and Jc2k what do u think is the best solution. M. r1299472291 committed the suggestion. You need to update the type signature as well now it no longer returns None. See mine above u are right ,fixed. Yes, the None is unreachable because it will never be called unless the supported feature is set I think you changed the wrong one The other one does have the same issue, but currently can theoretically still return None. ahahah oh my god! But theoretically also this one should be fixed , btw i committed the right one.. (i hope) If we ever support more values it would make sense to bisect here Looks like we are actually missing coverage for this case, it was hidden before because of the way the flow was written From my perspective, this is good to merge once we have an explicit test for off added test for off state
Would the device class translation work as well? ( Connectivity and connected Disconnected as state) I need to discern between two different connection states. They exist at the same time. No translation key name? lost in translation... fixed Would the device class be enough? Is "sensor" required information to know what the entity is for? Yes, this is an addon sensor on the device. They both have batteries. Shouldn't this be TIMESTAMP? as the name implies that I think it's a full date and time. Not just a time. Will see when i get a user to test. Oh I'll need to recheck the docs on when to use what, it could be that this is right, but I'm not sure then Docs are not very clear now that i look :). But since this will be a datetime object, it probably should be timestamp. Both snapshots in this function are None, do we really want to use snapshots for that? Good catch. The test was invalid. Snapshots are nice and all.. But they do hide the check somewhat. Would almost be nice if it could update the .py file itself with actual data.
Kane610 is using the raw dict fine here, or should I add these as top level properties in the aiounifi library? Can we expand the library? :) Is SmartPower a UniFi name? This is part of the regular device right? Shouldn't need poll. This is part of the regular device right? Shouldn't need poll. One sensor one test, will help simplify later on should we refactor it to use pytest parametrize. If these are very similar, feel free to use parametrize on this test. I'm pretty sure I hate the approach I took with parameterized tests, do you have any pointers? Use entity id rather than sensor Combine the tests into one, no need to test updating separately. This should be the "final" comment :) Can we really consider one being representative of the other? i.e. should we have two methods or is this good enough? Final question :) I beleive one is good enough. I only have data on the PDU-Pro to go by, which i beleive is the only device currently that supports this. The UI uses both of these fields to display a utilization , so I felt it was safe to assume if balance was available, consumption would be as well. maybe it makes sense to check if both properties have values in this function? Either we do two methods of expect one value to be enough to determine availability
I feel like this integration is taking a wrong approach. - The MQTT integration should be used to make lorawan data accessible in Home Assistant. It shouldn't be wrapped in a config flow for a lorawan integration. - Each manufacturer should have its own integration. So there should be one for all Browan devices. balloob thanks, but would you mind to elaborate? If I understand your comment: - Each LoRaWAN device manufacturer would have its own integration (granted, this would actually be cleaner) - Each integration brand would use the MQTT integration. How? 1. Like I did here by subscribing to topics? 2. By inheriting from MqttSensor instead of SensorEntity ? 3. Where do we decode the binary payload? In this proposition a coordinator does it and dispatch it to each entity attached to the device, as one message from a device usually contain data for several entities 4. Or instead of ii. and iii. keep the current approach (inherit from SensorEntiry coordinator) but duplicate it for each manufacturer? - In such case we need to configure the network servers for every manufacturer, or is there a way to share the configuration between integrations? network servers: In short it is a server managing the security, addressing, radio parameters of a LoRaWAN network, and delivering the data the application server (Hass in our case). We need to be able to connect to several to benefits from local network server (local devices) and or cloud (cloud hosted network server, remote devices or trackers). Hey balloob, would you mind sharing an update on this or show me an integration where I could understand your comment? Thanks Hello balloob, I am sure that you have many things to do but I still need some guidance, please help me to understand: - How to use MQTT integration here as binary payload from the device must be decoded? Even Balloob recommendation [here]( issuecomment-985058373) is to implement an integration as the unpack template filter is not powerful enough for most devices encoding - I am OK to create one integration per device manufacturer instead of one LoRaWAN integration but some manufacturers are not doing only LoRaWAN devices, it might create confusion Thanks
To be consistent with detailed description , should we call this short description and name variable ATTR FORECAST SHORT DESCRIPTION ? I'm open to it. For normalization of variables, etc. it would make sense. It's easy enough to make the change, and I suspect there are only a couple of folks who are doing the custom component thing to expose the short forecast at the moment. Let me know one way or the other and I'll push an updated commit to this PR. Thanks again. I think we should be consistent and use short description , it is too late to go back and decide if we should have used detailed forecast instead. Sounds good to me. Let's make sure we exclude it from the recorder database. Are you referring to entity registry enabled default ? If so this is set to only have one such entity by default. Otherwise, I'm not sure how to exclude individual forecast data from the recorder, so if you could provide a pointer, it would be helpful. No I'm referencing implementing the recorder platform and exclude this attribute from being recoreded. I don't see any developer documentation and there aren't many integrations that implement this for guidance. When I check the weather integration, it is already including the forecast key in the exclude attributes . Does this already exclude this nested key? L9-L12 Oh now I see, that I missed in my original looks this PR. This is about the forecast attribute. Ignore my recorder comment. The forecast attribute is a strict set, you can't may not add new properties to it; this is the list defined: L140-L167 We are not adding new properties to the forecast attribute. The NWS component brings forward a weather entity called daynight ( weather.XXXX daynight where XXXX is the NWS station ID ). This PR add an attribute to that entity for a short concise forecast text string. The underlying pyNWS library presents it, we are just exposing it as an additional attribute in the daynight entity. Here's a screen shot: ![image]( The forecast attribute of weather is not supposed to have an short forecast attribute. It should also not have a detailed description attribute in the forecast either (which should be removed). See my previous response on the properties that are allowed to be in the forecast dictionary items in the list. Unresolved this review comment.
This is only used for the device, and thus can be committed, as de device name will automatically fallback to the entry title. Related to the above comment. Why was this check removed? Because this is set in the config entry. And if it wasn't present, there's a function here that restores that unique id if it wasn't set for some reason Right, but looking upstream, it seems that the method that gets the serial can return None ? fyi projector returns serial only if it's turned on and only if it is newer model. Olders models don't return anything on serial request. So older models don't have any unique id? Ok, sorry, my review comment earlier pullrequestreview-1575659064 might have led down an unhelpful path. If there is a scenario that can result in SN None , then the check is needed, but how would all the other parameters (model mfr etc) be set in that case? Maybe set manufacturer and model in all cases, and set identifiers , via device only when you have a unique id during init? Sorry, my understanding of how this all works is not complete. I haven't seen a device without identifiers yet, so I am not 100 sure if that works like expected. My current suggestion is to use the entry id if there is no unique id available, what do we think about that? Indeed if the projector is 'busy' [it could return SN None ]( L141) Can a pytest be added to verify that everything still works if no serial number is returned? It feels like this is a scenario we need to remain compliant with in the future. Please only refer to Entity instances as entity . Rename this to eg entity entry .
This will be 3 after PR - If it's merged before this you will need to rebase. Until then, this is correct. Please rebase as is merged
Only add files of this PR if needed. What happens if the connection fails? You should add error handling here. How should this be handled? Are we meant to keep trying to connect in the background, or return a specific error? At the moment if we fail to connect here HA reports that we failed to load and you have to reload the integration. If we're meant to keep trying to connect in the background, how should I handle that we don't know what entities we have until we have connected? Feel free to just point me at another component that does this nicely. I've taken a look around in other components, azure event hub will raise a ConfigEntryNotReady if it fails to connect during async setup entry . Is that what you are thinking? I really appreciate your help here. It depends which kind of error it is. A temporary connection error than raise ConfigEntryNotReady . If the error is persistent, please raise ConfigEntryError Looks like if you throw ConfigEntryNotReady here, home assistant will handle the retry for you integrations-using-async setup entry Sorry, I have forgotten to publish my pending comment last week. See my comment above ( discussion r1358326760) Thanks, Done. Please correct me if I'm wrong, but Airtouch5Zone controls multiple ac in a specific zone, correct? HA includes areas. In a service call, targeting an area instead of a single device is possible. Can you please test if an area is enough for your use-case? Are there other advantages compared to areas? Not quite. Airtouch 5 is a ducted AC system. There is one physical AC unit (represented in HA as Airtouch5AC ). The air output of this unit is ducted in to multiple rooms, each of which has a damper (to control flow rate) and a temperature sensor. These are represented as an Airtouch5Zone . A zone reports its current temperature, can be turned on and off individually, and you can set the target temperature for it individually. In HA it ends up looking like: ![image]( You can set heat cool mode on the AC unit, and turn each zone on off by settings them to "Fan only" or "Off". This mirrors airtouch4 and advantage air . Please remove empty keys. Are they related? They are similar systems made by the same manufacturer. They have different protocols and behaviours. Is the ac number always the same? Not sure if airtouch has an app, but the user has no option to change the order or something else... AC number should never change, unless physical changes have been done to the AC system (adding or removing a ducted AC unit). This is not something that would normally happen. is the timeout error that this function throws asyncio.TimeoutError rather than this one? It did the right thing in my testing (HA tried to restart the integration periodically), so I assume it's the right one. This is fine. See asyncio.TimeoutError ah thanks! I see I was playing around with this in python 3.10 so missed that Please fix the loggers Please move this to a separate function, which is then called with different par
The available function only declares if the entity should be marked available or not, use async device device info fn here. For supported it is fine. What does caps 3 mean? And is it enough to deem if the outlet has power metering capabilities? I saw I haven't documented Poe caps properly and I will fix that (investigation here Please investigate more about what the different caps mean. It can only be on one line, else you need to write a method for it. I can't find any information at all about outlet caps. What I've seen from the API so far: USP-Plug devices send "has metering": false, USP-PDU-Pro devices have two different responses: USB power ports, which have no power stats: "outlet caps": 1 Power outlets, which have power stats: "outlet caps": 3, My assumption based on the above: 1 supports switching [2 supports metering] 3 supports switching and metering I'm wondering if checking if outlet current is defined would be a safer approach? In all three cases above, the outlets that don't have support for providing power stats are not setting this property. I updated this check to check if outlet[id].power ! None . I saw [your comment]( discussion r1288848105). I hope it works like that too. I'm willing to give it a shot if you think it's safe enough. Edit: posted a new issue to talk about outlet caps: If True can be omitted. Don't overcomplicate it. I really hope we can use caps like that. Could you detail this in a PR in the library. Did similar for poe just now This should be in the sensor.py file as it's only relevant for the sensor right now. Should we use the cap for this one? Even though we don't have all data I think that's the way to go. What do you think? let's give it a shot!
Could you let me know why you made this change and the other ones in sensor.py? Just for readliness sake.
Shouldn't we have the restart test here as well? it now only tests the timeout added in 0745120c79f8d9e4bfec7b25ebabc4e547decbe8
Does anything here need one of the following? - suggested unit of measurement - suggested display precision Can use device class translations Does state of charge have a different meaning than battery percentage? Can use device class translations What's the difference between real power and power in naming? Isn't this the exact same class as EnvoyEnchargeEntity ? With the only difference the description being a different class? Can't we merge them? I can't seem to figure out the right typing to make mypy happy for return self.entity description.value fn(encharge) when i keep them both in the same class. Pushed up what I have (will fail mypy checks) - any thoughts on how to fix that? I would certainly rather have 1 class instead of 2 that are mostly identical. Ooh, now I get why there were 2 classes to begin with. Would a solution be to maybe make a base class with all the duplicate stuff in it? Means you end up with 3 classes, but less repeating. We can make some of properties that need an assert properties on the base class in a future PR Than we can just do self.data and self.envoy serial num
Raising this error here is captured a couple of lines below. If any output generating service causes an exception, it should be passed on. See [this]( discussion r1265668347) comment. Took me a minute to understand what you're implying, but I get it now I think. You're suggesting to re-raise the exceptions, right? So not just logging them, but actually stopping the execution. Correct. I'm not quite sure why myself, but that is a requirement for ServiceResponses With the exception handled above, this return value is unsafe. Please break out the core change to a separate PR. Thanks for the feedback! Opened 106164 and will rebase this once merged. I have rebased this PR after 106164 got merged. Note that bad user input during a service call should raise a ServiceValidationError nowadays. Adjusted We only create repair issues if there's a clear action for the user to take to resolve the issue. It's not clear to me that the user always has a clear action to resolve the issue. The script may have failed temporarily and the user may not want to continue on error. A response variable isn't always usable. True, didn't think of this. Thanks!
Reminder to bump this to the correct version once I merge and release It would be good to say, only for some utilities, see documentation. Otherwise people with an Exelon utility might be trying to enter a secret here. Same below. Can you add a test? See comment in for adding a parameter here to be backwards compatible. It would be nice if we could ask this in a 2nd step in the flow, and only if it is needed. So we can also request a direct link to the documentation. if not MFA: create entry, else return self.async step mfa() Otherwise it will be too confusing for anyone that has no TOTP secret. None is the default value returned if the key is missing in the dict. We can remove the second parameter. We can use the mock config entry variable for the config entry to access the config entry data.
This is a change, and it seems like might be a bit too much img width "954" alt "Screenshot 2023-08-05 at 2 08 38 PM" src "" img width "679" alt "Screenshot 2023-08-05 at 2 09 26 PM" src ""
I think we should not use a variable for that, but use actual logic instead. For example, consider the introduction of a try except or the ability to set a sequence of actions to run when an error happens (which in both cases passes the error). Many thanks for the feedback! I'll explore enhancing the script with a try except step.
you can infer the datatype here: set the schema for "value" to vol.Any(vol.Coerce(float), vol.Coerce(int)) . The validator will try to convert the string to a float, and if that fails, it will try to convert it to an int. If it can't convert it to either it will return an error, but if it succeeds the value will already be in the format you need Certain OSC software hardware will expect values to be in a specific format, so automatically converting values is not desirable in this scenario. cv.entity id instead of cv.string to get some automatic validation on the entity ID You should also look at entity selectors to limit this even further. I am assuming you only want entity's from the integration as input, a selector can limit the user to that. Example: L34C1-L39 you don't need this. Since you said the keys are required, they can't be None, the call will fail before it gets here if the schema doesn't pass unneeded if you have the coerce logic above in this case, I would make the OSC address the unique ID of the entity. Users can change the entity ID of an entity, so this will break. There's no reason why an entity coming from the OSC integration would not have a valid OSC address, so I don't see how you would hit this error. Additionally: 1. Instead of looping through all of the things in hass.data[DOMAIN] you could attempt to get the value with the key of the osc address , and if it is None then you know it's not there. e.g. if (config : hass.data[DOMAIN].get(osc address)) is not None 2. when you get config back, it's a reference to the object stored at hass.data[DOMAIN][entry osc address] (dictionaries are mutable so your reference is effectively a pointer). So if you need to set the value, config["value'] value will do it another option for this service is to create an entity service which will call a function on the entity. It will simplify some things for you. Search for entity service in the code, I can't remember the function names offhand but you should see examples of this being done in other integrations if each config entry is going to be a separate OSC address, then the unique ID for the entry can be the address not sure why the benefit is of storing the data this way since all of the data you are storing here is available in entry.data anyway (well except for value I guess) validate the input before creating the entry - is the input device and host valid? Set a unique ID on the config entry as well and then call self. abort if already configured() (or something to that effect, again, you will have to do some searching) where is this being used? You can set it as the default for the port in the schema in config flow.py this appears to be local poll not push, because the update function is periodically being called this is good as it makes the dev tools automation UI do the right thing. When I mentioned above to use the selector, do it in your code too so the backend does the same validation
You can use device class translations here Good call, thanks
With that change it now use the right entity id I think and thereby the tests works I guess this should return a float and not a string as the class is money? Same question for most below including percentage Return proper native types We should only do async add entities once so compile together before This seems to do nothing? Add this to the parameters instead updated in another commit Could we use as word separator. Would be good to fix on the existing ones too at the same time.
Should we automatically parse it as JSON if it's a JSON content type? I considered this and am happy to add it, but had erred on the side of not doing it because of the performance hit and it being easy to use from json in a template for this purpose. But I don't feel strongly. My perspective is also that it might be best to return it as is to not restrict and limit scenarios. Not a fan of inline if-statements, it's hard to read. Fixed.
The file includes "light" in the name. I'd rename the file, as the device is a dimmer switch and not a light, right? "logic group zdb5100" is enough to identify the device I think. So keep this line but just rename the json file. i agree Looks like the entities are named light.matrix office , light.matrix office 2 , light.matrix office 3 etc. Either adjust the fixture or adjust the initial expected state here and probably also the order of the service calls, ie turn off before turn on.
Can be simplified to: it seems this fails mypy Why you need this check? Mypy seems to like this more This way, you don't need the else check to set it to None
It can be simplified.
Please get rid of inline if as it spans multiple lines I think I added attr has entity name True . If so, translations would be cool! Added You can create a separate property for self.coordinator.data, saves adding this line every method The explicit coordinator data type annotation shouldn't be needed since the coordinator and its data should already be typed. Define the entity description as a module level constant since it's static. available is already defined by the parent coordinator entity. We should probably check that too via super().available .
Are you planning to add more select entities? You're now declaring different classes, only to set it to None in the declaration. Oh and you're not using the field somewhere either at this point If this is the only HOP select type, you can take it out of the tuple Yeah it will be the only HOP one, there will be others but they will be different types, will tidy it up. Isn't this the same as actually removing it? I'll check and if so I'll remove it removed as its part of the base coordinator entity This is already logged? I'll update the text which I ended up doing in my next PR Styling: unused? Styling, Coordinator is local: Keys is not needed here?
It would be nicer if this was all abstracted away in the library so HA doesn't need to know anything about the details of the api implementation Done. Is the library missing a py.typed file? I didn't realize that was necessary. I'll add it, but I think this also doesn't need the type annotation on the locks variable. Removed it. Drop this to debug or only log once at warning level and than drop to debug as we don't want it to log every time it polls
Need to try to load the previous data here We are probably setting this too early. We could type it above and only set it once the coordinator is registered. When the coordinator is registered we can restore or create a new one If available is false we should return None as well as it means the device is no longer in range and we shouldn't save it Actually it's ok to save it since we will know if the device is in range on next startup and it will be unavailable anyways. If we throw it away we might loose the state of a sensor that only updates daily Will this conflict with active data? Should it be passive data and only set when coordinator is set? Nope data is fine but should only be set when coordinator is set We can make this return a callable to unregister instead Need to make storage here as well. Probably s new object that has storage hanging of it Save storage Entity description is the one for the platform so it should be a type var That would be nice but should be another PR since we don't need it right now and likely requiring that is a breaking change This is the wrong entity description When we register the processor we should have a new function to register with restore that passes the entity description class and optional restore key which defaults to current platform This is a different problem and should get its own PR. Currently we load the data at startup but if the integration reloads it will not get the last service info This was an order problem and not an actual bug This just a typo This is a bug in bthome since if the device is asleep we don't remember its sleepy. xiaomi ble has the same problem Let's find this as from dict class method and as dict to be consistent with other implementations We could add as dict and from dict methods to the entity descriptions but this works for now. If we do it in more places that would be a good idea Would be cleaner to create the values rather than rely on the factory behavior so we know who owns the source should this also be key.to string() ? I guess set restore data assumes it's not . The device ids are either str or None but since we can't serialize None as a JSON key because the spec doesn't allow non-strings so it has to be "" . The restore goes the other way Should this be done in async register processor ? Since the coordinator can have multiple processors (one per platform) I did it here Why initialize it? It's in class definition so will be the same across instances. Good catch, its leftovers from previous refactoring fixed in c2751634aaeb729172944a6834ae74fb9aae5db5
Why do we need this? I'm not sure what you are referring to. If you mean the casting to a dict, that is required in order to be able to update the entry data in the next step. I think this is different from the typical suggested way of doing things is why he raised it as question. reauthentication notably you likely want to store the entry See [here]( L32-L75) as example which is quite similar to what you want to achieve. Not sure if it's possible to change the username or if that should also be removed from the schema? Okay, I'm not sure why entry data is passed into async step reauth if we are not supposed to use it. But anyway, I reconfigured the reauth flow to use the example code. I suggest you have another DATA SCHEMA without the url so the user doesn't have to fill it (I assume it doesn't change) Yes, good suggestion! I made the change. This should be a string, not the ex object. I believe this is exactly as the documentation describes: reauthentication Indeed, it works. I didn't think it would str:ify the sub exception. This should be possible to write as: Thanks. That's very Pythonic indeed. The assert is still needed though to satisfy type checks. I guess it's required to have a password which can't be ""? It is actually possible to remove a password from a user entirely and authenticate with just a username. Not very safe of course, but possible in Jellyfin. Done! Don't think this adds anything right? I suppose we can indeed do without. I removed these lines. All these tests that ends with an error should be continued so they end with an abort. Done!
Nice to have: using here "brushing mode" as translation key would increase readability and readability
I think we could arrange for the entity name to be None instead of checking the device class The processor isn't allowed to know abut the individual platforms You mean self.processor.coordinator.name ? Since the name in the entity description is probably undefined Probably can use is here Probably can use is here
Is this really needed? Is the real bug here that TriggerBaseEntity.async added to hass is missing a super call? In previous PR we said that this is a much cleaner way to say what's going on than using super() Is this a new option or it was just not tested before? New options. Will open doc PR
Maybe add a ManualTriggerSensor which knows about uom amd state class, similar to TemplateSensor ? Note: this changes the behavior in case of attribute parsing failure. - previously, a failure would cause the attributes to a blank dict - now, a failure causes the previous attributes to be kept What this change on purpose? (also see 97526) We should not change this behavior in this PR at least. So I see you have fixed that in the other PR so it comes back. Thanks
I think we can just update the entry to "remove" the title in the normal setup (using hass.config entries.async update entry() ) and don't need to bump the version and implement migration.
I think this should only be on the lock so the sensor can get it's name from the device class I think this should come out as sensor.vault door battery if it's correctly done? Yep. If I had actually run the tests, I would have seen this. ] Fixed. Any chance there is more sensor entities to come so you should do SensorEntityDescription directly or is this platform limited to battery ? Yeah, seems worth doing. Done! If you plan on adding more sensors in the future, it would be good to make the unique id f"{device id} {key} so you don't have to have one without a key and more with Good call. Fixed. If you want long term stats on the battery, you could add the measurement state class
Another PR should do translations here
We don't use YAML config for new device integrations Got it. Does that mean I should find another way to let user having some customized settings or it's just I should't use YAML config in the first PR? Thanks After this PR is merged you can add an options flow in a future PR It would be better if the the library raised named exceptions instead Are there any API docs available for this device? Its great that its local, but it would be nicer if it was push Sorry we currently don't have any API docs for it because the local communication is also a new feature for our device. I'll discuss with my coworker to see if pushing is doable or not. But it'll be alright if we decide to just use the polling strategy for now right? It fine to use polling if push isn't possible, but its usually better to do it up front since it makes it much more work to switch later when you have to support older devices. This is the default for CoordinatorEntity so it can be dropped Please implement the above suggestion applying it also for attr has entity name . Please set attr has entity name True has entity name-true-mandatory-for-new-integrations This should all come from the config data New services should be translatable and in strings.json We should use the key common strings for host Stale doc string Please move the custom service to the next PR to keep the initial PR smaller You should be able to unpack this at the entry point instead of here This should patch the library at the entry point in the config flow instead Do you think the id in the title is helpful? It is not allowed to except the bare Exception outside the config flow. Please except the specific exception. Please remove it as you can import value directly where needed. You don't need the property code below Please remove this empty file Pass yid instead of the hole config object.
This should be migrated to use EntityDescription s instead. Plumbing this on will not help anything and makes it worse IMHO. Hi Frenck, Help me out here.. On purpose I didn't do any refactoring in this PR and only extended functionality. This conform as you requested on another PR to not mix changes in Feature and refactoring in a PR. It's one or the other... I do want to look into the EntityDescriptors and implement that in the coming time. But then it would be nice to have this PR completed. I think we should consider refactoring first, before adding new things. Partially typed, please complete the typing. Instead of implementing the property method, we can just set the shorthand variant directly in the entity constructor ( attr icon ). This is refactoring that is not related to this PR, please remove all unrelated changes.
I noticed that this is a duplicate of the assignment on line 177. Is that intentional? Out of curiosity, is there a reason to grab entity. obj holidays instead of just using the obj holidays variable directly? It seems like the latter would let you avoid the pylint suppression. The one belonging to the entity is adjusted by the users settings. I don't think I see anything that modifies obj holidays on the entity. If the user changes their settings, doesn't that just result in a new entity getting created and registered? (And presumably, a new copy of the service method getting created and registered as well) The service is called with the date already. It makes no sense to return the date, or what do you think? It will be removed I would expect that domain services are registered in the init .py file or a dedicated file but not inside a platform file. Therefore I would suggest moving it into init .py . What do you think about it? I think it belongs to the binary sensor as the object being queried from this service. Probably more a matter of personal taste as in the code base you will see many different flavors.
Isn't this the reporting station for every data point? In any case The API returns a reporting station associated with each measurand (AQI, PM2.5, and ozone). Right now the integration just stores the reporting station associated with the PM2.5 measurement. It's not clear if there would ever be a case where different reporting stations are used for some measurands, but I wanted to be clear where the data is coming from. Understood! If you could still look at the capital letters :) nvm Correct me if I am wrong (you probably have this fix on your env, so if you can double check), but I think when adding latitude and longitude to state attributes, it gets added to the Map (in the sidebar) and afaik there is no way to hide entities. So maybe use "lat" and "long" for naming and then you can use state attribute translations to give it the full name Good to know... I'll fix that in the next commit. It looks like state attribute translation might only work for climate entities right now (at least it doesn't work for me in my test env) so I will probably just leave as lat and long for the time being. It work fine for sensor attributes as well so I suggest you implement it right away. OK, I sorted it out, should be good now If you mark it ready for review I'll approve it :) Can you try this and then run python3 -m script.translations develop --all and retest? Note: I explicitly didn't use common config flow translations as that would be a different context of strings Thanks, works now I explicitly didn't do this since this is a sensor attribute and not a config flow data thing, would you agree otherwise? I think on this occasion context can't be different e.g. different translations and I did check the code base that other integrations does this as well. So I would vote against myself on this particular one.
Should be optional so if not set it automatically use the default. We only need to store this if the user manually as he's aware he has more tries than the default (needs to be documented obviously). Rename to DEFAULT API CALLS PER DAY The default should be 100 so that it just works for new API tokens. For existing installations it should load the already configured value from the config store, no? The low-level API (pytomorrowio project) has max requests per day method to obtain contents of the rate limit HTTP header (when present). Otherwise it defaults to 100. So I think every free API token is currently limited to 100 API calls per day. And that should be the default when the config entry is missing. It would be ideal to have an OptionsFlow to allow existing users to change the limit without having to remove and re-add the integration. "api calls per day": "Number of API calls per day" Well, they aren't the number of API calls per day. They're the upper ceiling - there's some calculation happening when using multiple tomorrow.io integrations. So I think max api calls per day is more accurate, no? It's really a target and not a maximum. If HA gets restarted a few times during the day, then the number might exceed this value. But at any rate, just make the naming consistent everywhere. It's really a target and not a maximum. If HA gets restarted a few times during the day, then the number might exceed this value. But at any rate, just make the naming consistent everywhere. Planning to. To be honest I only made the PR to get an opinion on how to implement it - it's far, far, far from ready. CONF API CALLS PER DAY "api calls per day" Rename to api calls per day
Maybe rewrite to something like: Not sure if adding a switch (i.e. match case (py310 )) is recommended within HA (would opt for better reading in this case uhh this is a bitwise operation Switching programming languages more than twice a day isn't proper. Apologies, disregard Maybe check for a numeric value instead of string length?
We should probably log or raise error if it fails, try to look at other media players for how to handle missing source Please remove this from the code. You can link to the issue in this PR comment
Unrelated to your PR, but just noticed it
We shouldn't store the port in the host config entry item and probably not ask for port in the same form item as host either. If any string splitting should be done it should be done in the config flow, since for the device api host doesn't include the port. Sometimes in integrations we ask for a url which can contain both host and port eg. So there may be some leeway in the form to ask for host and port combined. Codeowners should decide how they want the form. Thank you for your guidance. I modified the config flow. I still want to do host splitting, since most people will not specify a port, and the extra port field in UI will be confusing for them. I discussed that with Codeowners in python-kasa when I created PR to support passing a custom port. How should the user know that they can enter port by using a colon in the host form? Normally the form name or description should inform the user what data should and can be entered. Do we have any precedence where the host form is used to enter both host and port? Please use lowercase snake case variable names. I updated the description for the host. We should also look at precedence. In the same commit, I updated variable names from hSplit to parts in two places. I was referring to this question: Do we have any precedence where the host form is used to enter both host and port? Yes, this is a well-known notation for specifying port in URLs: : :text Port 20numbers 20are 20sometimes 20seen,8080 20of 20the 20HTTP 20server. Right, but I mean in Home Assistant config flows. I am not aware of any precedence in Home Assistant. However in this case the use case for the user is exactly the same as in a browser. In a browser, there is a default port 80 and you don't have to specify it. Most non-dev people are not even aware of the possibility to specify a port in a browser. Similarly, in this case, most people will not use the port and it makes total sense not to put it in a separate field. I don't agree. We shouldn't introduce a new pattern in the config flow forms for a single integration. We should follow the common patterns in Home Assistant so that config forms are as familiar as possible between integrations. The only form item in Home Assistant that I'm aware accepting both host and port is the url form. If that doesn't fit this case, I suggest using separate forms for host and port. Side note: Please don't resolve the conversation if there's disagreement in the conclusion. I don't agree with you. Are you a gatekeeper for merging this PR? Can I disagree with you and still move forward with merging this PR? Should we wait for rytilahti to chime in on the subject? What if rytilahti does not agree with you either? Yes, it currently blocks this PR from being merged. Codeowners should also weigh in. If members disagree we'll need to find concensus among further members. I agree with Martin, this is not a good way to handle this input and also not the way this is commonly handled in Home Assistant either. T
It is already marked as "diagnostic", any reason we disable this by default? Only that it provides access to all networks without any additional decision. You think we should skip disabling it? After additional discussions on discord we agreed to keep it as is.
I'm not entirely sure but if I'm not mistaken location can be returned None if the user only press submit (using the found location).
Shouldn't we separate this into a new function to get notifications. The code that extracts this later looks rather ugly. Sure, it is just a proof of concept yet, but GA does not trigger, when an event is sent Mode the code to a new function notificationSupportedByAgent is a value per device that is expected to be reported in the sync response Ah so this is the wrong place? Yup: should be enabled here: L614 if there is a trait with notification support. Thnx, I'll have a look Moved the setting. Now there is an extra option to enable announcements, so that works now. What still does not work is that sending notification should trigger the announcement. Any idea? I think you must allow it in the google home app on the device. I need to look more closely on the data that is being sent too. That is correct, when I moved it to helpers.py as you suggested I was able to allow it in the google home app. But it might be possible to insert this from the trait. Looks like you had a missing comma and ruff black etc has merged 2 lines together? I dont think this is okey for a final solution (okey for POC obviously). We should not synthesize a non standard attribute "last event". It should be separated in the trait generation. Right, I agree. The point is that we probably need to generate a special request to trigger the doorbell. request May be you have an Idea on how to do this? we have sync response and attributes response in the trait. I think we just need a notification attributes() function on the traits, and some flag on th trait that it support notifications. That sound good. Feel free if you want to commit any suggestion. I'll undo the current changes. we have sync response and attributes response in the trait. I think we just need a notification attributes() function on the traits, and some flag on th trait that it support notifications. For the event we probably need a sync request instead of a sync response. Need to ve done only if trait exists before we ae done. Can we set this from the trait? Made it conditonal Event id is not a static type of event. Its UUID that is unique every time a event is triggered. Ps. You can generate a random number to test. But we need a better solution to get it from the context of the event that triggered the state change later. This looks too complex. It should just be a query notifications() function which is used to build the notification data. Same as query attributes(). Sure, it needs to be simpeler, but my main concern for now is that triggering the notifications does not work.
Shouldn't we redact the password in the URL? I think generic has a redact url I'm replacing user and password in the generate source method. I don't want to use the redact method as that is the cause of issue I'm the referenced issue Why rely on replacements if you can just set it without? There will be more variations of that url in the future so better to change it than duplicating it Right, but replacing usernames password is, IMHO, bad practice (easy to mess up). It is better to have them not there in the first place at all... I'll follow your suggestion and rethink it once another source is in play :) Please break long strings around 88 characters per line. New PR resolving comment
Looks maybe like this should be in options instead of data so you should implement and OptionsFlow? That is a good point, I did not considered that. It is better as an option. Any particular reason why we store all these in data instead of options? What data do you mean? I noticed we can change many variables from data within the options flow so you can ignore this comment. Doesn't look like we test anywhere if the regex is proper or if it can blow? Since we now check the regex on submit, this point should be obsolete. You should use cv.is regex as part of the schema instead of cv.string . Then we're doing the proper test already there and don't need to validate any further that it's a proper regex. I tried this, but it caused the config flow to become unavailable with this error message: TypeError: issubclass() arg 1 must be a class Seems very strange. Should work fine if you do Nope, it throws the same error. Gui: 500 Internal Server Error Server got itself in trouble Logs: I just realized that some of these cv's doesn't work in config flows so obviously regex is one of them. So we need to use cv.string as you had it. Should we perhaps not use cv.is regex to check that it's actually a regex? So this doesn't actually filter the result more than making a True or False ? Should it not be saved to coordinator results so the binary sensor can trim down the result further? Yes, this is the intended function. If the filter detects a region the message is forwarded, if not it is ignored. I don't see why the message should be filtered further in binary sensor. It's not obvious that's how it works. I think you should open a doc PR and add information about how this works. Current doc doesn't say that much and also the string you added for the config flow doesn't tell that much either. If you're happy with it, please click "Ready for review". I see a doc PR has been made
This is not needed anymore since this part will be config entry only Done, this could be removed in the switch.py too then? Nope, that's deprecated and will be removed in the December release if I recall correctly Both sensors are having the same behavior, Take a look at using SensorEntityDescriptions. This way you have one base sensor where you inject different types of sensor types. that sounds very interesting but I was not able to find this in the doc, could you give me a hint how that works? Out the top of my head, checkout homeassistant components youtube sensor.py to get an indication I see there are many sensors like that, I'll have time for this improvements somewhere in the next week Since you're using device classes here, you don't need the attr name as it uses the name from the device class. Didn't know that, thx Please do these changes in a separate PR understandable, I've reverted this changes Can we rename PLATFORMS SWITCH to PLATFORMS PLUGS or something related instead Maybe, put propably not in this pr Please do the renaming in this PR, as it will improve the readability of the code. This constant is only used in two places in this file. why do you think the usage of constants is a bad thing here? I think because it's only used in one place, so there's not a real benefit to make it a constant at this point. To fix Ruff in the pipeline We don't need a type annotation and class attribute for device here as there's already a type annotation of the entity device parameter. Please sort .
Where is this variable defined?
If you aren't redacting any data... then you don't need to call it either :) You could use snapshot testing here, which makes it easier to update in the future.
This is a good change, but I wouldn't go too high as we want the database to still be responsive between purge calls and the purge will block the database for a bit we can reduce the amount used in the attached test too -- more speedy test


Should do first refresh here so we only continue if data is retrieved raise UpdateFailed Could be moved to the coordinator instead to have already formatted data saved? This is missing super() to add in available from the coordinator I think this should probably be renamed to user data as it's not the user but the data from the user If one user is wrong or one call is problematic it will set all sensors unavailable. Is that really good or should we make this slightly more sophisticated? Perhaps only do logging if calls fail for a certain user but raise UpdateFailed if all calls fail for all users? Currently the dict would look {"username": None} if a user is not found, so this wouldn't work right? Not exactly but it would save to the dict so change it so it only adds to the dict if get user data actually returns data This would log every time if for example the username is not valid anymore. Can we set something so it's only logging once and not repeating (unless there is a valid response in between. this and this, can be pulled out of the try except scope. Can't this throw? Yes it could and I saw it after I pushed it. It's fixed now
we can move this to line 337 (or after) to eliminate the if Good point Done Small suggestion to simplify the message. Also wondering if we need to mention checking your network configuration or if we can just say Check the CoIoT configuration in the device's web panel? The problem can also be caused by network configuration, e.g. Shelly device in a separate VLAN or blocking multicast on the firewall of the device on which HA is running, I think that we should leave information about checking the network configuration.
We don't promote the use of bind hass anymore, please remove it We should use our standard naming convention decorator to show this is OK to call from the event loop: We only need translations for domain , shouldn't we just ask for those? As I understand it, we only need this for a single domain, which would allow us to greatly simplify the function? My goal was to keep make it similar to async get translations . It would be good to reuse some code between them, but I haven't found a nice way to do it I have kept this approach to extract and reuse some common logic Replace with a guard returning early: It seems very inefficient to call async get translations just to populate the cache. Could we maybe add a function async get translations which calls cache.async load instead of cache.async fetch ? async load translations should be refactored so the code which prepares the set of components and the code which creates the translation cache is not duplicated in the new function async load translations I have refactored this logic and extracted async load translations Why do we need to listen to EVENT HOMEASSISTANT STARTED ? I have added it just as a fallback, it should work without it as well Removed Should this have its own event listener which only caches translations for the loaded component? Extracted a separate event listener When does this happen? It happens just after HA start, component loaded events are generated with following values: config.area registry , config.auth , config.auth provider homeassistant , config.automation , config.config entries , config.core , config.device registry , config.entity registry , config.script , config.scene When they are passed to translations loader the process end up in exceptions being thrown: This is fired twice at startup, with no event data from this method: L379-L380 It's also fired when the configuration is changed, with the configuration change included in the event: L2226-L2227 This means we can improve load translations to only check the event data and return nothing if the language has not been changed. I have changed it to handle situations when it's fired with no data during startup. Is there a way to detect if specifically language has been changed in the config? Should we flush the translation cache to not keep unwanted translations in memory? I don't think they were flushed before, also they are probably still used by the frontend as UI language is set in user's config. But I can try to add it if you think it is beneficial. I'm not convinced config should be responsible for maintaining the translation cache. I think it could instead be handled helpers translations.py , with a call from here to setup the listeners: L256-L259 I have extracted async setup load listeners , added it to helpers translation.py and called from bootstrap.py I still don't think it's useful to support lists here. If needed in the future, we can add it then This should not be public Let's not support lists here, also,
Solved with 96890
- There is no need to prefix it. - I get the idea; however, nothing requires the webhook id to be unique, it could be reused for other things even. Would it be better to take a unique id via configuration instead, then? I think it would be better to migrate this integration to the UI, so we have an entry identifier we can use instead.
Lgtm. Does this addition negatively affect the test coverage? oliv3r Did you check the coverage before making this comment? I don't think it affects the code coverage; sensor.py of Tuya component get omitted from code coverage. Exactly the point why I asked that iKaew
I would not expect that the state is written here. There might be other attributes an integration want to set on the entity before writing the state. May be the name of the coroutine could be better async register event ? E.g. mqtt first processes all topic (they may be shared) and finally calls self.async write ha state() to update the state. E.g. mqtt first processes all topic (they may be shared) and finally calls self.async write ha state() to update the state. So, call this method last? So, call this method last? May be, but it is at least different from the other entities. May be add an option that you to choose if the state is written? There is nothing else adding anything to the state? So, I don't understand your comment I guess. Well an MQTT entity can be available or can be unknown or not and might have extra state attributes (that can be blocked btw). How is this for the event entity? The available proeprty can still be set on update if you'd like. The entity will go unavailable at that point. As that doesn't require a trigger to be called, the method this comment is on, isn't relevant. The unknown state only exists once in an event entity, during its first creation. The unknown state isn't managed by the integration implementation. Removed it We probably need a helper that subscribes to the events and dispatches only matching ones....a more generic version of async track state change event . That would avoid the pattern were we dispatch the event to potential listeners and they reject it because it doesn't match the relevant device etc. Maybe we could make the event required to have the device id in it so you only subscribe to events for the device id. It would make the events a bit more standard Logbook already knows how to handle the device id in events so it would probably be a good idea to formalize something like that at this time Maybe the subscription tree looks something like [event type][(device id, event type)] ...not sure all the use cases here though So, maybe this example isn't the best to demonstrate implementation details. I would not expect entities to listen to existing HA events. I would expect them to tie into whatever provides those events in the first place (provided by the package library the integration uses). MQTT overrides this property, is it needed to mark this final ? Yes, in this proposal it is, as it is protected and managed (including restore) by the entity. In this specific version it becomes an internal. I am finishing up a second alternative that is more "old-fashioned", so we have something to discuss. I've tried the second approach and came to the conclusion that will be much worse. I should not be an breaking issue. Ernst79 are there any bthome events to think about here? Could we add phone here? I think the event platform could make sense for fritzbox callmonitor . It currently uses a sensor but that isn't ideal. The event types could be something like ringing , dialing , talking , and idle in tha
In the old code, the controller id was the string "1" . Is it OK also with an int? It does seem to work with int but I'll update to string Can we use the modulus operator, or is that less readable? Can we add an explanation here why our zone id is an ever growing number but the russound library expects it to be split between controller id and zone id?
why is this assertion needed? Because config entry.unique id can technically be None Not for this PR, but maybe we should introduce a class ConfigEntryWithUniqueId or something to fix this? Or make ConfigEntry a generic class, where the unique ID type can be specified? commented out code commented out
Please extract the device specific interface code and data parsing to a standalone library published on PyPI. 4-communication-with-devicesservices Hello! Thank you for reviewing! I am a little confused, I don't understand why adding support for e-bike data has to be blocked by this PyPi requirement. To me, it looks like this component was already breaking that PyPi requirement completely. So I would think there should be an issue open on the repo to refactor the whole CityBikes component, but I couldn't find any such issue. So it feels like you are saying HA should block features and improvements because of, what seems like to me, out-of-scope tech debt, which isn't even documented as an open issue in the repo. Please let me know if I'm wrong. No, you are right; we block it because of tech debt, and prevent more debt to be introduced. Please feel free to jump in and help out resolving that. which isn't even documented as an open issue in the repo That is not what we use the issue repo for. It is not our task list, it is a place where user can report bugs.
Is it intentional to not have a custom name for the binary sensor? Is it clear that a binary sensor named "Connectivity" reflects WAN status? Or Connected , or Active ? The change I originally wanted to make (it was more a proposal) was using device class translations. By using connectivity it should be in line with other integrations providing a binary sensor with device class connectivity. The only question now is if this "dekt de lading" correctly. The sensor name would be binary sensor..... connectivity and the state would be "Connected" or "Disconnected". And these strings are already translated in a lot of languages :) This is actually something we should address and not just migrate: - The unit of measurement should not be in the entity name. Good point, any suggestions for a new name? Upload download speed? Download speed is fine by me. That works
For some strange reason, this device was registered under the name unnamed device. Does this have to do with device registry? When does a name reset? This should not be set if the entity does not have a unique id We should still set this if the entity does not have a unique id This should not be set to None if the entity does not have a unique id This should not be set to None if the entity does not have a unique id
Why is this check removed from the test? Oh, PR should've been put to draft. But for some reason the name of both devices are different, but I can't seem to figure out why they are different, as they are created from the same data source OK, so the problem is that device info is accessed before async added to hass has been called, which means the device name is reset to the config entry name when the entity is restored. The bug is already there AFAICT, this just PR makes it evident. I think the solution is to conditionally add the name to the DeviceInfo here: Can you move this to a separate PR please?
Store the address as upper() so you don't have to do this every time Please avoid progressing the flow in the helper. Make this return an error string or None and let the caller progress the flow based on that. These likely won't be seen by the user and generate log noise. Its better for it to be displayed in the UI It would be better to store nothing instead of a default here so we know in the future if its unset in the event we can somehow get the name for the device and use it when the user didn't set it before. This is just an opinion, but I think the successful case should be the final return of the function and errors should be caught by the guards. Please remove this. Debug logging should be controlled by the logger integration Set this in init . It's too late to set it here as it's read when the entity is added to hass L617
Can we add a test covering this? While working on this I found that the following bit in the core async call prevents ServiceResponse from being returned as None : L1978-L1982 That seems counter intuitive to me. allenporter, Seeing as you've implemented this mechanic. Could you elaborate on the implementation pointed to? IMO if something goes wrong during a service call, returning None should be possible and not be captured again in the core's async call . I've changed to returning {} i.s.o. None for now, but this seems unwanted behavior. As instead of None or usable data, there is now a third option that could be returned. If something goes wrong an exception should be raised. See response-data for our design standards agreed upon in the architecture discussion. Thanks for the info. The exeptions in this case are handled and don't propagate. To be true to the design standards I believe these exceptions should then be re-raised. Though to remain consistent with the existing implementation of shell command we should stick to the logging produced and return gracefully. I lean towards the latter, but Ok with either implementation. I don't think the existing implementation is right either. This should be raising instead of swallowing even if not considering response values. The response values guidance is reiterating the current desired best practice. Can we add a test covering this? Added check to existing test in last commit. But as this test is disabled ( disabled to check if it fixes flaky CI ), its not counted by the test coverage. Oh, I see. The test is fixed in please rebase this PR once that has been merged Let's mark this PR as draft until that's done. Why is a cast needed here? mypy throws an error: Error: homeassistant components shell command init .py:133: error: Incompatible return value type (got "dict[str, str int None]", expected "JsonObjectType None") [return-value] Before casting I tried type hint ServiceResponse which did not work, but JsonObjectType does the trick without the need for casting I'd like a second opinion about if this change is wanted Agreed. Not quite sure if that's the best way to handle these situations. But in the sense of what errors stack trace are represented to the user, I do believe this is more helpful than the "got none, expected dictionary" error thrown otherwise. I'd like a second opinion about if this change is wanted I discussed with frenck on discord, he agrees this makes sense
The device class will deliver the translated name :) What is this timestamp for? It's name is just time, but what does it actually do? It's pretty much what time the device thinks the world is in. It generally not that useful that is why it's disabled by default. Maybe i should remove the entity. I think showing this information in system health or diagnostics would be a better place, as it doesn't make a lot of sense for people to make automations or get info from imo Agree, removed. Should this be description.char? Nope. Key is a uuid which that dict is indexed by. Could have been .char.uuid which would have been the same. Aah, I was missing where char was used but now I see it These can be set outside of the init. (Native value one not sure) Might be nice to make a base class that takes care of constructing the unique id if you plan to keep using this pattern Will do a refactor separate, since it affect previous integrations. I would probably call this get cached to make it clear no IO is happening here It would be better if the library provided times natively in utc so we don't have to convert here Device stores time in local time without knowledge about timezone. Suppose i could pass in timezone for the client on start. I will ponder a solution for future lib updates. I do agree
In a follow-up PR, let's make this a DataClass Implemented in this PR based on feedback below. Why do we now need to call this manually from async unload entry instead of letting it be called automatically on unload? The ordering matters. Discovery needs to be turned off, so that new devices are not added, before calling hass.config entries.async unload platforms . With async on unload discovery was being turned off after. This function is about unloading a config entry, not about preparing to potentially load it again some time in the future. In async setup we should create an object in hass.data, in which the YAML config, and anything else which should persist between config entry reloads, is stored. In async setup entry we should add that which is needed by the config entry. In async unload entry we should remove that which was needed by the config entry. Maybe something like this: Sounds good. I've done this and also changed some of the layering composition too. - async setup is now responsible for initializing the hass.data[DOMAIN] as well as the pywemo SubscriptionRegistry DiscoveryResponder. I've moved this pywemo initialization here as in the future it is likely that we'll want to deprecated the configuration.yaml settings and move to one Config Entry per device. When that happens these pywemo instances will need to be shared across all Config Entries. - async setup entry async unload entry now do as you suggest, adding and removing only what is needed for the config entry. - I've moved everything to do with Platforms into the WemoDispatcher class. This also included simplifying a bit of the boilerplate code in each platform module ( async wemo dispatcher connect ). - I made a few helpers to assign the correct types, for mypy, from hass.data[DOMAIN] : async coordinators , async registry , and async wemo data . [Aside: I wish I could use async wemo data from within wemo device.py, but can't due to circular dependencies. These helpers the asserts within seemed like a reasonable way to improve type safety and catch mistakes with tests.] - I overrode the async shutdown method for the DataUpdateCoordinator to properly unsubscribe from push notifications. I missed this in the first go at this PR. Aside: I wish I could use async wemo data from within wemo device.py, but can't due to circular dependencies. These helpers the asserts within seemed like a reasonable way to improve type safety and catch mistakes with tests. I think you can move the new type definitions and the helper for getting the typed instance from hass.data to, for example, wemo models.py to avoid the circular dependency? Yes, that and if TYPE CHECKING: solve this nicely. Thanks for the suggestion. Done in [cfde9bb]( It's OK to type like this to avoid asserting the type everywhere: Done in [cfde9bb]( Done in [cfde9bb]( We don't usually use this pattern, and our linters don't complain about unused parameters. It's more common to rename to config entry if you want to highlight the
.get will already default to None, so you don't need to explicitly add it here. This comment isn't helpful, as it doesn't explain that a follow mode value of device equates to an outdoor sensor. This entity description doesn't have a translation key. This would probably result in sensor.{device} air quality index and sensor.{device} air quality index 2. Please add a translation key here and add something like "Outdoor air quality index" to the strings.json And to clarify, other entity descriptions dont have translation keys, because they get their name from the device class, Hence the reason why having two descriptions with the same device class (and thus the same name) is confusing. joostlek I've updated the code to include the translation key and the relevant strings.json update, but for some reason it isn't being picked up in the UI. I've even done a fresh install just to clear any potential issues out. Can you can a look at my changes and give me some direction on how to fix the problem? Much appreciated! I tried it again today and this time it's working.
You might need to test this on your device, but I think the states of Alarm Control Panel are already being translated by default, so you don't need an extra translation key for this. Checked the strings under the Alarm Control Panel and it looks like you are correct. Also, can't find any integrations that implement translation on alarm control panel entities. (did a github search) Removed it. Maybe make this a parameter, that's more consistent. Not sure what you mean by this? Could you provide an example? Edit: I'm assuming you mean add as Class attribute? Is there always one device active on one HA instance? Can there be more? There can only be one per EZVIZ account. The integration also only caters for 1x account. How often do people change system? I think when you move to another place with another ezviz instance, the only thing that you will have is that your removed device is reused again for the new setup. Not sure if having device identifiers static is something what we want, so I'll leave this open for others to review Don't make it harder to cater for multiple instances of the integration in the future. Use the unique id for the entry if no other unique identifier exist to use for the device. In the possible states you're checking ARMED HOME and now you're setting it to ARMED NIGHT? It makes more logical sense to do arm home. Have changed it. Done. Why is this declared on the object, whilst it is only used in update() , I think a local variable would be better. Correct, I have implemented your suggestion. Thanks. self.schedule update ha state(True) async function can not be called from sync code. You can use schedule update ha state() , but you don't need to do that since it's implicit after a service call for all polled enities. So just remove. You can't call async function from sync code. Write is assumed after update. typing is superflues. For some reason entry.unique id is set to str None Is there a better way to do this? Also, though it might be cleaner to define device info here. f"{entry.entry id} alarm" would work aswell. Not every integration has unique id set iirc. Understood. I initially thought elupus meant the config entry unique id. Depends on your integration, I think both work well. Only some cases it makes a difference (think of integrations that set the mac address as unique id, if someone removes the device and adds it again, it uses the same device identifiers). But I don't think that's a big deal here. EZVIZ uses the account email address (can't have more than one account on a specific email address) I'll leave as is then. This is a async function, it should use async schedule update ha state()
Since there is no device name, this is prefixing the device with the project ID, which is not user friendly.
Unrelated, but we likely have a lot of data we could add here Definitely, but I don't have access to those devices. I'll note it down as an integration to check the tests lib to see if I can fill this info using this info. But in a later PR ofc
Why not just lower case this instead of using slug? Some strings contains periods, and our scripts don't like periods in translationkeys
Is estimation still a thing? If not, we could remove this and use the device class translation to minimize the amount of (double) translation keys It is estimated Should the device class of this sensor be VOC? No, I according to the documentation it is TVOC and not VOC Not really sure how this change affects everything, since before the device would be registered by every sensor under a different name, which doesn't seem right. Mill has moved to a new cloud solution. So I am working on rewriting the integration. Will make sure the naming is correct in the new version. issuecomment-1627776157 Should I wait until that rewrite is done?
We can probably make a resolvable issue here so the user can fix the issue. Sounds reasonable. Could you point towards an implementation example? Not used it myself yet but here is an implemented example L88 If a user uses English with "christmas" and then changes to German it will not find it anymore right? That's a possible scenario when German language holidays localization exist for user's country. I wonder if it's worth mentioning that at [strings.json:33]( diff-ad4c9e983391df7ebc852868dc7ebf2cc4d0f85766b9cb2ec89ec69a7a09507fR33) Yes. I think it should be mentioned and as it's in the same form (right?) it should be pretty visible to the user. It's also later logging if it can't find a holiday listed so I think that's probably enough what we can do. Hi arkid15r Do you want to pursue this? Otherwise I suggest you might close this one and I'll make a new one. I think this one is a bit too far behind to make good with rebasing to catch up. Thanks Please take it over if you can. I guess you're more familiar w all the HA context quirks. The PH part changes have been included in this PR so it shouldn't be a problem to reuse them. At this moment I'm unable to get this PR to a meaningful conclusion. Thank you, gjohansson-ST Langauge is not an integration option; it is a Home Assistant configuration. Integrations should use the English language and use Home Assistant translations in case they want to provide translations. .. Frenck It's which language you would configure named holidays in (so has nothing to do how it's presented to the user). So for myself do I want to remove christmas as holiday by writing Christmas Eve or Julafton (or any other language supported by the country).
Why is this str:ing at all? You are right, it is not in all cases. Should this be called force polling ? Another option would be to disable push and have them uncheck a box for Push updates Or enable push which defaults to True if not defined in the options and have them uncheck a box for Push updates If have implemented an enable push option that is enabled by default and can be turned off. Should we tell them in the description that if updates are unreliable, they can disable push updates by doing XXXX? If have implemented an enable push option that is enabled by default and can be turned off. I added comment to indicate that IMAP-Push can be turned off if updates are unreliable. Should this default to True like it does in the main path? Thnx, yes, of course
stale doc string stale docstring Why set to None at startup? I thought this was undefined with fallback to method in base class like many other attr properties. Then it needs to be defined at init. I will check base class a bit later though. Why does this get set to None when its added? See other Please use our common unit time enum for the units. L592 Will fix in followup. Not sure how i missed that. Fixed in
Nothing was changed on this one? :smile: Thank you for double-checking I wanted to add that this is integration-specific. But then I realized that this is better placed in the line below. Forgot to remove the comment.


Maybe I overdid it a bit here. Nah I think that is fine
You cannot send data when confirming a subscription. This is wrong. send message can only be used with either result or error messages, and cannot be used when in a subscription (like this command). All messages need to be send using send event Let's change the domain to wake word Let's merge this into async pipeline from audio stream by adding option to specify a start stage and set it to PipelineStage.WAKE WORD . We can then re-use all the different features: - we get a websocket API - we have event callbacks This will not be necessary if we expose this via the Assist pipeline run WS command. I would suggest we allow passing in start stage , like we do for the other APIs. You can raise WakeWordDetectionError here too . Should this event include the audio metadata like STT-start ? And if we only allow a single metadata type, do we check that in validate? I've included a hard-coded metadata like stt but without the language field. I don't think we need to validate at this point because wake stt share the same audio stream, and stt will convert to the right format. Is this necessary? If it s not detected we will timeout and sent an error event. Any reason we want wake output to wrap the output? Just to match the others: stt output , etc. Right, but isn't the difference here that the output is not generated by the stt integration but instead, you're creating this dict just above it ? I would expect something like "wake output": asdict(result) We should allow the caller to pass in a timeout so we stop detecting a wake word if nothing comes in for X seconds. Added a timeout to the wake word stage input Should this be wake word too ? Same. Why is this necessary for the client to pass in? Should VAD be an option or will we always VAD ? Remove to do comment in code. Equivalent to Not quite: bool(-1) True Can t we just call it done. Commented code Is this start or end of the wake word ? Or do we just assume that the chunk is just that wake word ? This is the chunk after the current wake word chunk. Is that one considered lost now?
My impression is that only entity services registered via component.async register entity service to change, and not services registered through hass.services.async register . That is, the entity services can be targeted with a target that matches more than one entity todat, but the other type cannot. I think that OPTIONAL LEGACY may not be needed. replaced by component.async register legacy entity service Naming here is arbitrary I realize, so this is just an opinion. In the future the all here may not be obvious so i'm tempted to either pick another verb other than list or maybe event just calendar.events ? Same below for weather forecast... weather.forecast ? I think we should (1) move this into the service that is being deprecated and (2) add this only when we have the replacement service ready Will add it in a follow up PR for calendar and weather Does is work for this type to remain unchanged? (if EntityServiceResponse is a subset if ServiceResponse ). I know the type is different below for the entity service call itself, but wondering if this works without this change or if its flagged still by type check. mypy complains without this change Thanks, resolving. Have to revert that change. I have to check if result is not None before using popitem Whats the typing problem here? It can't match the type of the response data index? It complains that respone data might be None which does not support indexing Alternative would be assert response data is not None Maybe the None should be removed from EntityServiceResponse type? entity service call returns EntityServiceResponse None so maybe its simplier to propagate None explicitly anywhere its needed.... Yep that works Maybe include the entity data in the response just to ensure each response is associated is not getting jumbled across entities? e.g. f"response-value-{target.entity id}" Done I don't think we should include optional in EntityServiceResponse . That's confusing when reading the code where this is used. It's better to be explicit in every place about when something is optional. Please break long comments or strings around max 88 characters per line. Please limit docstring lines to 72 characters. The first line should be a header and single sentence and then an optional body. I was hesitant about adding this method instead of making the two integrations handle it, but I guess it's good as it's used in two places.
Should it use vol.All(ensure list, [CONDITION SCHEMA]) ? The schema must be empty because there is no options for this selector.
tiny tweak

This needs to change.... So, the device itself has no actuator ? It cant be turned on but it sends an event only when pressed held down etc ? Well, it is additionally an actuator (Dimmable Light), but the Generic Switch part of it is an input device, where you can add rocker switches. Ah yes, that makes a lot of sense. So this device would be translated into a device composed of a light entity and something (that new entity type) that listens for the device events. Because the required attribute is CurrentPosition and the deviceclass explictly set, you may drop these Done
What is the unit of this? There is no good unit, for my cam the value is from 0 to 4 with 0 a terrible connection and 4 a perfect connection (corresponding to the amount of wifi bars shown in the reolink app). But from what i understand of the API docs, there schould also be cams that report 0-255 as wifi signal. This is just directly the integer returned by the API. Use translation key instead of name done Why not set this directly on the ReolinkHostSensorEntity as you do with EventConnectionSensorEntity Because EventConnectionSensorEntity is a weird one that does not get its state directly form the API but from the host class living inside the HomeAssistant code. All other reolink entities get there state from the API directly and are defined in this way. If I want to add aditional sensors I just need to add the entity description to the list of HOST SENSORS and done. So this is for future proofing. See for example the switch platform of Reolink: L55-L201 Sure. My comment was more based that it looked like a one-off but let's keep it as is. If you return "keys" instead and use the ENUM device class with set options these can be translated done This should probably not be a sensor but just part of diagnostics. We don't allow calculating state in entities. These values don't come directly from the api but are just how Home Assistant interfaces with the api. opened to remove it.
How do we know that there is no overlap between the response value keys and the slots keys? I just thought that overlaps are rare, and there is always the easy workaround of "restructuring" the response from within the action. Eg if there is a slot named events you can easily write. So the common case is simple, and the rare case is still doable with a small workaround. Another approach would be to introduce another response variable at the level of intent script : Maybe this is more consistent, but the double response variable is cumbersome. We've discussed this PR in the core team. We suggest we hardcode a response variable. I suggest naming it response result . Ok. Maybe action response is better to make it clear that it comes from the action ? Done, let me know if you need anything else.
Please create a function for it, where you pass the source list and the list to append into. So the function can also be called for calc remove holidays . Same here. These are not the same as was the case in binary sensor Sorry, I should be more exact. I was thinking about something like: And than call it like this It can be simplified. Just saw it now :)
Should you set attr name None since it previously set name to the device name? Other devices (like sensor) overwrote the name attribute, so if I set it None here, I would expect some issues down the line Do we not have these already somewhere else ? 3 other places right now ( gid 1068986889) I'm not sure if it's a good idea to hard code the children names instead of using the device provided ones, any specific reason for doing that? These are not used anymore (besides maybe the led?), right? I'll link an issue where there was a decision made on translations looking like "xxx 1". But even tho renaming devices work, automatic translations would still be a lot better imo I agree to disagree given the fact that people provision these devices using the app while also giving them rememberable names. Requiring them to perform renaming once again (and again, in case they need to start again with a clean installation) only for homeassistant would greatly hinder the initial UX, especially for people who may have dozens of devices. Also, wouldn't this also be a breaking change, if (I'm not sure if that's the case though) these translated names would override the existing friendly names currently read from the device? Entity ids should stay the same, but it's a small consolation if all your devices would suddenly need to be renamed manually. So wait, let me try to understand. It is possible to set the device alias via their app? Yes, of course, see (starting from 2min or so) for an idea how it looks like in the app. Aaaah, that makes sense. I thought the names were always Plug1, Plug2, Plug3 like in the testdata, so I was confused since I really dislike that kind of naming
Only the first word should have capital first letter unless it's related to a brand or something else. So you're suggestion is incorrect. This is intentionally improperly cased because for this integration (in HA 2022.10 and earlier), the unique ids were based upon improperly cased sensor names (e.g. VIN Avg Fuel Consumption ). This code is testing that the integration properly migrates from the bad style to new style that uses the API JSON key constant ( VIN AVG FUEL CONSUMPTION ). In order to test that, we need to intentionally create one with the (old) bad style. EDIT: looking back at how I wrote the migration, casing doesn't matter for the old unique id since the migration converts everything to upper case due to the inconsistency of the previous versions. So casing here doesn't matter for test functionality purposes, but I would still assert that my suggestion is correctly improper since it reflects what the casing was in HA 2022.10. Please also make the same change to the next test case test sensor migrate unique ids duplicate I also must say, I don't like this change how I did this, since this is only working since every translation is the same as it's key ("rear left" - "rear left"), if your key would now differ from the key ("rl" - "rear left" - "rear left") it would break I think
If you want to do this, the name needs to be set after discovery in init .py async setup entry How do you mean exactly? The line adding the name to the device says entry.data.get(CONF NAME), Only found from discovery so that indicates that the name can be None. So wouldn't that make entry.data[CONF NAME] breaking? The block is guarded with if entry.unique id so the name won't be none if the unique id is set But when unique id is none, there is no device so the naming would be messed up right? Sorry it took me so long to get back to this. I think its fine either way since the if entry.unique id will prevent it from being a problem
I think this test should be in test init.py, not test sensor.py We can move this in a follow-up, together with other tests of shared functionality. I agree this is not the best of names. Would action response be better?

I think we should document the response data e.g. service-calendarlist events Most definitely! I will open the according documentation PR. I just wanted to get early feedback whether this approach is feasible at all. As implemented, this looks like it should be an entity service entity-services -- however I think to make that work, we may need to update it's registration method to support this if that is the right direction to go, like I had to do for calendar list events for the entity component. I tried to implement it with an entity service until I realized it does not support response values. In the long run I want this service to live in a "base" component just like you mentioned for calendar list events. The new base component could be travel time . I saw that calendar uses component.async register entity service like other components. Is this a way which is also allowed for "downstream" components like waze , google , here or restricted to base components like light , calendar , button ,etc. ? Glad to see another service with return values! I have some broader questions that come to mind. Not that we need to handle all of this in this PR, but can we talk a little bit about what future additional features you had in mind? For example, would we ever want to support service calls to return arbitrary routes between arbitrary origins destinations in the future? If so then i could imagine a different service call (not an "update") but i'm not sure what the API would look like -- e.g. config entry as input instead of an entity. Anyway, just curious if you had thoughts about the future direction I generally don't want to increase the scope here too much, but this is really making me want to keep thinking about better common APIs across some of the routing and travel time integrations ... e.g. a common device class or some service that can work across Waze, Maps, and Here. (but also on the input side, defining device classes for input location values) I see separate threads here: 1. We do see so many common elements that a travel time platform makes sense now. I can provide standard properties like duration , distance and standard services like update travel time and get travel time where the latter could provide information on arbitrary origin destination arguments like you mentioned. 2. This brings up the question where this service should live. It shouldn't need a configured route between A- B just so I have the service available while it certainly does need a valid config entry so it can use credentials for here travel time and google travel time . 3. The next point is that we can introduce a LocationEntity . It is a entity which can be used by travel time integrations as a origin destination. For now zone , device tracker , person have coordinate attributes but also sensor entities can hold coordinates as a state. Follow up questions would be if those LocationEntities should appear on maps.
This validator is also used for backend checks (e.g. configuration flows), while this homeassistant: feature is only supported by our frontend. I think, for that reason, we should not add it here. .. Frenck If so, how could i implement ingress URLs in mqtt config urls then ? Should i create a dedicated cv.url or homeassistant prefix validator for ? Made the validator specific. We could also consider making a new generic validator. If so, how could i implement ingress URLs in mqtt config urls then ? Should i create a dedicated cv.url or homeassistant prefix validator for 96100 ? This needs to be added to Zigbee2MQTT, I'll contact Koenkk for this. I already did an MR which got reverted because of HA rejecting it: Just reopened it We had actually issues on it (using relative URL's), but it seems it can be readded using the homeassistant schema. I have informed Koenkk . Feel free to reopen a PR for Zigbee2MQTT. Why is this changed? Was caused by a previous commit and some black magic Should this be named CONFIGURATION URL PROTOCOL SCHEMA LIST to match the name of the validator?
This is not needed, make urls like: homeassistant: config general or homeassistant: hassio ingress addon slug This is supported by the frontend and the way our internal integrations also work. We should not accept any relative URL here (we don't allow it on the backend either, so no reason to accept it from MQTT). Thanks i did not find the information about the homeassistant: prefix. I removed my modifications and added the following to tests components mqtt test init.py; tests do fail, is it expected that this prefix is not expanded in tests ? I think you might need this:
Looks like this is actually the serial of the gateway and not of the device. So a gateway could provide multiple devices and the serial of device is not exposed. L72-L73 This will get us in trouble once we update to PyViCare 2.28.x where the gateways will be exposed. Maybe we should get the right serial here, instead of the gateways one. img width "1040" alt "Bildschirmfoto 2023-10-13 um 23 25 19" src "" Does Vicare support a name or something better as the serial for naming? Before this change, the entity was for example ViCare Circulation pump active After it would be TEST-123456789 Circulation pump active which is not really userfriendly. In the App it looks like this: ![image]( I have registered both comm modules to one site. The site has a name I could choose on setup I think. The device (heater) has a predefined name (Kessel) which is not changeable. No idea how this is reflected in the api. I'm not familiar with ViCare but how many devices has a user usually? If the most only have one device, I would suggest to add the serial only if two or more devices are returned by the api Good idea. For most users, they probably have only one device. We're adding a lot of logic now to make sure the user knows which device it is, only when someone has more devices. What do you think about making the device name to model last or first 4 chars of the serial . Since youre moving the integration to has entity name True , users can rename the device and all sensors all at once. So if we name the device like this by default. What do you think about this solution? (Also note, since you are not changing unique ids in both device and entities, this isn't a breaking change. This will only affect new users setting up the integration) This was my initial and preferred approach, changed it due to discussion r1342419794. Not sure if you read the Discord thread, but we had a discussion, also with Frenck and we agreed on not changing the device name to add a serial number. To be able to distinguish which device is which, we made an architectural proposal to be able to add a serial number to device info. You can read more on that here ( extracted type fixes to 101926 Just checked the lib, can we maybe make the code nice with these types? Why is it required to use an alias here? It's just for better readability, all other classes from PyViCare are prefixed with PyViCare . Same here Instead of creating the device in each platform, we could store it in hass.data[DOMAIN][config entry.entry id] Please adopt all platforms Of what type will DEVICE CONFIG LIST be? It will be a tuple of both values This uses the device type provided in the configuration. In my setup it's fine as I have two devices of the same type (gas boilers). Others could have issues when multiple devices of different types are present and the type cannot be determined via type auto by the library. Can we go with this as a limitation or is there a better way to configure the device type? Maybe this is accept
Would it make sense to translate the states as well? We translate the good bad poor ones Ah ok, didn't know :) I mean it's in the strings.json with this PR :) Yea, indeed Those as well Those as well The downside here is that the names of fields in the translation file must be lowercase, so I can't add these. They also come directly from the API lib, so I can't really change it myself Those as well This is breaking, we cannot avoid that, but we need to document it and mark the PR as such. We should not slugify for values. Instead a mapping needs to be made and looked up. Would it be safer to use get() here? Marked the PR as draft for now Oh did not see this comment. Will check it later today!
frenck Can you verify that removing device class also works for update entities? I am not 100 sure. That doesn't work for them.
We don't allow device or service integrating integrations to use other entities than their own entities. That kind of interface is reserved for integrations that should consume other entities, like template integrations and similar integrations. I'll ask for a second opinion. Oh, that's new to me. Back when I first implemented this feature (had to split up the changes because it was too much) it seemed to fine. Thanks for asking around Hey MartinHjelmare, since it's been a while, I wanted to ask if you had the time to check on this matter The conclusion is that the approach in this PR is OK, we will allow integrations to use entities from other integrations which have a location, e.g. zone and device tracker entities can be used in other integrations. Thank you! I'll look over everything as soon as I get the time To make the code easier to understand for others, please rename from gps tracker to something with device tracker (what the variable holds) or something with dynamic region (what the variable enables). Updated in commit bf2fcac066a86cb32b4ae886884109a0549a42c2 This is not very helpful to the user, could you create an issue registry issue instead explaining to the user what went wrong and how they can fix it? I think the user should be given the option to change the device tracker via an option flow, or a reconfigure step as added by this PR: I'd like to do this in a follow up PR together with other potentially useful repair issues. The linked PR is not merged yet so a repair flow where the user can select a different device tracker would be a good solution I guess? But I have yet to work with those hence the follow up PR This is not a good source of unique id, how about using the entity registry ID if the device tracker is in the entity registry instead? Is this the ID you suggested? (not really familiar with the entity registry sorry) This is the entity id of the tracker, should we use the entity registry ID instead, which never changes, so this keeps working even if the user changes the name and entity id of the device tracker? The data I get from the user is only the entity ID as far as I know. Can you give me pointers how I'd go about replacing the entity ID? I'm working on switching the unique id to use the entity registry ID which is your comment above. Do you mean that part? Apart from that, I need the entity ID for the get position data util function, where I read the attributes of the entity Raise a custom exception instead for all the cases that return None here. These cases are not expected and the function caller needs to handle that. What's the preferred way to handle the exceptions in a coordinator? For the config flow I'd guess an error for the respective exceptions is good but I'm not sure for the coordinator. Currently, it would set the position to None which would still instantiate the API but it would probably become unavailable Don't log in the util. Let the caller handle that as needed. Why do we make changes to this
Please exclude specific files, and not all. This file doesn't seem to belong here, please remove it. Tests for the config flow are missing. We require 100 test coverage for configuration flows. It seems like you manually wrote this? Please use our script.gen requirements all to update generated files like this one. I could not find the public repository providing this package. Could you point us to it? May I ask if it is the Github address or Pypi? Repository... GitHub. thanks I personally think this is clearer but that's just my opinion in .const and then this line: Adding guards instead of nested if statements This will reset the domain data every time a new device is added This will only run once, and the addition of new devices will be automatically discovered here ?: def poll discovered device( args, kwargs): discovered devices refoss coordinator.data known devices refoss coordinator.find devices() if check new discovered device(known devices, discovered devices.values()): hass.create task( refoss coordinator.async device discovery( cached http device list discovered devices.values() ) ) refoss coordinator.async add listener( poll discovered device) As soon as you add another config entry it will run again and the second one will overwrite the data for the first one When adding again, In config flow.py, if entry exists, execute function: abort if unique id configured(), Just quit. hass is a singleton. Every hass.data is the same. When you add the second device it will set override the previous data when an empty dict Ideally domain data is a dataclass Example in lookin models.py Ideally this is asyncio instead. We generally don't want to start new threads as this is a legacy design which doesn't scale well when a user has many devices. aioshelly might be a good lib to look at on how to do this This is still overwriting data Store it as hass.data[DOMAIN][entry.entry id] so each entry has its own dict. But its better to use a dataclass instead Use the helper from the scaffolding instead max debug level here This looks like you could use lru cache instead Use the Enums here resolved
We should not pass our internal constants to external devices. If our constants would change, this would break :) To be more consistent with other part of the code in Daikin:
You can reference the levels from earlier I think this is one that's in the weather translations I think the standard is Wind gust (which is also in the weather translations Or does this value target previous night or next night? It's a forecast, so it's about the night that will come. I think tonight is more appropriate.
This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository. changing-the-entity-model MartinHjelmare thanks! I will bring this up in there. Not needed - deprecated Line removed Not needed - deprecated Line removed hydrogen 97096
Need to check if object id can contain '-' and if we need to convert to . Or it there are any other problem chars or if the entity code will do this for us. Can add some tests for this must start with a letter and can end with numbers. must not have a space in the name. can not have special characters except the underscore ( ). must not be a keyword.
Incidentally, I'm adding support for pH sensors and numbers in You might be interested in that too. Yes and no, your proposal is afaik only for sensor and numbers, whilst this sensor is just an On Off switch if the pH status is good. Gotcha. My Poolstation integration does show the exact value, which I why I'm adding it as a device class. Then that would be a sensor in sensor.py, not in this file
I moved this fixture as it can be used for more tests than the lock tests. I had to patch this to make sure the event callback is for the binary sensor entity as the lock fixture creates more than one entity otherwise. I would replace the current contact-sensor with this one and adjust the tests as our fixtures are devicetype bound, otherwise we might get some confusion at some point. The Eve dump should result in the contact door sensor and the battery sensor.
You shouldn't name your entities, but follow this guide: entity-naming Misunderstood the difference between device name and and entity name. Thanks for the tip. Changed, but still added explicit name, as this device is not really HVAC nor a Climate control device. Explicitly use device name as entity name ( entity-naming): Make the manufacturer a constant in const.py Perhaps consider using a [data update coordinator]( coordinated-single-api-poll-for-data-for-all-entities) in case you want to add other platforms. I do not plan to do it in this PR, as to not grow it too big with different sensors. Rn i will keep it to a single climate entity. I assume in this case this can be left for the future one? I think that's fine then. Please keep this sorted Move this into the integration setup, so it can raise when it fails. A user can recover from these errors, please complete the config flow until entry creation. This is to ensure the errors have no side-effects. Please parameterize the test instead. Use CONF HOST , CONF PASSWORD , CONF USERNAME from homeassistant.const instead. This one is only used once, maybe just add it in place and remove the constant instead? is there anti-pattern to do with it? I'd much rather not have magic variables like this in random places and keep them all together? Happy to change if that's the standard here We are not using the device name here discussion r1254879625 the previous request for change asked to add this. Who has the priority? frenck comment has priority. Didn't know myself, that attr name is needed here. I'm so sorry. So it is a fan...? It is a ventilation unit. So the closest hvac mode i could find is a fan. HASS (from my testing) currently doesnt support not setting and HVAC mode on climate entity, it's not supported by the code and breaks the FE controls It is a ventilation unit. So the closest hvac mode i could find is a fan. HASS (from my testing) currently doesnt support not setting and HVAC mode on climate entity, it's not supported by the code and breaks the FE controls It has a default, so it is optional and not required? Wouldn't it still be required? You can't complete a setup without it, and even though it has a default, a user can delete the text from the textbox? The string conversion is not needed? For type safety, user input has a signature of dict[str, Any] A host cannot be a unique ID, as it can change.
We should not use DOMAIN and DEFAULT NAME as part of unique id . f"{router.unique id} {description.key}" is OK. We need to change router unique id property: and import TYPE CHECKING from typing . It is possible that router unique id is None because config flow allow creation of a single instance for Router that do not provide a mac address. For this reason we use 'DEFAULT NAME'. Of course I can remove DOMAIN from here and in the migration procedure. Maybe I could use entry id for entity unique id ? Sorry, my mistake, I thought router.unique id is entry id now, not enough coffee. Of course we can use entry id as router.unique id . Or we can use something like this: This should be ok now and migration to new unique id for existing entities is implemented. Can we standardize the style of the new IDs? I mean getting rid of the sensor prefix and slugify remaining e.g. 2.4GHz. I was waiting for this request . The problem is that this is mapping what is returned from the library, but I think we should slugify at bridge level and so have the key properly formatted. I will try later how to do this. So maybe it's easiest to just slugify description.key in the sensor module? Or even slugify the entire unique id : This is done. Are Load Avg sensors not available for AsusWrtHttpBridge? Entity unique IDs are migrated but entities remain unavailable. ![obraz]( Yes, AsusWrtHttpBridge provide CPU usage instead of Load Avg. Because are not provided by integration, user should be able to manually delete using UI. I don't think we should do this automatically, what do you think? Then we definitely need to remove them from the registry if the integration uses the http https protocol. Ok, I will manage this as migration action... Done. This will bring up a blank dialog with the Submit button. I think here we should ask the user for the password (I'm not sure about the username). Please take a look [here]( L311) for example. My error, I misunderstand the explanation in documentation. I review the logic now: it will try to authenticate with new password using only http and https, if this fails it restore back original configuration (for old router that do not support http). The failure to migrate to http result in a different abort message What's the reason it's a dict and not a list? Was just for label translation. Replaced the dict with a list and used a selector in the schema with translation key This value will not change over time, so we should not implement such a sensor. You mean sensor memory total ? It should be fully removed or just represented as sensor without state class ? Yes, I mean memory total. If I remember correctly it is not allowed to create entities with static values. Yes, make sense. Removed sensor implementation. I know it's not part of this change, but... we shouldn't create state attributes with static values. Do you think we could remove it? That would be the next point for breaking changes section. Not really important, I forget about this a
I am not a huge fan of this cast, value as str followed by str(). This seems to do the same thing multiple times, can this not be simplified? Not sure about separating OVP and HLLR WIFI protocols in different entities because they seem quite similar. I would argue that they are both air-air climate entities with an Overkiz integration, and separating them as different entity types would unnecessarily expose the internal peculiarity (to not say complexity) of the protocol. I agree about the excess casts, which aren't the proper way of dealing with Optionals. I have a small refactor in commit 07cb23d to make explicit backfill and fallback of missing parameters. Why do you need to cast it here, if you check for if state below? Good catch, there is no need. Why do we need this? Hitachi has several air to air heat pump devices that use 2 protocol versions (OVP and HLLRWIFI) that have small differences in states mapping strings. Now hold on with the approval. I can only test 1 of the protocols (HLLRWIFI) with my device and we ( iMicknl) have found a tester for the other protocol (OVP) who is reporting a bug. We should fix it before merging. issuecomment-1667583322 I am resolving this conversation as I have isolated both protocols and will make a separate PR for OVP Please remove this sensor and add this in a new PR. ( use an enum for hlrrwifi:OutdoorTemperatureState ). No strong objections. Out of curiosity, this sensor being part of the added device and fully tested, is your recommendation because of the string constant which is added in the [pyoverkiz 3.11]( enums (thanks for that)? Mainly because one PR should target a single entity platform. To understand, when can this happen? And how will this exception be handled. Should we not just set a default target temperature? I do not think that this can happen. The device always has a temperature setpoint, it is available in the device's state and we fallback to the current state in case it is missing from the command. When the exception is raised, it is getting logged and a "toaster" notification appears in the UI (if the action was triggered from the UI). If we don't raise an exception and pass the command to the API with an undefined temperature, the behaviour will be the same but with a confusing Overkiz API error message instead. I do not feel comfortable silently choosing and setting a default temperature on behalf of the user when something goes wrong internally. There is no known scenario where this would happen, so I have removed this test and exception. Seems the code that this comment was describing is not present anymore. Have you tried if you can just pass the command data as a list? Should be supported as well and the preferred way of doing this. Yes I have tried. But the call fails if I pass the array directly. the globalControl command is expecting 5 partameters, and not 1 that is an array.
add "bluetooth" and "wifi" to .const as variables to avoid magic values I'm not sure to keep this controllable sources logic and don't want to cluter .const for now. You probably can remove it as it is no longer used Sure, will do, thanks for the reminder! add "media player" to .const Thanks, actually I think it's better to import it from homeassistant.components.media player.DOMAIN. Adding guards make the code flow clearer use "and" instead of " " unless you specifically want the bit-wise and operation same goes for line 201, 208, 222, 229 Thanks! Oh, this was intended. Is this method still necessary? Good catch, thanks!

We don't have to store the entry data, as the config entry is already available downstream. This should be moved out of the platform into the integration setup. What if this fails? Please implement SensorEntityDescription s instead. What would be the consequence of this error? This is not needed anymore since I can default the API to always return distances in KM and to my understanding HA will convert the units if necessary. What would be the consequence of this error? Is each sensor doing requests on its own? Shouldn't it just do a single request to get all sensors in a single go? Considering the number of sensors this integration provides, this seems like it will be doing an awful amount of requests. Requests to the same endpoint are cached in the API wrapper, so only a single HTTP per endpoint (a total of 3) requests are actually made. While each subsequent request will use the data from the previous request. So why not use an DataUpdateCoordinator instead of making each entity responsible for handling it on its own? Should i use one coordinator per endpoint or have a single coordinator and have it make all 3 requests? In the docs it says to use the coordinator if there is a single request, however since the records and usage endpoints only have 2 sensors each it may be excessive to make an entire coordinator class for each of them or is that preferable to a single larger coordinator that handles all 3 requests? I think it is fine to make three requests (if they can be updated at the same time). The field already describes that? The coordinator is the only thing stored, so no reading to add another dictionary. We don't need to update before add when using the coordinator. As the coordinator already has all data available. This is already typed Seems to be used. Does it throw an specific exception for authentication error? As in, can we know the difference between an connection issue and an authentication issue? If so, we can raise an auth error that will trigger a re-auth flow for the end-user.
This line didn't have coverage before the change, either. Please add in a test to increase coverage MatthewFlamm added test coverage
Sensors like these must use the timestamp device class and return a valid datetime object. Thanks for the Feedback, changed that. Please review the changes made. This is new sensor right? Do we still need to migrate? Why is this being changed if it's overwritten in the new sensor? I get that you might need to add datetime for implementing the GlancesTimestampSensor . Sorry, I don't get your point here, could you explain what you mean? GlancesSensor is the superclass of GlancesTimestampSensor and thus both methods need the same return type... OK, I think I just got what you mean... I added the additional isinstance check to make the code generally more resilient... Accessing value as a dict without making sure that it actually is a dict can lead to a crash Please remove the if statement as you expect the state to have the same value as A SENSOR DATA["uptime"] . Currently, the state is None as an exception is raised. Looking at it again I do not even see the point why the other sensor tests use that if clause. Should the unit test not fail when one of these values is None and thereby does not match the expected value? I am going to check it again, but I am pretty sure that the assert was working when I was debugging it the last time. Should the unit test not fail when one of these values is None and thereby does not match the expected value? We expect the test to fail, but the if statement prevents it from failing in this case. It is expected not to fail, but to match the given data... I understand that the if clause can prevent tests from failing when the data is None. I mean that there is no point for the other sensors preventing it from failing (by an exception). A cleaner solution would be to use assert state : hass.states.get("sensor.0 0 0 0 uptime") is not None before checking that the value matches the expected value. Please use the util function [ parse datetime ]( L183) instead. Please verify again what type you expect from the coordinator. In the code here, it looks like a string. In the test, however, you mock it to return a datetime. I had a quick look at parse datetime and it is looking great. Thanks for the hint, I will use it to generate the datetime. Concerning the types I think that it is right the way it is. The api is providing a string, but the actual sensor must return a datetime object as suggested by frenck. The test data depicts this behavior by the expected value being of type datetime and the mock data being of type string, such as a string received by the api. The mock is not returning a string but a datetime object. See my other comment. OK, I have to check it again when I have more time... I was looking at the constant MOCK DATA , but jsut after a quick look I don't see any references to this at all.. Thanks for the improvements for now, I am going to work on it later! This data is used for two things: - Mocking the data from the third-party library - Used as expected value for the tests As the GlancesTimestampSensor co
The auto mode doesn't support manual temperature control. The heat cool mode supports both low and high setpoints. In ha, are auto mode and heat cool mode the same? No. Auto mode means the user can't set the target temperature, while heat cool mode allows the user to set low and high target temperature setpoints. Both modes have some level of automatic control, but they are not the same. hvac-modes I couldn't find the set methods for low and high in the base class of climate L402 We use async set temperature to set those setpoints as well. Just look for the proper parameter names. Here's the service schema. L118-L130 Here we may need to wait for the write attribute of the matter server to be added to the dependency of HA before we can proceed, because the setpoint cannot be achieved through a command We actually added that yesterday based on your feedback so we could move on and add that in this beta too. So if I understand it correctly, some thermostats do support setting the hvac mode but you need to write the attribute yourself instead that there's is some ready made command within the cluster, right ? No. Auto mode means the user can't set the target temperature, while heat cool mode allows the user to set low and high target temperature setpoints. Both modes have some level of automatic control, but they are not the same. hvac-modes Yes, besides the system mode, when we need to adjust the low and high set points in the heat cool mode mentioned here, we also need to use write attribute to set them As soon as [this PR]( is merged, you can rebase your branch and you will have a "write attribute" available in the client. The Home Assistant auto mode means the user can't control the temperature. Does it have the same meaning in Matter? Yes, it has the same meaning Does this value never change for a device during its operation? maybe add it to the discovery schema's "optional attributes" anyways to be sure we receive state updates What is the meaning of running mode compared to running state? Does it really mean the same thing? the specs are very unclear and interpretable on multiple ways. Most likely the ThermostatRunningState is comparable to what we call hvac action Yes, I haven't had the chance to fully understand this part yet I figured it out, as marcelveldt said, ThermostatRunningState is similar to hvac action. ThermostatRunningMode is used to indicate whether the thermostat is in cool mode or heat mode when the SystemMode is set to Auto. However, when you are in this mode, you may not necessarily be cooling or heating, just like when your SystemMode is set to cool or heat mode However, in the matter spec, ThermostatRunningState is an optional attribute... In ha, is hvac action mandatory or still optional? I see the default value is None optional Can we update current temperature and target temperature in update from device instead? Ie use attr current temperature etc. I've put the logic in here instead of the " update from device" to prev
This won't work and will translate True and False to string. You just want to actually match against the types. The FKB API is weird, it has separate functions for setting a config value depending on if its (what they determine to be) a string or a bool value, but it expects "true" and "false" as strings for bool values Why a service and not config entities ? It would be hundreds of entities really... There's over 300 settings (per device) that could be changed with this service Okay a service please . This approach will make it impossible to render a proper UI for this service. This is not a boolean. If you are going to go with a config type to determine the type of ATTR VALUE , you need to use cv.key value schemas Will this automatically convert booleans to true false while also accepting those as strings? Python lib should accept both The device id should be a list of strings, not any list.
Why isn't config a part of hass.data[DOMAIN] ? Tbh I don't remember. I can probably refactor that so it lives in the KNXModule class in a Followup PR (this is used like that in every platform). these 2 if-statements can be merged Stale docstring Support for restoring the native value of a TimeEntity could be added to the time integration, similar to RestoreSensor which restores the native value of sensors.
even I've added some testes it is on exception list, beacuse I did not get it managed to test the async image itself Can we do SVG? I had it before, but with svg you got a problem with dark background color, because the "white" space between the black digits in the QR code is transparent ( will provide a screenshot today evening ) ok, let's keep it PNG. png svg --- --- ![image]( ![image]( qr code based on fake data uhhh ... nice Instead of adding device friendly name, use attr has entity name True and set name to just ssid . I don't think that adding "QR-Code" to the name is necessary, that's clear from the picture. we already have switches ( to turn on off the wifi ) which are named like f"{device friendly name} {ssid}" , so this might confuse the user? The switches are named "Wi-Fi {ssid}" ... will change the name of the image entity Please always put hass as the first parameter when present in a signature. That's our convention. will create a followup PR later this day 95437 This won't work, the async image method is only called when frontend requests the image, and frontend requests the image when self. attr image last updated is changed. This is explained in the introduction here: the docs seems to have changed since my last view will have a look into this later this day, thx 95470
May be you can add disks in stead of changing current test data? This ensures the current code is tested correctly. I did add the same level of tests as was already here for the disk sensors (i.e. not much). Should i create some test for both disks and raid arrays ? What kind of test would you suggest (any examples appreciated) ? I did not only change the test data (which i did for consistency reasons), i added the DATA STORAGE GET RAIDS test data specifically for this feature. Sorry, i re-read your comment; i would like to avoid crafting test data (i.e. guess how the router should look like if it had both the initial configuration and the new one). Maybe i should just create a dedicated const-raid.py module ? Also, for the record there are no tests on the current data. Isn't this as binary sensor ? We should not add a BinarySensorEntity to the sensor platform. Add this to binary sensor.py . Can you revert this formatting change? Can you add type annotations? Is the docstr correct? No, and the module name neither, i think i messed up my commits at some point, i'll fix this The module name should be test binary sensor.py , because you only added tests for this module. We can always add tests for other modules in a follow up PR. The device name is now part of the entity ID The entity name could be shortened I suggest to remove parts of the prefix as we have set attr has entity name True For example: self. attr name f"Raid array {raid['id']} {description.name}" This part is not tested yet, that is why the CI tests fail Possibly you need to call await hass.async block till done() in your test Since you added the degraded state simulation, it seems to fire this callback now and coverage is now 100 exactly Awesome, thanks ! I really didn't know how to do this, now i do ;) Please lowercase variable names for local variables.
Please don't add comments, do a self-review instead where you add questions or remarks Alright, removing that. It's an open question based on an earlier PR thread relating event firing: issuecomment-1594720799, where bdraco mentions the cost of firing events rather than using specifically registered callbacks. I'm comparing the issue registry here to persistent notifications that use callback registration instead of these event firings and it seems to be something the issues component should use as well. Though admittedly that should be a separate PR. Issues are expected to be much more rare so firing an event shouldn't be a problem. It might only become a problem if they update from a 3 year old install but than it's only a problem once and not really a big deal This seems pointless Often only functions should be used on objects to get data from them rather than just grabbing into the internal data members. Hence the function (That is used by the template {{ issues() }} ). I don't agree, if we don't want the issues attribute to be accessed it should be renamed to issues some getter added, but that's beside the point of this PR. How is this useful as a filter? Unsure what you mean, but this format is kept in line with the others, e.g. areas and area id . adding this to filters means the issues function can be called by using Jinja's [filter syntax]( filters), I don't see how this is useful for the issues function, and I don't think it's useful for areas either. Ah, got it. Thanks for clarifying I think we should remove this
Can you please define all values statically here? A dependency dump can introduce new values and it easily can happen that it will be forgotten to update the translations too. Same also for MIDNIGHT MODES , SCHOOLS and CALC METHODS Will the default value for the new three values change the behavior of existing users? These defaults are the same as what defined in the API docs: So it won't affect the existing users.
This is too much protocol details. Those should be kept in the 3re party library. I'm not sure that the 3rd party library is the right place for this. There's nothing about this that is specific to FKB. Most (if not all) of the FKB integration users would use this to be able to change HA dashboards on a kiosk without reloading the HA UI. So this isn't a FKB issue per se. Do you have an opinion on this cgarwood ? I agree with Martin on this. This is not something we should add should accept in Home Assistant itself. .. Frenck
consider putting these in .const Good call, updated I dont think you need to catch the AbortFlow, hass will take care of that for you why is the sleep here? IsakNyberg It's not ideal, but the reason is that the thermostats are very flaky, and too many socket requests in a short period of time can completely overload it and cause it to need a restart. Because I need to establish the connection to validate it during the config flow and then immediately let it disconnect, and then reconnect again right after when the integration is setup, I am concerned about overloading it. So, I added a sleep here to avoid that case. If you have any other suggestions, open to changing it! Is it possible to recreate the socket on the client side only? In that case you would not need to close it in the config flow (provided that it was successful). If so you can put all the necessary information in the config entry, and then you recreate client side it in the integration setup. IsakNyberg Good thinking. I updated it to use the coordinator instead of the client directly, and then stored the coordinator in the hass data so that it can be picked up in the component init instead of recreating the client. Validation can be removed here as it is already done in the config flow Why would the coordinator already exist? This is the setup, it doesn't The hostname is not allowed to be used for a unique id. Please see the [unique id requirements]( unique-id-requirements). Please remove the try except block, as there is no reason to use it. Why do we add extra features? I think this might cause issues if there are more added to the climate entity features New integrations should use has entity name . More info can be found in de dev docs, don't have the link on me right now I think we only use this for precision, not for temperature steps If you want to define the logger in const. Otherwise, use logging.getLogger( name ) . I still need to see what the coordinator does, but I don't prefer to call the coordinator in the config flow It would be better to specify the exact data type or create a data class. Oh nvm you already have this. In that case, please change the thermostat name to a translation key. Please rethink if you want to use the DataUpdateCoordinator as currently you don't implement the required functions and write all the logic in custom functions. This is the valid function definition. No additional arguments are passed, so you can't extract the logger from it. Why should the device stored here again? You are already setting device info The coordinator is already assigned in the parent class.
This change isn't related to this PR and should therefore not be in this PR. .. Frenck aargh... sorry, will review again, thought to have been clean this time
Does this count down update the value during runtime? E.g., does this actually lower the value each update causing it to count down in the UI? Yes, it's updated That isn't allowed for a numeric sensor. It can provide a setting, but not an active countdown. Sorry frenck but I don't understand the issue or in what way you want me to adjust this. This is already being used in other device integrations like the [fan]( L233C16-L233C16), [Air Purifier]( L299). What is wrong with this one? You can see the counter on my last post It is allowed to update, but it isn't allowed to be used as a countdown. This needs to be removed, otherwise it cannot be accepted. Ok I will remove this Why change the format from the native values? I basically set it in the same way as it's shown in the SmartApp UI from Tuya. I also thing it's more using friendly then having to calculate hours to days. I basically set it in the same way as it's shown in the SmartApp UI from Tuya. That is not correct to do. The UI from Tuya can be customized for each manufacturer for each device type they have (which are over hundreds of thousands of devices). Please use the specification provided instead. Fixed Hmm, in most cases, this is not a read-only value, thus this shouldn't be a sensor? From when I have seen the WORK STATE just updated when the is switched on So, what is the added value to have this sensor in this case? I'm confused? From that I have seen the WORK STATE can not be set, it's just an informational detail about it's current working mode: Idle, Active... (Have a look at the attached imgs) What do you want me to change? I don't see why this is added at all. The workstate is used to provide information for other entities, it shouldn't be a sensor on its own? The WORK STATE is just for this device, this indicates in what mode the device is : idle, auto, active this value if read only we can not set it. frenck Could you please clarify what exactly what you mean by "sensor on its own?" Just explain me how you want me to implement it and i'll do it. I have also removed "WORK STATE" as it's not clear or at least I don't understand what is the actual implementation requirements Can't we give this switch a translated name, preferable better than "Switch"? What do you suggest? Value? Remove name and add a translation key that matches the "Switch" value. E.g., translation key "switch" . Done Move name into the translations as well. Now its using the translation key Add a translation key, and move name into the translations file. Now its using the translation key
Not sure why this is added here? This is new, how can this possibly need a migration? Reverted this part. Please rebase the PR onto the latest dev and leverage the entity translations that is currently in the dev branch. Should it be named "Switch" in this case? Or just after the device name? IMHO the standard "switch" is ok in this case. I changed to translation key "switch" . But it is the only switch in the device right? Right. This device is an Air Conditioner companion. It is a socket with a power monitor and IR receiver transmitter. The device does not contain a relay. This single virtual switch is used to enable the Air Conditioner control. ok, clear, in that case we should remove the name and let it adopt the device name. Let's disable these by default. For example, voltage isn't really a thing one is looking for on their auto-generated dashboards to look at every day. Maybe even consider marking them secondary by adding an entity category.
As you now have a default no need to use .get as it always has a value. Also this change does not consider the scenario when you go from a device class to "None" to clean it off. It would just always keep the previous device class Could probably be worth to make a small function to check this as you have the same "issue" in both config and options flow Also this change does not consider the scenario when you go from a device class to "None" to clean it off. It would just always keep the previous device class This cleaning already happens, the options dictionary is redefined at each manipulation, so the current logic does not include the previous value. Should add a test to cover the new scenarios - Setup with "None" as device class and state class - Change to a device class and state class - Change back to "None" Added at Please make this it's own test in test sensor.py Thanks Added in I had included it in test config flow.py because in test sensor.py I can't validate if the configuration option manipulations are reaching the final result in the sensor (unless I reproduce the same test test device state class in test sensor.py ).
A brand is only created if there are more integrations under 1 company brand. For example Google has everything from Google Agenda to YouTube and Philips has Philips hue and Philips TV. So this integration is not a brand. I understand. So this json file can simply be removed? Yes Still not removed btw Please add the Options flow in a follow up PR to make this PR smaller and easier to review Done, options flow was removed Not sure if this helps, but this should be an url validation so please test it out I can't get this to work. cv.url fails: Looks like Voluptuous does not recognise this function in order to serialise it. So I tried vol.Url . This does not fail but the form does not show a text field where to input the url. I've tried many different variations and I'm stuck. Do you have any examples of this working? Haha I don't, this was purely theoretical. You can keep it as str Anyway, invalid URL's are caught up on line 60 and a proper error is shown. Please only capitalize the first letter of a translation key (unless a company name) Hmm, the tests should also be added to your name. I think hassfest might be having a bad day with it (I also saw another case of this recently, so maybe its something we have to fix in hassfest) ConfigEntryAuthFailed should only be raised when the integration has a reauth flow and you dont have one yet. So please raise ConfigEntryError instead Would it maybe work if you did: This way you don't have to manually acquire and release locks. (and if you dislike the extra indent, you could move this function to async handle state change and call it like
Bind hass is legacy and we don t use it for new calls done The general advice with python is to try to avoid designs that call functions in a loop if you don t have to or need them to be performant. I don t think that will be a problem here unless we expect hundreds of notifications caveat emptor: this only matters in performance sensitive situations. I don t think we would be dismissing frequently but in this case we can probably avoid the whole loop which gives us a much cleaner design anyways I can make this totally independent. It's not an issue for me. I'll just replicate (to an extent) the pop logic from dismiss. We can avoid the whole loop by making a copy of the dict, clearing the notifications dict with .clear(), and dispatching the copy as a remove. Done Let s not mention frontend here since this api doesn t operate on the frontend. The frontend just happens to consume it Call the async api here Rather just delete this line That was leftover, just going to remove it. I know its obvious whats being copied, but its better to name it to show intent because it always gets refactored later
Adding a device class requires an architecture discussion approval. changing-the-entity-model I suggest removing this change from this PR to not block the PR. Ok, I can do that. Current flow (mainly amp-hours) are fairly commonly used in the boat RV space but probably not widely used elsewhere (in favor of power watts). The latest commit removes these changes to sensor const.py. Define the entity descriptions as constants in a container that we can look up instead. See eg the xiaomi ble integration. Done. In the new version I'm looking up these constants by device key.key because there are sometimes different keys that have identical device classes and units (for example, "AC Input Power" and "AC Output Power.") This module should not be in Home Assistant. Got it, I have it following the VictronBluetoothDeviceData class to the victron-ble dependency. This class should be defined in the 3rd party library for victrion ble.
This is not a setting, but a status, we don't care about functions or status ranges. We need to scale the value, as every DP in Tuya can be scaled differently by the manufacturers, it also can return floats, while we only work with ints, so we need to round. (PS: suggestion created in the GitHub WebUI, probably needs black)
Why do we need a content type, can we not derive this from the image download? The response should also hold the content type May catch a key error in case the content-type is missing? Lets resolve this in a follow-up PR
Please also add the follwoing import import homeassistant.helpers.config validation as cv Done Please add validation for the minimum value. Done New integrations need to add support for [translating name and attributes]( "temp" is not a user visible name, it is the actual parameter that must be used to set target temperature. I'm not sure if I understand your comment in this context. Please adapt your entity to support the [new naming format]( has entity name-true-mandatory-for-new-integrations), which is required for new integrations. All API specific code has to be part of a third party library hosted on PyPi. Home Assistant should only interact with objects and not make direct calls to the API. Please move the API code into a library. More information about it can be found [here]( 4-communication-with-devicesservices) Done Use for all static properties, class variable instead. e.g attr should poll True Please adopt the code to the suggestion above. Please return a DeviceInfo Please remove any empty keys. Please move this class to climate.py as it belongs there. The coordinator can be used my different entities in the future. I cannot place CCM15 into its own file, it will fail to load with: This is because you are referencing the climate entity in the coordinator (and the climate entity requires the coordinator). If I understand correctly you are doing this because the coordinator can discover new devices and add them on the go. Other integrations solve this by doing stuff with listeners, for example the hue integration: L53-L66 This way you don't have to bother the coordinator with creating entities, and you are not bothering entity platforms with how the data is created. This would be more extendable and easier to extend Please address this similar to the way commented by Joost Please remove it, as we no longer allow configuring the scan interval. Please set it to a fixed default value. If the user wants to change it, he can disable polling and call the service homeassistant.update entity , when an update should be requested. For consistency, please move hass in the first place. Use class variable instead Use class variables instead for constant values. Please also adopt it for target temperature step , fan modes , swing modes and supported features The name of the entity is a number? That's not user-friendly. Do you think we can use something else? The ccm15 module treats each AC unit as a zero-based index. So, there are really not good options in terms of naming that could provide anything useful to the end user other than the index. We should add a unique id by host and port and check if only one config flow entry exists for it Can you show me a sample that validates for multiple hosts? Can be set outside of the constructor Same. Also there is a constant for this, PRECISION WHOLE iirc
What if the one they want isn't the first one? Based on how the async dispatcher send is called, the notification is always added in a dictionary under the key of its notification id. I believe this dictionary will always consist of only one item. L215 When the websocket api connects it sends the current ones. Does the trigger need to know about the current ones when its connected? Did not take that usecase into account. After some changes It's now going to be just the one notification if only one exists in the dictionary, or a list of notifications if multiple exist. Also allowed multiple update type s to make it easier to only listen to added removed callbacks. I think it would make sense to iterate the list and trigger once per notification. That will allow the notification id matcher to work as expected I don't think you need to make a copy unless there is a risk of the data changing during iteration It would be a bit cleaner to reverse the conditions and return instead of having another level of indent I'm not sure what you mean with this. Should this be split up in two separate if statements like so? That works. Much easier to read Please use a named variable instead of a letter Why does this need an ignore? Pylint throws an error on the use of CONF NOTIFICATION ID from the notification. Even though it's not a variable used to access. fixed in ccb678bacd49d9ec85fb5caf9a7b4ff9978dd576 Use [] when we expect the value to be present r1233373849 r1233373849 You have blocking set above so this isn't needed
Heads up, this changed in the Image entity today. We need to store the content type? The content type only checked. Not sure we need to store it. Yes we have to store it, it is a property of the entity even. Just saw, that. I'll need to add an extra option for images that are received as raw data. Can we make this more readable, maybe: Instead of this, how about allowing configuring either a URL topic or a image data topic? Hmm, may be that is more straight through indeed. Any how we need an extra config topic. If this fails, should we set the image to None? As far as I know we do not update the state in case of an error in with other MQTT platforms. But may be could catch exceptions here and log a warning. I have updated the code to set the image to None Should we set the image to None before returning? I have updated the code to set the image to None Should we set the image to None if we fail? As far as I know we do not update the state in case of an error in with other MQTT platforms. Right, but this is a bit different, we fail loading a URL Good point Why do we add this here if it's MQTT that needs it, not image itself? What's the point of this? The timestamp is used for the image entity's state, it's not exposed as a state attribute. Is this validation really needed? We only want image content types, but if you think this is not needed, then I can remove it. validation was removed Limit the split to 1 This is not correct, the tag needs to be the same among the members of the Exclusive group. was a typo This message seems a bit unnatural, should it be: I'm not sure if topic from url topic is great, maybe something like image topic url topic would be better? If this is only supported to extract the URL, I think it should be url template instead
I am a bit lost here... How could I test this? We don't allow scan interval as option. Every integration that supports config entries allows the user to turn off automatic polling and then the user can automate the update interval as needed with the entity service homeassistant.update entity . Huh? I found exactly the same for quite a lot of other integrations...? Is this just old code? Sad I only knew after putting in that much effort :(. Nevermind, it is as it is, but how can I know this next time before I start implementing an issue? Yes that's legacy code. If you're unsure about something and it's not documented in our dev docs or architecture records it's best to ask in our discord server.
I'd move this down out of the try... except block. Side note: Should we raise HomeAssistantError here instead? Yeah, that's weird. I will make that change.

I don't think this should be added here as it would suggest all devices supports grouping, which isn't the really the case (old Apple TVs for instance). You need to add the features related to grouping to SUPPORT APPLE TV. You can just map all of them to GROUPING and the issue above will be solved. I'll explain my reasoning: Apple devices can be controllers, that actually play the media and send it to other devices. Other AirPlay devices can be players. Home Assistant has a few features gated behind this support flag, one of which is the group members attribute. A device that can be grouped needs to have this flag set so that it can expose that attribute. In async join players there is an extra check for FeatureName.AddOutputDevices to see if the device can be the group controller, that feature is set If there is an MRP connection (so not for AirPlay only devices). Now I don't have any device that doesn't work with grouping so I can't run any more checks. postlund do you know if feature support is device specific, or OS version specific? Also can these old Apple TVs be added to a group over AirPlay even if they can't be leaders? Are there any AirPlay devices that cannot be added t a group? If I knew that I could try to add more specific features flagging.
PRs should be a small as possible. This PR should be split into three separate PRs: - One bumping the library version - One adding the binary sensor platform - One adding the sensor platform Library was bumped already in I changed this PR and the other one to support binary sensor only. A new one for sensor is following. You can remove this whole property. It just duplicating the inherited functionallity. Remove this property too. Dont set this. Set a translation key instead and add to strings.json Translation key instead. Please do this loop in handle coordinator update callback and just set attr is on there instead. This function takes a list of entities so pass both on one call. Rename to check for recording entry use coordinator.device info These are constant, so set on class level. Moved into PhilipsTVBinarySensorEntityDescription now. These are constant, so set on class level. Moved into PhilipsTVBinarySensorEntityDescription now. use coordinator.device info fold into handle coordinator update. It's a one line function only used once. fold into handle coordinator update. This class is mostly a duplicate of previous class. Only changes are id and what recording entry its looking for. They should really be using BinarySensorEntityDescription to describe the differences between the two and share the same class implementation. Working on this already. Forgot to set the PR to draft. Sorry about that. Just need to figure out why the update from coordinator doesn't work in my new implementation. Updated it in [d1c337c]( I will work on the other little items the next days. should be a dataclass , if you had issues with stuff being optional either just give them defaults, or look how others use mixins to solve that. What about using the "const.py"? In "light.py" or "switch.py" the consts are also just defined as I did. I would have preferred if these constants came from the library. If not, and only used once i think we can just write out the string. This re-types the entity description to your subclass, making type checker happy with access to the new fields Partial constants. The RECORDINGS LIST is not really named reasonable. Just drop them i think. Just write out "recordings" here. Since they are only used once i see no need for the constant here.
This should live in assist pipeline.vad and we should make sure it's consistent across any integration that uses VAD (so also ESPHome). Instead of storing it on VoIPDevice , I suggest that we make it a select entity provided by assist pipeline select.py , just like we do for the selected pipeline. That way there is a single consistent place that we control this for all integrations that use VAD. This doc string still belongs to the pipeline selector. Commented out code.
This list should be alphabetized Why was this marked as resolved? The list is still not alphabetized? Please remove this copyright blurb from this and from the other files You need to add this requirement to the manifest It is, the package name and the library name are different. That package comes from the lib sma-manager ![image]( Sorry about this, I didn't mean for all caps Please don't add this, we rely on type checks Please don't add comments like these, explaining what obvious code does. Add comments which explain why we do something if not obvious, or what the code does if the code is complicated. In this case, no comment is needed. The library does blocking I O, it's absolutely not acceptable to do blocking I O in the asyncio event loop. Either you need to rewrite the library to do socket communication over asyncio, maybe you can find some inspiration here, or all blocking library calls must be handed off to executors ( await hass.async add executor job ). Again, please remove obvious comments What's up with this default IP address, how is it helpful? Why do we allow the user to configure this? These already exist in homeassistant const.py Not OK, please add a documentation link ( I don't see any integration happening?
Should anything be done if one of these callbacks fails? Nah, let it burn It feels awkward to put a response here, but the trigger doesn't know where the sentence was triggered from (websocket, ESPHome, VoIP, etc.) Moved response to callback You cannot use threading locks inside a callback executed inside the asyncio loop You can just remove the lock, as the asyncio event loop only executes one piece of Python at the same time. Let's have the callback return the response. That way the user could define different responses inside their script in the future. When Home Assistant starts up, it will register a bunch of sentences and causing this rebuild to be called a lot. Can we instead rebuild this on demand when it's needed the first time ? This is not testing the trigger. Use async initialize triggers from helpers trigger.py to initialize a trigger. Moved this test into the default agent tests. I'll coordinate with emontnemery for a proper trigger test. I think that we can remove this function if we are just exposing this functionality via a trigger Why would we support matching the same sentence twice? A user could reuse the same sentence in a separate trigger. It's odd, but having a trigger "use up" a sentence seemed odd too. The problem is that hello and hello[s] are 2 different keys in self. trigger sentences but both would match the sentence "Hello", yet not both will be called in that case. Using the trigger id as the key now (and the virtual intent name for hassil) this is no longer used. I think that this data class could be dropped. Why do we need a trigger ID? that's only for internal bookkeeping. Just generate an ID (with ULID helper) at registration time. Or just track an integer to generate unique incremental IDs. Using ULID Given that the last one wins, if one trigger doesn't return a response, it shouldn't override if there was a response previously returned. The callback should be async if we want to add dynamic responses based on something in the automation in the future But then we don't really want to wait for a full automation to run either. We can start with it being callbacks today I guess I made it async and am waiting for the automation to complete. No response can be returned yet, but this will make sure the confirmation in ESPHome, etc. is delayed until the automation finishes. Couldn't we make self. trigger sentences a list and just use the index in the list as ID ? We could, but this would make unsubscribing more brittle. Callbacks are gathered without an await , and the way asyncio works is that only a single block of Python is executed. So it cannot happen that a callback unsubscribes and breaks things. When refactoring it as a list, I realized it won't work because I use the key as a virtual intent name in hassil as well. If this was an index instead, it wouldn't be stable after an unsubscribe. We should first fetch all callbacks and then execute them in parallel using asyncio.gather Let's remove the return. I don't 
That is only relevant if using [emoncms.org]( Majority of users interface with a local instance, it does not require internet access. Same query as in the manifest.json. By default EmonCMS would be used with local hardware server, so local polling. Similar to MQTT, which mostly is local, but can be used with a cloud service.
This is not overloading (same method but different signature), this is overriding.
Is there a CannotConnect error thrown somewhere in the code? No, I have removed this section and associated test What should the user do when this happens? Updated message to show "try again later". Will have to check the logs to see what went wrong. Any suggestions to clean this up? Maybe something like "try again later, or report the problem somewhere with needed information "? Ideally this code is never encountered. This might be a bit confusing. Is the user id a phone number? Is this always the case? If so maybe you can change the name of the constant variable There are three different types "User ID" - mobile number, email and username - commonly referred to as User ID There are 3 different ways to login, mobile number, email or a userid. The app currently only supports mobile number but we could add the other options in a future update. Somewhere else in the code it says CONFIG KEY USER ID "mobile" If this value is supposed to be a phone number..? Have you checked if there is an input field that validates phone numbers? (like check the nr. of digits?) I have no idea if it exists but if it does it would be nice ) Yes, I have added a validation function and added tests. This info is not really related to validation right? Maybe you can just set it in async step user instead of returning it here I believe this is how the file is generated after scaffolding. Do we need to change this? You mean here? or in the scaffold? change here is not really super necessary but it's a tiny thing; having the names of methods match with what they do return is convenient. Is this the only possible reason for an AuthException? if not it can be confusing for the user. Yes, there is an http call to login and the exception is raised if it comes back with an error. But there are many other possible errors right? The webservice could be totally unresponsive. It might return a response with status code 500. Will these also show up as "Invalid user ID or password" to the user? Will there be other authtypes in the future? If so maybe it is better to also save it in the entry.data? That might make it easier to add new authTypes in the future. This has not been tested yet, but it may be possible in future. Although the app only currently supports mobile number. These seem like constants. are they? maybe const.py is a better place in that case Are these features for a specific device? or do all Miraie AC's share these features? Yea, moved all the constants to the const.py file. Yes, these are all supported by the MirAIe AC devices. Where do these values come from? They probably should become a variable constant These are values set on the app. I've moved these to the constants. Ok clear. maybe you can add a comment with where you got the numbers originally. 91? is that the country code of india? Yes, I think these devices are only available in India at present As you reraise the exceptions, the logging can also be moved to the parent method, where you handle the exceptions
The initialization value does not match with the return type of the function. I'd suggest to not initialize it at all, but instead just add a type hint. Same for panel Agreed. Fixed in ba62cd8a8164c776d1a2a4bb04eede92b2c776c5 Addressed in ba62cd8a8164c776d1a2a4bb04eede92b2c776c5. For readability and for future possible implementation, I'd rather prefer having explicit checking here. Why is client updated but panel isn't? Does this really have to be solved without reloading the config entry, or would a reload be better? Here's an example where the update listener just reloads the config entry: L223 You're right, seems easier and more accurate to reload the entire config entry in such a case. Thanks for the suggestion! Handled in 853152eb54dd6481b3f95c792af344ebd047b514 DummyPanel is not a great name, it suggests something used for tests. Can you come up with a better name? Agreed, merged in 1e030a1c64ad2aff3ee6fa66137818e238d64268 The comment does not seem to match the code, there's no warning print. Is it referring to raising UpdateFailed below? Agreed, handled in 26d11f7b650005fb7097ae92ca2dbb03fdeb1b4f Instead of giving options here, check the type of the client to know if it's a local or cloud connection. Done in 502aff4b9dd8d98494268f02bf02f55fed74072f How come this check now only happens once when setting up the config entry? Unfortunately, this can happen. The Elmax installer (or the user, if he has access to the admin console) can disassociate a panel from his account. If this happens while the user had the HA system down, we want to check this specific case and make the config entry fail with the AuthFailure message. Yes, I understand why it's checked. My question is why, with the changes in this PR, this check only happens when setting up the config entry instead of every time the data coordinator updates? If cloud is used, and the panel is disassociated from the account when Home Assistant is already running, what happens now? Have you considered a menu step instead of this? Done in f660390c1331fb241f7dc03dad573550e1ce8585 This is not OK, please add translations, or better, make it a menu step. Done in f660390c1331fb241f7dc03dad573550e1ce8585 This seems like an unnecessary option, why would a user disable this? Sorry, which option are you referring to? About SSL, the user might want to disable it in case the exposed certificate from the panel is untrusted, expired or untrusted and therefore rely on plain-text http. In general not all Elmax panels support SSL and the majority are not equipped with Globally Signed SSL certificates. About following MDNS, some power user might not want to rely on MDNS, instead they might want to use ARP binding static DHCP lease at router level instead of relying on mDNS discovery following option. The panel ID is used as unique id, it seems to me this code can be replaced with abort if unique id configured , passing in an updates dictionary with the new host and ssl mode. Unfortunately, that is a bit more 
Why not set that this always support release notes instead of recalculating based if there are a new version available or not? Because if a user blocks internet acces for the Reolink device (commonly done and supported by this integration), the online check on the reolink.com server will fail and there will not be any Release notes available. In that case the self.coordinator.data will be False (no update) or a string (version) instead of the NewSoftwareVersion class. So we have to check dynamically. To me, it is unclear why this is added, or what I have to do with it as an user ? Like, it has UpdateEntityFeature.INSTALL ? Like, I would click the Install button, right? Why would I download this even? .. Frenck frenck the build in firmware update utility of Reolink is notoriously bad (and therefore also the API commands). Often there is a firmware update available from the reolink servers, but when checking on the camera itself it will display that it is already running the latest firmware, same thing can happen when pressing the install new firmware. However manually uploading the new firmware file to the camera always works (Reolink support also tells people to just check the reolink.com server and update manually instead of them fixing the build in auto firmware update of the camera). So in case the install button fails (unfortunatlly happens on quite a lot of Reolink models, they should really fix that), the link will directly download a .zip file from the reolink.com server which includes 2 files: the .pak firmware file with the new firmware version and a .pdf file with the instructions on how to install it (just go to the reolink client- settings- system- maintenance- Firmware update, use "browse" button to select the .pak file and hit "update". The .pdf includes screenshots of where to find these buttons tabs. This .zip file is exactly the same file as would be downloaded when using the Reolink Download Center (the underlying donwload url is obtained from the same json servers also used by the Reolink Download Center) So in principle the install button schould work, but often fails, the link provides a alternative. I will change the sentence to reflect this. c0ffeeca7 Could you check this text?
I'm not quite sure we need this check, shouldn't we just add it if we decide to deprecate the non-list format some time in the future? Not related to this PR, but I think there's a bug here? If the MQTT config is emptied by the user, we'll setup the entities which were in configuration.yaml when core was started because because mqtt data.updated config is falsy? It is a left over from the complex config management we had before. It only is used when reloading yaml. I'll open a PR to clean this up. 96812
caldav isn't an integration by the Nextcloud brand. You're right but what's the correct way to give the users a hint that they could also use caldav with their Nextcloud server? There are multiple solutions, for example, the nextcloud integration could provide that calendar functionality (so, it just works without the need for other integrations). Another solution would be providing a virtual integration binding to caldav, but IMHO that isn't really fitting in this case. .. Frenck The first solution would be nice, but would also mean to implement caldav a second time. Or is there a way to use the other integration directly. The second approach could also be a simple solution like this. But this would mean you have to set the url and credentials a second time what is technically not necessary.
Can we also test minimum, maximum and some value in between here? The api itself is patched, so passing 3.0 vs any other number will give the same results. It's just checking that is called correctly as a paramater. It'd be cool if we could parameterize this too, and test volume too low and too high Personally, I don't think testing volume too high or volume too low is really needed, as it is handled by the actual Number Entity, not my code. Sending an int value works? I was using array param as [value] where value is int Nvm, just tested it here and it worked Yeah I figured it out as that is what the app does. It doesn't always work for some other setters. It's weird like a lot of the things Roborock does The standard is not to catch plain exceptions, but to have more specific exceptions to avoid accidental bugs. When does this happen? Is it expected to silently omit entities? Well I have return exceptions true. Sk ok any random exception that occurs will be passed through instead of crashing there - we notify the user that something went wrong when adding that entity, I.e. it isn't supported, or something about their device made the code crash. I could potentially add more if statements for different errors it could be, but since I'm doing return exceptions, I still have to handle all exceptions Just to clarify, i'm specifically talking about catching plain Exception vs more specific exceptions. That is, my comment is not about return exceptions and applies even if this were a normal try except block. I am imaginign the code is the same as: which we wouldn't allow here. But it isn't quite as simple as that, as right now return exceptions basically does do I'm just changing that to log rather than to do nothing. I can change it to RoborockException instead of Exception though if you would like, but I still have to make sure that it is returning a valid response and not an exception I think it's worth the change to RoborockException. It's not super specific, but at least it tells readers we are expecting an error from roborock and not elsewhere, if that makes sense Sounds good - changed! It looks like entity description.update value is trivial enough that it should just be inlined. Is this equivalent to something like this? Well the issue there is that that assumes that value should always be an int, but there will more than likely be float number entities I need to update too. so I'd have to create a new key in the description for changing value if needed, which feels more complicated than this. Open to whatever you'd like though.
If you change description.key you must implement the migration of unique keys to new values. description.key is used to generate an entity unique key : L443 Ah right, overlooked that part, what do you suggest we do? My preference is having one value to identify the sensor. And if so, how do we migrate it? Wait I forgot that description.key is used here L409 and here L434 Should I revert the key change? I don't think you should change the keys, we need them to access the sensor data from the API payload. Please revert this. key and translation key do not need to match. You should probably keep regular strings instead of constants for the translation key .
Warning: the key is changed here, but it is part of the unique id. I suggest that you keep "key" and "translation key" separate. Sorry missed that one
Seems as cover is also based on this so needs some refactoring and can't just simply be removed e.g. leaving cover without a name. Set the attr name to None so it will default to the device name, which is self.roller.name
Is there any reason to have an Invalid option for the inverter only. Not for the meter and ohmpilot as well? The inverter endpoint has explicit "Unknown" and "Invalid" (without a value assigned to it) status entries noted in the API specifications, whereas the other two don't. So for the others we just use None which evaluates to "Unknown" in HA. img width "907" alt "Bildschirmfoto 2023-07-27 um 21 51 58" src "" I would suggest not to expose the complexity of different status messages. Instead I belive having a generic 'get status message(type)' should be preferable. It could then call the specific operations and in one place handle invalid unknown error code responses. This should allow simplified maintenance across different types and more easy expandability for furtehr types. I did play around with that idea a little bit, but tbh I couldn't come up with a way that was better readable than just having 3 independent functions. A generic factory function that has branches for those 3 types accepting a TypeVar with value restriction as argument was my best guess... Since all of the branches need slightly different error handling (one has plain .get() , one needs to handle 256 code 511 specifically and one having a default value of InverterStatusCodeOption.INVALID ) doesn't really make it less complex better readable. Feel free to make a suggestion or a follow-up PR, maybe I'm just thinking in the wrong direction here. Yes, I thought about it as well. And honestly, there will probably be a very finite numer of cases to which it could even be extended to. Afterall, it's not like the fronius API is boundless :)
stale
Add type hint: Use a snapshot assertion here instead. You should move the dependency bump to a preliminary PR. created here: 94111 Why not use the asdict method from dataclass package?
It's still open hardware monitor right?
Those are not constants. You should add them to another module (maybe utils.py) if you feel they are necessary. You cannot change the unique id without making this a breaking change. If you insist on making this change then please open a dedicated PR just for the unique id change. I don't understand why this is now empty. Is it a mistake? This dict is for special attrs per sensor. And there aren't any currently. So just a placeholder. Then it's dead code, and should be removed. Just pass None where appropriate. In my opinion you should look instead at using real EntityDescription, and avoid re-inventing the wheel. Each individual entry should then have icon, category and enabled default. You should also use UnitOf constants. I'm not quite sure what you mean with your first point. Use something like this: BOOLEAN VALUES? I know I implemented this, but back then it was the only way to implement translations as we didn't have entity descriptions. But can we maybe replace this with adding a translation key to every description? What do you think about this? i like this idea ... give me a moment [b18a601]( Why is this added? 7e137f7 One issue with renaming all these strings is that the old ones are removed from lokalise. So even if we rename the keys (which imo looks nicer) the current work on translating this integration is wasted. Recently Paulus could rename some keys in lokalise to make sure the old ones aren't removed, but I think that's something for a future PR. And depending on the amount of work. i've checked it on lokalise ( 43 keys for sensor and 4 keys for binary sensors ), but do not have the permissions to rename or clone existing keys, so i think it is something for a core member with respektive permissions Yea, I think only Paulus and frenck can do this. What do you think about the intention to keep the current translation keys the same in this PR? to preserve the already spent efforts in translation, we should keep the current names will adjust it 99e4eb7 the diff still looks "heavy" but this is caused by sorting of the keys Is it just me or are there more strings than before, I am on mobile so I can't easily compare, but I saw Cache Expunges as added strings, but it wasn't there before. Am I missing something or is this PR also adding more sensors? there are more, because there were also additional sensors added Can we move them to a separate PR? I think this PR would be better scoped to use entity descriptions and change device info and add sensors in a later PR 7c2c30b I can't see any item in the list that has this value. 81e58a5 Can we do the device changes in a different PR? escoand do you want to move this to a new PR? unrelated changes were removed with 2926a88 Is the URL a valid unique id? Should the URL not be replaced by the entry ID? you're right ... will prepare a PR for this later this day
This will allow all devices of the integration:
This is not covered by tests, and it doesn't seem to be accessed by the time platform What's "DnD", is it "Do not disturb"? If yes, I think "DND" is more common. Does it really have to be an acronym though, or could it be written as "Do not disturb begin"? The only downside is that it gets rather long and you can't really read it if it is the full thing ![image]( We should set the name to what we think it should be, then address the UI in some separate way (e.g. assume it may cut off even if its "DND Begin" even its just slightly easier to read...). For example, Mop intensity is a wide select bar and it includes the name of it in the select bar and maybe that needs to happen here too. Is there a way to include the name inside the selection for time? Or would that take changing the Time platform itself on the frontend? I'm suggesting a frontend change (or a bug filed?). I have only a little experience with frontend but it seems possible.... Created an issue here: For now I have changed this to be do not disturb begin and do not disturb end. The icons fortunately display a little bit of information to make it clearer even if it is cutoff. I wanted to do begin do not disturb and end do not disturb, but since the entitles are sorted in alphabetical order on the dashboard, that made them very far away onthte dashboard from each other and even more confusing
seems may not need this since using domain identifier?
Fixed could be slotted will do on next aiovodafone release could be slotted See above Fixed This is scraping, but that is allowed for login pages Unfortunately is needed to get the csrf token . Everything else is json Most of this belongs in an external library moved to aiovodafone This content type doesn't look right for json Unfortunately the return is set to "text html" by the web server. Without I get a " JSON parse error: Wrong JSON or ContentType " error. This content type doesn't look right for json Same as above This content type doesn't look right for json One more All of this should be in an external lib moved to aiovodafone Done Missing tests Added with 100 coverage The signal should be unique and which means it should use the mac Ok, will review. There are at least other 2 integrations that need to be fixed: - freebox - asuswrt and maybe even icloud ; at minimum the comment is wrong ;-) Simone - Done Enumerate the changed data here and send the signals for the devices that have changed sample psuedo code I did a heavy clean-up of the code, now should be ok
This is not a value provided by the device or service but a calculated value. We want to avoid adding such calculations in Home Assistant. .. Frenck frenck this is the same math that is already happening below to calculate throughput network in and throughput network out . Do you suggest that the component instead log read time , write time , read count and write count , and then leave it to the user to create template sensors that do the math? If we subprocess iostat -x to get the r await and w await statistics that iostat calculates instead of calling psutil.disk io counters() , does that make it count as a value provided by the device? Almost all periodic statistics are calculated values based on monotonic counters that the kernel provides. We return processor use as psutil.cpu percent() , but that's provided by the following calculations that psutil makes: this is the same math that is already happening below to calculate Just because we did these things in the past, doesn't mean we still allow these things. Not all the things we did back then turned out to be good ideas. .. Frenck Do you propose that calculations be moved up into user templates, or down into psutil?
We can still check this with pytest.raises(ValueError) I think. That didn't work, I think it's because the callback occurs in a separate task Oh, right. Now I remember. We've discussed this before. That's the reason we log instead of raise. I suggest we revert all of those changes and keep the log, and add a comment why we log instead of raise. Ie, it's due to the dispatch, and we don't want to raise in a separate task. Move the log message to the exception argument. Do you remember why we create a task for this call instead of awaiting it? I don't... Perhaps the thought was that we don't want to block on battery devices, but the controller should handle that so I'm not sure why we felt the need to do so here. Ok. We can address it separately if it's not needed.
New integrations need to use a config flow to be configured. You can create one using python3 -m script.scaffold Since this is a config entry based integration, you need to implement async setup entry You need to pass the function to the executor job.
Entity category should be set to CONFIG Why are we overwriting this method of the coordinator entity? This will block users from manually updating the coordinator. I saw that this was a seemingly common thing to do when you need to update a switch async. since is on is a non async property. I got this approach from a wide variety of other integrations unless if I misunderstood anything and there is a better approach It's common for polling entities that don't use the coordinator but the built-in entity update mechanism. This switch state doesn't seem connected to the coordinator data. Is it? Should we even inherit the coordinator entity here? It is connected to the coordinator as the coordinator holds the api. I guess a better solution is for me to get the value on a coordinator update and store it inside the coordinator? It depends on how the API returns data. If it returns multiple data points, you want to store it inside a coordinator so you can share it among entities. You don t want to pass the coordinator around if you only care about api . The coordinator is meant to fetch data for more than a single data point, eg one data point being one entity state. If the entity needs to fetch entity specific state using the coordinator is probably not the correct approach for fetching the data. I'd add a specific entity method that updates the entity state. We can still inherit CoordinatorEntity if we need the auxiliary coordinator state for device info eg. Ie, we can keep using async update here but then we should also call super().async update to also request to update the coordinator if the entity relies on both coordinator state and entity specific state. So far the switches I have only rely on entity specific state, so I'll throw together a Non-coordinated entity and use that - a lot of things can be determined from the status props that the coordinator holds, for those that can't, I'll use a non coordinated entity and directly send the command. I don't think I'll have a PR for that tonight, but I should tomorrow morning. If in the future any rely on both coordinator state and entity state, I'll create a separate coordinated switch entity Sorry for this misunderstanding! Thank you for the insight! Do I need to get this completed before the beta release tomorrow? If so - should I revert this for now? Or just commit the temporary solution of adding a super() call to async update? Or is neither needed I think adding a call to super().async update is ok for now. Done here 93840 Also added a extra switch, but can remove if it makes things easier Please address my comments in a separate PR that I can merge immediately. I don't prioritize further changes, sorry. Understood. I finished the non coordinated entity faster than I thought I would, are you okay with my making that one a PR or would you prefer for me to just keep it simple and leave it on the super().async update() for now? I can take a look at that. 93841 Thank you again for your help! This m
We should always have a timeout on everything. Maybe 5 or 15 minutes ? Since this might be a long running task, can you give it a name (2nd arg to create task) The constant is the one for connection delay. I think we should rename this to get multiprotocol addon manager or something This comment looks a bit mal-placed. Not caused by this PR obviously, but still. How can the addon name be hard coded here when we pass an addon manager to the function? It doesn't seem like anyone is overriding the default value. If so, please remove it. This is a confusing way to say we want to wait for an add-on first start, and then kill itself. I think it would be clearer to explicitly first wait for state running, and then wait for state not running when flashing. How come we need to sleep here waiting for state? Should could this be functionality provided by the the base add-on manager class instead? Since we're juggling two add-ons and the code is growing I think we should name variables and functions - including the flow steps - by which add-on they interact with ( multipan addon manager .. ) etc. Either remove the finally clause, ore remove self.install task None from the exception handler just above I think it would be nicer to split the function in two, one which uninstalls an addon, and one which first waits for an addon to uninstall and then resumes the flow. Maybe rename this since it not only starts an addon but also resumes a flow. Isn't this the wrong string? Should we make the addon name a property of the addon manager instead so we don't need to copy these strings everywhere? Could we give a better error message? This means flashing is actually ongoing (or is hung)? This method could be generally useful in the parent addon manager. We can consider moving it in a follow up. We typically use synchronous sync in a non-standard way in Home Assistant, where "sync" in Home Assistant jargon means something which blocks and hence should not be run from the asyncio event loop and "async" means something which either finishes in a very short time (a callback in Home Assistant jargon) or a coroutine function. We may want to rename this class and its methods to not confuse it with the Home Assistant jargon, maybe WaitingAddonManager or something. Do you have any suggestions MartinHjelmare ? Yeah, sounds good.
The Imperial system is mostly gallons per minute
This must remain after getSystem() otherwise auto detect fail. Also can remain as is. Once it get a system structure it is likely correct. Ps. We dont even need to store this setting in the config entry. It will be deduced from the system structure once it has connected once. Its only needed during initial connect. The problem is that if this issue isn't fixed on the backend, the transport method needs to be set before we make a call to system - otherwise it just fails with the empty system. By forcing the transport we've set in config both during the init of PhilipsTV and putting it before getSystem , this should ensure that we're properly communicating. I guess adding a check in getSystem that verifies the presence of the contents of the response, and retries via HTTPS when the first request fails, could work. I'd possibly even flip things there, and try HTTPS first and only then fall back to HTTP. You pass it in the constructor. Thay should be enough? Then what is the point of setting it here again? It how the autodetection works. getSystem will modify the property, but not the setting on how we access.
I aimed for a year when I wrote this. I should replace the domain names and the service names with placeholders. It's a lot of text currently. Happy to get improvement suggestions.
Please add in alphabetic sorting Isn't the device class already proving the right icon in the UI? As this is more of a thermostat I thought this icon is more suitable Not resolved. Please remove it Use attr unique id to define in init Use attr name Can be defined in init? Same as min value? Put as class attribute Use attr device info in init This whole thing with a previous value and a new value etc. makes no sense. Can't you copy the logic from sensor.py and make some thing similar. Should not be needed There is no value in having a listener here when async update will be called automatically I used a listener here to remove the delay in calling async update. The delay was allowing the temperature to be set out of range until async update is called. What delay? All logic should be within async update() and you should now the min max values or you need to fetch them before setting a temperature so you know it can be done or then raise if it's out of range. Sounds like the min max would be a floating target which also seems a bit odd? It is a floating target based on the target temperature of the climate entity, plus or minus 2 degrees. If I change the target temperature there is a delay in updating the min max values. So you should probably implement a data update coordinator before this PR then which can coordinate all your data and refresh data more easily than in individual platforms. Same Not needed Should raise HomeAssistantError so we can display a message to the user and not just silently abort
I haven't quite wrapped my head around how ENTITY SERVICE FIELDS gets used vs TARGET SERVICE FIELDS and if I were to add my new field to those instead, do I move the "at least one of" validation up to those constants despite them probably intentionally being wrapped in vol.Schema.
Please remove pairs with empty values Done Ideally this happens in init so if the cloud api flakes out it can happen inside a block that will raise ConfigEntryNotReady I think the easiest way to handle this (and your comment in config flow.py) is to add a DataUpdateCoordinator. I'm going to want that for a later update anyway. I'll do that later tonight. Done. Please use the new entity naming scheme Done Please combine the executor calls into a single call to avoid multiple context switches Done. Please handle transient failures by raising ConfigEntryNotReady so it tries to setup later Done. Usually we use unknown for a broad exception catch and try to give the user a better error for named exceptions Okay, I'll change this to a broad exception catch instead. Even the generic PyschlageError would be essentially an unknown error. (I'm not even sure what would cause that at this point TBH) You can use a generator expression here. black will complain about this suggestion I think the list comprehension is fine--I'd imagine most folks have a small number of locks, so the overhead of the list is fairly low. I m not sure what the objection to using a generator expression is given it s less code? Done device info is only read when the entity is added to hass. We should set it once instead (in init) Well that makes sense. The device info should be static. Done! If auth fails, return False so we don't retry over and over. In a future PR you can raise ConfigEntryAuthFailed to start a reauth flow Done. Also we should log an error so they know what happened since reauth will likely be next cycle if we merge before beta I added a LOGGER.exception call. Did you have something else in mind? We usually don't set anything in hass.data until we get past the point we are sure the integration is likely to set up Done. Should the scaffold template get updated to reflect this? L18 This is generally fine as a source of the unique id, if the cloud service has an account id, that would be better (in case they can change their username). AFAICT you can't change your username. But we do also have a user id, so I changed it to that to be safe. Sounds good
The downside of async track time interval is that it will keep firing the CLI command, even if the last one wasn t finished. Polling will actually avoid calling update on an entity twice. I think with the last change that should now be covered so it will not fire again until previous has completed logging. We don't need to pass True here anymore with the new code. Fixed in
Please fix this docstring added proper description Pick the one you like and use that removed the comments Do like this: changed to your suggestion Is this really wanted? you mean printing the new name? was more kind of debug information - removed How is this possible when the schema requires a host? good point, removed this check removed test for it All errors should have translations in strings.json, they should not be English natural language added adjusted test german translation Please remove commented out code ups, removed This doesn't seem to be used? Please use the attr shorthand for attributes which do not change Please use the attr shorthand for attributes which do not change added Instead of implementing this and all the other properties, you may want override handle coordinator update to make the code shorter still need function for properties(fan speed, battery level, state, is on, name) or? would like to let it like that for now and take a look with for it with the other entities (binary buttons, sensors...) We don't need this both in the docstring and as a comment removed the comments DataUpdateCoordinator is generic with the return type of async update data . changed The schema requires a password, therefore you can access it like:
This should be removed if you implement unique id property below This has has entity name so this should only be the appendix Might as well do it in init with attr name Do you mean like this? self. attr name "Hourly" if hourly else "Daily" Names then become 'Forecast Daily' and 'Forecast Hourly' I have tried to follow the rules here: [has entity name True (Mandatory for new integrations)]( entity-naming) No reason to change device info. Both entities should be same Device (Service) gjohansson-ST I have moved DeviceInfo back to attr device info as it was previously. I don't think adding two weather entities is a good method. It only adds confusion. How would you do it? I also think that ideally this should be one entity. But his method does allow you to easily display the data in frontend cars that work with an hourly forecast weather entity such as the default one in HA. I could only find the [met.no integration]( that also has both daily and hourly forecasts and it solved it in this way. This PR allows weather entities to provide hourly, bi-daily and daily forecasts. Instead of adding a new entity, I'd suggest this PR is refactored once that PR is merged. This PR 75219 allows weather entities to provide hourly, bi-daily and daily forecasts. Instead of adding a new entity, I'd suggest this PR is refactored once that PR is merged. Agreed, I already asked about the state of that PR [here]( issuecomment-1561052680). It's been in process for a year now so I wonder when it will be merged. Some small bits left in frontend but should be pretty close now Great. Can you give a preview of what it will look like in the frontend? There are some screenshots in the frontend PR: Looks good. As we're reworking the forecasting system maybe it's also a good idea to consider my request regarding cloud coverage property [here]( We cannot use attr unique id here at all. attr unique id makes the unique id property unused. Where can I find that behaviour in the docs? Can I still use entry.entry id to generate a unique id? Because I don't think I have another source to generate one Please remove the ignore.
The attribute keys should be "available" consistent, right now, they are not. Please make sure the keys of the dict are present consistently. .. Frenck
Climate has these attributes too, and them not being used is a bug (that can be fixed in another PR) Good point, I'd be happy to prepare review that as well If the current temp is not set yet it will be None and cause errors. Good point Why is this needed, and how can it be it was not needed for climate ? Do you mean that there is no section here for the climate domain when water heater is explicitly referenced? Climate does have a similar section but Google has decided to separate thermostat devices into the [ TemperatureSettingTrait ]( while all other temperature setting devices use the [ TemperatureControlTrait ]( L1004-L1026 My thinking was if any other (non climate) devices in the future want to take advantage of this trait they can expand it similarly. A water heater entity does not support turn on and turn off. The OnOffTrait trait is required for a WATERHEATER though by Google. How do you want to solve this part? A good question that I haven't found a decent answer for. One possibility would be to use it to control operation mode, letting off set to off and on set to the last used operation mode (or some default). But too me this seems confusing and prone to issues. Probably the better option would be to implement the [on off as query only]( examples), and let it report the state as off unless a mode is set. That way the UI will report the state accurately, but you won't be able to change it. If we wanted extra points we could implement the modes trait for water heater as well, and let that control the operation mode (if supported). ![2023-06-15T16:14:18,813379544 10:00]( Climate has a turn on off service. Water heater misses that, perhaps it is worth to open an architectural discussion and suggest adding this service to the core water heater entity Changing the core entity sounds like the best long term solution, [and there's discussion about water heater modes already]( Maybe a change to add preset modes and implement the turn on off service to bring it closer to climate? I'll draft up a post and see if anyone bites Implements a turn on turn off service for water heater. The architecture discussion was positive on adding the this. Once merged, we can go on. I was swayed while reading architectural discussions into broadening the scope of the question to whether a [generic temperature control entity would be viable]( It hasn't gained much traction and I'm not sure if it's a feasible change to make, so I think just implementing the turn on and turn off as you have done is the right solution. Thank you for getting it through Now that it's been merged I'll pull in the changes and see what needs to be tweaked. hookedonunix , I am working on a PR to add MQTT support for power on off. jbouwh Is that for the water heater or a generic on off? Yes: It will only support pessimistic mode (no state topic), as the steeds needs to be set through the mode state topic. The Celsius range seems unrealistic. 0 deg Celsius is the freeze point of water. Unde
In the case of button, I understand the return value can be Any , but in the case of the provided parameters to this lambda, I think we can be more specific, right? Definitely, updated typing to be more specific. Just going to fix this to match Entity naming convention used throughout. Done A bit related to this ADR: Should be make this longer?
No need to define modes, you can just do: assert [...] state.attributes.get("operation list") Good point, thanks! This is duplicated. I think we should move these contants to const.py if they are used both in climate and water heater Would you like me to replace the ones in climate.py as well? Or save for another PR? Yes please, since they are being reused. We do need a PLATFORM SCHEMA const as this is deprecated stuff. Later we can move the shared parts of climate to a new class. You need to add an import from .climate import MqttTemperatureControlEntity You can add a common test to test the value templates. Seems you miss some tests Just to be clear, do you mean missing tests that cover conditions like the one above? If so, consider it done Yeah, you can do a coverage test to see what lines are not covered with tests. e.g.: pytest -n auto tests components mqtt --cov homeassistant.components.mqtt --cov-report term-missing This is part of MqttTemperatureControlEntity , so it can be removed here. This is part of MqttTemperatureControlEntity , so it can be removed here. This is part of MqttTemperatureControlEntity , so it can be removed here. This is part of MqttTemperatureControlEntity , so it can be removed here. This is part of MqttTemperatureControlEntity , so it can be removed here. This is part of MqttTemperatureControlEntity and available as a class method, so it can be removed here. This is part of MqttTemperatureControlEntity , so it can be removed here. Not sure about the method names but I think this is cleaner than leaving unimplemented abstract methods and dealing with operation mode typing If the method names were not correct, you would have trouble getting the service calls working. Seems fine to me here. This is al ready initialized in WaterHeaterEntity , so we can remove it here. We probably shouldn't set self. attr min temp or self. attr max temp if this is not configured. The default temperature is in Fahrenheit and should be converted if the local unit is Celsius. The component class covers that if the attribute is not set. May be we should not set the attribute here. May be we should set the unit first.
This already has a device class, we should not have to set an icon in this case. Thank you. Lash-L can you address in a followup PR? Will do once I am back at a computer. Thanks for pointing this out Fixed with 93774
Use the LawnMowerEntityFeature to define what supported features are required for the different services. Please remove battery and link. Supported features is only used to mark what services are supported. This should be typed with LawnMowerEntityFeature I think. Here too. I don't think we need to accept keyword arguments. Well for example my RTK mower has zones, mowing height etc. How would you suggest this happens? That's not part of the design yet. removing for this iteration. args for schedule at least? also CI should now pass :) We only need the service helper functions if we need to do extra parsing or validation of the service data. That's not needed for these services I think. That would leave only the enable schedule yes? That would remove all right? Since we aren't doing any validation, how does this affect registering services? When we pass a string to the entity component service helper async register entity service it will look up the corresponding method name on the entity and use that method as service handler. sorry for the text spam, figured it out. I think. We can wait with device automation strings until we add device automations. That can be done in a follow up PR. I don't think this should be added. There's probably some exception in hassfest we should update. Yeah ended up auto added See the humidifier integration for example tests. We should also add a lawn mower platform for the kitchen sink integration and test that platform. See the lock platform tests in the kitchen sink integration. Will work on these this week : 1: These string constants are never used. Yeah been looking at them for removal after adding Activity. Will remove Isn't Schedule one feature instead of two separately for enable disable? If it's two different services and we don't require both services, it's safer to have two features. This typically goes before the Entity Follow the HVACMode example in climate: L8 Move name and description to translations strings.json under services . See eg the climate integration: L132 Please keep the enum sorted . Please sort .
Instead of SIREN ENTITY TYPE.key use description.key (pass in description entity) or skip entity description all together as I suppose no more entities will be added here Used description.key. There might be additional entities in the future, and I think entity description might be expanded in the future to include more entity class attributes. (looks that way at least - I can see how this would cleanup the pertinent parts and make changes easier...but I'm speculating.) Should we not instead refresh the coordinator and update the state from the data instead of just assuming the device is off? Unfortunately, EZVIZ doesn't have an api to get the actual state. (Even the app just uses a timer). I'm sure they will release something in the future like they did with the alarm panel. But then if we update only here the coordinator would think it's still on right and then change the state back again? Still need a reply here thanks The state is handled in memory only. Just using the API to turn the siren on off, it then also turns off after exactly 60 seconds even if the camera loses connectivity to the network. It's also safe to trigger twice, the camera just ignores the 2nd trigger if the siren is already active. Same goes when off. Right, so you should - Remove the coordinator as it's not used for this entity - Set polling to off (already off by the coordinator but since you remove it, you need to set it) - Set assumed state to true as we are assuming a state from now on - Use EzvizBaseEntity, which doesn't inherit the supervisor. (Still need the coordinator for api calls and it's session cookie) - Set polling to false. The assumed state attribute, when set, doesn't indicate status of the entity (show both on off buttons). The state is set initially and on every change (in memory) so this shouldn't be required I think? I see I'm wrong when it comes to assumed state, it does show status with both on off buttons. I'll fix. - Set assumed state flag to true. Should the "breaks in" date be in the description as well? Was previously requested to remove it (in other recent pulls) so just making sure. No, my mistake as it's already mentioned by itself. Remove that part No problem. One last thing, I see targetting is UK spelling and targeting is US spelling. Is there a specific standard that home assistant follows? Should I submit a pull to fix the rest to US spelling or do we leave it on UK as the rest in the stings file? Apologies for wasting your time with this question. Base is US English so would be good to correct it. We should only have what can fail inside the try-block. Please also change async turn on() What if someone press turn on 30 seconds after the first on press? Still going to turn off after the first 60 seconds or should you get a new 60 seconds? I see it resets, have added logic to reset the event. Thanks for asking. deprecation We don't allow calculating state in Home Assistant for device integrating integrations. The device should update its
The emulated hue integration uses the demo integration in the tests and expects a certain state I think. That's why there are some test failures. Same for google assistant integration. We aim to remove the use of the demo integration in tests, but that work is not complete. I pushed some fixes for the tests. I agree other integrations shouldn't use demo integration. Wasn't this partially why kitchen sink was made to not clutter demo with more entities? Kitchen Sink is about weird and incorrect behavior, right? Light temperature and brightness are very common entities. The demo light seem to lack logic in the init method for this case, ie with a color mode of ColorMode.BRIGHTNESS .
I haven't looked at your underlying api, but why not handle the token inside the api? Cleans up the code here a bit. Since you are getting a new token everytime you start up, it doesn't really need to be stored in a config entry imo Looks like you have things inside this try except that are not directly tied with the exceptions, you should move them outside the try except You should use asyncio gather for this. Personally to keep this PR small, I'd remove the Options Flow for now. Just another chunk of code that a core maintainer will have to review. the smaller the PR the more likely it is for this to get merged sooner You don't have to, but I would probably remove reauth for now and it add it in a future release. It is a helpful thing to have but it is not the top priority. And again the smaller the pr the more likely it is for it to get merged faster. Don't double nest these trys. This does not throw any of the exceptions, so instead put this inside of an else in the try except. Personally, since these are used in sensors, I may just put it there, but that's not really needed. You should however make it so you can translate them in strings.json These don't need to be set here, since they are just used in device info below. also device unique id and model You can remove the unused ones like dependencies and homekit Instead of name you should use translation key and add it into strings. DataUpdateCoordinator is generic with the return type of async update data . CoordinatorEntity already inherits from Entity . This can be set as a class attribute instead (as it is static) This is pretty specific belong to an entity. Let's move this into entity.py into the base class instead. It can access the coordinator there too, so there is not much needed to move it. Avoid asserting, it is usually an indicator of an logic or typing issue. Override the typing on the class variable in this case instead. We don't allow setting the scan interval. Provide a sane default out of the box instead. As this is the only option in this option flow, it means the flow can be removed. We don't allow configuration of the scan interval. There is no real need to use instance variables here Seems to be unused?
Take the opportunity to implement translations via translation key instead of setting just the name We don't have to use translation keys for binary sensors; instead, we can rely on the device class to take care of the transaction. Just remove the name should be sufficient. Ok, I'll remove name then. gjohansson-ST frenck so I tried removing the name, and now binary sensor.salon undefinedtype singleton is created instead of binary sensor.salon problem . I tried setting has entity name but it doesn't help either... So what I should I do in this case? I believe you need to use has entity name and device info for this to work (which should be done anyhow). Not sure though as I didn't completely look through the PR which uses the device class to make the name. gjohansson-ST frenck I tried dropping name from the entity description, but that triggers this warning and doesn't add " problem" suffix to the entity name from the device class: L337-L345 So I added has entity name True and name "Problem" in the entity description and dropped attr name from the BinarySensorEntity. I'm not sure if this is the proper way to go but I couldn't find any example in homeassistant components which uses BinarySensorEntityDescription with has entity name True and no name ... emontnemery since you implemented you might be able to shed some light here... So if I remove name "Problem" from the BinarySensorEntityDescription , the created entity will be binary sensor.salon instead of binary sensor.salon problem . I want to rely on device class in order to take care of the translation but still have the device class appended to the entity name. Is this possible? Thanks! You write binary sensor.salon twice so not entirely sure what you mean but my understanding is that if you want it to be binary sensor.salon problem you need to set name None You write binary sensor.salon twice so not entirely sure what you mean but my understanding is that if you want it to be binary sensor.salon problem you need to set name None You're right (message edited, sorry for that). I tried that but it still creates binary sensor.salon instead of binary sensor.salon problem ... gjohansson-ST name None added in db68d059c48f4944158b471f3037b15a105ef4ea And it fails because binary sensor.salon is created instead of binary sensor.salon problem : Fixed by: And a new merge from upstream (it fails without it): Could use a lambda in the entity description instead I'd rather go with this approach since it's the same I used for Airzone (Local), but I'll change it if this change is mandatory: L129-L136 Is this class needed, will there be other classes? Yes, there will be other classes, this is going to be very similar to Airzone (Local): L117 L139 L158
Please move to a separate entity.py, or since you only have one sensor, just directly put these statements in the sensor.py Putting everything in a dict solves the problem of having to initialize every value The big drawback of using a dict here is that you can't plainly see what information the config flow is gathering to use to create the config entry. This could be cleaned up with a data object, but the values would still need to be initialized. In it's current state, I think there are few enough members where that abstraction isn't necessary quite yet, though. Perhaps move the options flow for a later PR That's a good point, should have thought of that. That will clean up a lot of code and tests. Think I might do that actually! Perhaps use another name for this step, finish is a bit too generic imo, maybe boards is more recognizable I'd suggest getting rid of the separate functions for showing forms. It looks confusing for new contributors and you always have to trace back to the place where it was called. (for example what if this method is called while ids boards is None for some reason. It can get confusing) I can see where you're coming from with having to jump back and forth. I think it's more important to keep the async step methods as readable as possible though. That's where the high level logic is and all the form definitions makes it much more difficult to grok. Also having all the form definitions encapsulated in these methods makes it easier to reference. As a new contributor myself, it was really difficult to read through a lot of config flows for reference because they didn't abstract away a lot of higher level behavior. I'm with you there on the self.ids boards reference though. To make it easier to reason about, I'm going to pass that in as a param. I agree with you, in one of my first PRs I also did this and then I got this as feedback ( discussion r1169927319) Thanks, that's good to know. I still feel pretty strongly that this should be abstracted away into a method for readability in the async step method. Otherwise, it does seem like add suggested values to schema would be appropriate to use here. However, looking at it again, I actually don't need to set defaults anymore since I've removed the options flow. So I'm removing the logic that would make add suggested values to schema necessary, but I'll definitely implement it in the follow up PR. Not sure if GitHub orders all my comments like they are added, but to get rid of these small functions you can invert this method. Only if user input is filled go into the if section. is an example. For readability I personally prefer using a sentinel value to short circuit. At least in this situation. There's less indentation and as you read the method from top to bottom there's less mental overhead since you can just forget what's above the short circuit conditional. In this situation it also reads more linearly since when running through the flow user input being none is what happ
You could do the above if there isn't a difference between aidoo[key] being non-existent and None and it saves one dict lookup Yeah, the only disadvantage is the code coverage, since line 57 won't be tested. Done in 0b76625265274c4e92998677ca4bce02dcd74f53 with a minor modification to keep 100 coverage. You could probably also write it as return (aidoo : self.coordinator.data[AZD AIDOOS].get(self.aidoo id)) and aidoo.get(key) I'm assuming the data looks like this dict {"key": {"subkey": "value"}} which effectively makes it return (subdict : dict.get("key")) and subdict.get("subkey")
Reminder for myself to check back why we do this. Why do we do this? Instead of returning false, I would suggest moving the init part to here, and then raise ConfigEntryNotReady on a failure. Please move the options flow to a follow up PR to make it smaller and easier to review Please move this to an entity.py I would suggest to move device triggers to a separate PR. Is this step really needed at the initial configuration? Can't we let the user update this info in the options flow later? Maybe a personal opinion, I would actually opt for not using a const here, as it makes the code harder to glance over when you want to search where a certain abort translation key is used. As mentioned earlier, please only use this in the config flow, but to give you a heads up, checkout NumberSelector. That might be what you need here :) Can this function be merged with the async step user . please use self.async abort(reason "asd") instead of raising the issue yourself. In the translation I see that this would mean invalid host, where could this be thrown? Please make sure only the code that could raise should be in the try This could already be the case, but not 100 sure If you already want to store the default volume settings for the follow up options PR. Please put the mutable data in the options. No real need to store the name in the data? It will already be stored as config entry title Please use I DONT KNOW THE NAME OF THIS STYLE case for enums (you get the point :P ) These can be normal constants, no real need for an enum Out of curiosity, why does a media player have curtains lol I don't think having this as a default adds much value, everyones network is different. Please move this out of const Can be moved outside of the constructor Can be moved outside of the constructor It's the default. But since you're using websockets, do you still need to poll? (this is not a hint, but an actual question) Don't log on info, please use debug. Also, this information can all be provided via device info. Since you enum is a string enum, it doesn't work directly and you need to cast. Can you replace this with a dict that transforms the B O states into MediaPlayerState s Please move services to a follow up PR Please remove the classes from this file. You can create different test configurations using test fixtures.
We prefer setting up the integration and then calling the service via the service registry and then assert that the library mock was called appropriately. writing-tests-for-integrations
Will this integration show up under the August brand or under the Yale brand? neither at this point :) I think this domain should be added to the brands yale.json file.
Will the window covering values only get discovered with v11 of Z-Wave JS or will it be discovered already with v10? I'm thinking about our release strategy and breaking changes. If we don't get the architecture discussion solved before the beta we may want to hold off merging here and potentially ask Z-Wave JS to also hold off releasing v11, if there are breaking changes. Window Covering CC is already supported in v10. Main value of pushing this forward is because of this issue: Are there no breaking changes regardless if we release this with or without v11. Ie it doesn't matter if we release this now, also if v11 is applied later without further changes in core? that's correct - in v11, devices that have the Window Covering CC will no longer advertise the Multilevel Switch CC values, but once this change is merged that won't impact users since the device will now attach to the Window Covering CC values instead of the Multilevel Switch CC values anyway Isn't SlatStates an enum so the properties here will be constant? We shouldn't use a property if it's a constant. Just store a constant at the module level. Properties are for dynamically calculated values. can I override a property function with a class attribute? Having trouble answering this via google Oh, I see that it's dynamic by default in the mixin but here's it's a constant. Does it need to be fully dynamic in the mixin or can we use an attribute instead? We don't need to change this now. It's ok to keep them properties. It may not need to be. Will look at that later
These should be sorted. These should be sorted also (please fix CAMERA also) Should not be needed. These should not be needed. That's the point of entity descriptions. Should not be needed Not needed This looks wrong. I don't think it's needed at all. Little naming suggestion, as they can extend maybe in the future. The constant is pretty specific. Number, not switch Oops, revealed my copy paste from the other integrations. My bad lol. Instead of adding prefixing the device name, you could also set attr has entity name True as a class variable and remove this line. This should not create a persistent notification. Those are generally for end-user. Please raise an issue in the repair dashboard instead. When the attr has entity name is set (as suggest in another comment), we can remove this name and add it to the strings.json translations file (making this translatable).

I think "Packet loss" would be a better name than "Loss" Please do nor transform attribute or config constants. Use just a string instead This is old style naming For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. see also: - ADR-0010: decision That is the default This has a device class, which provides the default icon So! The icon can be removed
Changing the order might be a breaking change, when the attributes are accessed by their index. There is a unit test failing, which is checking the order, so it might be important... Did you check the usages of attr options? I see a point in reordering the list items by the moon phase, which could improve iterating in some cases. Nevertheless the current ordering is alphabetically, which also looks good to me. Thanks freeDom- I thought so but this in-github test does not provide a lot of information. I ran the testpackage on my dev instance on Sunday with loads of warnings errors in other locations and have not had the time to dive deeper. It is exactly the order for which one would use the real (!) order imo. The alphabetic order may have a use but I donot know that right now, hope that I discover the testerrors to help me see and understand. It is a very small update and my workaround is adding the correct order manually (it is only 8 values) freeDom- Hi, I have no clue what the error could be I started the local dev instance Then openend a new terminal in my branch and started this: pre-commit run --all-files which gives me this first passed then mypay and pylint failed. The number of lines is way too big as it contains lots of pointers to other things Then I tried to run: pytest tests This complains about jaraco not found...cannot find any ref. to it In short, unless you have good pointers I will withdraw, I spent already too much time on something I myself already have a workaround for (ie. time money) Possibly the documentation on the developer pages is not up to date but as a non-developer I am stuck quickly as you can see, which is not motivating me to continue to help improving HA ...but maybe that is a good thing too as you may not want too many 'hacker-type' people :) I don't know how you created your dev environment, so it is hard to say what exactly is missing. It looks like you are missing development dependencies, because running pytest tests should work otherwise... In the dev documentation is a detailed article on how to setup a development environment, which covers multiple methods. I suggest using the VS Code container, because this is probably the easiest way and it contains all dependencies. The problem with this PR is, as already said by frenck and me, that a unit test is failing. When running the unit tests locally you should receive the same failure as here in GitHub and should be able to resolve it. The error message in the test writes a file and line: tests components moon test sensor.py:62: AssertionError Thanks for the response and yesterday I re-started from scratch just to be sure. I removed all containers, images, also vs-dev env, etc. Then synced core on github, then used the deveveloper page with the github-link to kick start the loading into VSCode. But I did not re-install VSCode on my machine(should I?) On testing: via the developer-pages ... it states to possibly need to load additional things but these were a
Entity names are not made for instructions. Understood. I'll make the change and re-commit. Does this entity count down while running? Yes it does. It's set, then counts down once switch is set to true. Should this be setup elsewhere? We down allow number entities to be used for countdowns. .. Frenck
In this case, we still do return self.airzone.data() below, is that OK? In this case, we still do return self.airzone.data() below, is that OK? In the beginning I was seeing this too often because I was using a specific API call that I'm no longer using, so I used this to debug it. However, I'm no longer seeing this so I will remove this exception catch and handle it with the AirzoneCloudError catch. Done in 86f461cb3a75596b6cf3bc5aecf5665d75dd9b19 You could make this class an ABC and mark this method as abstract instead of raising if it will be implemented by all derived classes? You could make this class an ABC and mark this method as abstract instead of raising if it will be implemented by all derived classes? OK, I will try to do that, I just copied this from the Airzone integration and I didn't think about that :) L37-L42 Done in 07f234b7aa342df33506178efdc036f80fb6f6b2 Why is this conditional, the config entry's unique id is unconditionally set in the config flow? Removed in c779c6473cbdc94e7d411f143675dca6c0c0c053 Why is the unique id set here, and then overwritten in the derived class AirzoneZoneSensor ? You're right, I copied this from the Airzone Local integration and I think that it can be removed there too: L131 Removed in c779c6473cbdc94e7d411f143675dca6c0c0c053 Here the entry.entry id is used to derive the unique id, but in the base class the config entry's unique id is preferred. Just to be sure, you mean that I should do self. attr unique id f"{entry.unique id} {zone id} {description.key}" here, right? I think you should decide on a stable pattern and use that. Using the config entry's unique id is probably a good choice since it maps to ids used by the cloud API? Changed in c779c6473cbdc94e7d411f143675dca6c0c0c053 Is this base class really needed? Is this base class really needed? Yes, I'm gonna create webserver system entities as in the local integration: L102 L117 L134
Title is optional in options flows. Thanks
Should we replace "mount" with "network storage"? Why do these repeat? I don't know honestly. This data schema is not created by me. I am just using async show menu to make that screen when there are multiple suggestions: L85C15-L89 That is the data schema that comes out from this type of config entry. I think perhaps menu options can take a label value combo and makes the value the label if omitted? But I don't get why someone would use that instead of just putting the label in strings.json so it gets translated. This is how our voluptuous serializer serializes vol.In : LL91C14-L91C14
Should not change the deprecated platform schema. New changes should only be made into the config flow This key should always be there I think even with a None value Here I'm following the pattern from the province value, but it makes sense to change from get() to [] if it will always be set. However, I think that the None type hint should remain, since None is an acceptable value for the country with this changeset. province key is missing if the province is not set. For example not all countries have province state etc. country key should never be missing. It should be set to None if selected as such This can't happen as we (should) skip province in the schema if country is None Agreed, but there must be some sort of hint to mypy that country is non- None here for getattr(holidays, country) to type check. What is the preferred style in Home Assistant? I will add if typing.TYPE CHECKING: assert country is not None to fix for now, but please let me know which is best. I think you should turn it around if country and province: perhaps. Didn't look to careful though Should not be None , should be NONE SENTINEL in that case I think we should store the NONE SENTINEL in self.data and change to None in next step before writing the config entry. Missing country I'm not 100 sure what you mean, but I think what you're asking for might be covered by TEST CONFIG NO PROVINCE below. country key should be in these even if it's with a None value In OptionsFlow we should abort directly if no country is specified instead of loading a form with nothing in it. I m not sure what you mean by this. When I configure a workday sensor with no country and then chose to configure it again, it moves directly to the options form with the workday exclude, days offset, etc.
It doesnt look like you're using these values Casting to string first seems unnecessary. [Python recommends ]( datetime.datetime.utcnow) calling this with just now() and specifying the TZ explicitly. Would also need to update your import statement to include timezone . Alternatively, you could use dt util.utcnow() like you do later (maybe share the value?) since they return the same object. img width "607" alt "image" src "" These variable initialization seem like they can be simplified its unnecessary to have both import statements. Later on when you need strptime() , call it with datetime.strptime() Do we think we need to validate this? And why was 4 chosen? Just want to see if we're appropriately following the spec for these language codes tags How can a developer be sure what a 3rd application module set as output? I'm not sure "language code" is the same for all implementations and WebOS version, so I usually set constraints like that especially when INSIDE it there could be a big comparison for all other Codes. If in some implementation "language code" returns "ITA" or "ENG" there isn't any reason to do match comparison against "it-IT", "us-US " and so on, so this stops any further check before the string comparison. I think it's common in code-development setting constraints more stricted than could be required especially if source is not under our control ;) Thats fair, my question was more around if we're going to validate the returned string, why just validate the length and not be stricter? Such as a regex match for [a-z]{2}-[A-Z]{2} Changing the media player base entity requires an architecture discussion and approval. I don't think you need to change it to add some features that are specific to webostv. I suggest removing this change, or otherwise split it to not block the rest of the PR. changing-the-entity-model It needs an "architecture discussion" just to have ADDED (not removed nor modified) an attribute? It's even strange that "genre" wasn't already in use.... After all the core component of "media player" shows very few attributes that it would require a complete rewrite to allow it to be modernized a bit. Virtually all media video audio meta-tags metadata are missing and not shown: it doesn't show the Genre, not even the Year of production, we can't put the volume bar directly in the widget to improve Controls...well, it's very-very limited. However it's not a problem to remove just a new attribute if it creates a lot of inconvenience for you. It's incredible, but ok. changing-the-entity-model In your link it is clearly written: " Only additions will be considered " (without an architecture discussion). This is an ADDITION and not a change or a removal. It's very annoying waiting days to see as approved a simple addition of an attribute, especalially if it should already be added from the near beginning of media player (like other lacking attributes) So what happens now? If you obey me to delete that, I have to remove same at
Stale doc string ;) This should be for a future PR. Doesn't this break normal oauth login? Like, all oauth2 integrations in HA already have reauth, so it's difficult to see them as two different things haha Well in that case, I will leave that up to a member to decide on that since it was accepted on first go for Google Mail. I mean if it is easy and it makes sense I am happy to do it Typically we do as small of PRs as possible, so things like option flows and reauth come as separate follow up PRs to increase review speed of the initial PR. As an example, you mentioned below you were having trouble with the reauth tests and getting them to work. (Yes obviously the quality is better when reauth works, but it's a balance). I would suggest: Add the reauth and options flow and their tests in follow up PRs. I'm happy to help you get reauth working if you have a specific problems errors you want to discuss since I contributed to the google mail tests. This isn't used (it requires additional setup of strings) so remove. We can add back in a future PR. (Aside: the pattern is not to write unit tests by directly calling platforms, but instead to go through higher level integration APIs, though i don't think this has them necessarily since its part of the frontend translations) Where is RefreshError thrown here? Credentials doesn't seem to throw this in the constructor and check and refresh token appears to only call home assistant code not the google auth library. (I realize you've copied this from the existing integration so i have the same question about that code. FWIW i believe i reviewed that also so not passing judgement here) Could it be that it was left behind from a bigger OAuth implementation since we now only declare an AuthorizationServer? Copy paste, here and multiple other times in the PR This does not appear to be used, and can be removed. Pass the config entry directly instead of getting it through auth.oauth session.config entry.entry id then the dependency on auth can be removed from the constructor as well. (e.g. when creating YouTubeSensor the config entry id is used to get the auth which is used to get the config entry id, so some steps can be removed) I think there can be a compressed version of this, something like: I think there are a few things that can go wrong here that would make sense to handle, such as the credentials ended up being invalid or other transient failure with the API, or the response doesn't have what was expected . There are currently error abort reason strings that do not appear to be used at the moment, so either way something needs to be resolved there. What would be a good way to handle these? Because just having a try except with Exception and then just abort with "unknown" also doesn't sound like the way to go Yeah, I'd say catch the exceptions that can happen. If i understand right, it seems like the channels list is queried twice during the config flow, so maybe the relevant details can be saved to avoid 
Double whitespace. It seems that you skipped the pre-commit hooks :( done Whitespace missing... It seems that you skipped the pre-commit hooks :( done Whitespace missing... It seems that you skipped the pre-commit hooks :( done I'd suggest a bit more descriptive parameter name here, perhaps requires auth or authenticated ? I like requires auth, let's use done
Please update the docstring Edited, thanks for noticing
It would be good to add type hints here. Changed! Not needed Changed Not needed Not needed Changed Changed Not needed Changed Not needed Changed Changed Not needed Changed Not needed Changed Not needed Not needed Changed Not needed Since the index refers to something different in each platform, I think it's best if you convert to string in each platform. Its always and integer index in the calling layers. So I only needed o convert it to a string in the base class. Can you please explain why this is needed? I spent a long time adding this check and it highlights an underlying bug IMO Setting up the envisalink platform sets up a watchdog task and a task that retries to connect on failure. When shutting down these tasks are still running and cause a pytest failure. I see many other tests use this same strategy. The watchdog tasks should be cancelled on shutdown. This is a bug that needs addressing in a separate PR. I suggest that you use a preliminary PR for tests task cancellation, then revisit this one. Please take a look at 90782 You could do something similar here, extracting all registered entities and using snapshot assertion.
Are you able to set the entity category? It felt like the entity should show up in the controls section, rather than the configuration or diagnostic section. Omitting the Category appears to be the only way to achieve this, as "Controls" does not appear to be in the entity category definition L1153 Ok, I was looking at the 'kt' air conditioner just below. Based on what you say, this is a more of a functional light than a backlight. Is that correct or does the 'kt' need changing too? With the Air Purifier i have, its a bit more of a backlight (it turns off the LEDs) The way it was worded on the Tuya website, it read more like an overall "light". I'd say its more of a functional light, but neither here nor their about it. I don't have either product or any images, but based on the descriptions it sounds like it should be the same as the backlight below it (name and category). If not then I recommend adding a comment to the code giving a brief reason for the difference. This is partly to promote consistency of whatever might be added here in the future. Updated as requested :)
You could make the dict a constant and save a bit of branching Than you can do Nice one! I will change it that way :) Done in ef47a1af222b45c548a573555a4aaaea09c336a1 Does self. speeds need to be saved? doesn't look used outside this function. Yes, it's used in async update attrs : Also if you want this to work with HomeKit you have to use the constants FAN LOW, FAN MEDIUM, FAN HIGH, FAN AUTO, etc. Someone might ask you for that later ... Ah! Thanks, I didn't know that! So I guess that we could support a subset of the speeds then? Or shall we mix AUTO LOW MEDIUM HIGH with percentage values? Its not so great, but mixing probably is the way to currently offer the most functionality Fan speeds are always hard because you end up with something like: auto low medium 75 high I'm tempted to add support for N to homekit so we can avoid something like that though so maybe best to leave as-is. Done in ef47a1af222b45c548a573555a4aaaea09c336a1 black really could do a better job formatting these type of unions, but nothing we can do about that.
If this switch is for controlling the whole device, would the device name be a better name for this? You are probably correct - I will try to make that change sometime tomorrow
Do we need this as we have the session inside the coordinator? I will remove this We should do coordinator.async config entry first refresh() here Ok Should have the correct possible exceptions and not just catch broad I think this was copy paste, no error should be thrown as far as I'm aware, removing the try-except Already inside coordinator Should be done in init Missing typing Don't think we need to store anything else here so can put the coordinator directly I would prefer if you put this in a coordinator.py file. Ok, will also remove the argument Don't think we need it as we already have the session stored in init Can these calls raise so we need to add a try-block? No, if it fails an error code will be returned (ret) Perhaps change session to session to avoid complains from pylint Not related to adding a coordinator. Please put that in a separate PR which should also implement use entity name and translations If this is not added, the coordinator is never used. So would like to keep this. Of course it is as it adds available etc. at properties the fact that it holds the session used. Adding DeviceInfo should not be in this PR
The point of the new command is that the result should exclude entities which are not recorded. I think that should be covered by the test, maybe set a state which is filtered out by recorder settings? Good idea. added in 81a58cdfddc3ef0b3da00582ec299871eb88ad28
I suggest that you add yourself as codeowner in a preliminary PR. I suggest that you create const.py in a preliminary PR, with DOMAIN , CONF NOTIFY and CONF RECIPIENT . In a preliminary PR you could move this to entity.py SensorEntityDescription could be done in a separate preliminary PR I think BinarySensorEntityDescription could be implemented in a separate PR (preliminary or follow-up) I think you should move this under the DOMAIN key, either as a dict with sub-items or possibly as a dataclass. This constants resolves to "netgear lte hass config" . Much will eventually be moved to coordinator and leave just the notify service using it.
I would remove the device class as it's a setting and not representing the actual state of the battery. Instead you can add unit type PERCENTAGE, and change the icon to icon "mdi:battery-charging-high", Agree, this is not the state of the battery. It's a target. Thanks. Was unsure what this should be - changed as requested
Only thing I dislike is the Wi-Fi spelling. Although they are used both throughout HA. Wi-fi finds 23 files using it in components, wifi finds 54 files. It is following the Microsoft style guides for writing, which we have adopted. It specifically marks the use of "Wi-Fi", as that is the official registered mark for it. See also the redirect that happens on this URL: Right, I can live with Wi-Fi, only the annoying thing is that the entity name is now wi fi, and that looks bad imo I'll make a note of that and fix it in the next iteration. We can just suggest an object ID for that (but that is slightly out of the purpose of this PR).
Something is wrong here. Power is not energy, also power should not be TOTAL INCREASING It's energy (kw h) even if the device call it "cpower". ![image]( Energy is kWh kW h is something completely different. Typo, i wanted to say "kwh" Can you set the units here? Could the units be one from UnitOfTime? Could the units be one from UnitOfTime? If you are confident it is actually energy then you need to change the device class and the unit. This affects how the entity appears within the energy monitoring aspects of HA. Yes it's the energy consumed by the charge, in kwh. Typo: actual fixed Typo: actual Fixed Please put in alphabetical order fixed Please put in alphabetical order fixed Are you sure this is only for EV charger? If not please remove the comment. I suggest adding a comment why this is to be displayed as energy when the key states 'power', if this is correct. Ideally with a url link to the tuya definition. Comment added. Unfortunately there is nothing in the tuya IoT documentation about EV chargers :( Is it definitely correct to include all of these new entities under the group for 'smart energy meter'? I don't know how the tuya integration works, but many of the new items might not be found in a smart energy meter. If this is correct I suggest adding a comment to the top of the 'zndb' section to state that the group covers both smart energy meters and chargers, with a link to the tuya documentation for each. Unfortunately there is nothing in the tuya documentation on EV chargers :( But EV charger use the same product category. Here a screenshot showing that: ![image]( Maybe this text could be clearer. Is it 'waiting for charge to start' or 'waiting for charge to finish'? Fixed Please point to the API documentation for this device category in the comment here. How does this entity behave? Does it count down during charging? Voltage sensors should be disabled by default. A unit is missing in this case? Or is this the total of years? CO sounds like carbon monoxide?
Why do you have two variables that are the same thing? use Platform.SENSOR instead Is this used? Yes it is. You don't need this as you are setting it below your hass.data is a bit complicated, you may want to look into using a model. Look at the lookin integration for an example Don't think it's that complicated, 2-3 key value pairs. Tried to introduce models, but imo it brought more complexity than clarity. Could be that I did also something incorrectly. I'd remove the Optionsflow for now. the shorter this PR is the quicker it will be reviewed by a maintainer. You don't actually have any possible errors. If something can go wrong while setting up - you need to check that here and set it in errors['base'] Why are you setting a variable to a constant? a few changes 1) just directly set native unit of measurement, you will have to look it up but there should be a attr for it. Because it is static, you don't need to do property like you are. 2) Use built in Home Assistant units instead of a constant str you made. I don't see anywhere in the constant fitting unit Eur MWh. Don't set this to an empty string Why are you setting capability attributes? I'm not sure what your data is, but sensors typically have a native value that displays what they are I'm using attributes because the value is a forecast, meaning array of of values (in this case objects). That is not possible with native value as it doesn't work with such format and has size limitations. From what I've seen people either use attributes or have a sensor per array item which I don't really like from user point of view. Instead of doing this class, create your own dataupdate coordinator. look at other coordinator.py files in the codebase for examples. It would be better if this datetime stuff was handled in your api. Imo it's better if the API provides more generic time format like timestamp as it can be used by whoever rather than doing it custom for one use case. set your domain here, no need to do a fstring, makes it more complicated than it needs to be imo. there's nothing wrong with it I guess, but it is just unneeded. As your integration is communicating with a service device it should only be setup via UI as specified in the [ADR]( Please remove this method and all yaml configuration related parts HA is supporting [selectors]( In this case, I would suggest a [number selector]( number-selector). For implementation see also show-form Can be removed as it is only used by the yaml configuration The CoordinatorEntity is handling it already I would suggest creating a class for it. This will improve readability maintainability and also support for type checking. If you are the maintainer of the library, you could introduce the class directly there. Change data type to the new class, which holds the data Can you please describe the reason for this function file? Why you don't do it directly in the init .py New integrations need to be [translatable]( translating-entity-name) Please adopt your 
Maybe type these on class level instead. Why the prefix on just this variable? I would probably have used a dict comprehension. Thou below did look rather ugly :) so feel free to ignore. so feel free to ignore I will Seems like this have so self needs. Maybe make this a module local helper? Why the prefix on some?

Could put this in a second step so we can populate the list? Populate the list with what? We can't fetch all lastfm users :p No idea how lastfm works but perhaps you already have a "friend-list" or in minimum your own account it can be pre-populated with? Yes you can be friends with people. Hmm, I was thinking that it would block adding people who aren't your friends, but now thinking about it, it's possible to add custom values, so that would solve it Doesn't look like we need a copy? Should we consider putting it in options instead and implement options flow so the user can edit the list easily? Oh right, forgot to add the OptionsFlow Put it where it belongs e.g. config flow I think I saw this at another integration aswell. In the future we can use this in the repairs. Or would you suggest moving it to config flow.py now and moving it back to const when it is used in multiple files? Move it to const when there is use for it in multiple. Where can I find these guidelines? Not sure it's mentioned anywhere but for this it's always 2 releases so it can be in .6 and therefore it can only break earliest in .8 I think you should revert this and create the api connection in the setup as it was before. And pass the User object to the sensor? What if the user deleted their account? Are there any integrations that have good ways of handling individual entity failures? Probably use the available attribute and set to false if the user is not longer available (for some reason). If it's the main user account you should raise ConfigEntryAuthFailed and setup a reauth step in config flow. But I guess it would make sense to implement a data coordinator after this PR so you refresh all users in one go and the coordinator can then help out with the entities instead of each entity having an api connection. Uhm, we tried implementing a data update coordinator, but we reverted it at the end. epenet will find the PR when I'm on my PC Perhaps it doesn't make sense with a coordinator but still think you should revert this change Do you have a good example for integrations that go well with unavailable entities? Before this MR, the sensor is created by passing the User object at construction. But what if the situation is that the user did not exist? Then LastFMNetwork.get user() would throw an exception, and I would not have a User obejct to pass into the sensor. That's why I put this logic this way but not sure how it can be better I need to correct myself here. I can do api.get user("non existing user"), but then I'd get an User object which can't be used to make calls. In the setup of the config flow (line 38) I call .get playcount() to get pylast to throw the exception. So I think I can just create the sensor with an User object, but it wouldn't be a usable object, but then I'll move the validation part to the sensor You can put both these functions outside of the class and skip this base class all together Use [OptionsFlowWithConfigEntry]( L1881) instead Make a [list
we can return early here if there is no tilt support ? This is already done in the second PR: - [condition for lift]( diff-4b2b22eb334827e09a3d8dfdd0e35111a6534495741a49727962c2186d6f3847R161) - [condition for tilt]( diff-4b2b22eb334827e09a3d8dfdd0e35111a6534495741a49727962c2186d6f3847R181) this is going to cause issues in the long term. Now the required attributes are too generic. just add multiple schemas for the possible combinations. so add one schema with CurrentPositionLiftPercentage as required and CurrentPositionTiltPercentage as optional and one schema the other way around. What about this: yeah that is very complete, let's do that. Thanks Changes applied! The is closed attribute is only concerned with the main up down movement of a cover. are you sure ? what about a tilt only cover ? There's an architecture issue opened recently about this. We don't currently have a way to represent this. ah yes, true. Should I modify it? or can we leave until the issue is solved and then modify it? Best to remove it so we can merge the PR. omw
I think we can just use a default in this case? You could just use CONF PORT that we already have in homeassistant.const I considered that, but it's important that this is identified as the SIP port (as opposed to other ports we may let the user configure in the future). We should only show this if a user is running in advanced mode. Most users shouldn t care. The other reason I am not a fan of this option is because it makes the tutorial harder. What is driving this feature? Port collisions (already reported during beta) How about moving this into an options flow instead? We can keep the initial setup clean of it that way. This seems to be misplaced at this point, as this is now part of an options flow, not a config flow. Ah, thanks!
Duplicated code. Maybe refactor into a helper function. I am not happy with this "heuristic". I would prefer an explicit check against the known ids "Network:Hostname" and "Hostname". Maybe something like this: Missing error handling if no hostname id was found. If this unlikely event happens hostname id is undefined and an exception at line 45 is raised. Hi stegm I have updated some tests now and they currently pass. I don't think it is correct to return "Network:Hostname" in case it fails but I'm not sure how to get the tests to pass otherwise. I'm not a developer just trying my best here :) Hmm, I think mocking the get hostname id is not necessary nor should be done in the first place. Maybe I prepare the test changes for you. See review comment for details. Not sure: is this except block actually necessary? I added before you updated the tests since it failed otherwise for me, I have now removed the try except and added a raise error in case it fails Thanks, I have added this now Either you have to handle the None case in every usage of this function explicitly or you use an exception here. I think the later would be easier as this case should not happen at all. I removed the try except and added a raise ApiException("Hostname identifier not found in KNOWN HOSTNAME IDS") instead. Is that ok?
5 sec of scan interval is very low, why ? Today I get Freebox s sensors using Node-Red and MQTT. The polling interval is set at 5 secs and it s working fine. Using a lower poolling frequency will cause somme issues if the sensors are used with an alarm system Label ??? At what it refers ? To use enum values not hardcoded string and remove lines from 53 to 55 async add entities should be call only once. So the API returns true when there is no detection ? choose the correct return value This file should not be modified, the code here is not related to the PR purpose. async add entities should be call only once. Why are you managing tracked devices ? You are in a setup function called only once. In case of you reload the integration ? Create identical sensors twice don't create them twice, but keep only one ! I don't think you need to keep track of devices that sensors are created. Why are you managing tracked devices ? You are in a setup function called only once. In case of you reload the integration ? Create identical sensors twice don't create them twice, but keep only one ! I don't think you need to keep track of devices that sensors are created. Change camera.py:L53 to use FreeboxHomeCategory.CAMERA You did not add those categories compatible with HA in this PR You did not add the alarm HA platform in this PR. This const isn't used ! You should use StrEnum from Python 3.11 enum.StrEnum : enum.StrEnum
Why is this not a binary sensor ? The documentation describes the binary sensors as "This can typically be one of those batteryless wall switches". "EnOcean binary sensors have no state , they only generate button pressed events." The new device is not a user actuated wall switch, and it most definitely HAS a state . It is essentially the same as the window handle (minus the third state). Personally I find the naming scheme a bit awkward with binary sensor and sensor, but that's not my call. IMO the documentation is misleading. Just because the current EnOcean binary sensors do not have states doesn't mean that you can't add binary sensors with a state. The 1BS D5-00-01 device should really be a binary sensor, and the documentation adjusted accordingly. The code fits into the "sensors.py" very easily and IMHO is well placed in that file. "binary sensors" only serves the one wall switch protocol. It does not have state, nor does it have device classes to differentiate between types. To keep the code clean, I would rather propose "binary sensors" to be renamed. Just because it's easy doesn't mean it's correct. You are adding a boolean (Open Close) sensor, so it should be added to the binary sensor platform.
Comment? :see no evil: This code could benefit from using an event handler design, where each event has a corresponding handler function. We look up the correct function using the event type. We have this util to help with designs like that: L11-L22
You can wrap this on self.async on remove instead I'm sorry but I do not understand what you are suggesting, any chance you could be more explicit? What is the "this" you are referring to, and why would it be better in a different function? Thanks for that example, that's helpful. I think that would be good suggestion if we only unsubscribe when the alert is removed, but note that we also unsubscribe resubscribe in async update config , in case the entity that is being watched changes. So I believe I need to maintain the unsubscribe pointer so I can call it in that case? I did add your second suggestion about cancel the notify on remove, good catch. You could do like this, then you don't need to remember unsubscribing from async will remove from hass I feel like this will not work? If I push self. unsub to the on remove list, and then later call the reload function with updated yaml (say changing the watched entity), I then need to unsubscribe and register for a new watched entity change, and save the new unsubscribe function. But the original unsub function will still be in the on remove list. I would need some way to remove that function from the on remove list and replace it with the new one when I update the entity. I don't see a good way to do this. Given that, I think I prefer it how it is? This is the same code as in init , can it be moved to a helper? Moved to update from config helper function. This is the same code as in async added to hass , can it be moved to a helper? Moved to update with hass helper function. Let's remove this implementation until alert also supports a storage collection I'm still new to python so maybe missing something obvious, but when I don't implement this I get complaints that a class that inherits from CollectionEntity must implement a from storage function, and that function must return an Alert object. If I remove the implementation, how to satisfy this? Remove this See other discussion about from storage , I can't remove this until I resolve that discussion. (otherwise I get code coverage task failure)
The state must be non numeric. Is that the case? The class docstring indicates otherwise. The docstring is misleading. The value is numeric because it's the key for the state, but the state translation is a string. Right now the only values that would become ENUMs are Notification CC values that have states
It's a bit weird to sprinkle asserts here. If the point is to make sure fetching the language list was successful, replace the asserts with clear prints of what's wrong and then exit the script with a failing result code. If this is a leftover from developing, please remove the asserts. I added tests for Microsoft TTS, since there currently were none, adapted from the tests for Google Translate TTS. Moved these assertions to the tests. What if this page changes layout? I think that's fine, the script is run manually, and is meant to make it easier to regenerate the list of supported languages as I understand it. Please move the microsoft tts tests to a separate PR Moved to PR 92215 Please move the microsoft tts tests to a separate PR
We should not show the time left. That is a calculated value. Instead, we should use the values provided by the device. I assume the fact that the app shows the user the calculated values doesn't change anything? Roborock recommends replacing the consumables every x hours - as far as data goes, the time left is more useful than the time used as most people won't remember the amount of time that a consumable can be used for before replacing. ![image]( I'm fine with changing it to the exposed value, I just wanted to ask for clarification sake Thanks! I will discuss this a with some other core devs later this week. Will get back to this. I went ahead and made the change - and if you think it is best to just do work time instead of time left, then I am all good with that! Ah I posted that comment as soon as you sent that. Sounds good - I will leave it on this corrected version and I can just revert it if you decide the other way is okay. Thank you! Lash-L The main point is that we don't want to have calculations in the home assistant integration. If you think time left is more suitable, you should update the library to provide that. If work time is good, that works too. I think time left is probably more suitable that way someone can get notified when they are x hours away from needing to replace a consumable. I'll change the library to reflect that. Thank you! It is now being done in the library These seem like the should be diagnostic sensors. I checked xiaomi and it also uses these as diagnostics. Makes sense!
Make this an issue instead Ah, TIL. For some reason I'm not having luck getting the issue title and description shown in the UI, only the deprecation breaks in warning is there. I did run python3 -m script.translations.develop --all . Make this an issue instead As above. Repair issues for deprecated service calls should set is fixable True and is persistent False to enable the user to fix the issue when they have updated any automations or scripts that uses the service. This function could be stored in an attribute on the button entity description. Then we'd only need a single entity class. We normally define entity descriptions as constants stored in some container at the module level so we can iterate over them or look them up when creating the entities.
We don't have to preform calculations anymore. Instead, use the provided native value, and set the matching native unit of measurement. If you want to default it to kWh, set the suggested unit of measurement as well. I have changed the unit of measurement to Wh with suggested units kWh. I have changed also all other energy sensors (so I kindly ask Nicolaas for new review). Since the suggested unit of measurements I think there is no need to change docs. frenck klaasnicolaas Do You both agree?
Move this one to the class variable as: It is assigned when used, allowing to remove asserts as well.
Why this is called here. I can understand calling below async send message but after setting. do we really need this? I created a test entity and then changed its value to test the condition for the notify service. I think it's an easy enough way to use a condition, but i am open to suggestions for better ways to do this if you have any. Or do you mean async block till done() ? In that case, I want to make sure that the state is changed before calling the group notify service, so that the condition for service1 is properly evaluated.
This seems like a vague name, maybe name it "Power failure alarm"? Same comment as above about this possibly being too vague Since this is not a control but a sensor, should the states be "muted" and "unmuted"? There is a physical mute button on the device, This entity is used to show whether the device is in silent mode Same comment as above about this possibly being too vague Same comment as above about this possibly being too vague Since this is not a control but a sensor, should the states be "enabled" and "disabled"? Our API does not support change the settings of the beeper, but the mobile application can , this entity is used to display the status of the beeper
States are limited to 255 characters. This will cause a problem if there are many a records Hi. A IP is max 15 characters (if all ip-tupples are 3 characters) 100.100.100.100. That leaves us with 17 A-records. That is waaaay higher that I've ever seen. Max I've seen in the wild is around 8 (Heroku LB's) So I do not think that will be a problem. Should probably put in a limit anyhow
You could expand the entity descriptions and put these functions there so instead you would have await self.entity description.button fn(self.hass, self.device.appliance.haId) only here gjohansson-ST tried it, but then I get follow error: You need to mix in your own key's See [here]( L27-L42) an example which is for switch but similar can be applied for this button Ok added the mixin. But don't get this error This is the same like here: L162 gjohansson-ST DavidMStraub, can you tell me what's wrong with this two lines? It looks like you're calling the method on homeassistant.components.home connect.api.HomeConnectDevice rather than homeconnect.api.HomeConnectAppliance , which is stored in the appliance property of the latter. DavidMStraub yes thats the issue I see. So then i can change it directly to the HomeConnectDevice from the button directly. So this should work, right?
config[CONF TYPE] in [TURN ON PLATFORM TYPE, TURN OFF PLATFORM TYPE] is better and readable way of saying 'it should be one of TURN ON, TURN OFF types'. Thank you. That's much more readable indeed. Again should be config[CONF TYPE] in [TURN ON PLATFORM TYPE, TURN OFF PLATFORM TYPE] . This file is 99.7 similar to turn on.py . You should reuse the code not duplicate it. I think I'm too dumb to do this. I got little to no Python experience. I really tried though. Would you mind doing it yourself? I can give you the needed permissions. Thanks for the suggestion but it's a lot more complicated than that. For example, I have to refactor attach trigger, media player.py and triggers.py. I just spent 2 hours trying to do it, and it ended up not working. I'm pushing my draft changes if you want to review them.
you can use the [ client context ]( L91) from homeassistant.util.ssl to get a ssl context - like: we should also catch possible ssl.SSLError in validate input to show the user a proper error message. Further, the CONF SSL CIPHER LIST needs also to be considered in validate input . I have tried that, but it is catched some how by the aioimaplib library. Whan SSL fails it raises an asyncio.TimeoutError , that is not enough to present a proper error. We could catch that and present an unable to connect , but that is already shown by default. We already catch that. reference: Can we mark it as advanced to only show it for advanced users? We need to check self.show advanced options and update the schema dynamically.
Gas measurement changes about every 5 minutes. Would it not be better to have a seperate sensor. It could be disables by default. A pre-disabled sensor would do, but it was 'rejected' on initial release discussion r776924496 For the user there is little or no extra information, other than knowing the exact timestamp. For most users the 'Last updated' will be sufficient. Right, using state attributes is even less appreciated AFAIN. IMO it makes sense to have this info. A pre-disabled sensor would do, but it was 'rejected' on initial release [ 55812 (comment)]( discussion r776924496) I think that comment was about what this provided instead of the entities normal last updated . I suppose this is a more accurate fetch of when the number was retrieved rather than when the entity updated. This should still be a sensor and not an attribute and I think disabled by default. When is this updated?
Is all the data json-serializable?
Why isn't this a select entity? Good call - Wasn't something I thought of at first but definitely a better solution - I have made the change. Same as the above Update device.py to schedule a coordinator refresh on send command. So commands update status right away Good call - I used async request refresh. Why is this setup limited? Why not just up the full integration? Limiting the integration setup makes the tests match reality less. For example, if the select vacuum platform would have an issue when loaded together (whatever side-effect), this would mask that. IMHO, this should not be needed. .. Frenck Same We should avoid using getattr , instead, extend the entity description with a lambda (so we can keep it correctly typed). We can use a list comprehension instead. async add entities accepts a generator. Seems weird we have to look this up every time, while it is actually pretty static. Maybe add it as a lambda to the entity description? What if this call fails? Hey frenck, I'm actually not sure what best practice is when the call fails. I tried looking at other select.pys to see what they do and most of them just call the command. What is best practice here? I'm happy to implement it. We need to catch errors and throw an HomeAssistantError if the calls fails, with an message in that error that can be displayed to a user. All other raised errors are not caught handled upstream. Fixed :) Thank you for the pointer No need to store this, we can just access it directly This seems to be unused?
A lot of these catch clauses are very similar. You could catch many of them in a single except block (or perhaps just catch smtplib.SMTPResponseException which all the exceptions with smtp code and smtp error derive from), and include the exception type name in the formatted strings (e.g. type(err). name ) without losing too much logging information, and reducing the verbosity of the code a lot. You're right, I was able to drastically reduce the code by just catching them all at once and dynamically setting the messages based on the exceptions. I figured I'd still catch the four that have smtplib.SMTPResponseException as their base exception so that I could reference them specifically by name. SMTPException is the base exception class, so you don't need to enumerate all of these exceptions, you can just have the generic one, and name should still return the correct class name You're right and I had indeed considered that, but I decided the extra few lines were worth the added readability and maintainability. Enumerating them all could make it easier for others in the future to understand which exceptions were considered when I wrote the code, so adding additional functionality for one of the specific exceptions might be easier, if for example they could instantly know the code does not handle some other exception. Only catching the base SMTPException could make the code less clear. This was effectively the problem I was remedying in the first place, since the original code just showed it catching a single exception and it took extra time to figure out how it related to the other ones. raman325 is probably right here to catch only the base exception as if other errors are added down the line it's still going to get caught as the base exception is in the list. Don't think the list of exceptions provides any necessary value as you want to capture all of them anyhow to provide to logger output. agreed with gjohansson-ST - it's clear from the code that you've made the exception logging generic for all types. If you are concerned about readability, you can also add a comment that just says this is the base exception class and that details will be logged, but it took me all of 30 seconds to understand that was your intention.
Wait, programs are switches already? Switches already have services? Why do we need these? If anything, we should deprecate the start program service IMHO? Maybe I'm missing something, in that case, I'm happy to hear the reasoning for adding this service. frenck The stop is an own (DELETE) REST endpoint see It just stop the active Programm when the machine is running. It s not switching a Programm. Because if you run and switch the Programm it will not stop just pause. That s a different. If you want to stop you also need no switch or the active Programm this is just handled by the home connect backend. Pause Resume works different. Not sure why we should deprecated the start service. In my own HA UI I don t use the switches. I use input selects for Programm and Temperature and use the start service to start. Just missing the stop service to stop the machine. My UI is more like the home connect app. With the switches you can just start and pause the Programm, but you cannot stop and you cannot change the temperature. frenck still seems to be right as what you are trying to implement seems to already be part of this [switch]( L47) No see here, it's different. Also if you not use the switch. Or I don't get it, how you can use it as service. I just have a button to stop the service, but currently there is no service for that programs stop program Example: img width "389" alt "Bildschirmfoto 2023-04-22 um 14 24 57" src "" For the button stop, which service can i use? There is just home connect.pause program , home connect.resume program , home connect.start program and after this PR also home connect.stop program So, even if this is the case: I just have a button to stop the service, but currently there is no service for that It should not be a service, but a button. Either case of the discussion, this PR isn't correct. Why is the resume and pause a service? For me it make no sense that everything is a service but the stop not, why is the stop missing? The button is just one case, what do you use for a script or automation etc.? And how I said look not consistent if everything is a service like start, pause, resume but the stop not. Why is the resume and pause a service? History maybe? But that doesn't mean we allow should introduce more things using incorrect constructs. The button is just one case, what do you use for a script or automation etc.? The button. History maybe? But that doesn't mean we allow should introduce more things using incorrect constructs. mhm maybe? But then we can change all together, see no big deal for that. I have no idea why the pause resume start is not a button. I see its currently a service, so for me it was just consistent to do the same. But also okay todo all with a button, but why do not create a issue for that? Then its consistent... I have no idea why the pause resume start is not a button. Probably history before we had button entities. I see its currently a service, so for me it was just consistent to do the sam
Why call this again? It was already set up if not node.is controller node it's needed for controllers too but I take your point These should all be disabled by default. they are in the class definition, but will add to the ED Same. If we need a special entity that has these attributes already set we don't need this in the description. Alternatively raise ValueError with the message, as it's a user error. should it be a ValueError or HomeAssistantError ? We currently use ValueError for bad user input and HomeAssistantError for api errors. The entity always writes its state at the end of entity addition. Move the log message to the exception argument.
It seems you do not refer to the payload from the config schema here, further you should assign DIRECTION FORWARD , DIRECTION REVERSE or None when assigning self. attr current direction True, should be fixed now May be we should define direction on and off payloads as we do with oscillation? Yes indeed. Added in the update, with tests. Also the docs PR is ready for review That was a python syntax trick that I was not aware of, thanks for the suggestion! Can we split this string to avoid long lines and make ik more readable? Fixed with a multiline string (added in a separate commit). same here And this one
Due to big change, I've added myself if you don't mind. Grabbed from L391-L494 I think in future PRs we can add the ability to customize this list for users in settings, as it was done in the old Android TV integration. I don't see much benefit having this list. In fact I see more downsides. I don't want to get into the business keeping this list up to date or have to review PRs that add their favorite apps. Also what happens if an app gets renamed and we have to update the list here? That would be a breaking change. If on the other hand users reference the package name in their automations, which by the way is less likely to change than the app name, it would be a breaking change not caused by Home Assistant. Yes, I agree with you, I removed the list. But what do you think about the ability for users to create their own list in OptionsFlow , as it was done in the old Android TV integration? We can do it in the future. Or is it useless? Does this do anything here? I thought this is meant for platforms. Good point. Per creating-the-perfect-pr could you do the refactoring in a separate PR? It seems to me that this practice is used here (move common code into a common class) when a new platform is added. In any case, to avoid duplicate code in this PR, can we keep this change? Include name (from entry.data[CONF NAME]) like the original log message. IP address isn't meaningful to most users. Done. Good point. Similarly per creating-the-perfect-pr it would be better to extract these changes in a separate PR. This is a necessary change to test the new platform, as the previous solution did not work correctly when adding more than one callback. The API returns volume info["max"]. Why not use that? For my devices I think the max is 10 or 0 because of soundbar, more on that below. Also if I remember right often the level and max are missing and I think are set to 0. Can you run demo.py of the underlying library and watch the volume logging when the device turns off? I think that's an instance they are missing. Another instance might be if you have connected a soundbar and you have setup the volume to control the soundbar via HDMI CEC. You have VOLUME STEP support but not VOLUME SET. Not sure if you can detect that and not include VOLUME SET in the supported features. Maybe if max is 0 remove the VOLUME SET and if is non 0 add it? I added checks and make floating VOLUME SET in supported features. Is this going to throw not defined if this function is called before we get the volume info updated callback? Since now we have a floating VOLUME SET Home Assistant will throw an error that the service is not supported if there is no information about the volume. This needs to use volume max instead of 100 Good point. Is this really needed? If yes can it be shorter? Should there be a mutex lock in this function? If async set volume level is called multiple times while previous ones are still running the final volume will be unexpected. The delay is needed, because

This doesn't seem to be used, can it be removed? Move this up before RingDoorButton. RingDoorButton is used in RingButtonEntityDescription cls argument so it needs to be defined like it is to avoid a NameError . Move this to before async setup entry Can we extend the tests to test this? Can we add the new sensors to the tests?
Thank you for your reminder, I will modify it You should be using the constants in homeassistant.const, also typing Edit: or just import from const Thank you for your reminder, I will modify it So you reference the platforms here but don't use them in init.py? Thank you for your reminder, I will modify it Maybe you should check the connection state in some global way? Because the Connector integration obtains the motor list through the HUB local UDP interface (the HUB and the motor communicate through 433MHZ), it is impossible to judge whether the motor is available through this interface, so by default, as long as the motor list is obtained, it means that the motor is available Same here Because the Connector integration obtains the motor list through the HUB local UDP interface (the HUB and the motor communicate through 433MHZ), it is impossible to judge whether the motor is available through this interface, so by default, as long as the motor list is obtained, it means that the motor is available Should there be anything in this field? (If not, feel free to close this) Thanks for the reminder, I will delete this line Instead of this, define a dataclass which you store in hass.data[DOMAIN] which has a reference to the shared multicast listener, a dictionary with data for each config entry, etc. This needs to be handed off to an executor to not block the event loop: Why is this needed? Does it block shutdown of home assistant if we don't clean up? Either make this private or move it as an inner function of async update data Is it enough to only update once per hour? Why do we sleep? When does this fail? Should we retry, or ask the user to confirm the login details? Do we need to handle other failures? Why do we allow the user to input multiple hosts instead of creating one config entry per host? This effectively makes the integration a singleton config entry, can't we handle multiple config entries instead? This is not a good name IMHO, maybe HUB TYPE DEVICE CLASS MAP would be better? This should be stored in a dataclass object instead. If this happens, what do we do? Should we inform the user? You don't need this, it's already in self.platform.config entry Can each host only have a single cover? Also, this can be simplified: Remove this if availability is not supported
We shouldn t use this. We should forward config entry setup I'm forwarding now, but after loading the Wyoming info from the endpoint. This is to avoid loading it multiple times, once in each platform. Moved the info loading into the config flow. Forward the unload config entry Why do we store two addresses? Shouldn t it be one address and based on a capability query we decide to forward it to to STT or TTS? Storing just host port now Remove TTS support from PR until support for config entries has been merged You should ask for the URL Asking for host port Use new config entry support Shouldn t this be queried via capabilities? Maybe eventually, but 16Khz for STT is a hard requirement in Rhasspy for now. Remove from this pr and will be added in own pr Let s drop options flow from initial pr. When added back, it should only support updating the endpoint. Each config entry is a single endpoint. you should only unload platforms that you loaded. Better just collect a list of platforms to be set up, and then call async forward entry setups with all of them that match. You should get the info to ensure that the given host port can be connected to. And use the name of the endpoint as the title. Replace these with host and port . Use key references to load translations from the common file. Remove this. Don't write to hass.data here. No need to store it. Create an entity and add it to async add entities passed into your function. See for example the VoIP binary sensor No need to pass this in. Will be set when added to HA You need to inherit from the SttEntity. Don't abort when you cannot connect. Instead, make that an error (see scaffold) You don't need to add Wyoming to the title, as it will always be presented next to the name of the integration This one should stay an abort as the endpoint is valid, but not supported yet It's not internal. extend HomeAssistantError since you are raising it from HA defined methods. hm, should this be stt.SpeechResult(None, ERROR) ?
Use a select instead to specify the options they can use Use a datetime instead to provide date and time Should raise ValueError when users are providing faulty values end datetime is not optional
This would pass a callback function to async create task ? No it shouldn't: see the double () in the pop. Would that be clearer? Oh right.
condition seems to provide state translations in the new translation file. Is this a fixed known list? If so, the sensor needs to be marked with an enum device class and a list of possible options needs to be provided. conditiondetailed seems to provide state translations in the new translation file. Is this a fixed known list? If so, the sensor needs to be marked with an enum device class and a list of possible options needs to be provided. It's a list embedded in the lib. Do you have an integration which does this so I can look at that as an example? All integration that use SensorDeviceClass.ENUM The double underscore indicates it is a private constant and should thus not be used externally.
zry98 please remove the comment with the TODO linter fails specifically because the indentation, but that kind of comments are not common practice around here Removed These should be button entities, not services. Changed to buttons. Shouldn't this be I used Any here since there are other types of params for other commands (or devices), should I limit it to Consumable now? I used Any here since there are other types of params for other commands (or devices), should I limit it to Consumable now? frenck What do you think? I used Any here since there are other types of params for other commands (or devices), should I limit it to Consumable now? zry98, right now there are only 2 scenarios: method press params None for previous XiaomiMiioButtonDescription items, and the new ones from this PR, which use Consumable , so the suggested typing by Franck is the good one: method press params: Consumable None None (you can just press the 'Commit suggestion' button to accept it ) Use f-strings instead: I followed the code style in the same file, I'll change it. The entity name isn't used multiple times... so assigning it seems unneeded. Same as discussion r1174441079 The service call above is already blocking Same as discussion r1174441079 Same as discussion r1174441079 Same as discussion r1174441079 Remove the Any import now that method press params: Consumable None does not need it Done Please keep the list sorted . Please use f-strings instead of string concatenation. Please freeze time instead. Eg: L16 Freeze time instead per above.
Note; Contrary to the Debouncer, where I went with a RuntimeError if there are subsequent calls, I went with just ignoring the call here. super().async shutdown() and leave name? Oh, i see you went with non async version. Ok then this is okey. Resolved: now uses async version Please break out duplicate code into async unsub refresh(self) - None This is in unschedule refresh and unsub refresh Found a few more instances, so created a preliminary PR: 91573 This change should get its own PR. Agreed - now that async shutdown is async it can be done in a follow-up PR. We should also call async fire time changed to make sure it doesn't fire again to guard against future refactoring errors done
Put this above the setup methods I cannot, since that leads to StarlinkDeviceTrackerEntityDescription being "unresolved". Use translations Don't we need to unpack as it does with status? It works fine on my end without unpacking it. It would throw an exception otherwise right? I'm not sure but does this raise if location data is unavailable e.g. not turned on in the app? In that case I think it should be it's own try-block and add to the data so we don't destroy status if this is not available. It doesn't appear to raise, but it will if Starlink is unreachable (status would fail then too) It's probably a good idea to separate them anyways, just in case there's some API change in the future This separation doesn't make any sense as it would result in the same thing. I was more thinking that if location raises we could just "ignore" it and continue e.g. only return status with an empty location or something like that. But if it doesn't raise (I think you can test by turning it off on your own device?) then just put it together again as it was (to avoid duplicated code) Reverted
Just set it equal to the coordinator. A one item dict is unneeded. If you plan to have multiple pieces of data in hass.data for your domain, create a model. Not required - but best if you can remove Any where possible and specify it. You already have specific exceptions, you may as well just have them raise and then catch them outside your validate function rather than having an extra intermediary exception in my opinion. This is probably fine as is though. remove comment This seems like functionality you should only need to do on startup on expired credentials. Is there anyway to avoid doing this? Again login each time you need data need to perform an action seems very redundant and seems like how you would get your account banned. Every 10 seconds you are logging in to update for the coordinator and then everytime you open or close it you are logging in I'd create one instance of Linear() that holds email,pass, client session, and a list of device ids or whatever other information you need and I would add this to the coordinator Then whenever you need to do anything, you could do self.coordinator.linear api rather than repeating this code so much and logging in so many times. Hi Lash, I don't believe my account would get banned, as I have been testing this with my own doors for about 2 months now and I haven't received any disciplinary action. If I could, I would make this a Cloud Push integration, but there's a weird bug where Linear just stops sending events entirely. I'm worried the same would happen if I had a constant WebSocket open, it would stop sending events and it would break. Right now you haven't. But unless if i am misreading something you are logging in 17,280 times at a minimum each day since you log in each time the coordinator updates. and the coordinator is set to update every 5 seconds If 100 people used this integration that's almost 2 million additional log ins a day. 1000 users, almost 20 million. They will probably have to investigate why there is a massive increase in usage of their authentication server and why it is under load, while there has not been a corresponding increase in customers. Then they will either ban accounts or build some functionality to stop you from doing it how you are doing it right now. That is my opinion at least. Given that they haven't updated the app in over 2 years, I think the team that develops the app doesn't care for their app anymore :( I agree this is a valid concern, and I also don't think there's any reason to poll the state of a garage door every 5s. Please decrease it to something reasonable, maybe poll once per minute? Logging in every time the cover is actuated seems OK, that won't happen often. You can remove the unneeded ones You should patch locally instead of globally. "homeassistant.components.linear garage door.Linear" do this for all of your patches This is very short, 60s is more reasonable to avoid flooding the API I think you can just omit this since only the "GDO" sub-
Should we call this SSLCipherList ? I thought of camelcase at that moment, but when I look at ssl.SSLContext than I would agree with your suggestion will change it later
Please remove it, as it is not required. The token is never validated and not used in the config flow. Do you think we should remove it? good point. I had this idea that maybe users would like this to be configurable via HA UI but as it is now - line is indeed useless New integrations entities must support [translation of names and attributes]( Please adopt your code accordingly. Can you please add a link to this library's source to the description? Please also update the information on pypi.org to include a link to the source.
We should have the attribute consistently available, otherwise, you'll end up checking if the attribute is present or not in templates. We should probably exclude this attribute from being recorded in the DB example: So, I've followed this example, but I'm really struggling with testing. I've added tests for the exclusion in the recorder, but they're presently flaky for some reason (device trackers does show up sometimes) and I'm not sure why. Could use your help advice if you have any.
We are generally moving away from json because of performance reasons. We should use homeassistant.helpers.json here I can take a look at the json helpers api, but I'm using this here because it's actually how the existing to json Jinja filter is implemented, and would be worried about introducing quirks by using a different API. Looking at it a bit, it looks like the helper version is made for serializing home assistant objects and handles things like custom types, date encodings, etc. I'm not sure that's the right fit for Jinja, but open to input. Even using orjson directly would be fine. The performance issues are with the built in json lib Got it. Will explore making the change. As far as I can tell, orjson doesn't support the ensure ascii option or arbitrary indentation (anything other than 2 spaces) for pretty printing and includes a bunch of new semantics for various data types. Switching would be a breaking change for existing to json users. I suppose we could support the legacy options by using the old library and limit the new options to what orjson supports, but it feels like switching libraries may be beyond the scope of this change. I think we should switch libraries before making this change since it will increase the size and scope of a future breaking change otherwise It looks like ensure ascii is the default . While it makes sense for historical reasons that's not very friendly to users who's language isn't primarily represented by ascii FWIW, I think it's ok as a default since it just makes the serializer dump those strings using Unicode codepoints (e.g. uxxxx ), which are the most compatible option supported in the json spec. But if you prefer to migrate first I can close this PR and make a migration PR. It just won't be possible to cleanly migrate sans breaking change without introducing a differently-named filter. Also, features like preferring ascii and custom indentation formatting won't be supportable with orjson. But we can get somewhat close. I took a look through the community forums to see how people are using this function and I didn't come up with anything helpful. On one hand I'm not sure that its even used enough that performance is a concern, but I don't want to hamstring us later since its almost always worse to make a breaking change later. My biggest question would be whether the quirks of orjson are the ones we want to live with in the API -- Hyrum's law and all . It seems at a glance like a fairly inflexible API (sacrificing some usability and flexibility for performance, which is often the right trade off as internal implementation detail but maybe less nice for developer experience) and would take things like uuids and datetimes without a straightforward way to turn those features off -- quirks we'd need to support in perpetuity. One way out of this would be to deprecate the existing to json (leaving it in place but deprecated not recommended) and replace it with as json using the new library. The existing 
Using config flow requires that you implement tests for it with 100 coverage: testing-your-config-flow tests added It's recommended that you make a pull request with a single platform: 5-make-your-pull-request-as-small-as-possible Not just recommended - but I'm pretty confident required for new-integrations removed sensors, binary sensors, and buttons so only vacuum plattform is left now Remove this - yaml is no longer supported for new integrations You cannot change this in your PR ups, reverted now (changed it only for testing didn't had enough ram) I believe you need tests in this file as well, did you manually add this? It should be auto generated yes added it manually, removed it now Okay I'm going to make this comment here but it affects a large majority of the code. You need to create a new pypi package to handle communicating with the robot. 4-communication-with-devicesservices Then you should create a coordinator (There are other ways to do it - but this is the easiest imo.) You create that coordinator in async setup entry in init, and you set hass.data[domain] equal to it. Once you do that, you can acess the coordinator anywhere you have access to hass, and you should make your vacuum entity a coordinatated entity, so you can use the coordinator to update, rather than logging in and accessing it directly through the robot entity. i managed somehow to over-read this, will start creating a pypi package (sorry i clicked on request review by accident, can not undo it somehow) If you fail to get the information you need from that request, you shouldn't just continue setting it up anyway, the setup should fail. This should be in your pypi package This should be handled in the coordinator
Use PRECISION HALVES Remove RestoreEntity if you don't want to use get last state(). If you do, you can implement something like this: Already none Actually setting attr hvac mode is required: AttributeError: 'BroadlinkThermostat' object has no attribute ' attr hvac mode' Do we need to restore the state? Is the state not pulled during setup? Given that the thermostats do not have the best connectivity in my experience I do see a benefit adding it. But when there is no connection, the entity is not available (see L49-L53) so I don't see here any advantage of the restoring it. Removed it Otherwise your code will raise errors Are we sure that all these keys are present in the dictionary? If not we would suggest using .get to avoid KeyError Good catch At least with current version of broadlink external module all the fields are returned unconditionally: L64 Please invert the inheritance order.
Maybe convert play media to a async play media and than run the fallback in the executor instead so we don't have to jump back and forth Did this partially in [51dec6d]( since there are quite a few sync calls in the original method. Makes sense
May be we can just pass kwargs as parameter array, and we could do for every command template? emontnemery what do you think? jbouwh That is maybe also a possiblity, but in that case it is needed to make a copy of the complete kwargs dict before making any modifications, like done at: L759 Otherwise the information that is currently provided is missing. Since to goal is to know if the brightness was provided by the start of the action or not. Other impact is that the documentation needs to be updated with all available arguments and this needs to be kept in sync if in the future more arguments will be added. So maybe this makes it more complex from a documentation maintenance point of view. If kwargs is used a source that value will still be available. In the template you can check for the existence of any parameter. But in this case brightness will be set always as there is a condition check at L809-L812. diff-5349a6ce9c2c784e9fd69377eec96061257d838e33c937e671e9f99aa5ddba06R809-R812 I'm familiar with Jinja2 templating, but thanks for the information. Problem is indeed that the kwargs object is changed depending on the other options (the line I refer to) and later on used for other conditions (the lines you refer to). So brightness is always set in this situation and therefore not usable. So only when a copy of the dict is made at the beginning or the dict is not changed anymore it will work. kwargs is not changed and could be used as parameter array for to command templates IMO. The problem occurs when on command type is configured to brightness and a on action is done (so no brightness provided). In that case this condition is true: L751-L759 and the kwargs object is changed, because the brightness key is added. This is done before the template is processed. To prevent I'm wrong, I will do a small test later today. Thanks for your quick replies. Okay that makes sense, lets see what emontnemery thinks It's not clear to me why this is needed, it seems the light has a problem because when you attempt to turn it on, the brightness is set to max instead of to the previous brightness? Have you raised an issue on about why a light can't be turned back on to it's previous brightness? In the test case, you send 255 to the light's brightness topic, is that a correct example for resuming a zwave-js-ui light's previous brightness? emontnemery I starten with a question on the Z-Wave JS UI project, since my first assumption was that just an incorrect command type was used But that was something that was tested in the past and results in other isused. The interesting part was that it work as expected with Domoticz. So therefore I analyzed the differences and proposed this easy and non breaking solution, see here the details: So 255, or just the string "ON", which is converted to 255 by Z-Wave JS UI will result in activate the light on the previous brightness Makes this the reason clear? Regarding the question of jbouwh about making even more parameters availa
Looks like this might be missing some supported features supported-features Good catch, I double checked the documentation and set cover position shouldn't actually be supported, so I have removed the method and set attr supported features correctly. missing typing Fixed missing typing Fixed L303 If this property is set it will imply that set position is supported when its not
Looks like this need to include the other modes Removing since this PR doesnt support any presets. Oh but you aren't implementing set preset mode (maybe by design?) set-preset-mode Yes, this PR is intentionally omiting the ability to change presets since thats causing all the issues on 75246 Lets drop this since ClimateEntityFeature.PRESET MODE isn't set as a supported feature I think this can be removed as it looks like its already appended in AdvantageAirAcEntity and this would otherwise be a breaking change Oh very nice catch! I think the output shoudl be exactly the same but this line isnt required. Right. You were re-setting it not append :). Guess its time for more coffee on my part
We can just implement the native value property method instead in this case. If we never use the key in the NUMBER TYPES dict, it doesn't need to be a dict. It could be a tuple, eg. We don't seem to need the check. We can just return the value regardless if it's None or not. just figured that out on my own. Sorry for the commit spam, currently sitting in the train and the internet isn't fast enough to setup the full development environment on my work laptop... This is now no longer needed What is this call fails? Can it raise? should it be handled? The library could raise a ValueError in case the given number is not a multiple of 5. If communication with the BMW APIs fail, multiple errors could be raised: httpx.HTTPStatusError , TimeoutError (if the API cannot reach the vehicle in time) or a plain exception if something totally unexpected happens. In my mind, we don't need additional error handling in here, as each failure mode is an actual failure we cannot recover from (well, we could retry but that usually doesn't help much - either the API works and it runs through, or there is something wrong and we have to wait for the API car to recover). We do need to handle them. Only ValueError and HomeAssistantError is handled upstream. The rest are bugs and have side effects. But I suppose a broad except Exception as ex would not be the way to go? :) I could implement a custom error class in the library (or rather reuse the ones implemented for 90274 and add more for the remote services in an additional libary version). However I am unsure how to best continue with this: Adding error handling should then be done in this PR, added to select from 88759 and implemented for [bmw connected drive button.py L129]( L129). As I won't be able to get something else than except Exception as ex through until the beta cut, please advise on how you would like to continue: - broad exception (and adjust improve in a later PR) - keep as is and I'll create another PR in the next days that fixes exception handling for all above (should be able to fix it during beta fix if required) - don't merge this (and then have a breaking change for 2023.6) Hope this satisfies the requirement (and maybe it can be squeezed into this beta?). Otherwise this will be breaking change for 2022.6 and I'll add the breaking change paragraph again. What will raise a TypeError ? The climate start stop services won't trigger TypeError right now. When used in notify, it could be raised if parameters are of the wrong type. If wanted, I can remove it (as it should not occur here). If it can't happen we shouldn't add the code here. Figured as much an already removed in Please add a link to a changelog or GitHub commit compare view for the version bump in the PR description. Thanks! Forgot that, sorry. It is there now.
I think it s rare that an option is going to be passed here so we probably want to avoid creating the intermediate ones at startup. But since we only want to do it once we can wrap this in cache same for the function below To avoid caching the default one you could make it call another function if there is an argument and wrap that in cache (from lru tools) made create no verify ssl context() and client context() cached, because they are used by other integrations ( apache kafka , imap mail content , smtp ) Further these integrations can also benefit from this new "ssl cipher list" feature I think we should keep this function as-is and not accept an argument. Sounds reasonable ( because they are called "get default..." ). Therefore we need to use the client context and create no verify ssl context to get the correct ssl context Please cover these lines with a test No need to have a limit here as cache is slightly faster as it never has to check DEFAULT might be confusing because you can do sslcontext.set ciphers("DEFAULT") as well and it doesn't mean the same thing. e.g. the python default is not the underlying ssl library default I guess we could call this PYTHON DEFAULT unless you can think of something better. Naming is hard after a few rounds of reflection and a beer, I also came up with nothing better than PYTHON DEFAULT The keys here could be StrEnum
You probably need to check hass.config.is allowed path(path) here Hmm... I'm trying to understand is allowed path -- it looks like it's checking [this]( allowlist external dirs) value, but it's not obvious to me that this configuration parameter is meant for whether one can write to the directory (vs. read from it). Maybe there should just be a list of allowed directories or file patterns in the config for the integration? For now I went ahead and added the allowlist and am checking against it. Feel free to unresolve if you'd prefer I do things a different way.
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries. What does the response data represent? The payload in this case represents if an user has a pending fine issued by the traffic police. I don't want to rename it to anything more specific, since resp here is a response wrapper class that can be used to return other types of data, for example the full details of any fines you have pending - amount, date, etc. The idea is that the library is not HA-exclusive and can be used by anyone for their projects as well, that's why I used generics. If the api can return more than a single data type in the api call, I'd recommend using our data update coordinator helper instead to fetch the data centrally and then let the coordinator trigger an update of the entity state. That way more than a single entity can share the same data and api call. coordinated-single-api-poll-for-data-for-all-entities I saw that, but every request checks the fines for a single person, so it's not applicable here. Every GET request sends the user's Civil Number and Driver License, so you can't group them. To clarify, even if I include other data in the integration in the future, it will be stored in the attributes and not as separate sensor. It will always be 1 call per 1 person. Yes, but one person has more than a single data point, ie will be expressed as more than a single entity. No, we'll create different sensors. We want to avoid using state attributes as far as possible. Ok, I think we might be miscommunicating here because of my lousy explanations, sorry. The current version of my library has two different methods for checking if you have fines and for getting the fine details. The responses of those methods are not variable, e.g. one of them always has a bool in the response.data , the other one always returns a data object. Which means if you want to check status, you call the async check obligations method, as I did on line 62. If you want additional statuses, you need to call async get obligations , which is not used at all in this integration and I do not plan to use it in the foreseeable future. tldr: response.data in this case will always be a single boolean, which translates to a single binary sensor per person. Are you saying the integration will never expose any other data than a single boolean value per person? Yes In my experience, that sounds unlikely to stay true, but ok. Unless the government changes the way they hand the fines, it will probably stay that way. There is already more data available, that's my point. Someone may a want to have that available in the integration. We don't need this. It's already available as a state attribute. Please follow our entity naming guidelines. entity-naming This and all other requested changes are done. Please either set a unique id for the config entry or use our helper to match for existing config entry data. 
Need to swap uSv h with mSv h
Is SET RGBW PARAMETERS correct, even though this is a light which only supports controlling brightness? Yes. You can take a look at under ChannelActionParamsDimmer . Will this always be a bool, or do we need to convert it? Based on the linked docs, this will always be a boolean. You can check ChannelStateBrightness , ChannelStateColor and ChannelStateColorAndBrightness response object definitions. Should we return None here since the light is in an unknown state? It looks like state.on should always be defined, but maybe it wasn't present when channel entity was off, so this was a fall-back? It's been a while, so I'll play with it a bit to confirm. If that is the case, I propose we default to False if device is connected, otherwise it should be None . This seems to be 100 duplicated from the SuplaDimmerEntity , please move it to a shared base class. There's a subtle difference - SuplaDimmerEntity stores brightness state in brigthness property, while SuplaRGBLightingEntity stores state in color brightness property. I can still extract it, and define relevant property in the subclass. Isn't this easier to read? I opted to be more explicit in selecting exactly six characters from the end of the string. Mainly, guarding for the case that string of the form 'RRGGBB' is somehow obtained. What is "brightness state", do you mean color brightness which is extracted from the state below? I think this refers to HA state entity, and its brightness property. (It's been a while, sorry for the uncertainty.) Please add a docstring which explains the purpose of this property (maybe copy the explanation in the comment where the property is accesses) Using only an RGB tuple to keep track of a light's color brightness usually does not work too well. Does the color handling of the RGB light really work reliably? What happens if you set a color, dim the light to brightness 1, then dim it to maximum brightness, is the light's color preserved or not? From what I remember from testing - yes. I'll go through these scenarios one more time. I'll also look into explaining why it was done this way specifically. How come ColorMode.RGB is not used instead to avoid the conversions back and forth between HS(V) and RGB? Good question. I thought that externally this could be a HS entity. I can't remember why now, but perhaps it somehow worked better more elegant in HA?
I suggest using alphabetical order here. Please use shorthand attributes ( attr color mode) Please use shorthand attributes ( attr supported color modes) Please use shorthand attributes ( attr supported color modes) Please use shorthand attributes ( attr color mode)
I don't think this follows the entity naming convention. Only the first word should be capitalized. Connection Uptime - Connection uptime I think we can use [ key:component::button::entity component::restart::name ] here. IMO Last restart is more human-readable. ![obraz](
Should we raise if MediaPlayerEnqueue.ADD used with an unsupported media type? Added some logging! Unresolving this, as I think logging is the wrong approach. The problem with logging, is that the service call doesn't fail. .. Frenck This change seems to be unrelated wrong? Have you set up a dev env as per our developer documentation? My bad!
Why not just reverse ? wasn't sure if this would be to short, but if it's ok, than sure, i'll use them Why not just sort ? The service call is already blocking have also removed the unnecessary async block till done() from all previous test cases We can just re-user the previous one?
Could Should these be two number entities instead? Thought about that as well but heating curve is not something you usually want to modify via an UI element. Either you set it up once initially (likely not via Home assistant) or you have some very specific automation to change it which i also likely a rare use case Still i think a number entity is what makes sense here. Disabled by default. We have a marker for such things, which is the entity category. The entity category can be set to be a config for these specific entities. This makes them available from the UI (on the device page only), and excludes them from dashboards, selectors, voice assistants and such things. For that reason, disabling by default, isn't even really needed. Yet, if a user still has a use case, they can use them with all of the previously mentioned if added by the user explicitly. The use of entities, in general, is preferred over services (as they provide a wider use case, and also track things like history). I wonder if this should not have been a Select entity instead. see other reponse
You should split this PR: - one PR for adding an extra cover type to existing cover platform. - one PR for adding a brand new light platform. Please revert this change. This must have been introduced by Black. Reverted. Please revert this change.
As a new platform, should it not also be added to Platform constant, and to .core files.yaml ? It should indeed be added to .core files.yaml The PR already adds image to the Platform enum in const.py , do you mean another one? All good. I missed it in const.py I wonder if this might confuse with the last updated property of the state itself. Maybe use image last updated ? This can be just a dataclass, right? I wonder if we should make this a property of this class instead, including the attr content type ?
You probably want to call the function? This was my bad implementation, as this is property.
Consider updating this later to be an enum value defined by the pylib. that was the intent but forgot to open the PR: Can we add a sentence on why this is done, or a link to a conversation?
I think it is preferred if you handle the clientresponse error in your api and have specific api exceptions that you raise. It gives you a lot more power and is better for error catching makes the code in core more readable Everybody understands HTTP status codes. I don't see much advantage of having my own exceptions that wrap them. In addition, the coordinator where you are supposed to do the polling already handles HTTP errors so I think it's fine to keep them as is. A bit late to the party, but fwiw I think I'm with Lash-L on this one. It wouldn't necessarily have to be a 1:1 wrapping of the status codes. A 400 can represent many different errors for example. The lib should just expose an interface representative of it's domain and http isn't part of that. Done. type errors here How frequently does data update on opower side. 12 hours seems long. Added comment Data is updated daily on Opower. Refresh every 12h to be at most 12h behind. Do you have to log back in each time you want data? How frequently does the login expire? Yes. Added comment: Login expires after a few minutes. Given the infrequent updating (every 12h) assume previous sessions have expired and re-login. I don't think this is needed? You have recorder in dependencies in the manifest Removed. You are likely right. Tibber integration doesn't check but kitchen sink does L52 Why do you suggest 0 display precision for all of these? I would think you would at least want cost to be 2 decimal places Added comment: suggested display precision 0 for all sensors since Opower provides 0 decimal points for all these. (for the statistics in the energy dashboard Opower does provide decimal points) We also support a read-only constant field. Will look slightly better. I'm not familiar with that. Can you please link to an example? It's the ConstantSelector You can see it in action here components ha-form (search for Constant) I changed the code to allow username to be changed in the reauth flow and having it prepopulated to the current value. Is there really a use case for that one? Different username but same data? And since data is synced back, should we really support that? PG E doesn't let you change the username. Not sure about other utilities. I changed it to constant. People can always remove and create a new entry if they can change the username. The device entry type should be service. device-properties Please put the SensorEntity class last in the inheritance. Please type the entity description as a class attribute instead. That makes it more clear why we add the type annotation. I'm missing native unit of measurement for the cost descriptions with monetary device class. available-device-classes Don't set the config entry state here. Please use the already configured service reference. L75
Should username really be prompted again ? Should it not be instead added to the placeholders? Makes me think also that username maybe should be part of async abort entries match ? i don't think, user should be part of async abort entries match , because the created sensors are system ( url ) specific ( not user specific ) Further it may happen, that the user wants to use a new nextcloud-user for monitoring purposes ( eq. security concerns, renaming of the user, ... ), so it should be possible to change also the username, to be able to keep the sensors history data. As long as it doesn't request any user specific data it should be fine then. I think only the config entry is needed really, and it could be defined as a class attributes Does this work to have the initial username? unfortunately not, because user input is None at the first time: but this works I don't like default ! I'm running into all sorts of issues with it. Maybe this works? suggested value {CONF USERNAME: self. entry.data[CONF USERNAME], (user input or {})} this works Another option, which has the original password set: i'm not sure if we should provide the current password ( in most cases a changed password is the cause of an re-auth flow )
Slight change to previous implementation the domain is now picked up from the config entry. Slight change to previous implementation we check also the options (matches ConfigFlow implementation, and needed for Done I think we've stopped using patch.dict to mock handlers. We have this helper instead: L1246-L1253 The helper is only used inside component tests. Here I have followed the pattern used inside the rest of test config entries.py I think removal of patch.dict should be done in a separate PR for the whole file at once. I think it's ok to change it here, as it's a new test. I had another look this morning. Using mock config flow was conflicting with the autouse fixture: L49-L65 I managed to get around it by changing the domain of the test component. We should raise AbortFlow as done in the config flow. The integration can catch this if wanted and eg show an error instead. Side note: This is cryptic I think. If we just want to abort, we should just abort. Am I missing how this can be used? If i follow the code correctly, we don't want to "just abort". We still want to see if there is an existing entry. It seems to be a shorthand for "single instance allowed". It is used in tibber , tado , rachio , mullvad , logi circle , ambiclimate . We could change it to something like this: Right. I guess it saves one line.

Please don't do side effects like logging in entity state properties. We can remove this. If it's static we can use a class attribute, attr supported features . Please use integers instead. Please use constants with descriptive names for these integer values. Please use integers instead. This is more easy to recognize when reading the Matter specs so I'd vote to leave it like this actually or indeed put it in a constant with a comment behind it with the hex value Ok. A constant with the value is ok. This is not what happens. It stops on off plug in unit device attributes from getting discovered as covers. I don't particularly understand the way this is handled, the matter cluster can get a definite device type, can't we use that information? You can but you have overlapping device types. This was just something you can ignore here, I believe you copied it from another platform ? I may need to familiarize myself with the implementation again. Since we need the same cluster attribute for two entity attributes, is closing and is opening , I suggest we update both entity attributes in update from device instead. See the lock platform for an example. Is the attribute name also defined in the spec or can we change it to match Python PEP8 style? Ie, use snake case. this is how it is named in the spec but I suggest to change it to python snake case Please keep the order the same for all cases to make it easier to read. Please keep this sorted . Shouldn't enum keys always be uppercase (like constants) ? the point of the enum is a bit gone now this way. suggestions: 1) Add a missing method in the enum to fallback to "unknown" key -- read the operational status as enum. 2) drop the enum and just use constants instead 3) switch to IntEnum so you can do the comparing without the need for the ".value"
When you re-interview a device that has an Identify button, you get this error: and the button entity becomes unavailable until you reload the integration restart HA. It seems the existing entity attributes are missing the "restored" property, and so it fails this test: L467-L470 I'm not sure why this is, when the interview is complete and the node is ready, we dispatch a signal to remove existing entities for the device before going through discovery again. MartinHjelmare any idea why this is happening? kpine when you get a chance please try the reinterview again - I found a bug that may explain the issue although I am not sure, it seems like it should have worked even without this fix Fixed by moving entity removal to interview handler. Why do we create a task here? holdover from where I copied the logic from, will remove Side note: I think we should refactor the discovery and design it like we do in the matter integration. There we attach an Entity class and an EntityDescription to each schema instance and define the schema instances in each platform. entity category and entity registry enabled default are entity details and belong in the entity description not in the discovery info. It's a bigger refactor so something for a separate PR of course. Shouldn't we append to the list?
We don't need to disable this. True is the default.
This is turning into a lot of duplicate code. Would something like this work? There's a lot of duplicate code here. Would something like this work? And maybe async get wds state should be in the binary sensor module if it is binary-sensor specific. You are right. In my view the coordinator just needs async get device response and the rest should be handled in the devices. I just implemented it this way because switch and climate do it the same way... I will update the code, but for consistency climate and switch should also be updated. Looks good, but I think climate switch and refactoring should be preliminary PR. Done. Created I'm not sure you need to have two classes ( LivisiWindowDoorSensor and LivisiBinarySensor ) If you have only "window door" sensors, then it's not useful. If you are planning to have more binary sensor types, then maybe it is better to add two right away and maybe look at EntityDescription . Yes, there are will be other binary sensors. At least one of them ("battery low") will require a completely different implementation and be part of multiple devices. Another one will be a smoke sensor, which will be quite simple but I don't feel should be part of this PR. As you like to split features and code quality changes refactoring into separate PRs, I thought it might be smart to plan for this in advance and create the base class now. I still think that's the right way to go. OK - hopefully this will work for the other binary sensors. Damn. With all the refactoring going on, I think you should consider adding basic tests. With the correct fixtures it can be as simple as: I will look into this, thanks for the example Looks like this needs a lot more effort for me to understand what's going on in that snippet and how to do the testing right. I'd rather have the WDS support merged soon (the original PR was from december) and look at testing (for all the existing devices) later in a a separate PR. I understand you are quite picky about code quality and normally I see this a a good thing, but the livisi implementation is still very incomplete and not very useful in its current state, so it would be great to see some progress in supported devices. You may have noticed I'm very open to refactoring code for simplification and unification - so I will definitely continue to work on improving the code quality in the future. It's OK to keep tests for a follow-up PR... it's just something to keep in mind. Huh? Shouldn't the linter have catched this?
would this be considered diagnostic in nature? Made this and the "external sensor" entity both diagnostic now If it s diagnostic please use the diagnostic matcher Ditto
Since attr supported color modes is no longer static, you should remove it from the class attributes on line 62 and set it only here. I don't think you need this variable at all. I don't think this property is needed. IMO, brightness should be calculated inside async update , and the automatic attribute self. attr brightness should be used instead. For example: This feels like logic that should be extracted to the niko-home-control library. I think it would make sense to tidy up this code to use attributes in a preliminary PR: Then you can drop the three properties (unique id, name, is on) that will be automatically handled by the base class. I think this function is redundant. Maybe instead get state should be adjusted to return state["value1"] When BRIGHTNESS is used, it should be the only supported more.
Home Assistant climate entities already provide presets, It is not clear why a duplicate functionality is created or needed. I have overlooked this, and will remove the added service.
Optional comment: How about "Conference Room - F123, Bldg. 002" to be consistent with the other examples from the RFC? :) section-3.8.1.7 I think its kind of fun to keep to the rfc5545 examples for history, but not required Done. I'd say move to the end so its near the end in the developer tools. Moved. Is the "" needed here and below? If not would be nice to omit. The tests are not passing yet. My impression is that 'location' is not exposed through the rest API, so what I would suggest is: - Revert the change to event fields - Add a test that looks at the entity attributes instead similar to test active event Sorry I saw your message too late. I changed that here. L199 Please let me know if now it's ok. OK, yes, makes sense. Mark not draft when ready for review.
Like the bot commented - you can only have one platform for a PR. You can't just mark it as ready for review without resolve this change. You should go back to draft status until you make that change. Thanks for pointing out. To be honest i havn't understood the comment. The integration provides sensors and binary sensors. When i remove one of them, half of my sensor data is missing. I'll get back and study the documentation. You just have to decide what information is more useful for an initial implementation just sensor data or just binary sensor data. You can add whichever one you remove back in the future I'd recommend still naming this SolvidRemotecoordinator just to make things clear I'd also leave the file named as coordinator.py Thanks a lot for the hint! I'll rename file and class. I tried to learn from other integrations. some use the coordinator some the pattern i have choosen :-) commented out code You should use the CONF constants that are built in to core. i..e CONF USERNAME this is hard to comment on right now because you aren't using a pypi package yet But rename your hub, remove todo comment When its static, you really don't need to pass this. with a pypi package you can simplify this. create your pai, try connection to the api and validating with the api. Have your own errors in the api for cannot connect and invalid auth, then replace the two below. You'd be able to remove your hub and valid input. remove the unused ones replace this with your pypi package I checked that, and was sure "requests" is a pypi package. -- It is a pypi package, but you should handle all of the requests calls in your own pypi package. As an aside, it is preferred for you to use aiohttp instead of request as it is async by nature. Turn this into a pypi package. This should not happen in core Ok. Now I understand. And understand better. Hum. Don't know if it is worth to make a pypi package out of that. I think it is too silly and dump to be published on that platform. Let me think about that. The interface of the solvis remote is nothing known (rest, ...) and a mess. I just wanted to contribute my knowledge to this project and make it easy to integrate their system into the home assistant plattform. Maybe i'll just transform the code into a custom component. Let me think about that. Thanks for you help. Commented out code Look at the StateType return type, see if that encompasses everything it can return, you wat to avoid doing Any when at all possible You can't change a Ha const in this pull request. There is an entire extra process for that Ok. Thank you. I didn't know that. I'll consult the documentation for this new const.
This whole function can be replaced with the one for states with changing the table and column names We don't need any of this We can use the precise number for all columns now This still needs to rollback to be sure The try and flush need to be wrapped with an exception catch and rollback before raising Actually probably not since it means the db is broken We could make a test that actually corrects the schema and than makes sure there are no validation errors Maybe better to not make this PR any bigger and expand the test coverage when we add events We could do a correct and revalidate test here as well Maybe better to not make this PR any bigger and expand the test coverage when we add events
Stale comment If not a success, run.speech to text should already have sent an error event and we should not finish the pipeline. Add error handling. Should we catch exceptions here. Catching them now in each part of the pipeline and returning a relevant error. I wonder if we should be more explicit in requesting the type of run Maybe voice assistant run text vs voice assistant run audio ? Using stages instead handler should be unregistered when the pipeline finishes. For a future PR we should make sure that the request input is supported for STT, Conversation and TTS. The PipelineRun is the same. So you can first create the context, and have a single call to execute. There is no result for a subscription and it's not accessible in the frontend. Only events are supported. Handler ID needs to be included in the run-start event. I feel like we can make this smarter. In a future PR, should we move all these validation checks to be done before we start? We should also log it LOGGER.exception("Unexpected error during intent recognition") or else the exception is lost. Or should it be included in the pipeline? Maybe that too, yeah. It will get sent back as a WebSocket "error" message. log here too log here too Should we raise or send an error event? We need to translate this to an event anyway for the websocket. Or I guess the subscription could fail to be created if the input is invalid. That's probably better. This feels wrong in general, as details of the websocket API are bleeding into the pipeline. I think the handler id should be returned in a separate message before the pipeline starts. We should limit this to the enum. I think that you can just put the enum as validation ? This doesn't do anything, as you already did a send result . This needs to be an event. Are you sure this is necessary? we've had enum validation before and didn't need this. This is what I get if I don't include the set(...) : I don't know if this is a problem with the StrEnum backport or voluptuous I think you can just put the enum, not even use vol.In oh, use cv.enum(PipelineStage)
Where does the maximum of 90 C come from? Neither pyotgw nor the gateway impose such a limit while the OpenTherm Protocol Specification v2.2 implies a supported range up to 127 C (which seems a bit high in my opinion). I agree that it does make sense to have a limit on the service call, I'm just curious how you came up with this one in particular. We could get the actual limits from the boiler from the status dict if they have been reported ( DATA SLAVE CH MAX SETP and DATA SLAVE CH MIN SETP ). Mine reports a max of 65 and a min of 20 for example, but those values are not immediately available on startup. I relied on the Set Control Setpoint service code. ...but those values are not immediately available on startup. Any idea to wait for availability of those value? There's no guarantee that they will ever show up as message ID 49 support is not mandatory in the OpenTherm specification. According to the [equipment matrix]( boilers), most boilers do support it, especially the ones that allow you to set the value as well (message ID 57). We could write a custom validation function that takes the values from the boiler into consideration, but there are also some boilers that apparently report inconsistent or even false information. Taking all this into account I would say that a fixed limit is probably indeed best, with the proper explanation and warnings in the docs. I agree. Thanks. The last 2 lines are actually not necessary anymore and can also be removed from the other services that use the same method, although that would be a separate PR. pyotgw takes care of the status update and pushes it to all listeners. Same as above. The last 2 lines are actually not necessary anymore and can also be removed from the other services that use the same method, although that would be a separate PR. I can do that, if you want. But, after documentation writing. Same as above, why 90? Idem. I see. It may be a good idea to describe how to find the actual supported min max values for the users' boiler in the documentation for the service, i.e. which sensors report those values. Ok. I'll do that. Why isn't this just an entity? I relied on the set control setpoint service above. mvn23 will be able to answer better. But I'm afraid I don't understand: can an entity set a value on a device? can an entity set a value on a device? Sure, entities can either provide a value (monitor), like a sensor. Or a control, like a light, fan or in this case, number entity. OK, I got it. I'm not quite awake yet ;-) So should all services in this integration that send a value to the device be then converted to entities as well? Thus it would be a breaking changes. This new service is written as a continuation of the other services. Isn't that more consistent? So should all services in this integration that send a value to the device be then converted to entities as well? If those could be entities; Yes (but not in this PR). Thus it would be a breaking changes. Correct, but we can offe
Please remove the translation folder. All translatable strings go into strings.json . New integrations entities must support [translation of names and attributes]( Please adopt your code accordingly. Please update the error message that the phone number must start with the above requirements. Not required as you pass with from ex the hole exception. Please create a dataclass for it and return this class instead. This will improve type-checking. Handling the bare Exception is only allowed in config flow.py . Please handle here only specific exceptions raised by the library. All entities are using the coordinator, right? Then I suggest making CoordinatorEntity a parent of Tami4EdgeBaseEntity . Future planned entities won't use the coordinator entity Please move it into Tami4EdgeBaseEntity . As new integrations are required to support it. In my opinion, the word api describes better the object as edge
You should only have this update in the try Raise configentrynotready handling-offline-or-unavailable-devices-and-services Why are you casting all your attributes? Do they not come out like that on the api? It should not need to be casted, the upstream library has it typed: ![image]( Type errors Rewrite your logic for this to be if user input is not None. It will simplify your code and you will only need one instance of show form Translations are no longer needed. Remove this file For all of your patches, you should do homeassistant.components and then patch it within your integration. Not globally What does this mean? Let's sort them No need to set the icon for this one, we can rely on what the frontend has for the default. It is already unique for the domain by nature These are not attributing to the main state of this entity and should be their own dedicated entities instead. - The entity shouldn't be prefixed with the integration name. - The serial number isn't a user-friendly name for an entity. According to the upstream library, the room temperature property is already a float , why is it wrapping converted to a float() again? According to the upstream library, the air temp setpoint away property is already a float , why is it wrapping converted to a float() again? According to the upstream library, the air temp setpoint home property is already a float , why is it wrapping converted to a float() again? What if these calls fail? We can define this as a constant in this module, so we don't re-create this dict every call. Same as above, we can define this as a constant in this module, so we don't re-create this dict every call. What if this call fails? I'm confused by auxilary heating vs hvac mode? It seems like you map them as the same thing, but in the Home Assistant world, they are not. Same as above, it seems to mix up aux heating and ventilation modes into a HVAC mode What if this call fails? What if this call fails? Just return the serial number instead? Why the replacing? It seems like this can raise a lot more, like a DecodingError , which isn't handled.
Does this actually match ? Have you checked that the component appears in the UI ? From the code, you should be using "ts0601 garage.TuyaGarageSwitchTO" without the begining. without the begining. That's only when using a custom quirk, right? When the quirk gets merged into zha-quirks , we need to use the zhaquirks. prefix here. I doubt it. quirk class is defined here : L124-L127 As far I understand, the module will always be a single word without dot in it. You will not get the full path. Mhh wait indeed I have the full path when not using a custom quirk. I guess I never actually looked at working devices. I guess we'll have to find a better way to fix this then. I've been attempting this and found that the code in the PR matches but causes an IndexError: list index out of range. After a bunch of debugging I believe this is because it is looking for the "contact sensor" attribute on the "Basic" cluster rather than the TuyaGarageManufCluster cluster. I might be off base here, but the suggestion provided gets me a working sensor in the UI. (Testing with a clean 2023.06.01 components zha copied over into custom components) For code cleanliness, is there a way to pull these strings from the quirk definition rather than hardcoding? As with the sensor for the match. Additionally, my device only triggers the relay when button goes from 1 to 0. Adding: attribute reset value 0 async def async press(self) - None: """Write attribute with defined value.""" try: result await self. cluster handler.cluster.write attributes( {self. attribute name: self. attribute value} ) result await self. cluster handler.cluster.write attributes( {self. attribute name: self. attribute reset value} ) except zigpy.exceptions.ZigbeeException as ex: self.error("Could not set value: s", ex) return if not isinstance(result, Exception) and all( record.status Status.SUCCESS for record in result[0] ): self.async write ha state() here works but there's probably a better way that requires copying less code from the superclass.
Moved this to the top so we are sure we don't leak the old entity id from the states manager
This is currently a datetime string, in a format different from what Home Assistant uses. Therefore, parse it and just set the datetime object as a result. Also, add the following import to this file: from homeassistant.util import dt as dt util
This should be a separate cleanup PR (and probably cleanup homekit section also...) Thanks, removed from PR (and will create a new one later). This could be a separate PR... It's just a missing device class Agreed. I'll try not to fix things that I come across in the same PR. Submitted as 90182 This feels overly complicated. Maybe it would be better to use self. attr entity registry enabled default . Something like this could work, and give more control to the end user. Yeah, this is much (much) cleaner. I'm learning a lot here, thanks. Why did you remove the injected fixture? Did I? I don't think there was one in this test. There is the fixture you added to test config flow.py , but I don't think there was another one. Seems like a good idea though. Maybe it comes from a bad rebase? I'm not sure If follow. What change are you referring to exactly? According to github, you are adding this line inside the PR. You shouldn't be adding the line. Ah yes, I was offset by the terminology, but I get it now. Thanks for making it explicit. Could be a rebase thing indeed. I've split a previous PR (which is much better, but did leave some left overs apparently. I think maybe you should look at SnapshotAssertion L38-L41 and L49-L50 I will. This also sounds like something for a seperate PR. What do you think? Yes - most likely a separate PR. I'm not sure if it should be preliminary or follow-up... I'll start working on the PR asap. If this PR has to wait for that I understand. If not, it will surely please some users :) I've created 90126. I'm curious if this is what you had in mind. If so, We can choose which PR goes first. I merged 90126. This will need to be rebased accordingly. Thanks. I've done the rebase. I'll pick up the other suggestions later today. I think this change is not needed - maybe a bad rebase? Yes, thanks. Fixed this. I think this change is not needed - maybe a bad rebase? Yes, thanks. Fixed this. I think this change is not needed - maybe a bad rebase? Yes, thanks. Fixed this. Please add a comment here to indicate why this is needed (some meters return only one, or only the other?) I think this is a duplicate of the above test, and they could be merged with pytest.mark.parametrize
Let's not fake this in the demo integration. It's getting big enough I don't like that integrations have to look for to see if it's a search query. It breaks artists that have a too. It's started from a separate dialog and doesn't have to re-use the same API. The other tricky part is, how should search behave. For Spotify it's "global", while if you're browsing a local folder, you might be able to search through only the content of the current subfolders. made a change to the search test. Could still potentially break. open to suggestions. This was an relatively effective simple approach without having to make major changes to the architecture. This approach is not going to work and it will break certain normal cases. We shouldn't do it like this.
IMO this should be refactored in a similar way to the binary sensor and sensor platform, by extending from RESOURCE SCHEMA . PLATFORM SCHEMA PLATFORM SCHEMA.extend({ RESOURCE SCHEMA, SWITCH SCHEMA}) Done, but not exactly like that because it was not working : RESOURCE SCHEMA has a default conf method of "GET", while rest switch has a default of "post". I ended up doing so : PLATFORM SCHEMA PLATFORM SCHEMA.extend({ RESOURCE SCHEMA}).extend({ SWITCH SCHEMA}) NOTE : I noticed that switch methods are all lowercase, while the rest of sensors require uppercase. Changing that would be a breaking change, so I'll leave it here for now, that's not the point of this P.R. NOTE 2 : I've not yet removed code for Platformnotready, I'm waiting the other P.R. to be validated to see how to do it (if any change is required), because I need to update resource prior to raising exception, so as soon as P.R. is merged, the change I've done are "required". done This is a bugfix that should be standalone, in a separate preliminary PR. agreed, addressing it in 90627. Then I will change the code is this P.R.
I suggest that you set mock setup entry to be auto-use in the test file. I agree but if mock setup entry is used in the test, it needs to be added we need mock setup entry in the test Why do you need to patch here? Is that not covered by mock setup entry ? I don't think ALL settings should be available in the options flow. Maybe only CONF CHARSET CONF FOLDER CONF SEARCH ? There is also the async abort entries match to take into consideration. If have reduced the options to what you suggested. Combining more searches or folders to one entry, is something for an other PR. May be we need to test existing entries when changing the options that keyed with async abort entries match . The sensor unique id is defined as self. attr unique id f"{coordinator.config entry.entry id}" So combining more searches or folders to one entry would need to take that into account. When this integration was moved to [config flow]( this has been [discussed]( discussion r1053322565). The idea is that each integration entry is defined by the folder and search criteria (The charset is fixed for an imap server so I don't see the benefit of having this as an option). As you have noticed that if we make these as options we need to recheck the existing entries when they are updated through options flow and the user will not know which folder and search criteria are currently used for this entry. If we are changing the folder and search criteria the sensor loses its identity as we can have multiple entries for the same imap server and username each having its unique folder and search criteria. Added validation to avoid duplicates engrbm87 do you want to see the charset option removed? What's the motivation for the options flow? The PR description doesn't say that. I am preparing the options flow for ithe implementation of an email content event feature as discussed. Aim is to deprecate the imsp email content sensor. But how does it help to add CHARSET FOLDER SEARCH as options? Why do we need an options flow to fire an event? Email filter's might need changes over time. We do not what users to update there automations because the entry needed to be recreated. So folder an filter need to be settable as an option, and the user should be able to check the filter and folder configured IMO. Further I have been thinking of a sublist with combinations for folder and search so we only need one entity is the user wants to configure multiple searches, but it seems a bit much to do this all in one PR. I'm skeptical about the sublist. I think we should keep it simple. I think it makes sense to be able to view and change the folder and search but we then need to again check that no other config entry has the same data configured. I know this not related but I want to reuse this in the options flow If this string is missing in the config flow, it's a bug fix that we want to publish separately, right? You are right, I'll open a PR for that 90154 Why do you need to validate it again here? Can yo
Can we just make this App ? We also don't have Album Name, Artist Name etc. (note, user should never see this) On the note: That is not correct, it can be used in the automation editor (and it will translate it when used). We also use it in generated trigger condition descriptions and script automation trances. It is why I am doing all of this in the first place, as they now look "meh" (string transform magic) and completely untranslated. Small task to make the user experience of the UI better and more consistent in quite a few places. Volume? mutes ? Oops Should we translate this to Yes No ? does this even work, as attributes are boolean True False, and this is a string value of true false. Oh I see now that true false placeholders translate to Yes No. Not sure if we should do that, as it's not the same always, better to add a translation for Yes No somewhere ? Should we translate this to Yes No ? I think so? "Is it muted? Yes!" On Off in this case isn't really fitting. True False is IMHO too technical. does this even work, as attributes are boolean True False, and this is a string value of true false. Yes, as they are converted to a translation string when looked up (template literal). Not sure if we should do that, as it's not the same always, better to add a translation for Yes No somewhere ? Added the generic state yes no instead. Mapped true false onto that. Having them generic is helpful, as I have a few more PRs that will have a similar situation.
Is it necessary to add the units in the name? I assume the units are also shown after the value in the frontend ? Is it necessary to add the units in the name? Yes, otherwise you wouldn't understand the difference: ![image]( (this screenshot is a bit odd, as in, doesn't show this property for this light right now, but the gist is the same as with mix max in the screenshot). I assume the units are also shown after the value in the frontend ? State attributes don't have units. If this state attribute were to be used in a light specific UI, it would be shown with units. I guess in this generic UI, it would need to have units. Would it be better to replace "in Kelvin" with " (Kelvin)" ? Light-specific UI has its own translations in the frontend. Indeed. Same
Should this be just "Charging" to keep it shorter ?
Note: I'm considering sending a follow up PR to set a PRODID specific to home-assistant, rather than the underlying library. (Also, there was previously a bug here where PROID was never set) this shouldn't be necessary. Without it the tests fail with the frozen router problem, so I thought maybe I needed it. I've read this is when rest and websocket are both used in tests. I can't remember how I worked around this last time... Can you remind me what I'm doing wrong? Can't you setup diagnostics in a fixture at the top of the test diagnostics file ? ok, great. To answer your question: It's not that I couldn't, it just wasn't obvious this is the best practice. Thanks for clarifying! Note: diagnostics is a great platform to get familiar with syrupy (snapshots SnapshotAssertion).
Please try to keep the config-flow PR as small as possible. For example, this constants file can be created in a preliminary PR. You should turn the schema into a constant, and then leverage self.add suggested values to schema . Adding "holidays" is a new feature - please keep it out of this PR Unrelated to this PR - please remove and create a separate PR if necessary. All this migration needs to be kept inside binary sensor module, under setup platform function. There is no need for async setup method here at all. I think there is way too many debug statements around. I think they might be useful internally to debug the code, but I don't think they should be in the PR.
My initial recommendation was going to be that these should be static class attributes: But now I seee that all other entities in Gree have the same pattern. I think it should first be migrated to use SwitchEntityDescription to remove all the duplicate code.
register admin service 0c777d57caf096e26940f1f92bab7e1abb9c3eab
Looks strange :) Fixed
Probably fine, but we don t add other manufacturer specific clusters to the BINDABLE CLUSTERS registry. IIRC this doesn t affect "the binding part we need", but only what s showing up in the clusters UI when binding another device. I think this can should be removed(?) (need to have a further look) I dont knowing how the code is working then was only doing what i was instructed to do and testing it was working OK. For My is being better and more logic making one bindbal version of EventableCluster that also can being applying on manufacture cluster as this one and getting it bonded OK of ZHA without making new versions for every new types coming from different new devices by using in in quirks. I know you're already testing a lot, but as a quick test, can you try to remove the first line (with BINDABLE CLUSTERS ) and see if it still works binds the cluster? For My is being better and more logic making one bindbal version of EventableCluster Yeah, but with the current architecture, it's not really possible to do this in a clean way.
This file is no longer included in the git repository, please remove it Without it the integration setup dialog has no text and the generic error messages lose the user-friendly verbiage. cgarwood? ![image]( You need to run python3 -m script.translations develop --all in your local testing. Again, please remove the file from this PR. You may be basing your work on an old dev branch; the translations were removed from the core repo a couple of months ago. Got it. Removed. script.translations generated the en.json file locally. If the SSL settings are incorrect, what error will be raised when calling fully.getDeviceInfo below? If use ssl is wrong, meaning that it is set to True but the Fully app is not configured for SSL, the error will be "Failed to connect" ("cannot connect" with the translations folder removed) regardless of the state of verify ssl . If use ssl is correct, meaning that it is set to True and the Fully app is configured for SSL; but verify ssl is wrong, meaning that HA has not been loaded with the CA to verify the certificate, there will be an SSL error from the backend library. there will be an SSL error from the backend library OK, and how is that shown to the user? On the frontend the user gets "Failed to connect" as caught by except ( ClientConnectorError, FullyKioskError, asyncio.TimeoutError, ) as error: ![image]( And the debug log registers: aiohttp.client exceptions.ClientConnectorCertificateError: Cannot connect to host 192.168.1.30:2323 ssl:True [SSLCertVerificationError: (1, '[SSL: CERTIFICATE VERIFY FAILED] certificate verify failed: unable to get local issuer certificate ( ssl.c:997)')] OK, in that case I'd suggest to set the error to something more detailed than cannot connect to help the user distinguish between the different errors. That was my intention originally but there's nothing for ssl errors in homeassistant strings.json. I guess the general expectation is that the user will check the logs for the specific failure when getting "Failed to connect", specially if he is advanced enough to be setting up ssl with the integration. emontnemery, thoughts? I'd suggest to include the the exception error message in the description placeholders since the error message is likely to aid the user if they made a mistake in the SSL configuration. Now the exception message is shown to the user on the frontend, as recommended. ![image](
You can remove the unused ones Thanks a lot! I have resolved all input, should I resolve all conversations? You don't seem to have host Should be typed InCharge None Type errors Why are you setting part of data to be a const? Removed this Type user input Type this You should be doing this in init and then setting hass.data[entry.entry id] to your coordinator or whatever object you use to hold your api Then you receive the coordinator here from hass.data Your incharge data obj potentially? You should only have one instance of an object that handles updating and holds your api though - so you would have to change it I was a bit lost on why the async setup entry is both here and in the init file, should all content of this function be merged with the same function in the init file? At the same time I want to make sure that when there are new entities (in this case a new charging station) it is automatically added but looking into this I am not sure if this is the case right now even... So in init, you handle the general setup and you then forward entry setup, so you end up setting up everything that is generic in the init one, and then you "forwards the set up for anything platform specific in the platform async setup Ok agree, I will change it Type Return type Type and return type Return type Done Why not use: suggested display precision You could get rid of unauthorized if that gives the same error as not okay. as it will get caught there. Also potentially instead of having all these calls to async show user form, you could just store and error dictionary like most other integrations do. Nothing wrong about this that I can think of though Also you may want to think about creating custom exceptions in your api and raise those rather than returning the response and checking the status code Why don't you have your api just return the dictionary instead of the response? I don't think you use the dict aspect of the sensor types. You could just make it an array type your parameters CoordinatorEntity[InChargeDataCoordinator] You don't need to round, the frontend should do that. type parameters I think coordinator will handle timeout, I'm not 100 sure though, something worth looking into
Where are the 15minutes coming? Why do we not make it configurable?
hass.data[DOMAIN][entry.entry id] should be set to the coordinator, not the entry data and devices Ended up removing the coordinator as I really don't use it, my integration is 'push local'. I also notify the entities from a single endpoint, that being the device itself. I'd rename this file, entity.py or something, probably not base class I followed your advice and did just that. commented out code Thank you for noticing. I've fixed it. type errors I believe const is not the correct place for these I agree, I've changed it to the correct platforms. As well, remove all of these that are not Cover. Since a PR should be limited to one platform, you shouldn't make the PR too large by having all of the unused platforms I think you should be passing in update interval. Right now it starts off as None You need to type your parameters You need errors in here, right now you have cannot connect I belive issue tracker and documenation are not keys that should be passed. Those should only be passed in HACS integrations. edit: documentation should exist, just not issue tracker This is actually wrong, there is a use for both of these keys: documentation issue-tracker Keep reading that documentation If this integration is being submitted for inclusion in Home Assistant, it should be If this integration is being submitted for inclusion in Home Assistant, it should be omitted. For built-in integrations, Home Assistant will automatically generate the correct link. They shouldn't be linking to hacs Thank you, I've changed it are you able to differentiate between cannot connect and invalid auth? If so, you should. As well, you should check for any unknown errors. You should be consistent with iNELS. Sometimes you write iNELS and sometimes iNels - whichever one the brand uses you should stay consistent with. Why are you mocking hass? and Why are you mocking config entries? writing-tests-for-integrations Solved You shouldn't be adding to hass.data until after you verify you can connect and authenticate. Where you have it below is fine on line 88 You should be consistent between .get and [] just stylistically speaking. I don't know if this is something maintainers would actually have a problem with though. You do it above on line 62 as well. I'd remove the options flow for the initial PR. Maintainers really like the project to be as small as possible, and this isn't essential, so you could always add it back in a small PR after this ones gets merged I've never seen this done - so maybe it's okay, but why not use vol.Schema()? What's up with CONF DISCOVERY? You always set it to True and I'm not sure if you even use it? You never use this Did you copy these const from somewhere? A lot of them seem to be unused. Go through and remove anything you aren't using Delete translations - they are no longer used. Translations work differently now
What does this UDN look like? Are we sure its unique enough to meet the unique id requirements (I'm assuming it does because its being used elsewhere but the test doesn't show what the UDN will look like)? unique-id-requirements Ideally the test has a valid UDN diff-0ab1317eaff266adde985b400a178004e4d447a9c4adc2a653ae8c77b5c5c434R25 The UDN contains an UUID, for example: uuid:3dcc7100-f76c-11dd-87af-00226124ca30 Does uuid: need to be stripped from the string to match what get radio id() returns? Those 2 ids have sadly no relation to each other. So to summarize: - The UDN is a good unique id when discovered through SSDP - the radio-id is another good unique id, but can only be accessed after authenticating with the device. We can thus not use the radio-id as the sole unique id, because it would not allow us to differentiate two devices where we are not authenticated. - UDN and radio-id are not equal. So it's theoretically possible for a user to add the device twice: once via SSDP discovery, once via manual configuration. AFAIK, it is not possible for a config entry to have multiple unique id's? Otherwise we could also register the radio-id as a secondary unique id for SSDP discovered devices. We aren't allowed to have two different formats for unique ids for the same integration. Can the UDN be accessed with authentication as well? I triple checked if a new API call had been discovered in the past year, but sadly not. [The API does expose a UUID]( netremotesysinfodmruuid), but that one is different from the UDN returned in the context of the urn:schemas-frontier-silicon-com:undok:fsapi:1 SSDP. Wiresharking did show that that UUID is being passed in the context of the DLNA SSDP, but trying to use that will result in a very ugly brittle solution I'm afraid. Your other option is to call the api to get the radio id once its discovered via SSDP and set it. If they changed the default PIN and you can't obtain the unique id, and we don't know if we are going to present the user a flow for something that is already setup, the best option is to abort the flow as they can always set it up manually. To mitigate the cost of probing, we should abort if a config entry already exists for the host we are about to probe. OK, I've removed support for ssdp discovery of devices with nondefault PIN. The overhead of the ssdp-flow for existing devices is now 1 call to the device discovery URL to retrieve the webfsapi endpoint. This discovery file is small file ( 200 bytes): The user did not trigger this to happen so we should log at debug level since its unlikely they will connect a background discovery with the trace This could be a bit more DRY if you move this into an async create entry function since its nearly the same code at the end of async step device config if needed I've now re-added this function. I had to remove it during the review of the previous PR. Let's extract the hostname and abort if its already set up so we don't probe Examples: L94 L169 I don't ha
We should not use brands in case there is just one integration. Please remove the brand. They also have eBus devices, so I thought there should be a brand in case eBus gets tested added. See Fine for me to remove the brand, though. They also have eBus devices That is cool, but those are not in Home Assistant. Once there are multiple integrations, we can consider using a brand.
Apply typing to the full method instead of just some of the params and return. The int() is not needed This is currently unused, so delete. (I realize it may be used in later PRs, but can be added later) VACUUM seems unused and not really needed: What is the intent behind this? It doesn't seem to be doing anything so i think it can be removed as well as async reload entry below. Are these abort codes actually supported by this integration? These forms show one step and switch between another step, which is not allowed. While rendering step user it sends the user to step email, and instead it needs to stay on step user. These steps should be combined. To advance to the next step, call the next step and await on it. This could be an attr icon This appears to be unused and should be removed Any particular reason to change the initialization order between this class and the parent class? I'd opt to keep it the same (either change this or the other) The parent class takes every field of device and copies it as a member variable. How about picking one apparoch other the other. This appears to be unused. The base coordinator already has self.coordinator so i don't think this is needed Looking at this on it seems like this project needs a little more work (e.g. has TODOs, no links to github, etc) so can you do some work to get this into a healthier state? I ended up doing some digging and found which appears to be the source and i see you're doing cleanup work. (I was surprised this was running such an an older vesion with upates in the last 24 hours) Yeah good point - I'll take some time to work on the pypi page tomorrow. As far as the version being delayed, offline support is currently being added to the package, so there's a lot of rapid development, I was going to wait until we had it fully tested and functionaly before it got bumped I was mentioning before that we can reduce the number of member variables in this class. I think we should inline show email form and request code as it will reduce overall the number interactions that require storing state in the config flow that is just for rendering in a single step, or the fact that the method returns a client on success or None to indicate that it stored errors in the member. While in general, it is good to have helper methods to factor out logic, we can just inline this and make it much more compact and easier to follow all the error handling in one method. (I assume the original motivation to have these helper methods may have been when the code was mixed across steps, which we've now removed from your previous changes, meaning we can further simplify) This can be omitted When using get if a field is not present it will return None which I think is unexpected here given that all fields in the config entry should be set by the config flow. Let's instead assume they are set (which will hard fail with a key error if they aren't, which is a shouldn't happen) Use the Platform enum L54 This is unused Th
This is unrelated to config flow, can it be moved to a distinct PR? Can these constants be moved as a preliminary PR? Can the coordinator not be implemented in a follow-up PR? Config-flow PRs are already quite big. If it's not possible, then I'd recommend moving this to a separate coordinator module tbh, i'm not aware of how to get rid of the following block ( which somehow did a similar job as an update coordinator ) in the async setup entry without implementing the update coordinator if there is a suitable solution for this problem, then sure i will go with it and do the coordinator in a follow-up PR Maybe the coordinator could be a preliminary PR then, instead of a follow-up PR? Can the base entity not be implemented in a follow-up PR? Config-flow PRs are already quite big. If it's not possible, then I'd recommend moving this to a separate entity module the base entity was a side effect of implementing the update coordinator If the connection fails during import, this would leave an incomplete flow. I'm not sure if this is intended - maybe it should bail out instead? You can use add suggested values to schema to avoid loosing the previous user input. uhhh ... nice, did not know this function, yet I recommend moving the codeowners change to a separate PR Please ensure that async setup entry is mocked in config flow unit tests See I think you should have a test for connection failure during import process. Are you not creating an issue here even if DOMAIN is not in config? I think it should be: Maybe move device info to another PR. I am not sure that the url is a valid identifier and I think it should have it's own review process. The "step" is not the same as the "source", so SOURCE USER isn't really valid here. You can use SnapshotAssertion here: I wanted to limit to these 3 to avoid importing additional parameter like scan interval. Or should I do the limitation just within the import step itself, before it forwards to the user step? Yes I think it is better to cleanup the original import data BEFORE passing to user step. These appear to be compulsory:
Unrelated - please remove from this PR Unrelated - please remove from this PR There is already partial coverage of vacuum platform. You should add some tests for the new service. This new class feels unecessary to me. I like to keep PRs as small as possible - seems unlinked to room targeting. I got rid of the added text description in this error I like to keep PRs as small as possible - seems unlinked to room targeting. Please remove unused code so.. not 100 sure what you meant, but I figured this whole function could just be deleted since it's just overiding a function from the base vacuum service that will already throw an unimplemented error. If this isn't wan't you meant let me know I like to keep PRs as small as possible - seems unlinked to room targeting. I believe I've gotten rid of the extra bit here. This line should be split - we try to avoid lines 88 chars. You should add type hints. You could also expose the kwargs: I believe I've exposed kwargs correctly, and the rooms list is now types. does this look like what you were going for? This feels like bad input to me. Maybe rename variable: I like to keep PRs as small as possible - seems unlinked to room targeting. You should be checking against a more precise exception. this should be good now renamed to this Please adopt your code to support [service translations]( I believe I have done this correctly now As already epenet commented, I would remove this code. If you want the rooms to be more flexible, I suggest you use something different than areas . As you raise an error, the service will be flagged as failed.
Unrelated - please remove from this PR Coverage is missing - config-flow requires 100 coverage. Unrelated - please remove from this PR I think there are ways to use translations in config-flow, but I'm not quite sure. Regardless I'd probably use a code description structure rather than just plain text. This hasn't really been adressed. I think you should leave it open. Maybe another reviewer has some advice. Added translation support. Is that along the lines of what you were thinking?
Can this happen? Yeah sorta, it can happen when the device is transitioning from a locked to an unlocked state or vise-versa I just don't think there is a nice way to handle that state. other than ignoring it since it doesn't tell you what the current state is so setting the is unlocking is locking attributes is not really possible and won't be 100 accurate What other device states are there? We do know what the current entity state is, if that helps? The only other state is not fully locked, ill see if I can maybe use it to set the is unlocking and is locking attributes Please break long strings and comments around 88 characters per line at minimum. Docstrings should not be longer than 72 characters per line according to PEP8. Can we use a base 10 integer (257) instead? I'd import and compare with the lock state constants, STATE LOCKED etc. This is a common state found in the const.py module. I don't think we need a warning. Unknown state is a known concept in Home Assistant. Keep the comment but move it above the state attribute modification in this block.
We've added a new entity, that is a good fit for this: The event entity. See: I would recommend implementing that instead.
Do we need to log this as info ? I think, debug would be more fitting. log-messages Thanks fpr the hint. Is done. Splitting up the results could improve the readability here: Thanks for your input, I changed the code according your suggestion.
I don't know if still applies as you signed the CLA CLA kinda voids it, but my editor is just set to auto add them. might worth adding documentation on the structure of the packet (if available) as it looks like a lot of magic number. Its part of the device docs from the company. Ill make some documentation on it. Please extract the device specific interface code and data parsing to a standalone library published on PyPI. 4-communication-with-devicesservices
So we already have services for turning it on and off, for those cases, we don't need to add fields in this service call. This leaves the snooze capability. I suggest renaming the service to alert.snooze instead, accepting the optional time it can be snoozed (in time format, not hours, so it becomes more flexible). Thanks for giving it a look. alert.turn on alert.turn off affect only the current firing of the alert (i.e., until the condition for the alert becomes false). The notification control call persists through future alert firings. It's useful if the condition for an alert alternates between true and false - e.g., a water sensor that's slightly wet or a temperature sensor that hovers around a threshold. I wish I had a better name for it. In an ideal world, to be more precise, we might rename the services: - alert.turn off - alert.acknowledge - alert.turn on - alert.unacknowledge and then add alert.notifications on, alert.notifications off and alert.notifications snooze to capture the new behavior. I've changed snooze to take a datetime as you suggest, and updated the comments to hopefully be a bit clearer.
Why is there commented out code here? Either remove it if it's not needed, or uncomment it if it's needed.
Use SelectSelectorConfig with SelectSelectorMode and SelectOptionDict Needs typing dict[str, Any]?
I think this check should be splitted. One to check if the entity is a scene with its own log message and the other one with the actual msg. Why not use scene id? We should not use scene id . The parameter scene id in the create service isn't an entity id. It's the name of the scene to be created. When configuring scenes in YAML, this parameter is actually called name . I don't think we would have named this parameter scene id today in the create service. entity id is good as we want an entity id to find the existing scene entity. Why not use scene id? Why not use scene id? This should probably be an entity service as it targets an entity. For those kinds of services we have a helper for registration in the entity platform. I'm not sure why we have the service description for the platform specific services in the scene integration and not under the integration that registered the service. It may be some legacy thing that we haven't updated. Can you try moving this to under the homeassistant integration inside a services.yaml file? Same here, if it works to move the service yaml descriptions. Raise ServiceValidationError for bad user input and HomeAssistantError for other problems. Pass an argument with the message to the exception. The message can have translations and will show in the frontend. We don't need to check for intersection in this service. I remembered why we don't use the platform entity service helper for the scene.create service. We want to register the service under the scene domain and not under the homeassistant domain. We should probably stay consistent with that also for the scene delete service. Let's move back to using hass.services.async register but create the validation schema using the cv.make entity service schema helper. We can do that inline I think. We can use async extract entity ids in the service helper to get the entity id s from the device ids and area ids: L433-L440 But do we want that? Who assigns dynamically created scenes to areas? And do devices even exist in this context? The service just deletes a small subset of scenes and takes an entity id as an input. What good would this do? Yeah, I guess it's an edge case. Ok, let's not use cv.make entity service schema for now. If we see a need later we can always add it later. Too late, I used it and pushed the commit. I guess it won't hurt, although it's certainly overkill. I just want to get this (and [this]( merged to fix a problem I've been having for almost a year, so if you want the helper, sure, let's engineer the crap of out it :) Move this back to under the scene integration. Sorry about my confusion. And this.
I suggest we don't assert the magic packet call as it's not important for the trigger feature and the magic packet feature should also be deprecated probably, in the future, as it doesn't belong in another device integration. Please remove all of them and we don't need the variable anymore.
Invert the logic here with an early return for easier to read and less indented code: Please move all the MQTT data and topic parsing to the 3rd party library. The library can accept callbacks for MQTT subscribe and publish that Home Assistant can provide and then the library can handle the logic and parsing as needed.
Host is not valid as a unique id. You have to keep async abort entries match Discovery requires setting a unique ID, so I'm continuing down this road... Poking around the repo, I see it's not unusual to use serial, is that acceptable? I just uploaded a draft with my thinking... Is it possible to get the serial without logging in? or MAC is also a great candidate for unique id, if it can be accessed during the manual user process. I don't think Obihai will respond to any queries without authentication. New upload using MacAddress instead. I think it might need some cleanup... Ony the part that can throw should by in the try scope. We should avoid the use of get mac address , it can return the wrong value depending on the network setup of the user. The host could be external to the direct (v)lan of Home Assistant. Understood, though I'm curious: Previous reviewer indicated we should not query the device for unique ID (serial number) until after setup has completed - as this requires a login. This leaves MAC address, unless I'm missing something. Is there another method of determining a devices MAC that would be preferrable? Instead of using get mac address here, can you first validate credentials, and after that use the Obihai API to get MAC and abort if there's a unique id collision? I just uploaded a patch that does this. Hopefully we are circling on a satisfactory solution... Existing entries for existing users don't have a unique ID set. So, their existing instances will now be discovered again? Good point. Easy way to resolve this is with get mac address, though it sounds like we still need to close on what an appropriate unique ID is. Serial number requires authentication, and MAC may not be ideal in certain network topologies. I just uploaded two commits with two different ways of handling this. The first just uses get mac address to migrate unique IDs. The second uses the Obihai API to get MAC (which requires a login) - My concern here is that if get mac address is returning an incorrect value these values won't match, but at least async setup entry will attempt to migrate the unique ID. I'm not sure if how this would fail in practice and don't really have an environment I could test this thoroughly in... Try scope contains more than it should. Same comment as above Instead of checking this at every startup, we could bump ObihaiFlowHandler.VERSION and migrate the unique id to MAC in async def async migrate(self, hass: HomeAssistant) - bool: which will be called if the VERSION is not up to date. We don't want to add devices without asking the user. Hence, move this to a new step async step dhcp confirm which has an empty schema and tries the default password and username, and if that fails move to the user step (or a custom step which only asks for username and password). Uploaded a new patch, with what I believe is what you're looking for. Why are we bumping the version conditionally? Good point, I was intending to postpone the version upda
This part seems unrelated to "add support for other switch devices" Additionally, we should not crash if a switch does not have a location assigned (which is an edge case but might happen), so make the room optional. This should be a standalone "bugfix" PR. Also, I suggested to StefanIacobLivisi that a single "base" entity should be created to avoid duplicate code between switch and climate. Maybe that should be considered also... I see. You seem to like your PRs quite granular, which I understand given the load of work you get every day. As the livisi component is quire fresh, I fully agree that a refactoring will be required soon. I'm not an official Livisi dev (just someone who needs this integration to shut down my OpenHab installation) so I'm probably not the right person to do this kind of refactoring. However, when I get around to tackle the MotionSensor integration and this hasn t been done yet, I will have a look at what is common between these 3 types and create a base class if StefanIacobLivisi is okay with that. Also, if you are planning to contribute quite a bit, then you can add yourself to the code owners on the integration. Then you will receive notification when the integration is adjusted. PS. congratulations on your first merged PR: now your workflows no longer need approval to run However, when I get around to tackle the MotionSensor integration and this hasn t been done yet, I will have a look at what is common between these 3 types and create a base class if StefanIacobLivisi is okay with that. I think you should consider creating the base class earlier rather than later. It will simplify the review of new platforms when you implement motion sensor. That's what I mean to say. Before I start to implement a new platform, I would do this myself, but as long as I'm simply doing small bugfixes I don't see myself in the position to do this (as I'm not sure if StefanIacobLivisi already started working on this). Also, if you are planning to contribute quite a bit, then you can add yourself to the code owners on the integration. Then you will receive notification when the integration is adjusted. Can should I do this in this PR or create a separate one for the addition (and if so, what type should I choose, none of the options in the template seem to fit)? Separate PR "add myself to livisi code owners" with code quality checkbox.
Why is a token file needed? The Google Calendar integration has a flow for TV and limited input credentials type. Isn't that an option here? Unfortunately not. That's the only way which requires quite some steps as outlined in the documentation PR. Did you test all the different credential types? Why do we still have a session if we're not going to use that when using the JSON file for credentials? Why should the user set up the integration via a web auth flow when the credentials from that flow won't be used in the integration. How will reauthentication work, eg if the client secret is reset? Fixed. Reauth can't work if you use the creds json file.
This adds I O to every mock hass object in every test, while it's never used. We shouldn't load it here. If needed, just insert an empty HassLoader object. Whoops -- 100 right. Will fix. Done. you should be able to include this in the previous list comprehension. That results in a duplicate key in the dictionary. Will switch to a list of tuples here. Is "code" the right word to use? The Jinja documentation calls them "templates", so I'll switch to that terminology. import-context-behavior Let's limit to a specific extension Let's use .jinja, which is what their docs recommend: template-file-extension this won't close the file. Use the singleton decorator from helpers singleton.py that will do this automatically for you. when is hass None ? There is also a check for hass is None below, and IIRC there were at least testing scenarios that had None as a value -- this was initially added to appease them. For now, I'm going to move it down to after the later check and get rid of the extra condition. The docstring says this will load custom jinja, can we make the function name more distinct? Rename this too Let's make the magic number a constant and also document the limitation The comment suggests something happens only if hass is available. What if it isn't? Slightly adjusted wording. If hass isn't available, imports won't work, which was the behavior before.
Odd to reboot an entity? This should be a button entity instead? We usually try to keep these in alphabetical order. Why do you import the whole namespace here? We have about 42 files that import the namespace, and 1892 files that import AddEntitiesCallback directly. Since you are using a single element from the namespace, I think it is better to simply keep: Same here - I don't think the changes here add anything. I would revert the changes to sensor.py There are no arguments to a button press. I think the pylint warning is here for a reason: you shouldn't be catching the broad exception. I suggest that you simplify this code This is a constant. It should be defined outside the init method. I suggest that you create a module constant BUTTON DESCRIPTION and assign it to as a class attribute: Could you add type hints here? Is serial a string? This should be a class attribute: Thanks for all your patience. Not used to working with folks who are as detail oriented as you, definitely challenging (but in a good way). Especially considering how overwhelming it is to try to learn how to develop integrations! This seems incorrect. Reboot - reboot . The prefixing should not be needed? Leaving out the prefix results in an entity named "reboot" which IMHO is confusing and undesirable. ![image]( I do see that if I use attributes instead of setting entity description (comment below) that this does work as you indicated, so I'll use that approach. The problem seems the missing DeviceInfo that causes that, if you add device info it will grouped in the device. This seems odd? Entity description are normally dynamically. Instead, in this case just class attributes could have been used. This seems a shared pattern with the sensor platform, extracting a base entity might be a good idea at this point. This raises a red flag for me, is every platform creating their own instance? Why? Instead it should be created during entry setup, so the platforms can just use them.
You don't need anymore the cast if you call value as string. hvac mode should be of type HVACMode It seems that pylint doesn't pick it up because we are inside climate entities namespace, but I think it should still be implemented. A second thing that I don't really like here is that we have a compulsory "empty" function. I suggested that we raise a HomeAssistantError in r1118390937 but now I wonder... I'll ask for a second-opinion... Thanks! I fully agree and we have an empty function in another climate implementation as well. If we have a decision, I will fix that one (in a separate PR) as well. It seems empty function is OK in this case.
The dependency bump should be a standalone PR Moved dependency bump related test changes to 90127. Using SnapshotAssertion is great, but it should be a standalone preliminary PR. Moved SnapshotAssertion changes to 90128. This can be simplified with snapshots: you only need to pass in the entity id and then snapshot does the rest. Or maybe you don't even need to pass in the entity id (but you may need to patch the PLATFORMS constant to only return SELECT entities: Avoid conditional tests. Split it into two instead. These constants shouldn't be necessary if you use snapshot assertions One to keep in mind for a future PR: this should be moved out of init.py into entity.py Or you could also use Callable[[RemoteServices, str], Coroutine[Any, Any, Any]] Nit-pick: you can replace x with v for vehicle, and x with o for option. While I was on it, sure :) Why is this not represented by a number entity with min 20, max 100, stepsize 1? We need step size 5 as the API doesn't accept anything in between. I wasn't able to do that with number steps somehow. Did you try setting native step to 5?
Copy paste remnant Spelling You don't really need the init method here. You can assign and evaluate on the same line nowadays The NumberEntityDescription should be defined as two constants, not generated inside async setup entry . As specified by Kane610, this is not needed. The type hint is wrong here, and there is no need for the intermediate variable.
There's already a configuration option related to samples: sampling size . I think it would be better to use the term "sample" here too so it's clear they refer to the same thing, hence preserve last sample , keep last sample or something like that. Agreed, this is more consistent. Used keep last sample . Updated documentation PR as well. Since configuring this is meaningless unless max age is also configured, I think we should fail if the user sets this without also setting max age . Hence, please add a customer validator to PLATFORM SCHEMA which checks this, you can check the valid state characteristic configuration and valid boundary configuration for how to do this. Added validation associated unit tests.
unique ids are per integration and per platform so no need to prefix it here. Is the rfid globally unique or is it possible to have two systems with the same rfid? example-acceptable-sources-for-a-unique-id It should meet those requirements, but I'll add a caveat as you made me learn of an extra feature in the integration I didn't know about where the unique ID should be zone rfid " " zone loop because the way the integration works is I can define a different entity per loop within the sensor. The zone rfid value is a serial number printed on the device by Honeywell and is in the firmware of the individual sensor. When the sensor broadcasts it's current status it includes that serial number in the RFX message to say "I am device 1234567 and my status is open" so it is intended to be globally unique. I can't 100 say Honeywell never reused an ID obviously, but they're meant to be a device serial number that cannot be changed. That is why I'm limiting this change to just RF sensors. Hardwired sensors are only unique within your system, like it might just be "zone 3" because it's wired up to the contact for 3 on your PCB. RF sensors are different though because they have this serial number. Second thing I'm curious of your input on. This integration is a little unique to me because most integrations add entities by like making an API call an getting the list of sensors. There is no such capability for Honeywell systems. So in the options flow you basically say "add a new sensor" and then type in the details. Since the zone rfid loop value is intended (and must be) unique, I would think I should also update the config flow code to actually have validations to prevent the user from adding duplicates? Any precedent for something like this that you're aware of? I adjusted the unique id to guarantee uniqueness now but I'd love your thoughts on the config flow side We don't want to patch HA internals in tests. writing-tests-for-integrations Make sure to not interact with any integration details in tests of integrations. Following this pattern will make the tests more robust for changes in the integration. Instead create the entry in the registry and test that it returns the error
It looks to me like whiteled brightness returns an int, which doesn't match this return type. Good spot, you are right. Changed it in the latest commit Since get brightness is actually an int (if I understand Python typing right), this should be 100.0 , right? Yes you are right, changed it. This is important because otherwise rounding errors will be made. When specifying callable in entity description the norm is to suffix it with fn done This could be defined in the entity description It is not part of the default LightEntityDescription, so I would still need these lines to set the attributes, and need to add both supported color modes and color mode to the enitity description of each light, so that will be more lines of code. Currently it is more compact, I like it better this way. But if you insist I can change it to be in the entity description. No, I expected those attributes to be exposed from the description but if that is not expected by the light platform then its nothing I would request being changed. Will the API always be updated directly after the call? Yes, setting properties on the host camera is always done using the send setting function which has these lines: L2845-L2849 So it will indeed fetch the state from the API after changing the light status. In your lambdas you say channel can be int None , but here you say it can only be int . True, this was because I was thinking about NVR entities that would not have a channel, but I ended up using seperate EntityDescriptions for that like in PR I have changed the typing to only int across all 6 PRs. brightness is already an int, by the validation schema. Thanks, I have corrected this Should led status have a entity category of config? Yes, I have added the entity catogory done done
commented out import? Done remove comments Done commented out import? Done You shouldn't need to do this, it should be handled with await config entry first refresh as long as your config entry is correct Done remove commented out code Done Do you want this to continue through if an api token isn't given? why do you declare api token before this instead of just raising an error if there is not a api token passed through? Yes, because the device offers the option to disable the security token authorization. Also if this is not recommend, but the users need this if you change this to user input is not None, you then don't need to call async show form here. Look at updated scaffold config flow for an example Done Great, thanks. Need typing on errors What does that mean? You shouldn't need to do str on host and token. They should come in as str. Done devicedatas a typo? again shouldn't need to do str() Yes that might be correct, but the SlidingDoorCoverEntity expects a string and not an Optinal[any], so I have to do the cast Not sure, but I think it is typically better to do native value, instead of handle coordinator update I am also not sure, but I cannot find an overrideable method or attribute thats called "native value" in the CoordinatorEntity or BaseCoordinatorEntity, or how can I use your solution? Thanks for your feedback You can remove the unused ones. Done This file should no longer be pushed. so should I delete it? I have one more question: Although I use the predefined constants of HA (as well as CONF HOST) only the text field for the host is filled with the corresponding title in the setup, the token text field is without title. What can be the reason for this? A google search for "intellidrive" does not provide results for the sliding door controller, I'd suggest to set the domain to reisinger intellidrive and name the integration "Reisinger Intellidrive". This is not matching the implementation, did you forget to update strings.json ?
Home Assistant already supports these features natively... why add a separate API and handling for that? When you say HA already supports this, I am not sure how it does that other than to put it into configuration.yaml and restart. Is there a different method to turn a log on off without restart? There are multiple approaches. There is a service available for setting logging on the fly. But more importantly, if the loggers are defined in the manifest.json file of the integration, they can just be enabled disabled on the integration config entry: debug-logs-and-diagnostics There are plans to build out that feature, with things like recording over X time and things like that.
These tests should be combined to one, where the options flow is initialized with empty data and user data is then passed in. In that way it better mimics the real behavior when the user configures the flow. Also, the test should assert the API is called with the new location, maybe something like this: Could this use a SchemaOptionsFlowHandler instead (see accuweather )? Since this is just a single schema without any validation it seems a better fit. Not sure if SchemaOptionsFlowHandler works in this case. The OptionsFlow is calling hass.config entries.async update entry to update the config entry, which SchemaOptionsFlowHandler doesn't seem to do?
Don't think this needs to be inside the try. We keep try exception block short as possible.
Can you explain what this sensor reports? This state class is not allowed, but there's a new device class which will allow it: Either we should use the new device class, or change the state class. Edit: I had a chat with frenck about this, the recommendation is to keep the device class set to energy but not set any state class Please move this change to a separate PR fixing the bug, we should not mix it with a PR adding new features.
Drop this, and instead do self. attr device info DeviceInfo(... Why is this set to None , and then also set in init ? Typically, only a single entity (the device's "main entity") should set attr name to None . Since light entities are created in a loop, does that hold true? Edit: OK, so a device is created for each light entity, I didn't get that. Does that correspond well to litejet hardware? Yup. As in the other comment think of LiteJet like a hub that is exposing multiple physical devices the user interacts with. This conflicts with what's set in in light.py and scene.py . Or does a centralite device which generates switch entities not have any light or scene entities? Edit: OK, so a device is created for each switch entity, I didn't get that. Does that correspond well to litejet hardware? Right. Think of LiteJet as a fixed-in-stone hub system that has no extensibility. It has a central panel that every keypad and light wire run back to. The keypads and lights can be in different rooms (HA areas) so I made them their own devices. Scenes can act on multiple of these lights so I attached them to the hub device. This seems like a good proposal
As I understand it, the possible onvif events defined in homeassistant components onvif parsers.py ? If so, the events are currently using a name which is English natural language. For the device triggers, it would be better to map non natural language to natural language, for example: motion alarm - Motion Alarm Maybe add a new key event id to homeassistant.components.onvif.models.Event ? Note: Translatable entity names will come soon: the entities generated from events should then have their names translated. I wasn't sure this was relevant as the event name is only used in the subtype of the event, nonetheless I implemented a conversion to non-natural language. This means we can't adjust the English wording without breaking automations. Add a non optional event id: str to the class instead. In a follow up PR, the English translations should be moved to onvif strings.json and the name be removed from the Event dataclass. More details here: I did the requested changes but one of the event ids is created dynamically. I checked the documentation you linked to but couldn't find an example of such a case. Are translations like this supported: s line crossed - s Line Crossed ? emontnemery can you have a look at the changes please?
Ideally we exclude android. but we don't support wildcards here and I'm not 100 sure we want to do that so that might be something for a future pr to add exclude wildcard attributes We may want to limit it to startswith for performance (or maybe even a pre compiled RE) .. that's not for this PR though Starts with could also work in this spot and would be cheaper to test against then glob. We should instead use hass.helpers.entity.entity sources , which works for all entities: Good idea
We have a webhook integration, see i.e. ecowitt. Please use the webhook feature together with this callback Changed to the webhook integration like ecowitt. Additionally, this needs to explain to the user what they need to do and how they can fix this issue. Right now, this is more of a notification, without any clear path for the user on how to solve the problem and how to dismiss the issue raised by this integration. I committed your suggestions and added a sentence. This is not how this check should be done. get url provides parameters to set your URL requirements and will throw when it cannot meet that. See: However, as per above by pvizeli, it should not handle build this by itself. As far as I can see I can only force it to SSL, but not require it to be HTTP only. Added some additional parameters to the get url function, but I don't see how we could remove the HTTP check here. I removed the http check issue registry stuff. there is nothing that return False or get checked, why not just set to None? Changed I mean we have the same issue on ecowitt, no SSL support. We just documented it at the docs. But that part I guess, frenck need look over it removed the http check issue registry stuff. When implementing this ( async with ), mypy throws following errors: changed the method to async instead of callback .
Looks like a duplicate entry? No, as there is one for Switch Multilevel, and one for Protection. I can specify in the comment, if you think it's needed. You misunderstand me. You added three to the list when you only need two. The last two are dupes Edit: nope I misunderstood you, apologies! I believe we already discover the protection CC though? No problem! The last two entries are disabling endpoint 2 by default. Both Protection and Switch Multilevel has to be disabled for endpoint 2, as everything is doubled up with two endpoints on this silly device. We need to also verify that the second endpoint entity is disabled (can be done using the entity registry) Added test in last commit We want to also test that the entity has a state after enabling the entity and letting it be added. We can reload the integration to let the entity be added: L153-L166 willmakenoise would you be able to make this requested change in a new PR?
You should be creating the api here, and checking authentication then return configentrynotready or configentryauthfailed. I've not seen someone not use a coordinator, so I don't know if that is allowed(could very well be, but i'm not sure). I Then you should store the api coordinator(if you need to make one) in hass.data[DOMAIN][entry.entry id] Okay I think instead of a coordinator, you could use your SunWEGData object. you should access this from coordinator from hass.data[DOMAIN][config entry.entry id] I think this should live in init You shouldn't need to make multiple instances of your data object. Look at the August integration to see how they handle this. They do a similar system instead of a coordinator I'm creating one data for each sensor. Do you suggest one per device.id? I would say best practice is to have one - period, and just have the sensor define how it uses it differently. But I think one per device id would be a good step. Again look at August code and I think that will be a good example. By just having one you can keep track of authentication, reauthenticate, and not have to authenticate n(sensor number) times. When you make a new object each time you create the sensor you are making a bunch of unneeded api calls. Just give the data object here and use the data object in different ways inside the Inverter object. This goes for all of them StateType str int float None Remove unneeded ones Ok. Need datetime as well. I'll remove date and Decimal You don't allow the user to pass in url. Can the url that you have go bad? Or is this just a remnant from elsewhere? Again, you don't let the user pass in the url I think you need to actually check for this. needs comment What do you mean? Isn't this an obvious line? I think that over-commenting is not needed. Yep sorry - my bad. I looked at it wrong. No comment needed here I don't know if this is needed best practice. instead of using self.data, just pass user input to async step plant self.data is to persist authentication information. And the user input inside async step plant is to receive the plant selection, when needed. just have data user input If I do that, I'll loose the username and password. Remove this and just access entry.data best practice is to type this dict. I can't. If I type it, I'll have type issues with a float(previous value) below. The issue happens because of the datetime possible return. Maybe rename this to api variable or something similar so that it is a bit clearer. At first glance I thought it was a key to connect to the api rather than a variable to access certain data in the api. type config just use config entry.data directly StateType datetime.datetime use Instead of a global mock of the package, mock the package directly through the component. Homeassistant.components. ...
There's no need to check this IMHO, Entity.platform can't be None once the entity has been added to Home Assistant. I think we should either type Entity.platform in a similar way as we type Entity.hass : L238 Or, as another option, only add the platform attribute when the Entity is added and remove it when it's removed: I'm not sure if the 2nd option is quite worth the squeeze though. Are these calls async safe?
lambdas shouldn't be multiline I've been told before. You can provide a method instead I changed it to a seprate method, thanks for the feedback. Could you review again approve? One of three untyped lines of the file I guess if you don't expect more variants of sirens you could probably just put the methods directly. True, I have done that now. Second of three untyped lines of the file Thanks, I added typing now to both lines :) Third of three untyped lines of the file Should this also be moved? Yes I have also moved that out of the entity description This unneeded conversion has been removed. It already is an int? You are right, I removed this unneeded conversion.
The other day I tried to serialize a vol.Exclusive and it wouldn't work. I wanted a simple "select this section or that section" of the config. I know this is not related to that, but I just wanted to express my appreciation for what you are doing here. Approved.
Put Coordinator in its own Coordinator.py file redolved with [eab7ef6]( needs doc comments redolved with [eab7ef6]( Consts should go in const.py I think this would fall under that. Need doc comment redolved with [eab7ef6]( You can delete the unused ones redolved with [eab7ef6]( doc comment redolved with [eab7ef6]( I believe this should no longer be pushed That is correct redolved with [eab7ef6]( You don't check this in your config flow. You should redolved with [eab7ef6]( What if authentication fails? Or something is wrong with the api the connection? redolved with [eab7ef6]( You should probably create test for these. But I don't think it is strictly required. I notice in pywaterkotte you've got a reference to a serial number. If that does what it sounds like then using it as the unique ID gets this validation for free. Should be fixed with [aea0760]( I think all new integrations are required to set attr has entity name and follow its naming rules. See: should be fixed with commit [5d37a49]( This should happen after authentication. you can make it hass.data.setdefault(DOMAIN, {})[entry.entry id] coordinator on line 47 is this the actual default username and password? If so - this is fine, if it is just a placeholder, I would skip this. remove this comment type errors instead of patching it globally, you are supposed to patch it from within the component. "homeassistant.components.waterkotte heatpump. ..." instead of patching it globally, you are supposed to patch it from within the component. "homeassistant.components.waterkotte heatpump. ..." instead of patching it globally, you are supposed to patch it from within the component. "homeassistant.components.waterkotte heatpump. ..."
Why is this method overloaded? Add a tests which tests the behavior when the lock already has the setting in the entity registry options. I think this will be called only when the entity registry is updated. Compare with sensor which has a method async read entity options which is called from async internal added to hass and from async registry entry updated . L758-L764
Copy paste? I think this has caused issues with the token. It looks like local calendar has a workaround: L61-L68
Why not using switch statement ? hi! Thanks for you feed back.... hum! good question.... For next update, I replaced the if else block code by The Python idiom for this is a dict lookup, not if-else or pattern matching: Thanks.. Indeed, you should use a dict in this case Why update binary sensors as often ? If this isn't related with cameras, it should be in a separate PR. It's for next PRs... the idea is to add all Freebox sensors .... I splitted the big PR into other small ones Okey, so this is a first PR of implementing multiple Home devices from the Freebox ? Maybe you should add something to the "Proposed change" section of this PR. Rename this file as home base.py , because the actual "base class" for this integration is router.py . Or as below EDIT: While seeing the code below I understand why you did this, to be consistant in the file. But still I think you should use here. This is always true, you can remove this property ? Code comments aren't allowed, but comments that explains something are I don't think you need to return anything Where is this used ? For future use ? Where is this used ? For future use ? Where is this used ? For future use ? May you type functions ? kfb ? and adapt calls accordingly Not used add typing Somewhere it has to have self. attr is streaming False But this also seems a param for a future use, not used here.
I'd suggest to drop this, and just suppress the FileNotFoundError instead. Ah alright, that makes it way easier to read Should the empty directory also be removed? In that case, I guess we needed the function again. I think you can just call rmdir() after trying to delete the file and suppress errors from that too. I've left the helper function since now we need to suppress 2 calls. This breaks any existing translations. We should avoid that, unless the keys are really misleading with the changes in the PR. If the are, we should manually fix the existing translations. Frenck should be able to help with that.
The reason we do the json parsing afterwards, is that if the test messes with the object, the fixture will not be updated. Because of the LRU cache, these changes will now remain between tests. Most fixtures won't be changed, and that's great. It's just a gotcha that maybe we should at least document (although no one will ever read it ) If that's a worry, we could also remove the LRU cache on load json and keep it only on load fixture Yes I don't think we should cache fixture objects in a common helper. It's ok to cache a fixture string, but mutable objects should be cached by each integration as wanted as that's fragile. Done - but I have kept this in draft until 88247 is merged to avoid conflicts Which json tool should be used for an array of objects? For now we only have helpers to check the top-level ( JsonValueType for any json, or JsonArrayType or JsonObjectType ). We can add extra helpers if we want to ensure that each array item is an object but for now we don't have those. Why isn't this an array type then? Nevermind, I misread. It's an assertion.
We shouldn't look at the registry here Let's subclass the entities and coordinator and have them register for needing an active connection. Then we can decide to poll based on how many are registered that want an active connection What do you mean by registering that we want an active connection? Is that just the mode attribute forActiveBluetoothProcessorCoordinator? Or is it more to it than that? Than subclass the entity as well to call self.async on remove(self.coordinator.processor.register active(sub)) in async added to hass Than you can check if we should pool if needs active update Alternatively change hass.data[DOMAIN] to be a dataclass ex L19 L159 that stores a new object and the ActiveBluetoothProcessorCoordinator and refactor needs poll and async poll to be bound methods to a new object that could keep track of when entities need active polling. bdraco I implemented this, added a few comments I would appreciate you look at (no rush). But it seems like the coordinator doesn't do the normal manufacturer data updates now, I'm sure I forgot to add something to the class or I made some mistake there, but if you know what it is, just let me know. Thank you as always! This has to start as None, otherwise, needs active update will never be true, and the battery will never be added. I get an error if I don't type the entity description, and I get an error for the coordinator. I checked and they are both the correct types, but how can I make sure the typing is correct. Do I need to subclass processor? Put this at the top of the class above
There is no need to add a service if there is a button entity for it. Done This will fail black formatting, it will need a carriage return: This is only for custom components - please remove version. Have you tested this feature? Feedback on the renault-api library has been inconsistent, and the function doesn't appear to work on all vehicles (does it actually work on yours?) The service worked on my Dacia Spring. I will test the button today. Just tested it and worked with my car. Dacia spring. Great can you please adjust tests accordingly? Should we split the renault and dacia integration? For example dacia spring don't allow schedule charge? Is possible to have a base integration that is common to both and then specific for each brand? It is the same library so I think it's better to have a single integration. Even some Renault vehicles don't support schedule charge... It is better to adjust documentation for this This is a cleanup - I suggest you open a separate "cleanup" PR to remove this section. done I opened 88064 Sorry. I didn't have the chance to do it.
Do we have any other integration in need of this unit? If not, then maybe it should be added to local constants instead. Apparently Airq also uses it. Gen1 Awair devices had a "dust" sensor that reported combined pm10 pm2.5 values. This array was used [elsewhere]( L57-L69) to turn the "dust" sensor reading into identical pm2.5 and pm10 sensors, which felt more in line with the rest of homeassistant at that time. Since the Awair cloud API is no more, we don't actually have to update this array. A future PR could remove that aliasing entirely.
Since you're providing translations for this I think it would be a good idea that you have a translation dictionary so the key values doesn't change if the reolink API changes down the line The dictionary is already used, it is the SpotlightModeEnum defined in the reolink-aio library which makes the translation from API key to key used by HomeAssistant. See here: L6-L11 I will not change the Enum names in the reolink-aio library because that is the whole point of that Enum. Since you're providing translations for this I think it would be a good idea that you have a translation dictionary so the key values doesn't change if the reolink API changes down the line Same as above, see L14-L19 Can both get options and value both be None? Do we really want to create this entity if both are None? Yes, but we always need either get options or options , the option list is always required. So if get options is None, the options will be directly the list. Diffrence between options and get options: options: list get options: method providing a list To make this more clear I have changed the entity description to now require get options and not use options anymore but always get options which can be list[str] Callable[[Host, int], list[str]] Calling .keys() should not be needed.
This is a "light" and should thus be a light entity? These are the build in floodlight LEDs of the camera: ![afbeelding]( The control of this floodlight is a bit complicated: This switch can be used to manually turn the LEDs ON, while this switch is ON they will always be ON. When this switch is OFF, the floodlight will be controlled based on the internal camera Floodlight mode see select entity in this PR: Floodlight mode OFF : floodlight will always be off. Floodlight mode Auto : floodlight will turn on when an event (person, vehicle, motion etc) is detected by the camera and turn off a couple of seconds after the event seeses. Floodlight mode Schedule : floodlight will be on off based on the internal camera time schedule. Then we have a single floodlight brightness number (see PR which controls the brightness of the LEDs but this brightness is shared between this switch and the Floodlight mode , so if a user does not use this manual switch and leaves it OFF, we still need to be able to access this brightness to control the LED brightness when the camera internally switches the LEDs on (mode Auto or Schedule ). Therefore I can not incorperate the brightness in the light entity as would normally be done. I think you have to use the light.turn on service to change brightness right? I was a bit confused wether or not to implement this as a light entity or not, and decided for a switch, number and select entity. frenck Which entities would you recommond for these 3 features (manual on off, mode, brightness)? Which entities would you recommond for these 3 features (manual on off, mode, brightness)? If it is a light, a light. Alright, I will change them to light entities I have removed the Floodlight switch in favor of a light entity in this PR: Same as above? For the build-in Infra red lights (see picture above) it is again complicated: When this switch is OFF, the IR LEDs will always be OFF. When this switch is ON, the IR LEDs will be ON when the camera is in night vision mode. Night vision mode is controlled by the Day night mode select entity see PR Day night mode Auto : the camera will decide internally when to switch to day or night vision mode. Day night mode Color : the camera will always be in day mode color vision Day night mode Black White : the camera will always be in night mode infra red vision black and white picture frenck Schould this be a light with only turn on off, keep it as a switch or use a select entity with two options: Off and Auto? How is this complicated for a light and not a switch? Both are toggle entities... When this switch is ON, the IR LEDs will be ON when the camera is in night vision mode. That is not what the name of the entity suggests or reflects. I have removed the IR LEDs switch in favor of a light entity in this PR: I have also renamed the entity to "Infra red lights in night mode"
The slider is automatically set in general, was it needed to override it in this case? .. Frenck I tested, it was indeed not needed so I have removed it. Looks like this is handled by the light entity in diff-0248158d2443bae1c91d1ec20d1335a8a86a69b421c2a258f843a71c1027c957R45-R56 No not true, when the floodlight mode is set to "Auto" or "Schedule", the camera will automatically turn on off the floodlight internally independent of the light entity. The Brightness of this number entity applies to both this automatic turn on of the floodlight and when manually turned on through the light entity. The light entity will only allow you to change the brightness when also actually turning on the floodlight, while this number entity allows you to change the brightness while the spotlight keeps off is controlled internally by the camera floodlight mode ("Auto" or "Scheduale") see: diff-24a4e9eab3c1a3ca00959be0cca50b3701b27598b6ea20bf268b3a5cef5004d8R39-R48 I have to agree partly with cgarwood, this is highly confusing towards an end user. I had to read the above 2 times, to even remotely understand what is going on. A user won't be able to figure this out by looking at the Home Assistant UI and their entities. That latter indicates something is wrong IMHO. frenck I know, it is also a bit confusing in the reolink app client. Would you have any suggestions on how I could make this more clear for the end user? Maybe rename to "Global floodlight brightness"? And or remove the brightness control from the light.floodlight entity so this is the only floodlight brightness in HomeAssistant? yeah or maybe "Floodlight turn on brightness"? Good suggestion, I renamed to "Floodlight turn on brightness". Schould I remove the brightness control from the light.floodlight entity or just leave it? (It will do the same thing as this number entity, but since you have to use the light.turn on service it will also turn the floodlight manually on untill you turn it off again using light.turn off). Schould I remove the brightness control from the light.floodlight entity or just leave it? I think that one can be left as is. I guess we can just use the native min value and native max value in those cases, and omit the additional lambda. Thanks, done this everywhere where the lambda was not required. Same as above. Same as above same as above same as above as above Maybe this fits better same as above same as above What's the difference between this number entity and the light entity for the floodlight? L46-L55 See discussion above: pullrequestreview-1323877435 I read up on the comment history in the PR. Please add a code comment explaining the situation so we don't need to wonder what's going on when reading the code. CC starkillerOG I will add a code comment and some extra documentation because this is indeed not clear enough, just a moment Documentation PR is here: Code comment PR is here:
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries. ok, I'm new to home assistant and was not aware about the adr - sorry.
We should drop Pill here since we may want to add support for additional devices the vendor makes in the future Also change BLE to Bluetooth since BLE is less likely to be understood by all speakers I m not against this, limitations compatible tested devices can be explained listed in the doco Okay, done. I've also updated the docs accordingly. This should use the Home Assistant constant and not the integration value Import from homeassistant.const
You could move attr has entity name to base class I would think Good idea, just done it in the latest commit, thanks! We can use asyncio.gather here to do this in parallel. Thanks for the suggestion, done This is static and thus can be moved into a class variable, just like done with the device class. Thanks, done If there is no data, we don't know the latest version. If something is unknown, it should return None . I added this just before: The reolink API will return a boolean False if no update is available, so there is data received from the API and we do now we are on the latest version, the API return is just a boolean. Note that if there is a new version available a string will be returned. This is fixed, maybe set it as a class attribute instead? Done What if this fails? A ReolinkError will be raised, if the rspCode is not 200 or code is not 0 a ApiError (derived from ReolinkError) will be raised, if something goes wrong in transmission you will get the coresponding ReolinkError raised. it shouldn't raise an ReolinkError. If something goes wrong, it should raise an HomeAssistantError. Alright, I now try except the ReolinkError and raise a HomeAssistantError intead. I'm confused what or why they are different. The class descriptions are exactly the same? Sorry, I forgot to update the docstrings. I now put a (hopefully) clear discription in the docstrings: ReolinkBaseCoordinatorEntity is for entities that control the NVR ReolinkCoordinatorEntity is for entities that control a camera connected to the NVR A camera connected directly to HomeAssistant withouth using a NVR is in the reolink API basically a NVR with a single channel that has the camera connected to that channel. Some exotic models like the the [dual lens cameras]( when connected directly to HomeAssistant are then basically a NVR with 2 channels with each of the lenses connected to one of the channels. We don't need to add the platform domain to the unique id. The entity registry is aware of both the integration domain and the platform domain. It's good to add a unique suffix if we're planning to add more than one entity type for the platform.
We shouldn't be determining this every action. Instead let's figure this out when the entity is set up, so the right DPCode can be referenced correctly every single time. .. Frenck Hello frenck , thank you for this review. I will try to do this (this is my first PR in HA) We already identified in init which mode we should use. We need to check here only for that mode Same here A second opinion is needed here. Are these two opinions exclusive? What should we do if a device supports both? jmcollin78 Does your device include DPCode.SWITCH in self.device.function ? Maybe we could extend the if statement to Before applying this suggestion, wait for another opinion. No. My device have only DPCode.POWER in function. The device can be configured in standard instruction set (the previous "mode") or original DP instruction set which include the "POWER". The device cannot have both. See more explaination here if needed : This PR fixes this issue. Thus, your last proposal will not change anything. Device are only in one mode possible : POWER or SWITCH. We can change this putting the device into Native CP mode on the TuYA cloud. This is explain here: So for me, your last proposal is useless. This seems to be device manufacturer specific, as this is not a normal DP name. (capitalized). Please note, that we don't want to add implement device specifics, but only use Tuya standardized data points. Have you contacted Tuya about this? Yes TuYa, have been contacted. You have the result here: issuecomment-1415277555 The contact of TuYa is the origin of this PR. Devices have 2 modes: standard instruction set or original DP instruction. This PR is made to make the "original TP instruction set" works. frenck is this a blocker point ? If yes I will not try to fix your suggestion below and stop this PR. This ain't right, we have helper methods for this, please use the find dpcode methods to find them.
HomeKitProvisionPreferredThreadCrentials should be HomeKitProvisionPreferredThreadCredentials ? Think this comment is a copy paste error It is indeed. The UI for this is still up in the air, if everything goes to plan you'll actually never see this button in a stable HA release. We aren't supposed to access hass.data in tests. Can you call the button entity press service instead?
Seems like you accidentally committed this change. pre-commit auto changed that file. Yes I probably got confused by the name, either it has been a merge error. It should be fixed now logger is unused in this file hass.data should only be set once you can confirm that you can authenticate and connect. You probably should also be using ConfigEntryNotReady and ConfigEntryAuthFailed Exceptions changed. Same as above, scaffold put it here. For the second part, I did not get how I should differentiate between the CannotConnect InvalidAuth that scaffold adds automatically, by the ConfigEntryNotReady ConfigEntryAuthFailed you mentioned If you change this to user input is not None: then you don't need to call async show form to begin with. Just handle user input if exist show form Instead of show form handle user input show form Right, good suggestion. The script.scaffold integration command makes it this way though, perhaps it needs to be changed as well Yep. I submitted a PR for the scaffold to be changed, it should be merged shortly. You can remove the unused ones Also I believe this is now supposed to be in domain, name, then alphabetical order. You don't seem to check do in config flow. You probably should Sorry, I did not get what I should check in config flow. These are there because of scaffold as well, I did not change anything You need to make this an external package. 4-communication-with-devicesservices I thought it was a [strong] suggestion, not a must (but I noticed I was wrong, reading it again from your link). Either it is just few calls. It will require me a little longer to fix this You shouldn't be creating them, you should be importing them from homeassistant.exceptions import ConfigEntryAuthFailed, ConfigEntryNotReady you need to set hass data [entry] like you do in your async setup entry in sensor. But you need to do it here, not in sensor. This should be done in init. errors should be typed Should be solved now
Stale docstring
can you remove options from here. Yes, in a separate PR: This feels more suited as a check in the websocket command. This should just return the display dict. Makes sense let's not include translation key if it's not set. Let's not include it if it doesn't have a value. Also not include unless it has a value. Should we also have area ID lookup and device ID lookup? That'll be a bit more work, because we then need to invalidate cached display dicts when the area id or device id lookups change because an area or device has been added or removed, unless we have some sort of stable lookup which is not affected by area and device dict entries be added or removed. I'd say we let the zlib compression of WS commands handle deduplication of area and device id for now. Shouldn't this one also be optional ? Sure, that's possible You can now use the new MockHAClientWebSocket Maybe a silly question but do we still need this entry since it has no useful information? I think we need it so frontend knows that the entity is in the entity registry and can be customized? This API output is only meant for displaying. When we open more info and the settings screen will be shown, it's based on the other output. CC bramkragten piitaya Yes, the config-entities page can use list endpoint.
do a real connection attempt type the host variable instead of silencing mypy Use the same name for the integration everywhere. This is not OK This is not correct, please refer to the documentation here: available-state-classes To be clear: total total increasing should ONLY be used for sensors which we want to accumulate a grand total for. Same comment for some of the other sensors. Why is this done via update , does the charger not push updates? What's the point of this? I need it for modiy the sensor entity descriptions as i want. Why do we sleep here? Instead of this, add lambdas or functions to the entity descriptions, to which you pass the charger object and which return an updated value. pymodbus doesn't seem to be used by the integration? is this dict ever used ? could this function be moved to v2ctrydan ? wrap only the line that might fail, catching all possible exceptions does not help to identify problems These should be translatable no print allowed
We should check if it is actually an IPv6 address... and not an error message with : in it or whatever else it may produce in the future It's not an error message, it's the format of the IPv6 address, for example: 98.207.254.136 IPv4 2a00:1450:400f:80d::200e IPv6 It's the easier way I thought about checking if an address was IPv6. We can probably add some regex, but I think it should work. Screenshot from the apify 64 service: img width "949" alt "image" src "" It's not an error message, it's the format of the IPv6 address, for example: I understood that was not the point :0 The point was: We should probably do some validation... I understood now. Yeah, a simple "Error: something" will be understood as an IPv6 address with this simple check. I relied on http error codes but better to do a proper check.
This is already inferred. What if authentication fails? We should only add it to the hass.data once we know we can continue the setup (so test authentication before adding it to the hass data). This method isn't needed in this case, all it does it wrapping everything into something else... Put it directly in line in the user step instead, which means you can get rid of the InvalidAuth and CannotConnect error classes as well. If you flip this around, you only need to call async show form once These can be omitted with the suggestions above ICON seems to be unused. Please move the coordinator into its own module ( coordinator.py ). And initialize it in the integration entry setup instead. Monthly costs, with a total? Doesn't this reset monthly? If not, what does this sensor mean? Averages are not suitable for state classes. Same as above Why would we keep total increasing stats on this? Same as above? No need to alias it. domain shouldn't be wrapped in a tuple. The coordinator should be created in the integration setup and stored in hass data This uses a coordinator, why is True passed here? This is the default behavior - This can be directly put into the native value property method. - Add add a lamba function to the entity description, so we don't need to use getattr() . host doesn't seem to be part of the config flow? - The config flow doesn't seem to check this (but it should). - This is not a device, but a service: We don't keep resulting translations in our repository anymore, please remove this file. I assume I remove the entire translations folder? or just en.json? In git that will result in the same thing... as git tracks files, not folders. You can't add empty folders :) duh! Thanks
No type annotations? Maybe add the integration to strict typing if we're close? oops. That would have been nice. Will adjust and add strict typing
Per PR 87543, translations are no longer in core needs docstring needs docstring This confuses me. You are taking a dict, then making a new dict with the same keys and values as the original dict? Why can't you use the user input dict? Why do you need to make a copy need doc string This will currently fail style checks. It needs to be in order of domain, name, then alphabetical. This is a recent CI change. not 100 sure if it is intentional I don't know if you need to have sensor as a dependency, I've never seen that before, but I'm not sure. needs docstring
It seemed like things are migrating away from extra state attributes and to capability attributes , which is why I put this here, but I wasn't totally sure. My understanding is that the capability attributes don't change, but rather are defined as a part of the device structure. If this is the case, preset temperatures are not such capability attributes, but rather settings which can be embedded as attributes next to an entity. Yeah, as I said, I wasn't sure what belonged where. If they don't belong in capability attributes do you know where a better place would be? Is it extra state attributes after all? Apparently, yes. The device state attributes is deprecated in favor of extra state attributes . See [here]( L373): Although not huge in size, given their relatively seldom change, I would consider excluding these attributes from being recorded in the DB. Here's an example of how to do that: This makes sense, I'll make this change. Thanks for the pointer. This is static configuration, which we should not add as an attribute. It doesn't add anything to the state machine (as it add no state information, but configuration). This seems to be an addition to a particular use case that is very specific to your use case and not generic. Maybe using the customize feature is more suitable to resolve your use case? Is this what you mean by the [customize feature]( That doesn't appear to allow for adding more than a predetermined set of variables, none of which would allow for storing this data.
This isn't allowed, for more details see the original pull request: Prices colletion is removed! It might be useful to also adjust this so that it is clear what is today or tomorrow, but I think it means that people will get a new service with entities and I don't know if that is really useful Good point, but as you concluded, that would lead to a breaking change, and I see this as an enhancement which shouldn't break anything Where is this used? No longer used, removed Why the today gas entity? Copy Paste error, Should be today energy next hour price HA has got support for [translating entity names]( name-of-entities) and all other sensors of energyzero are already supporting them. For consistency can you please make the new sensor translatable too?
Just to be sure, is this checking that quirk name have 2 levels? There will be 'deeper' quirks like zhaquirks.xiaomi.aqara.sensor switch aq3.SwitchAQ3B
The MQTT topic parsing and creation should be done in a 3rd party library published on PyPI. The json loading and parsing should also be done by the 3rd party library. The library should provide objects with attributes that represent the sensor data. I recommend using pydantic in the library to create typed objects from json data. Look at how tasmota or mysensors integration use the mqtt integration. The 3rd party library should handle all the MQTT details.
Usually we don't store the data in hass.data until after the first successful refresh Can this be a bound method instead? It doesn't look like it needs to be recreated each time Let me know if this is not what you had in mind. Thats better (I'd call it async refresh though). I don't think you would ever have enough of these that it makes much difference here but we have problems with entities that generate a new callable when added to hass when we get to hundreds of them since it means we end up with hundreds of copies of the function in memory instead of just the reference to the bound method. This has been removed given the other calendar entity simplifications. I'm a bit confused how this works considering the update method is overridden to do nothing below? Here is some context: I remember now we were holding on doing more with this pattern and coming up with a solution in the calendar integration. I suspect the solution looks something like having calendar integration automatically update state based on the upcoming calendar event time. If that sounds reasonable to you, I can explore that and get Frenck's ACK also, then come back to this. It would be better if it only write state based on an event predicted change etc instead of blindly doing it at a 1m interval. I'm going to propose a change to calendar to handle this and come back to this after. Calendar entity was simplified in 98037 to handle these state transitions, so this was all streamlined. Is this used? No, removed.
I would suggest you use the property. This implementation would make current option static If options could change then I suggest same there the options can't change, this is linked to the modules, so there is no way in changing these names. Is the options known so they possibly should be translated? I would not do a translation, in velbus (on the modules) these names will never be translated, so these names are static there. if we translate them in hass, whats shown in the modules and what is show in hass will not be the same Are you sure to add this to config? this is debateable, but i think config is on its place, you can not change this from the modules itself, you need to do this via the config software What if this fails or raises? I would have expected error handling here?
homeassistant components zha switch.py:509:0: I0023: 'W0237' is cryptic: use ' pylint: disable arguments-renamed' This doesn't belong in zha core device.py , us unittest.mock within the unit test or directly overwrite the attribute on the object within the test. Due to this would need to be updated to ts0601 trv.ZonnsmartTV01 ZG everywhere, right? No, the change in 93268 will compare only the 2 last tokens from both the component's quirk class and the match definition. Everything else is not taken into account. I think you can set attr multiplier to 0.1 and then remove this entire method. (It's named "multiplier" because it goes from ZCl - ZHA IIRC) Thanks ! That simplifies the code a lot and get rid of the tests. I didn't see that multiplier. I think you can set attr multiplier to 0.1 and then remove this entire method. Same as above: should be possible to use attr multiplier Same as above: should be possible to use attr multiplier Is this entity even created when freshly pairing a TRV? (So, delete the TRV completely, then pair it again) window detection is not initialized from what I can see. It should likely be initialized here from what I can see: For the Aqara TRV, we use the "window" device class and thus don't need a separate translation key: L300-L306 I suggest we do the same here. This is not needed, since it's already set by ZHANumberConfigurationEntity . (Just fix it here in the added code. Seems like the existing code needs to be cleaned up in another PR.) Assuming the offset is in Celsius, we should set that: It's not optimal that attribute name, unique id suffix differ, and translation key all differ. For upcoming [quirks v2]( discussioncomment-8191961) ("expose entities via quirks"), we can still define them individually, but by default, they're the same as the attribute name. IMO, online set is not a great attribute name in the first place, but this might be because some other Tuya TRV quirks use the same? Yes I agree, not the best name. I can update the quirks and this PR is you want with "update" or "update attrs". Assuming the offset is in Celsius, we should set that: Not sure about this yet, but should this include for how long its being boosted? So "30 second boost" for example? I think this can use local temperature calibration as the translation key. (that's the ZCL attribute that seems to be equivalent to this)
You're removing domain here, but it's still part of EntityFilterSelectorConfig class let's add a test to verify domain still works And device class is twice.
Why not inherit from BalboaEntity , then you don't need to replicate async added to hass The BalboaControlEntity listens for events on the " control " specifically rather than on the " client ", so that it is updated less frequently. self.async on remove(self. control.on(EVENT UPDATE, self.async write ha state)) vs self.async on remove(self. client.on(EVENT UPDATE, self.async write ha state)) I see now Maybe you should add a comment in the code as it looked identical shfn I looked originally. Done I think representing these as fans is stretching the entity model a bit far. Can these be number entities instead? I would argue that a pump is a fan that moves liquid instead of air and seems more intuitive than a number entity.
This one is automatic
It looks like your service requires a zone id parameter, that should be defined here as a field. shows an example of how to do this. missed that, thanks

I recommend that you create a preliminary PR for the dependency bump. This feels like it should be refactored using SensorEntityDescription Of the parameters passed into these, the only one that's captured by SensorEntityDescription is name (and I would also have to pass in an additional parameter - key ). Wouldn't using SensorEntityDescription in this case be an overkill? You can replace "uid suffix" with "key" You can extend SensorEntityDescription to have a new key "sensor: MeterSensor" (maybe with a Mixin class) This is exactly what EntityDescription is designed for: to pass in the three items that are different on each sensor. You should use a Mixin class to ensure the key is required. This assert should not be needed. I think this should be StrEnum Enum is part of the standard library, while StrEnum isn't. What's the benefit of using it? All the values are strings, so I think it makes sense regardless of the standard library. The changes to async update data do not exactly make the code easier to read! I keep getting lost as I try to follow it... I tried to break down into smaller functions. Let me know if you think that helps I think you should create a dedicate model to store the MeterData , with four properties. Not needed:
are there any effects known in Matter world as far as we are aware? Or is color loop the only one ? can you move this into a small helpers file ? this looks a bit weird to me as color loop is an effect state the device is in and not a color mode. Maybe leave it out completely ? If someone is really attached to colorloops we can do a separate PR to introduce effect features ? Yeah removed the color loop part entirely since it's an optional thing that doesn't really need to be implemented and I don't think any manufacturer has implemented it in a first place Please sort . Is the order here important and controlled by the chip SDK implementation? Otherwise I'd put the mandatory items first with lower values. That is entirely related to the matter spec unfortunately can't really change the order [Matter Application Clusters Page 114]( page 116) Why do we assert here? Is it to satisfy mypy? That is indeed to satisfy mypy Why do we copy to integer here if it's already an integer? I'll fix this, it's part of an older commit within the pull request. I'm missing a test for brightness state attribute. In a follow up PR, I think we should split the light tests so that we can test all lights that support on, off and brightness in one test via pytest.mark.parametrize and different fixtures, and another test for the color light features, etc. Ie, we still want to test the dimmable light device type and all other device types we support. Perfect I'll make tests for each light type :)
This is a bit weird, as DEVICE CLASS STATE CLASSES never holds None value, but the set can be empty. Should it not instead be: Or maybe: Actually, maybe it is fine: - it will show "[]" if it's an empty set - it is future-proof in case None even gets added to DEVICE CLASS STATE CLASSES (though I can't remember why it is not typed dict[SensorDeviceClass, set[SensorStateClass]] ) Sorry - me again. Based on this discussion discussion r1071169863 I think the type hint should be adjusted to be DEVICE CLASS STATE CLASSES: dict[SensorDeviceClass, set[SensorStateClass]] { And then you can use: Made it more beautiful! Thanks for the input

I would suggest allowing floating point values by changing this line to: vol.Optional(ATTR TIMEOUT, default 10.0): cv.positive float, . Granted, setting a floating point value from the UI won't be possible with the way service configuration sliders work, but I think it would still work properly if manually defined in YAML. Is there a reason the timeout bounds are set to 10-60? I think it makes more sense to have the lower bound be 1, or even 0. For the upper bound, perhaps 300 seconds (5 minutes), which matches many of the other time limits for other things around Home Assistant such as light transitions.
I don't think this is needed if its set in the description L405 I don't think this is needed if its set in the description L372 setting in the description should be enough L372 L405 We should be able to use the parent's version of this instead L372 This should be provided by the SensorEntityDescription already L149
Why do we extract the mac address of the peer here, only to then lookup the peer based on the mac address in the DevoloPlcDataRateSensorEntity constructor? Can't we just pass the peer directly? Hi emontnemery , the data structure is a bit unlucky for my usecase, but maybe you see a better approach: So what I basically do is, I grep the MAC of all devices that are REMOTE and then look which data rates match the device I'm looking at (the local device) and the peer device. In case I have three devices and the local device would be A, I would see six pairs of data rates (A-B, A-C, B-A, B-C, C-A, C-B) although I'm only interested in two of them (A-B, A-C).
I think we need to finalize this one (mark as final). When marked as final, this isn't needed. I think this should use the native unit. It looks like device class can be unbound now... sorry about that. Almost all of these things have been moved into const.py , I suggest moving this there too. Rename to NON NUMERIC DEVICE CLASSES ? We have a bunch of tests that use these three too, which could use the constant now :) Reverted this change as it is not the same logic. It should be return device class is not None and device class not in NON NUMERIC DEVICE CLASSES (NOT None) That, sorry, it was a quick untested suggestion on GitHub Or (shorter) return device class is None or device class not in NON NUMERIC DEVICE CLASSES This will work though return device class is None or device class not in NON NUMERIC DEVICE CLASSES Fails too in tests :-(. the bool wrapper ensures we return a bool The use of bool() really isn't needed here It is, when device class is None it will return None It isn't. The reason it is now needed, is because the comparison on the first element is missing. You can remove the bool, if it is a full boolean expression. This method is partially flawed. For example, a sensor without state class, without a unit of measurement and without precision and without a device class will return false. The fact is: We don't know. Could be numeric, could be textual state I guess that is its goal, but we should make that more clear in the doc comments. That happens for sensors that just return a text state. This would work too: return not (device class is None or device class in NON NUMERIC DEVICE CLASSES) That results in the same unknown issue. We have sensors that don't provide enough information to know if it is either number or not (regardless of any logic we can apply). That was my point with my comment above, we should document that. An sensor can have a '' as a state, but a numeric sensor can not. But I agree it is hard to understand the logic. That's why I wasn't sure about naming. I didn't like is numeric because it implied the value had been checked I proposed numeric state expected because if that condition is True, then it HAS to be a number. If it returns False, then it CAN be a number, but it doesn't HAVE to be.
Please remove the translations folder. All translation strings go into strings.json New integrations entities must support [translation of names and attributes]( Please adopt your code accordingly.
I don't think it is a good idea just to exclude your project from tests. You should definitely have at least some test for your integration I believe async setup platforms is being depreciated and should be replaced with await hass.config entries.async forward entry setups This doc should be updated This api needs to be in a seperate api package. It should not be inside core 5-communication-with-devicesservices I don't know if logging user input is best. Will place their password into their logs and means they have to be careful ever sharing them. Also not sure why it is needed. run pre-commit. I believe this will not pass lint test. Why are you setting value here but passing it in?
Looks like its possible to have a password without a username from the schema above
You might be able to use cluster.endpoint.device.quirk class here. However, changed the "matches" to only check the "last two strings" when separated by a dot ( . ). So the code here should also check like that. IMO, this "last two string getter" should be put in the base class though, so we don't do the same thing in multiple places. Not sure if it should be done in this PR though. --- But tbh, I don't like this whole "quirk class" matching system, as it can change during refactors and with now only taking "the last two strings", it's not even required that the manufacturer appears in that "quirk class" depending on how zha-quirks is structured for the manufacturer. For example, I'd rather prefer something like a "quirk ID" (just a simple string that's set in each quirk that needs to be matched against in ZHA) that uniquely identifies a quirk not something that can change like a file name when refactoring). (But this needs to be discussed first and not done here) Thanks. I edited the code. I agree that there should be a more maintainable way to match quirks. Although I do believe that the method now is better than my first attempt :). I'll do testing on device again to validate. Hmm, it's not ideal that these aren't translated. Also, the capitalization needs to be changed to match the HA standard (for all BitMapSensors): e.g. "In progress", .. Thanks, missed those capitals. Wasn't there a PR that mentioned the translation of enums ( was closed)? I take it that that hasn't been done yet. Maybe I could take a look at that. The translation of enums could be done in a separate PR and the translation of bitmaps here as it is (for now) only needed for Danfoss. The extra state attributes can be easily translated for the bitmap, but the state of the entity doesn't seem to work for some reason. But if I can get that to work, translation of enums is also going to be easy. Okay, looked at the code for a couple of hours to realize the translations didn't get regenerated. It worked after all. I added every enum in strings.json. However for enums to work, new merge requests are required. I could also manually change the camelcase to snake case in my own enums, but that would make them inconsistent with zigpy. Edit: I made this PR work without any changes to translation code and made a separate PR for enum translations. I'm not sure we can want to show this in the UI for the sensor? (I wonder if we should remove this for the first revision to rather get it in for the next release?) This isn't shown in the UI. It functions as the translation key and is different for every sensor. Ah, you're right of course! I think "minutes" should all be lower-case here. Or maybe just "min" even? Done. This works of course, but in other places we mostly copy first and then update with the new attributes. Maybe we should try to keep that style here too? (undecided still) I see and I would prefer to keep that style, but REPORT CONFIG is a tuple and has to be done this way. Doing
Typo, "updatedf" Fixed mime type.startswith("image ") would likely be faster and more straightforward readable. I didn't know that function existed. I'm using it now Do we know that parts will always have all of these indices? The code here doesn't make it clear what exactly we're splitting apart. Yes those parts will always be there, because that is how I build the folder structure. But I added them as variables now. Take a look if you agree we should remove this here, because it would be called for each config entry - just do the webview register within the async get media source in media source.py as mentioned above, do this register just withing the async get media source() this seems to be unused? just direct start the ret list with its first entry nope, meanwhile it is fully async :sunglasses: you can directly instantiate it would call it album items to be more explicit over item use the objects as is use the objects as is I still had to change the file size manually to sm. Because otherwise it would be xl. And that would be way too large for thumbnails do not assert something, but handle possible issues not needed anymore, when passing the SynoPhotosItem directly ( see comments above ) - this will handle the case if mime type could not be guessed ( instead of assert it ) - splitting of location is a bit more readable Nice, I didn't know you could add multiple to a split - only relevant parts are within the temporary filehandle - use mode "wb" in filehandle, which opens the file in write-only byte mode - means, file is cleared on open this ret should be moved into the if block, beacuse it is only used there we should name it album item This information is missing from the docs Why only support a single config entry? When support is if added later for multiple it means all the urls will have to change to include the unique id of the config entry Multiple config entries are supported, they are passed into SynologyPhotosMediaSource(hass, entries) . tbh this comment is confusing, so i'll remove it from code Thanks for the fix. It looks like nothing cleans this up. Since you are already loading these into memory, it would be better to serve the binary data instead of writing it to disk I changed it from a fileResponse to a normal response
Nit: 'tag' comment copy and pasted from tag.py? Thnx Nit: Update comment This part is not used, removed now
let's remove this. This is making the integration overly complicated. If a user wants to limit areas etc that are send, they can define specific areas in the prompt. Removed Let's remove continued prompt. It adds complexity that's not needed. Removed We should never store the default options. That means you can't change them anymore. Any bug in the template is now stored forever. Am now pulling in default options at request time if options are not set Remove continue prompt. Removed it There's no config YAML for this integration. This fixture doesn't seem needed. It doesn't do anything more than the fixture above, besides running through the config flow, which isn't relevant for where the fixture is used. Please set up the config entry before starting the options flow to ensure that the config flow module is loaded. I've added the mock init component fixture to set up the component before this test is run
How is the dependency bump linked to reauth? There are no release notes and no tags in the library, so what are the changes between 0.0.14 and 0.0.15? In the 0.0.15 version, aiolivisi raises the TokenExpiredException when the authentication token is expired. How is this linked to reauth? Here is only a rename for this method and I added it in the 0.0.15 version of aiolivisi. So it is linked to "dependency bump", not linked to "reauth" "dependency bump" should probably be a standalone (preliminary) PR. I will create a new pull request for this, thank you! The new pull request with the dependency bump is here: Please adjust also the english translation file. I added the changes in the English translation file. This file should be removed from the PR. Translations are now fully automated. I removed the translation. I changed this, thank you. I changed this, thank you. I changed this, thank you. This makes me realise that: - self.data schema should really be a module constant: DATA SCHEMA vol.Schema(...) - self.aio livisi has wrong type (it should be AioLivisi None ) but maybe it should be dropped altogether and made into a return value of login : async def login(self, user input: dict[str, str]) - AioLivisi: I removed the self.aiolivisi from the class. This feels wrong. Should data not simply be updated with the password? You are right, I changed this, thank you. Even though it is a constant, it is specific to config-flow and should be kept in the config-flow module. I refactored this, thank you. For styling, I would invert the logic: I changed this. Could you fill in the schema with the user input? Done, thank you. Maybe you could you fill in the schema with the original entry data? Done, thank you. Here self.reauth entry should always be set. You can use assert here and drop the condition.
Can you add some type hints and return type? I guess you mean it like: def resolve slot data(key, request) - dict: A bit more specific dict[type, type] and also the function attributes. Something like: def resolve slot data(key: str, request:dict[str,str]) - dict[str, str]: However I don't really know about the requests type. The key is a string but the value could be anything actually. So I'd just say it's unspecific request:dict in that case. That is indeed what I mean. If needed I try to find out the type hints. The value part of the dict can have multiple types, so we can assign Any here. You will need an import for Any. from typing import Any I suggest we move the deprecation part to a new PR and leave this one for the nearest resolutions Fair enough. For now I'd only exose the new ID Variable which is the most essential. The Docs PR is already changed for that. Because it's a bad Idea to introduce new variables just to remove them later anyway. The ID Variable however is made to stay there in the long run. Should be fine now. Is this needed for this PR? We should not ask users to use this, so let us not add this. Will current fields change in behaviour? Or are only new fields added? If we are changing the data available in the templates, then this would be breaking. In that case , may we should we should an option to expose slot id's. In that case it would not be breaking. Then we could directly use the new format and assign the new behavior when the option is used. The name value old is only internal. The Variables will be mapped to the proper Template Variable Names. If we have a Slot named "SlotTest" value old will be mapped to {{ SlotTest }}, id will be mapped to {{ SlotTest Id }} and value is not mapped yet and for future use. But if u want i can revert this variable name change. It does not change any behavior yet. Okay, lets change that then. Please also remove the comments that things will change. We can add them in the next PR. Same here this might belong to the next PR
Please import and use the Platform enum Done, thank you. Done, thank you. Please add tests or add climate.py to the coverage ignore file .coveragerc I added the tests from climate.py to the coverage ignore file. Thank you. I don't think these two constants are any use. Done, thank you. Unrelated to PR, please remove the changes to strings.json Done. Done, thank you. Done, thank you. Apologies: my previous suggestion didn't put in the correct amount of spaces Done, thank you. You need to have 100 coverage on config-flow. Are the changes here required? I think you can revert them and maybe implement in a dedicated PR. I reverted this change, I will do this in another pull request in the future. Thank you. I have an error here: cannot use assignment expressions with attribute . Can I replace it with if (controller type : controller data["controllerType"]) AVATAR: , and then assign the controller type to self.controller type ? Sounds good I changed this, thank you. I changed this, thank you. I changed this, thank you. The type hint here is wrong, or you wouldn't need to check for None . (same for below checks)
That wouldn't be needed (already in parent class). Can you remove and check it?
Maybe rename to airpurifier mode just in case? Should these also be uppercased? Or rather, stay lowercase and the translated strings to be uppercased?
Can set the coordinator directly there as you probably aren't going to store anything else No need This looks like it should be part of the coordinator directly? What the value of having a key in the extra attributes? Make use of translations directly instead Set the NumberSelector directly in STEP USER DATA SCHEMA and then convert to int in validation or when reading the value What's this? What's this meant to do and why not part of the normal user step? This does not appear to give the user any chance to change anything?
This looks like it belongs in an option flow since it can be changed later after the integration is set up I initially did intend to put it there, but it does require some significant changes to the rest of the code to make changing it after the fact possible. In reality, I'm not sure there would ever be a need to change this value; it's main use case is if you are behind a proxy, you can't use the rtsp stream at all. Why does it require significant changes to the rest of the code to expose these settings as options as well as or instead of adding them in the config flow? Normally this is handled by letting the config entry's update listener trigger a reload of the config entry when options are changed, in that way you don't need to do anything complex to have the new settings applied when the config entry is already setup. Here's an example: L46 L65-L67 Will that recreate the platform entities? That's the part that I imagined would take some work. I am admittedly still figuring out my way around this code. The only setting that makes sense at all as a post setup option is the mjpeg option. Without the other settings, you won't even be able to connect, so you can't make it past the initial config flow.
There's a shorthand way to do this in init : entity-class-or-instance-attributes Converting this to shorthand, requires a request to the actual device first. At the init this is not done yet, this is what update before add True does. Same as above manifest.json needs sorted now. domain, then name, then the rest of the keys alphabetically. (ref These properties can all be converted to the shorthand instance attributes For non-changing attributes (like ICON), yes. But in this case it cannot be set in the init, because it requires a call to the device first. It doesn't need to happen in init , it can happen in update: This reduces the line count a great deal, which is a good thing These can also be switched to the shorthand instance attributes Same as above. Thanks for your review by the way! If the device is offline unreachable we should set the available property to false As documented, the Devialet speakers have a physical off-switch. When using this switch, the device should not go to unavailable as this stops updating the state and requires a manual reload of the integration to get it active again.. This explanation makes no sense. If the device can't be reached, because it's unplugged, or because the user has flicked a physical on off switch, it should be set to unavailable. State off should be used if it's possible to call the turn on service to turn the speaker on. It seems to me like there's a bug related to handling errors which you need to fix. If Home Assistant loses connection to the speaker for whatever reason, Home Assistant should always automatically reconnect without user intervention such as reloading the config entry. It seems this is fixed now, nice This is different from the corresponding code in async step user : - Config entry title is set differently - There's no check in the confirm step if the device already has a config entry - Error handling differs Please refactor the code so a common helper function called by both async step confirm and async step user does the needful. Please remove this from here and set it in mediaplayer.py instead. Also, isn't a 5s poll time a bit on the short side? This 5s poll time is mainly to refresh the attributes: volume, position etc. while playing. The Devialet API seems to get a push mechanism someday, but until that is implemented this seems the easiest way. This is not a representation of a Devialet device, it's a representation of the media player capabilities of a Devialet device, let's rename accordingly. There's no need to store the serial number both as unique id and in a separate attribute Please look into the [entity naming guidelines]( entity-naming), update as needed, and set the flag has entity name to True Done that, thank you. Instead of this, in particular because it's mentioned that there are issues related to reconnecting to the speaker, please look into the [data update coordinator]( coordinated-single-api-poll-for-data-for-all-entities) which helps a great deal with erro
I think these should be in alphabetical order. Not sure i understand you point here, it seems alphabetical the list i added? myuplink should not come after zwave me m z It's added to the file by a tool build into the HA dev - so think's it fine :) I don't think you need to should empty hass.data on setup I could be missing something be unaware of something though? It's "normal" what i can see, and i got some problems (i could be wrong) if i removed that line. We normally use dict.setdefault . See other integrations for examples. We shouldn't reset the hass.data since there could potentially be more than one config entry for this integration. Does the manufacturer change from my uplink? Are there multiple? Not sure, but it's a get or create method, so think it's fine? You can remove the unused ones Done I don't think you have to, but it would be good to type all these dictionaries you are making Can you give an example? It's dynamic dictionaries. point info: dict[str, DevicePoint] points: dict[str, dict[str, DevicePoint]] Again II don't think it is needed, but the more typing the better imo, esp if you ever want to enable strict typing. type these Done Delete this file - no longer in use Done The library doesn't specify what requirements it needs. It looks like aiohttp is needed. Please add that either to setup.cfg or pyproject.toml in the library. Still learning python - so where should i put aiohttp as requiment? In the myuplink package or...? Since you're using setuptools as build system in the library I recommend following their documentation on the subject: It's the dependencies setting that you want to use to specify library requirements. Inherit from CoordinatorEntity too. Then we can simplify the state update here. Look for examples in other integrations that use a CoordinatorEntity . Seems to be quite a big refactoring to make that change - i investigated other integrations when i did this setup. This file isn't needed anymore. I'd rename to eg create devices . Can more than one user authorize the same application? Ie is more than one config entry allowed? Can we set a unique id per config entry in that case? Is there a user id? A rebase seems to have gone wrong. This should be removed. This is why CI is failing. MartinHjelmare it fixed some CI errors, but something else came up. Again, seems related to another integration? Just rebase on latest dev branch. We fixed that yesterday.
Percentage is not an allowed unit for voltage device class. I'm assuming it's just copy paste leftover from above. Yup Its a paste error. Will adjust shortly
This integration has existing code with protocol details that belong in a 3rd party library. We won't allow changes or additions that add more protocol details to the integration. The details need to be extracted to a 3rd party library published on PyPI first. Why the windows handle are integrate like this but not the wall switch??? they are in the same family (rorg f6). I am not the first user how would like to see it in the dashboard. So i don't understand your answers. i am new user of HA, so what is Pypi? i just not understand your answer Best regards ![image]( [EnOcean Equipment Profiles EEP V2.6.2 public.pdf]( I tried to explain this above: This integration has existing code with protocol details that belong in a 3rd party library. We won't allow changes or additions that add more protocol details to the integration. The existing code is eg the window sensors you mention.
This sensor is now added as 'name' for the device. Maybe we want to do something extra as well? This is set in super(). init .. but MyPy does not not checking this. This feels a bit ugly. TBH, this is a bit filthy. The ExternalDevice list in diagnostics return a list where the unique id's are used as keys for the dict, we should hide that. But.. This hides all the values in this list, which can be used for real diagnostics. I do not like this but I can't think of another way. The unit is not predefined and can be everything, but in practice we see only 'm3' and 'GJ' for external devices. Another problem is that is is theoretically possible to have an invalid unit for the device class. ( Gas can have 'GJ' or 'Cats' for example.) We also can return the most likely unit for the device type, but that can trigger some issues when the unit is unexpected (which is also possible with this implementation). E.g. If we return GJ for 'Energy' and a device decided to use 'kWh' as unit.
The config flow isn't used here so it shouldn't need to be patched as above as above r1083345302 r1083345302 r1083345302 I'd actually make this a fixture so you don't have to patch it every time I'm 99 sure I need to do this in each test, as I'm modifying the value of the mock immediately before in some tests. If there's a better way to modify a mocked homeassistant.components.powerwall.Powerwall instance then I'd very much be happy to switch to fixtures and avoid all the duplication :) (sorry, python newbie here) Note: I've extracted this setup into a method to make it a little clearer avoid duplication I was thinking a pytest.fixture might make sense here. Not sure I follow, sorry. Can't find any relevant examples in the powerwall component. Is there an example somewhere I can follow allong with here? What you have is fine. I was thinking something like this: Ahh great, I reckon I can sort that out. Thanks again for the help Done! This needs to be run in the executor I've made a change to this section, and hope I've got it right This needs to be run in the executor This should use the async api instead This should use the async api instead This inheritance looks like it's missing the base Powerwall entity There doesn't seem to be a base Powerwall entity in this integration? Looking at some similar integrations, this would be a strongly typed version of the coordinator, this is already being passed in? Looks like adding this would end up being a very large change unless I'm mistaken? It should be a small change: r1083649806 If the set island mode can fail it should raise HomeAssistantError Operations like service calls and entity methods (e.g. Set HVAC Mode) should have proper exception handling. Raise ValueError on invalid user input and raise HomeAssistantError for other failures such as a problem communicating with a device. silver- We shouldn't change the on state unless we know the call was successful so we set the attribute after the call has not failed and than write state Ahh excellent, thanks for the pointer. I've updated this and also removed all the unnecessary coordinator and power wall initialisation code from switch- async setup entry Same feedback as turn on advanced-properties Icon to use in the frontend. Icons start with mdi: plus an [identifier]( You probably don't need this since Home Assistant already provides default icons for all entities according to its device class. This should be used only in the case where there either is no matching device class or where the icon used for the device class would be confusing or misleading. But the unique id won't work if they have multiple power wall systems since it needs to be set in init and include the base unique id I think Off-Grid operation might be a better name since its already bound to the powerwall device
this is not correct. Devices can have multiple identifiers, they don't all belong to vesync. You need to check the domain. changed as suggested this makes no sense. How could it happen to be None? And if that's possible, don't pass it to this function. You are correct, an early version of this file used this method for both diagnostics paths (config and device). Later refactorings meant that the only value for the other path was the redaction. This flow has been changed. There is no async setup function so this test does nothing. I don't recall why I added that test, removed. After this call, verify the state of the config entry is as expected. I'm not sure what I should verify on config entry because there are no changes to it...unless that is what I need to verify? I added code to verify that the setup does not proceed if not logged in. it's a bit overkill to copy paste this test and test single platforms. If you want to take this approach, use pytest.mark.parametrize I've been doing working on another vesync PR ( that has another batch of test improvements. I'd like to incorporate that test bed before trying to fix this, if possible. I can remove these test cases, if you would rather not have the extra test methods. Let's keep them out of this PR then. Removed the extra test cases. Will add them back in for coverage with an upcoming PR Commented out test. I removed the test, but in trying to implement the test, I realized that the implementation is not correct. It appears that modern integrations store the data per config entry and this integration does not, yet it's unload acts as though it does. This fix should go into its own PR. this is not necessary. Config entries are set up of async setup component. removed the extra setup call You can either define 1 dictionary at once or if you prefer to assign 1 key at a time, do that instead of using the update method: Changed to 1 dictionary Home Assistant will automatically add this config entry info that block doesn't get auto-added, it's intent was to place config entry values in the output. That block came from wherever I sourced the original code and didn't appear to add value. Removed the data. I would expect all info of device diagnostics to be inside a config entry diagnostics. But that doesn't look to be the same ? The devices here are coming directly from the VeSync manager. I idid this so that a user would be able to pull the config entry diagnostics and find out what the VeSync API is reporting. The device diagnostics report on the actual Home Assistant devices. I did this because up until recently, the vesync configuration would skip some devices reported by the API. The diagnostics will allow users to determine what is being sent by the API and be able to create issues to improve the home assistant device discovery. You can use our new snapshot feature for this! Docs: snapshot-testing fixed to use snapshot same fixed to use snapshot should this be redacted? should this be redacted ? s
This will help us later on when we start adding tests for sensors too :) It is preferable to assert the whole dict. If the dict is too big, you can create a fixture json file and then compare: assert diag expected diag Makes sense, are these guidelines documented anywhere? I don't want to miss anything else It's part of the same guideline... we want to try to ensure that if a follow-up PR triggers a diag adjustment, then the user has to adjust the test and we can check that we are not now exposing sensitive information. Usually, we also pass information from the config entry: L21-L27 You could use snapshots here instead, see: Done, thanks! Not sure how you generated this one, but the file is in the wrong place.
Can we check this in async setup to avoid instantiating all this just to abort? Should this be service ? Use the fixture Do we need to create a task instead of just awaiting the call? Probably not, I think I had some trouble when writing the tests and forgot to revert this. It was indeed not needed, fixed now extra space in doc string
I think you don't need to add empty dependencies There is no logging used in the config flow. So there is no actual need to define it as well as import logging Might be a bit more readable as for me This is the firmware version of the whole device as far as I understand. Maybe it's better to use it in the device info ( sw version ) instead of a separate sensor entity? Also, probably it does not change regularly, so there is no need to poll it each 30 seconds as other sensors It would better to store a dataclass here (see lookin model .py for an example) I realized that both of those pieces of data are just used in the coordinator init. so instead I set hass.data[domain][entry.entry id] the coordinator. Is that okay? Yes thats good as well example-acceptable-sources-for-a-unique-id The unique id should come from the device the device id does come from the device, the user just has to get it as we need it to be able to communicate with the device at all. The id is unique. There are no other unique identifiers from the api call and one username can have multiple devices, so that wouldn't work either. What would you recommend? L50 oh my. no authentication at all? Let's call this device unique id so its clear that its globally unique no authentication at all yeah, their api is completely unprotected for getting data. trying to set control anything is protected with a client secret, but I have yet to determine the best way to handle getting that making sure it is simple to get I may be able to figure out how to do it locally. And for the sake of making sure this pr was small, the integration is just data pulling only for now It looks like never need to look these up by key so this could be a tuple of SensorEntityDescription instead unique ids are per integration, per platform so no need to include the name of the integration Please patch the library where its imported into HA instead of globally Please do not interact with hass.data in tests writing-tests-for-integrations I removed line 47, I did a quick search around and it seems like most integrations either use the outdated (not hass.data.get(DOMAIN)) or just don't have it. If there is a third option that would be better practice, I would be happy to correct it. Removing it is just fine. Use the caplog fixture instead of patching the logger r1112397436 abort if unique id configured is doing the same thing here Don't set this until after you know the integration is going to actually setup (ie, passed though anything that can raise ConfigEntryNotReady) Create the coordinator, and than call await coordinator.async config entry first refresh() It will do the same thing as this block Only store the coordinator in hass.data after await coordinator.async config entry first refresh() has not raised How can I do this when I need the update for creating the coordinator? I need to get the firmware version. How can I do this when I need the update for creating the coordinator? I need to get the firmware version
should this be lower case? I created a new DPCode because Tuya has this entity with first letter "P" Capital. Using DPCode POWER it is not recognised. Power isn't listed in the documentation, also, there are no PD codes with a capital letter. It seems like this is specific for the device or manufacturer you are using. Unfortunately, we do not accept such workarounds additions. Please report your issue to Tuya or the manufacturer instead. In the mean time, this needs to be removed from the PR. Already send ticket to TUYA API dev team to fix the "Power" issue. Already deleted non-standard DPCode. Changed entity to standard POWER with lower letters only. When TUYA fixes it, we sould be able to control device normally. Are you sure the device class state class are correct? 8... so there are more? Shouldn't this be a sensor with an enum device class instead? The Tuya entity is a Bitmap. The information I got was that 0 is tank normal and 8 tank full. That's why O chose binary and put onvalue 8. I tested and worked correctly. Do you think it can go trought this way ? 8 is an odd value to check in a bitmap? This is part of the humifidier entity and should not a number entity? This looks like a list with an limited set of options? Should this be marked with the enum device class with providing these options instead? This seems to be missing a translation key for providing the translation for these options This should be a fan entity maybe?
On line 869 it references input number.DOMAIN , should that be adjusted to also be number? It should use self.entity.domain there. I guess my thought process was from Alexa's perspective there's really no difference between an input number and a number. So leaving the instance id like this allowed numbers to report all the same capabilities and fields. But I suppose it may no longer be unique like this. If input number.a and number.a both exist this will break. I'll change it and add new conditionals to the other places that check specifically for the input number domain. May be you can add tests as-well ? Generally look for input number in the code and tests and see what needs to be done.
Not needed, already done at end of get or load intents we should introduce a per-language lock. It can now happen that our prepare call is still computing while the actual sentence comes in, and it's loading the same intents twice.
If you remove this, what triggers the import of yaml to a config entry? Have you actually tested the import from yaml to a config entry, and it works? You are right, I've pushed an update with the fix. Don't use dict.get on keys which we know are in the dictionary. What's this for? This checks if it can connect to the duckdns server to update the IP when the user adds the integration from the UI. This can be refactored to be removed completely. This is from our templates generators, but isn't applicable in for this integration (and just adds unneeded code). Removed PlaceholderHub and validation. Don't import private methods We need to guard against import creating a new config entry each time Home Assistant is started Unresolved, as this is not really solved. Yaml configured duckdns only allowed configuring a single domain for updating, but this implementation doesn't have that limitation. That's probably fine, but we should not allow setting up the same domain multiple times. Maybe use the domain as unique id? It seems to me that there is no need to limit the user to only one implementation of DuckDNS, but I added a check so that the same hostname (domain) is not allowed. To be clear: While new code owners are very welcome, only add yourself here if you plan to actively work on the DuckDNS integration by solving issues, reviewing PRs and so on going forward. If you're not planning to do that, don't add yourself. There wasn't anyone selected as a code owner, so I thought of putting myself. I will be happy to help out with any issues that might show up. We need to raise an repair issue to inform the user that this can be removed from their YAML configuraiton. I've already raised a warning to the user for the removal of YAML config on the config flow.py at the async step import method. Shall I move it to the init .py async setup method? I think that makes sense (see also my comments below, where this returns :) ) Moved it to init .py There is no real info retrieved here, the return value is also static. Maybe just incorporate it into the flow below and remove the need for this method completely. Removed validate input and return nothing. What throws a CannotConnect? It wasn't used, so I removed it Move the issue creation to the init .py , as this is not about the config flow. This issue is about YAML config still being present (which is handles in the package init). Moved it. This isn't used (but should be used... ) Maybe add a field description on which format the domain is expected to be in? Maybe add a description on where to obtain the token? The user can recover from this error. Please continue the flow until finish to ensure this error doesn't create side-effects. The user can recover from this error. Please continue the flow until finish to ensure this error doesn't create side-effects.
Can you please remove this extra line 2098 this should fix your black failure. Well, it doesn t appear that this patch will be approved, so I haven t bothered. But I made the change anyway. Thanks rlippmann, I'm still following this issue and hoping it will be merged! Maybe disforw can advise on next steps? is future is not a good name since the caller does not know if the passed time is in the future or in the past, can we come up with something better? Maybe name it remaining time , time until , elapsed time or something like that? allow future? No, that's not good. We're not allowing or not allowing the timestamp to be in the future, we're either calculating time elapsed since some time in the past or we're calculating remaining time until some time in the future. Given the name of the function, it seems very unnatural to add a parameter is future to it; I would expect it to return a negative age for a time in the future. Maybe split this up in multiple functions: - get age, which returns the time elapsed since a time in the past - a new function, maybe named something like get remaining time which returns the remaining time to a time in the future - A helper functions which formats the time delta calculated by get age and the new function as a string What about: Rename this to get diff() Change is future to an enum, with values like DiffType.PAST ONLY , DiffType.FUTURE ONLY , DiffType.ANY -- this makes the code much easier to read than trying to figure out what a bool means in this context Re-add get age for backwards-compat that just calls get diff(date, DiffType.PAST ONLY, 1) Note: There may not be value in having ANY , but being an enum at least opens this possibility. (I feel like I've needed a way to do a past-or-future date before, but I'm struggling to think of a good use case now) Your suggestion is fine There may not be value in having ANY, but being an enum at least opens this possibility. Let's not add functionality which we are not sure is needed. It's been a while, but I think the is future was meant to be more like an "allow future" flag. An enum with 2 values is a boolean :) Yes, but then please come up with a good name for a bool which clearly communicates how the behavior changes. I don't think allow future is good because it's not clear setting it to True means a time in the past is no longer allowed. Hence my proposal to leave the behavior of get age unchanged and add a new function get remaining time which returns remaining time until some time in the future.
It would be a lot easier to understand if you just use min value. something like min value on its own sets a value it cannot be smaller than (and the way it is coded you can do exectly that with just min value) BUT ... This will not work for my use case ... I would have to add another setting i.e. how do you suggest we achieve: if it is less than 0.025 mA, treat it as 0 I am open to another suggestion, as min value on its own will not. BTW.. reviewing this myself, these 2 very similar bits of new code should be moved into a separate function process result that scales, offsets, and checks min max Well you started off by suggesting only a min value ? My biggest problem is that you add 2 keywords (4 in total min max), and do not cover the cases where only 1 keywords is used (e.g. min with threshold or just threshold). This is adding a complexity to the configuration that is unwanted. I have no problem with a simple filter function (min max) but extending it is really something you should do with a template sensor, where you have a lot more possibilities. It is important to keep the configuration as simple as possible, the modbus integration is responsible for communicating with modbus devices and does very simple value manipulation. Just to give you an idea we have had requests to replace "scale" with a function, allowing the value to be graduated instead of a simple scaling, the list manipulation wishes are big, and are all solved with the template sensor. I started with one parameter. You asked me to add min value and max value which I did. If you don't use them it will work as now. If you just specify min value or max value then the pr will work as you requested. I had to add optional thresholds to make them work for my original use case. Please check the comments on the pr itself as they clearly indicate you can just have min value and it will work as you expect. This is clear in the code where the values are loaded in the constructor BTW.. my original proposal had been to clamp small values near 0 to 0, but what is there now is more flexible and will handle your use cases as well yes, and if you use a template sensor, you do not need to make a custom integration, which you need to keep updated whenever the core modbus integration changes pymodbus version. And not to forget my comment about what happens if you use just min value (which will not work with this PR) or if you use just min threshold which might have some side-effects. I tested min value on own and it works as expected. If you specify min value threshold on own it will do nothing. These cases are covered by the code Same as min value, please just use max value and remove max value threshold. same issue as min value please remove min value threshold same issue as min value please remove max value threshold. same issue as min value That is a strange name, the industry normally uses zero supress . I believe zero suppress stops zero (suppresses it) which is the opposite to what this is 
Grammatically this feels in the wrong place. Maybe this works better: Had to break the line and extended the wording somewhat more. Should we make the "No unit" case clearer? Sure
Will something like this work? I think any strings that aren't latitude and longitude should work. I went this route because it's the same pattern I've used elsewhere. With this property function added, remove setting of self. attr extra state attributes above Why do we set state attributes at all in this case? Because that information may still be useful for a user who wants to know the precise location of a sensor (but doesn't want that on the map). I have seen multiple PRs in related to show on map , I would not hold this PR, but it worth making an architecture issue to add a flag which the entity will be able to set if it wants to hide icons but still expose coordinates. Absolutely agree. I'll add that to my to-do list.
Maybe homeassistant.const.CONF VERIFY SSL should be used instead of this :thinking: Maybe we should use [ key:common::config flow::data::verify ssl ] here instead and adjust referring strings accordingly. "Verify SSL certificate" is somewhat unfortunate phrasing though, in practice it's TLS we do nowadays, but maybe the general public is better accustomed to SSL than that. Anyway HTTPS would fit better as a term here, so in that sense we might want to keep this phrasing. Thoghts welcome. The existing language is used by 20 integrations, so it probably makes sense to use the same here? Could the existing phrase be adjusted to something like "Verify SSL TLS certificate"? Yeah, I'll follow suit here, 9e2060ae8cbee05e0ad3be3c64e4372231e93e26 switches to the existing config and string keys. We could see what others think about adjusting the existing phrase, but I think it's off topic for this PR. "Verify TLS SSL certificate, "Verify TLS certificate", "Verify SSL TLS certificate", "Verify certificate" could be candidates worth considering. ("Verify HTTPS certificate" would be nice, but the key might be already in use for other TLS verifications besides HTTPS.) BTW I would prefer if we'd merge 85929 before this instead of this to its branch in order to not unnecessarily balloon it. Kind of would make sense to mark this as draft for that reason, but it's really not a draft but all ready for review, so I'd rather not. 85929 has been merged, this one rebased and good to go. I suggest adding this option into a separate step as it could confuse the users if they insert an HTTP URL. Maybe even better would be that we try the first time with validation activated, and if it fails, show a step where the user can turn it off. I'm a somewhat torn on this one. I do think the suggestions make sense, but: We're essentially doing the second already here: if a verified HTTPS connection fails due to a verification error, we say so and give a hint to retry with verification disabled. I'm not sure if a second separate step would be any more helpful. Verification is off by default because I'm not aware of a router that would could have a generally out of the box trusted cert installed, so verification must have been explicitly toggled on by the user, and as such, error should not come as a surprise. With regards to the confusion with a plain HTTP URL, I'm not sure if that's a big issue. We could amend the help text with something like " (if https connection specified)" to alleviate, but that would mean giving up on using the common string for verify ssl , and thus being possibly a bit inconsistent with other things in the future. (I see vol.Optional has a description , but it doesn't seem to appear in the UI unless I've missed something.) I suggest only to modify the session if the URL starts with https: and verification is disabled. Fair enough, done in 4cb0104b993be3a5adc947bf4e1dee030875b2a0, also in init .py . CONF VERIFY SSL has a default value, why do we use get here
I guess this is not related to added support for scenes? Please either move unrelated changes to a separate PR or add review comments in this PR to make reviewing easier. I reverted the two unrelated changes. This one and one in . api init .py to remove unused code. Should admin be required also to get scenes? Yes. This is an intermediate release to enable scene creating editing, which is an admin function. There is another change coming to make it easier for a standard user to consume a scene after it is created.
Thanks for adding the import! Please also add a issue for warning the user that the YAML config is obsolete. Another thing is that we need a test for the config flow (see [config entries config flow handler]( testing-your-config-flow). You should not delete existing tests. You should not delete existing tests. Please look at mock setup entry and pytestmark from scaffold L1-L14 and L12 This file is no longer needed. Please remove it. This refactoring should be done in a preliminary PR. It distracts from the config-flow amends. I think this should be using self. attr device info, and it should be done in a follow-up PR to avoid distracting from the actual config-flow. You need to keep the old schema, and mark it as deprecated. I think it is better to create the issue here before creating the import flow. I think it makes more sense to move async create issue to init module.
shouldn't this be 'redact matter attributes' as it is processing multiple attributes ? Can we collapse this? the whole dict value of this is not needed. That's just for lookup. - Node id is in parent - endpoint ID, cluster ID and attribute ID are in the key. - Cluster Attribute type name are not needed as we have ID That's a question for the server. I don't think we should adjust anything here. We include what we get from the server. Personally I like the verbose human readable values in the cluster and attribute type, and think we should keep them. All these should be flattened. Can we expand these classes to either just the repr value or we add dataclasses.as dict on it ? ? same
This is part of the state already, why add them as attributes? Please note, this is a change to an entity component, which generally requires architectural discussions prior to making the change. When a lock is jammed we want to know in what state this happened, Please note, this is a change to an entity component, which generally requires architectural discussions prior to making the change. In the entity model all these attributes are available. The entity documentation does not cover exposed state attributes. When a lock is jammed we want to know in what state this happened That is a historical value? As it is jammed it is impossible to know if it is locked or not. However, that said, that would be nice to discuss architecturally. In the entity model all these attributes are available. They are not exposed as attributes as they are not considered a state on their own. Architecture discussion started: Side note: ATTR UNLOCKING is not used? Will add that
May be worth raising on incorrect credentials ConfigEntryAuthFailed handling-expired-credentials Hello and thanks for your feedback! Yes, your suggestion is good. But this would require splitting the configuration for login password (which will be handled by the re-auth flow and for which ConfigEntryAuthFailed can be raised properly) from the SLL port settings as they are now. Also, the credentials on the router do not expire as happens with some connected services and so on. The user needs to do this manually from the same menu as changing port SSL - this was a part of the motivation to put them all together. This can be implemented at the next step as a new feature and will help make the integration better. For now, I would prefer to keep the proposed code as small as possible, so the Core maintainers will be able to review it and approve it (if they find it correct and suitable). Of course, if this plan is fine with you Hi There, This needs to be changed to: await hass.config entries.async forward entry setups(config entry, PLATFORMS) Hey, thanks! I did not know about this before and only found out when getting warnings with the 2023.2 update yesterday Why not use the hass helper for format mac? Because format mac works only with MAC addresses. Also, the router.mac is already formatted using format mac in router.py (line 137). The commented code is used to convert the whole string to a predefined unique id form (including description.name )

The same change is needed in number platform.
IMHO we can't do this. This will just break about every used light template out there. Should i try to have the 2 naming side by side ? Or keep what i feel is a confusing name for HS, and add the other stuff around ? That might work, mark that in an exclusive group, so the old still works, the new will work, but setting both throws a configuration error. I've reverted the "deprecation" of the "color" option. Should we add a warning that it might be at some point, or just leave it like that ? I've left this part commented for now because i don't know if i should check for the exclusive aspect of the 2 config value ? I also don't know how to make pytest look for an exception but if this is pointless i will be more than happy to not dig more into it. The function does not explicitly return a value if self. color mode is falsy. I prefer to write an explicit value that should be returned in this case. For example, ColorMode.COLOR TEMP or ColorMode.UNKNOWN . Given the way the light is created, i believe there is no reason to have self. color mode still at None . Because of this, i feel like returning ColorMode.COLOR TEMP would hide some error and be counter productive. I've try to add an else that return ColorMode.UNKNOWN as proposed, but i can't find a way to test for it. since i can't find a time where this can be anything but set. Because of this, adding the else raise an untested new code, and stop me from filling the PR requirement Tests have been added to verify that the new code works. I believe the correct way to manage this is actually to remove that useless if and proceeded to do so. I am open to suggestion. Previously, if several scripts were specified, the color mode remained none. And the getter returned a value depending on the presence of the specified color. For example, if you specify CONF COLOR ACTION and CONF RGBW ACTION at the same time, the ColorMode.HS and ColorMode.RGBW modes will be added. After filtering ( self. supported color modes filter supported color modes(color modes) ) both modes will remain, so the length of the list will not be 1. This if will not work, and the field will remain None . Then ColorMode.HS will be returned from the getter if the specified color , ColorMode.COLOR TEMP otherwise. After your changes, specifying multiple scripts will always return ColorMode.UNKNOWN . I think it makes sense to add an if similar to what was before. If there is only one specified color (for example, self. rgbw color is not None , and all others are None ), then return the mode corresponding to the color. If there are several colors at the same time, return ColorMode.UNKNOWN . If neither the mode nor any of the colors are specified, return ColorMode.COLOR TEMP as before. After your changes, specifying multiple scripts will always return ColorMode.UNKNOWN. I'm willing to talk about this more, but i believe you got this wrong. Before the change, the type of the color mode was pretty limited and "calculated" in this function. When 

Not needed as it can take the device class to make the name "Firmware" Hi gjohansson-ST , do you have instructions for me, what I need to do? If I just remove the entries, the entity isn't named at all and other integrations I check name it explicitly. You set translation key on the base entity so if you set it to None here it will not have a translation key and therefore use the device class as it's name So on the entity class set Then remove that section from strings.json as it will take it from the entity component instead. I added a comment where you need to put in in init Interestingly, that's not doing the trick. The update entity is still named like the device ... Probably because it's a pretty new change so commit your changes so far and then rebase onto the latest dev branch to get it in. I rebased, but still it's not working. So I pushed my changes so that you can have a look. Maybe I made a stupid mistake ... entity id would now be update.firmware so skip the device name in between. But I would suggest you run the failing tests locally on your dev so you can see the output. I guess, we are talking about different things. I expected the entitiy to be named "Firmware", instead it is called like the device: ![grafik]( I will fix the tests as soon as we understood the issue here. Hi gjohansson-ST , do you have some further advice for me and maybe also a hint for me, how I can update the device registry with the new version? Currently the old version stays there until Home Assistant is restarted. Hi gjohansson-ST , 98579 added what we are aiming at here. So I rebased to profit from the changes. Could you have a look again, please? It seems, that this doesn't work that way as async add entities expects an iterable. Updated the suggestion, wrap it in []
Remove empty fields You can start reauth upon UnauthorizedError : self.entry.async start reauth(self.hass) Actually on UnauthorizedError we should try to login, or simply reload the integration. I was thinking of adding this in a future PR Can you replace the 60 60 with SCAN INTERVAL constant? Please move to class attributes Coordinators should go into their own modules, in this case, move it into coordinator.py . This can't change, right? Why is it updated? As a matter of fact, what in this re-auth process guards that the right account is re-authed? async add entities accepts a generator, you can remove the list comprehension here. This seems to be incorrect, as there are conditions not met for this to be set. Will change the name to sentence case. Other than that, is there any other condition that's not met? That's about it as it seems. This must be following sentence case styling to be able to set has entity name . Additionally, it is a bit of an odd name, it would suggest a date of when it was last read? But I guess it is water usage? Would that be a better name? The read here is in present tense, as in the meter read. Common usage, and how the service refers to it, but maybe total consumption ? As opposed to some periodic consumption (e.g. daily, monthly), which I plan on adding in future PRs. We don't describe entities on what they do.. we describe what they are represent. They represent consumption or usage in this case. Why cast it to string? Because without it the meter id is formatted as a number, which seems odd (e.g. the attribute would show as "1,782" instead of "1782" ok makes sense. Why is the entry ID added to the unique ID? That seems odd and unneeded. I don't know if it's guaranteed that meter ids are unique across accounts. I thought about using the unique id instead of the entry id, but I'm a bit reluctant to do so because it's PII (the unique id is the account number, which is the account owner's national ID number). You could better maybe use a combination of account number and meter ID. Or, in case you really thin it should use the entry ID instead, use just the entry ID (it is already unique, no need to add the meter ID in that case). Please note, this should be adjusted before the final release lands, otherwise, you'd have to deal with unique ID migrations in later releases. .. Frenck The meter ID is needed because there can be more than one meter per account. For the prefix, my preference for entry ID over the account number is that the former doesn't contain PII. Maybe it's not a big concern because we do use it elsewhere, but it feels a bit off to me. ok This is unused? There is no need to handle it like this. The coordinator already has the data and there are no calculations involved here. Implement the native value property method instead. This test is incomplete. For example, if authentication is incorrect, a user can recover from it. Please make the test complete until the config entry is created (to ensure there a
When the telnet connection is up and running, we don't need to update the entire receiver anymore, but only attributes like interpret, title etc. which are not covered by telnet. This would save some API calls. Resolved in In combination with my previous comment suggesting not running the entire update when telnet is connected, we should update the receiver before connecting telnet, that all values are available from the beginning. Thinking we'd also want to call async update audyssey here too if the user has that configured? Resolved in along with Audyssey update Afaik telnet is not used by any app on the phone, but by some (uncommon) hardware extensions or maybe other tools similar to home-assistant (or a second home-assitant instance). We should mention the telnet issue. A common problem might be running a live home-assistant instance and a dev instance at the same time. Resolved in Does it need to disconnect when the stop event is fired as well? Very likely, but not familiar with capturing the stop event, have an example? Found out how to do this but stuck with a weird mypy error. Resolved in Stale? Resolved in Addressed in Addressed in Since Home Assistant has both sync and async function in the codebase we prefix ones that are safe to run in the event loop and do not do any blocking I O with async Seems reasonable, I copied this from homeassistant components devolo home network init .py so I might submit a code cleanup PR later for a few other integrations that don't seem to follow this pattern. Anyway, addressed in Addressed in Addressed in The translator isn't likely to know how to translate Configure button so it matches what the button actually says Addressed in We are missing a test that validates that CONF USER TELNET can be disabled Assuming the object already has the new state, we don't need to schedule an update and can just write the state. It would have been a nicer design if this returned a callable that canceled the registration since we could than wrap it in self.async on remove
Please limit the initial PR to a single platform. See also: 5-make-your-pull-request-as-small-as-possible Should I comment out the Platform lines or should I delete the platform files and remove the lines on the platform list? All other platforms should be fully removed. Please remove foreign languages from the PR and only keep English. Other languages can be managed from our translation platform, once this PR has been merged.
Looks like nothing in this is HA specific so it could live in the lib Fixed. Please only call async add entities once since it schedules a task Fixed. These classes are very similar. I'd extend SensorEntityDescription instead and add a value fn and a restore fn I thought about doing this, but there is custom logic in some of the entities that I think would make it difficult. For example two of the entities extend RestoreEntity, but the third one doesn't. Even among the two that extend RestoreEntity, the logic is different, since one of them needs to convert the unit and the other one doesn't. I just don't see a way that these three classes could be cleanly combined. Assuming you don't plan on adding any more sensor entities that seems fine. I'm concerned it could become a bit more difficult to maintain if it turns out to have more sensors. Yeah, I see what you mean. I don't plan on adding any more sensor entities. If I ever do, I'll definitely look into refactoring this to reduce the duplicated code. Please use f-strings where possible Fixed. Maybe self. data.client.state.realtime weight kg so we have less logic to maintain here? If it starts to get too long you could do this in the parent class In my opinion this logic belongs in HA and not the library. In the bluetooth packets from the scale, there is just a weight reading along with a boolean (which I call is final ) indicating whether it is a finalized weight reading (occurs once the weight has stabilized and the scale "locks in" a reading). The real time weight entity updates for all received packets, but the regular weight entity only updates when is final is true. I think the separation of these two data points is a detail of the HA integration, since no such separation exists in the data itself. They are both reading from the same bytes in the data. If you feel strongly about this then I'd be willing to change it. Just wanted to explain why I believed it should be this way. I think the value makes sense with or without HA involved. It doesn't seem like HA specific logic so I'd still put it in the library. We want HA to know as little as possible about the implementation details. Is the full name sent with passive scans? Most devices don't do this and only send the short local name since it takes up so much space in the advertisment so its a bit surprising I'm not sure how to tell. I've tested this with ESPHome proxies and discovery is working perfectly. Do ESPHome proxies perform passive scanning? Is the fact that this is working fine with ESPHome proxies sufficient to conclude that it is safe to use passive scanning? It depends if you have active set to true or false configuration-variables I have it set to true. Should I try with it set to false? I have it set to true. Should I try with it set to false? Yes, you may find you get no names at all with false It seems like this would be a bug if state was not an int That's why I added the with suppress(ValueError) . If the state fails to co
Remove this comment and apply what this comment states. hass.data should hold your coordinator api Done. type errors Done. swap this. if user input is not None: then do everything starting on line 92. You don't need this as you have self.async show Form at the bottom. Done. Why are you overriding user input? Why not just pass it as a parameter like you have as an option? Fixed use CONF USERNAME and CONF PASSWORD that are built into Home assistant Done type these parameters This should happen within init and then here you just access hass.data[entry.entry id] and you can get your coordinator. Needs a return type Needs a return type Done Needs a return type type data Remove unusued ones This has been changed - it should be ordered domain, name, then alphabetical order. You either need to not catch a broad exception here or you will have to pylint ignore it like you do in config flow CoordinatorEntity[YourCoordinatorName] type coordinator Instead of making a new class for each one, you can create a SensorEntityDescription. Look in the code base and you can see a ton of examples Done This is not a parameter you use Fixed - removed. This should no longer be included You don't check this as far as I see Should not patch globally whenever possible. Patch the api instance within the ha component Fixed
Is the lambda function needed here? Because if I add linear interpolation in the future, I don't want to sort the second via the second value, only the x. It'll be a first come first serve at that point. Can't you just use min(initial coefficients) and max(initial coefficients) rather than sorting if that is all you are using the sorted list for? Yes, but same reason above, I don't want the second value to influence the result. Please unpack bare ternarys that span multiple lines into if blocks Please name the variable what it is to show intent instead of x x value would be better assuming it s x, y values I think if this as clamp instead of apply but apply may make more sense to someone else so I other way works Done Can you use min() and max() here instead ? No, I have to explicitly check x against the min x and pull the y value. If I try to use min or max to 'shorten' the process, I end up overwriting the min result with the max. No matter what the if has to check the x value against the min x value and vice versa to ensure the single value is only executed. I could reverse the if order, but when all said and done the code becomes more unreadable IMO I'm pretty sure that code won't work for one of the test cases too. I have to conditionally run the min or the max per single update. I think it's just easier to read the current way. Agreed. Its not better You could use operator.itemgetter here instead of the lambda but it probably doesn't matter I switched to itemgetter, never heard of this before. Will use in the future. It would be nicer to use pytest to parameters instead to avoid the loop in the test Done
We should add a test for avoiding duplicate entries. E.g., test an existing config entry (e.g., user originated), some device comes in from DHCP and is thus ignored. frenck I just added a extra test to check dhcp aborts if the entry already exists. Thanks for suggesting this! Could you approve now? Could you approve now? Lol, you keep asking that, no need to ask that. Sometimes stuff will get multiple reviews.
DevoloCoordinatorEntity could use both CoordinatorEntity and DevoloEntity to offset some of the duplicating code perhaps (assuming based on your comments from the PR) I had that idea, too but then was unsure which version is better: copying the code or not to rely on the MRO. I checked other integrations and calling init methods explicitly seems to be ok. I adapted accordingly. This should raise HomeAssistantError instead of logging so user get's feedback I believe you should raise ConfigEntryAuthFailed instead and let HomeAssistant start the reauth flow The other platforms currently do it the same way. Mind if I clean that up all together in a separate MR? You could try raising ConfigEntryAuthFailed here but i think it won't start the reauth flow since nothing is catching it in this flow, but i haven't tried it. My assumption is that you have to do like what this PR does and start it yourself. But doesn't it also need to raise some failure so that the service call fails explicitly? It looks like it will return and effectively succeed? The test currently exercises that the service call succeeds which seems incorrect. Hi allenporter , it seems, that there is no other integration yet, that has a button platform and starts a reauth flow. So I looked at e.g. the update platform of shelly, the media player platform of webostv or the switch platform of uptimerobot. None raises an error after starting reauth. My other platforms also don't. However, I spotted raising a HomeAssistantError in the alarm control panel of totalconnect. I can do it either way, but in case we come to the conclusion to raise an exception, I would like to to that in a follow up PR for all my platforms. What do you think? Here is how you should think about it, ignoring reauth for a moment: If you have a service call and the service call fails, it should raise an exception right? For example, just a line below it raise an exception on DeviceUnavailable which is a different type of failure. Whether or not to fail the call is independent of whether or not you start reauth. Got it. So now I'm raising a HomeAssistantError after starting the reauth flow. I will adapt the other platforms (actually just switch, if I remember correctly) in a separate PR. I had to add line 113 in order to get mypy pass. But the other platforms indeed to it the same way. entity description: DevoloButtonEntityDescription No need to raise HomeAssistantError as you already started reauth. So the feedback of allenporter was not correct? No, you added another exception with a proper raise of HomeAssistantError but on this particular exception you already start a reauth alerting the user so for me it's overdoing it by alerting the user twice. Let's see what allenporter thinks. Before, without the exception, it was starting reauth without failing the service call. In the test, the service call did not fail. Is config entry title really the name of the button? No, it's the name of the device that provides the functi
May be we can refactor this a bit by checking the state is in a list of valid states, then assigning with some logic. something like python valid states [ self.config[state] for state in [CONS STATE LOCKED, ..., ...]] if payload in valid states: self.attr is locked payload self. config[CONF STATE LOCKED] self.attr is locking payload self. config[CONF STATE LOCKING] self.attr is unlocked payload self. config[CONF STATE UNLOCKED] .... May be the jammed condition should be handles different from the other states as it could happen when opening, closing or in open or closed state. That would require another state topic (and template) to listen to a payload for determining a jammed condition. OK, but how to determine the lock is no longer jammed? With two payloads for jammed and not jammed respectively? Because the example I know publish the jammed state to the same topic as state and has no other payload to specify the motor is no longer jammed. That is the reason why firstly I set the jammed state to false for all other states but I only changed jammed when the state reported the lock is jammed. You need to treat jammed different because the other properties remain, only the state changes. You will need two states payloads to control this and a separate topic. Lets leave jammed out of the state here and add a new topic to receive a jammed condition. It will need a second payload state NOT JAMMED. You could also choose to add this with a separate PR, if that is more convenient. May be we should set these in self. valid states in self. setup from config() , so they are set once when the config changes. For example: Don't forget to add type hints ad class level list[str] And add this to the module constants: Done :slightly smiling face:
What is this meant to do? The external API handler is shared, and it tries to download prices periodically for each day and sensor. For disabled sensors, there is no need to download, so there is where they get flagged for download. Should I make this in another way? This callback is called whenever this sensor's entity registry entry is updated, it doesn't seem correct to assume an update of the registry entry means the sensor needs updates. I'd move this call to async added to hass instead. Also, this should be called from async added to hass : is called whenever this sensor's entity registry entry is updated Oh, I missed that! I noticed that method was called when enabling disabled sensors, and never if the sensor was disabled, so it looked like a good place to place that. The async on remove callback is already defined, but in the sensor's init. I will move both to async added to hass asap Little problem emontnemery : if I enable the sensors inside the async added to hass , all sensors are enabled, not following the entity registry enabled default flag... I think this is why I put it in async registry entry updated . Should I query self.registry entry to enable downloads for each sensor only for when it's not disabled? async added to hass is not called if the entity registry enabled default is set to False unless the user enables the entity. I think this is a problem related to testing, the entity registry enabled default is only considered when the config entry is first added. Please double check this if I enable the sensors inside the async added to hass, all sensors are enabled The problem was in my logic to retrieve the 'disabled sensors' when running async setup entry . Now it's fixed, to apply defaults in the first activation of the API token, or check the .disabled attribute in other case. Thanks for pointing it out This should not be in an external API Hi emontnemery, I see. The logic in the external lib is this: (there are 2 methods to convert between sensor key and HA unique-ids) As you can see, the old unique id was just the selected tariff, just to be able to configure an entry for each tariff. To handle the addition of new sensors I'm just composing tariff sensor-key, but leaving the old one as it was, for backward compatibility. Should I resolve this logic in other way? Or it's ok if I just move those methods to the integration? Move this logic to the integration please Sorry, I didn't update this conversation. I moved it in the last commit: These are not constants, they are functions. Please move them to a new module helpers.py , util.py or something like that. Done Why is config entry id optional when we make this assertion? Why do we need this assertion?
I think it makes sense to add None support here, as user input in config flows is usually optional. It removes the need for a check in every integration. Without this, then we need to do either: or Moved to 85763 to avoid core changes inside the PR. It looks like there are required so user input[CONF USERNAME] ... makes sense here Ah yes. I had them optional previously, before I moved to menu. Why do we have this check? The items are required in the form. Indeed! They used to be optional. I removed the get but didn't think to remove the if Resolved in 86604
Same deal here, what's the ideal behavior for exceptions thrown by switches and buttons? I think I've answered this in the other PR, but happy to clarify if needed Yep, both throw a HomeAssistantError now. Thanks! We should name these async since we have both sync and async function in this integration (we do this for all integrations since there is both async and sync functions in the codebase and it makes it easier to follow the flow and prevent accidents where sync code is run in the event loop) Makes sense, done! Where are we catching asyncio.TimeoutError ? Looks like reboot has the same issue I assumed it was handled automatically, just like the coordinator one. My bad I'm missing tests or an update to .coveragerc for the switch module.
What should this be throwing, if anything? I feel like UpdateFailed isn't right Raise ValueError on invalid user input and raise HomeAssistantError for other failures such as a problem communicating with a device. It might make this a bit easier to maintain if you made a in the StarlinkEntity so you could write self.base unique id instead I took it a step further and moved the whole thing there Since you are passing description to the parent, you can set self.entity description there and drop this block since it becomes useless Good call! Looks like this block can become useless as well and be removed
Shouldn t this be bluetooth adapters This one is actually providing a bluetooth adapter so its not a consumer of bluetooth adapters Isn t this method also optional? I didn't think it was. I thought we needed one of async setup or async setup entry testing now... Blows up without it Let s merge this into the init file d53d2bbcccec330df6209b870c47c8f5dcef492c
We don't need to add the platform domain to the unique id. The entity registry is aware of both the integration domain and the platform domain. The remaining suffix, identifying the entity kind is useful if we add more buttons in the future. entity-naming Side note: This integration doesn't seem to implement device info. That could be a future improvement. Yes, implementing device info could be something I want to look into. The current state of the integration is ok but not great. Please use our dt util as far as possible for datetime things. L108-L110 We recommend creating separate PRs for library bumps and only include other changes that are required for the version bump in the same PR. I created PR 85720 for the version bump. Please rebase on latest dev branch as this change is now merged. Changes are rebased.
MINOR: I'd reverse this conditional since a not is usually cheaper than a string comparison. Is this at the right indent level? It looks like this will abort if there are any config entries Looks like this is set a bit early since you could abort before its used Probably needs a test to make sure this works when there are multiple devices Is that the exact hostname or does this need a wildcard? Exact hostname. D-Link has many blocks of mac addresses. 3 of them are used between the 5 I have so we'll leave that part out. debug logs confirm a match We shouldn't give them the option to enter the host here since we already set the unique id above and if they enter a different one we will now have the wrong unique id Not that it makes much difference but you could write it as above or is not None: Please reference the use legacy protocol in the user step (example in homekit strings.json ) so we don't have double work for translators. This looks like it could be two tests self.ip address isn't set in the user step flow.
Not all of these programs are available on all models. Do we check the availability? If not, I could understand this list might have been limited for a reason. For my understanding we don't check the availability. But Home Connect is only available to "high-class" coffee machines, so most of the machines will support all programs. Right. Maybe DavidMStraub can shed light on this one?
Has been removed due to the verbose logging from recorder mock so it can not assert I think it would be best to drop the key out of the dictionary That would probably make more sense. I'll change that.
We have a validator that always wraps things in lists:
StarlinkBinarySensorEntity, StarlinkBinarySensorEntityDescription should live in binary sensor.py since they are platform specific. StarlinkSensorEntity etc should live in sensor.py since it is also platform specific Makes sense, I'll move them while I'm here Create a tuple of StarlinkBinarySensorEntity for each key instead Is that preferred, compared to querying Starlink for available alerts? I'm not sure how often alerts change, but when they do we risk having issues that way right? I probably need to give you a bit more color Here is an example of what I'm thinking: L124 This would essentially be the same as how we set up the sensors platform right? Yes That's what I was referring to earlier - in this case the alerts from Starlink are prone to change. Is it preferred to essentially hardcore them by saying "we will expose a binary sensor for the alert with this tag", versus the current setup that asks Starlink "what is currently available? Let's create binary sensors for them" My concern is I'm not sure how often alerts actually change Alerts don't sound like they are binary sensors, they should probably be implemented as events I will look at the event docs, but both the app and the API expose these as "problem sensors", though the app also shows banners when there's an alert Just my 2 cents as an observer, but implementing these as events doesn t seem quite right because they aren t instantaneous things and instead show the state of the device. They would be similar to the tesla powerwall integration in how they show if the grid is on, grid services are on, and powerwalls are on. Maybe I should just hardcode the tags and hope for the best then Let's hard code them. If the key is missing you can skip over the sensor Usually we sort this alphabetical It would be a bit nicer if data[0] , data[2], etc was a dataclass attribute instead of a magic number I was initially going to make the function take 3 separate parameters, maybe that's the better way to go after all? So that would look something like lambda status, obstruction, alert: Ideally it would be lambda data: data.status["currently obstructed"] You'd need a dataclass ...something like: Ah ok, we can do that instead binary sensors Untested but probably works (will test it when I can factory reset if you don't get a chance to before) Also would be nicer if the lib provided the data in this format instead of here. I will raise an issue with the library, is it fine to keep it here for now? Yes On means update available, Off means up-to-date. The use of this device class should be avoided, please consider using the [update]( entity instead. This should be implemented as an update entity instead I will look into the update platform next. Buttons (and switches) are relatively small, would it make sense to tack update on the end of the same PR? Better to do one platform per PR. Its a lot easier to find small blocks of time to do reviews. Its the big PRs that sit for a long time because they need l
we should move the typing improvements into an follow up PR this seems to be unused? we should move the typing improvements into an follow up PR seems to be unrelated We should create only one sensor entity definition and use [ SensorEntityDescription ]( homeassistant.components.sensor.SensorEntityDescription) to parameterize it. the native value can be defined as a lambda we should move the typing improvements into an follow up PR These type changes were also applied by another PR this is exactly what the fixture sl setup above already does the tests could be combined into one: 1. setup the integration by using the fixture sl setup 2. add 3 items to the list 3. check all 3 sensor states 4. remove one item 5. check all 3 sensor states 6. mark on item as checked 7. check all 3 sensor states That's not best practice though. Each test should do test only one thing, even if it means duplicating some setup testing code. Unless you insist, I will keep the tests as-is (except for the fixture changes)
Should we await the beep instead? Yes. Fixed for query also. I thought about this and we enable the Identify buttons in HomeKit by default with them set to DIAGNOSTICS so I think it would be more consistent to enable them by default since they serve a similar purpose. Good with that.
We should probably set self. event to None in this case. Same. Same. Technically calendar end dates are a little strange and should be exclusive, so the end should be the next day ( calendarevent) Good to know! Is this really a user facing log message? What should the user do with this information? If it's a developer message please lower to debug level. We don't need to suffix the unique id with the platform domain. The entity registry is aware of both the integration domain and the platform domain.
This seems to work around an incompatibility, looking at It seems like the switch DP, is for controlling the power of the whole device, yet, this entity will at this point use it for controlling the fan. This entity need to be refactored using EntityDescriptions in order to make that distinction correctly. For this specific device category, I would expect another switch entity for controlling the power (and thus the switch DP not being used by this fan entity at all). I've added the EntityDescriptions like you asked and implemented 'fake' on off behaviour when there is no switch defined for the fan. I've also made a bunch of changes to exclude the 'off' value from the speed enum because it's not expected by the percentage util (see L12). I think this can be done a bit nicer in places, but since Python is exactly my main language I could use some help there.
This file is not longer necessary. Please remove it. Done. Why are the requirements changing? The hydrawiser library is no longer maintained. (See: which has had no activity since 2020, including responses to bugs or PRs) There's also a newer API from Hydrawise that's implemented using GraphQL which is much more robust both in terms of features, reliability, and supportability. (it's what their website and mobile app use) I don't think there's a clean way to do a drop-in replacement, for a few reasons: 1. The authentication mechanism changes with the new API 2. The old API returns truncated strings for things, which will cause problems in a migration 3. I don't think there are stable identifiers used across both APIs, so we couldn't make unique IDs in HA and then migrate libraries Since it's already a breaking change to the user to migrate from YAML to config flow, this seems like a reasonable time to also change the underlying API. I've looked at this again. I think you should postpone the new library until after config flow has been implemented. Okay, sounds good. I sent another PR ( to kick this off by adding a DataUpdateCoordinator to the code. It should make adding config flow simpler. Please look at mock setup entry and pytestmark from scaffold L1-L14 and L12 This might make sense - but it should be a separate, preliminary PR. Which part? The constant rename, or the key change? Both, create a preliminary PR dedicated to moving from hass.data[DATA HYDRAWISE] to hass.data[DOMAIN][DATA YAML] YAML should be imported and deprecated (search for deprecated yaml in the code) That makes sense, but should it wait until: 1. We have feature parity between YAML and Config Flow? 2. We have some confidence of what the correct breaks in ha version value should be? (Between initial review lag and my own lag in response, I'm not sure I could give a reasonable estimate for when this would actually be merged) Please add a comment in the code to that effect. Done. Using a DataUpdateCoordinator is a great idea, but it should be either a preliminary PR or a follow-up PR. I appreciate the sentiment, but I'm not sure I agree? The config flow implementation here is essentially greenfield, so setting up the scaffolding using best-practices (and such that it won't send spurious API calls) seems like the correct thing to do. If you feel strongly about this I guess I can back out just this part, but that seems like unnecessary work on my part. I hadn't realised that it was used only for the new implementation. I suggest that you turn this into a HydrawiseDataUpdateCoordinator class, inside a new coordinator.py module and passing api as an argument. You can then use coordinator HydrawiseDataUpdateCoordinator(api)
This integration is missing a library for the interface and data parsing code. We won't allow changes to this integration that involves that part of the code until it's been refactored to use a 3rd party library. Please extract the device specific interface code and data parsing to a standalone library published on PyPI. 4-communication-with-devicesservices
These seems to be not mapped? As in, I cannot find the list of possible states in Home Assistant mapped to the integration library? There is no official list of possible states so the library is just passing through what comes from the api. But unofficially I have seen a list from the maker that these are the current possible states for swing and fan. I would not think I need a fixed list of states? Well, the issue with not mapping it, is that we also won't know about things missing. When mapping and blowing up with an unexpected state, it makes it possible to extend the list as needed. I see the point. Perhaps better to implement a list of possible states and extend when new things appear. Would you propose to just create a constant with a list in the integration of possible states or would it be better to have it in the library and use it in the integration? Would you propose to just create a constant with a list in the integration of possible states You'd need the mapping in HA anyways, so keeping it here is fine. Available fan modes and swing modes is now implemented in this PR. I'll update the PR description as well I would assume that fan modes are sorted in a specific order. sorted would override that. Also, I would calculate this once when the entity is initialized to avoid doing this on every update (since they will never change) Removing the sorting which I agree would not be applicable. The list is dynamic depending on hvac mode so can't be a set-once. Api is proving the options randomly so need to keep sorted, both for user and for test Why not return it if it s not an available mode ? Shouldn t that be a warning if it is. For both fan mode and swing mode it now generates a warning to open an issue. Still doesn't return the value if it's not with the available modes as I suppose it's not meant to (we want them to open an issue so we can add it, also properly translated) Same. Pretty sure these are already translated for climate entities. Why do we need to re-define them ? Not all are translated. Should use references as much as possible. Done You can reference the one from horizontal swing
I'm not sure this comment is very obvious. Perhaps you could expand on how this works in a docstring on this function? Done, I think Same concern as the previous comment. Converting all the number fields to int before re-casting back to float (and vice versa) seems okay. Did you notice any cases where this could be risky? All currently existing entities have step 1 as far as I can tell.
I'm a bit unsure about this one. We removed 'gas timestamp' as it is automatically set by HA as last update when 'Total gas' value is updated. This value is important for Belgium users to know when the net supplier detected a peak. Should we add this? Here or as attribute? Removed and planned to be added as 'attribute'. These (sags, swells, and power failure sensors) need icons but I can't decide which one. Added a couple to have some ideas, but still in doubt. I think the added ones are fine. One can always customize if one wants. Currently it is just 1 or 2 , because NL and BE tariffs are swapped, we can't easily convert this to 'Dal' and 'Normaal' tariff because of that. Should we keep it raw or do we want to make it nicer for the user somehow? As this can only have 2 options, we can mark it as an enum. This will help the automation scripts UI to show possible options when automating on these values. Added this and tariff 3 4 for the few who have that in Averages should not be activated for long-term stats. The state represents a measurement in present time, not a historical aggregation such as statistics or a prediction of the future. Ref: available-state-classes Leftover debug print.
I couldn't find an architectural discussion on this. These seem like a random collection of radiation units, but where are those used? At this point, it seems like this PR is introducing dead code. They might not be used by HA Core at this point, but could be in the future and it would also add possibility to be used by custom integrations. Right, but that is not a reason to add things. As said, this is introducing dead code, which we don't allow. Custom integration do not need this to function, therefore we require use in our Core code base.
Service calls can't return values. This test is not testing the service call, it did not test the return values; it is testing the hass configuration internals. If it did test the return values of the service call, it would be apparent that service calls can't return responses.
Small nit: let's make sure these constants retain alphabetical order. Can do!
Rounding shouldn't be done in the integration anymore, instead, set the suggested precision. : 1: Good idea, I updated this to use SensorEntityDescription with a suggested display precision This change seems to be unrelated to the PR? Since this now uses a configurable suggested display precision it looks like it needs a unique ID to allow it to be updated from the UI This method seems quite unneeded? : 1: Good spot, since this is only one line I've refactored this to be part of init Seems like this integration could benefit from using EntityDescriptions instead. : 1: I've update these to use SensorEntityDescription
discussion r1060221206 allenporter - picking up where we left off: If I do it this way, the entity shows "unknown" when the washer is not running. The way it is implemented, it counts down until the cycle ends, then returns the timestamp for when they cycle ended (not None) from the stored timestamp. It then shows how long "until it ends", then when it ends, it shows "how long since it ended". I originally had it like your example with return utcnow() instead of return None, but that ends up updating the end time when the API receives a state change message - I needed to store utcnow() at the state change. Am I way off base here? Ah i was reviewing this in parallel and missed your comment... copying my comment here: Thanks for the explanation of this sensor and no you aren't way off, i just have two things I see a bit differently: (1) Make it a separate entity so that the other sensor types don't also have these fields (which aren't used). I think it would make sense not to use the value fn for that entity and just keep the state within that sensor (2) What do you want the value to be on home assistant startup? My impression is you can't set one, which is why my naive example punts on trying to get fancier and storing a previously estimated completion time -- I'm ok with only having a value when its not active, because I don't think it matters when the state is completed or not running. We don't need the estimated completion time anymore since we already know it has passed. 2, it when the sensor initializes "washer.running True", this way if the machine is NOT running, we return utcnow() and set washer.running False. If it's actually running, we get the estimated end time. 1, I suppose it's a toss up on how we do this. We run "special" code either way. Adding a separate entity would tighten up the access to the variables. Probably some python PEP out there saying which way to go.... I'm just not familiar enough with them. I'll do whichever way is preferred :) (1) We should not use a value function that has side effects. That is not expected. (2) My take is this seems like an arbitrary value, and we know it isn't correct. Therefore, setting None seems more clear to indicate that and i'd feel comfortable merging that. If you want to go now for unknown then we'll need someone else to review and I can tag with Second opinion needed to flag for another reviewer. You can also start with None, and then send another PR to add the behavior you are proposing if you want to keep moving forward incrementally. Ok - I've made a separate EntityClass for the time function and defaulted to None for self. timestamp. Is this what you had in mind? This still has issues with side effects while reading the property that are similar to the value fn. The original [rainmachine example]( L235) I linked seems to solve these problems: (1) compute all the state in the callback function then write the state. Don't update variables on the entity as a side effect of a property 
We generally place the coordinator in a file called coordinator.py instead. We generally place the generic base entity in a file called entity.py Can we make the return type ( Any ) a little more specific? Yes we can! Should this be a decorator instead? PS: Why are we passing coordinator.device the coordinator ? As mentioned below, I'm new to python, hence it's very interesting to know, that that's possible! Thanks! This init seems to be not needed? We can dynamically bring in errors to our translations. Please known error code not provided by an upstream library. Would a mapping of ApiError to str be ok, or must I if-check all possible errors in order for it to work? Returning a dict with a single item? Why not just return the title itself directly in that case? That's nonsense, yes. Did some overhauling, now the dict is being properly used! This does not seem to provide full test coverage for the config flow (for example, re-auth handling is missing). Please note that we require configuration flows to have a 100 test coverage. Sorry about that! I'm completly new to the python language and still eagerly learning. I hope the tests (expect to one testing DeviceApiError ) are satisfying now.
This integration has existing code that has too much protocol details. We won't allow new code that introduces more protocol details. For more sensor types to be added we need to first extract the device specific interface code and data parsing to a standalone library published on PyPI. I just now saw your comment in another PR adding the same feature... Should have looked into the closed ones as well. I see your point to not include protocol specific code, but it is quite bad we cannot integrate any non-existing enocean hardware for now. Do you know if someone is already working on a new library? [The one we are using right now]( seems to be abandoned anyway. I don't know of any progress in this direction lately, unfortunately. There's an Enocean Discord server for talking about the integration but there's not much activity.
Can this just be ? Most of these Mission classes are copypasta. Could you factor out into a generic one and pass in the few differences in the constructor? How exactly should I do that? I tried it like so: but that gives me an error in the IDE and I also don't think this correct. The constructor takes the form of the magic function init , so leave the class inheritance as it was with IRobotEntity, SensorEntity , and def init (self, mission type, mission value string): You may also want to call the super function. Thanks for helping but I still don't know how to proceed. I am generally not that bad in python but this is a bit too much at once. I have looked up the python super functions but that didn't help me either in this case. It would help me a lot if you can give me an example. This is my current state: My IDE says the following: init method from base class 'IRobotEntity' is not called I don't know how I can call this method. This does not work: Check Please remove commented out code. Oops forgot to remove that Have you considered setting [ entity registry enabled default ]( advanced-properties) to false for these sensors so that these are not shown on the UI by default, and therefore do not increase the DB size of people who won't care about these diagnostic statistics? That's an good idea. I will do that. Should these statistics only be fetched on initialisation, and not updated after? No they should still update after initialisation. I will have to find out how to do that. Thanks for your effort on that Integration! Wouldn't it be better to have a list of EntityDescription s, Instead of separate code blocks with SensorEntity s? example: [sensor]( Another thing is you should use the builtin UnitOfTime.HOURS instead of "hardcoded" hours . For the current amount of sensors I don't think it is really necessary. There are some other components that do it the same way, with a class for each sensor, for example [minecraft server]( use the builtin UnitOfTime.HOURS That does not work. It is not recognised by the IDE and does not work when running it either: NameError: name 'UnitOfTime' is not defined . use the builtin UnitOfTime.HOURS That does not work. It is not recognised by the IDE and does not work when running it either: NameError: name 'UnitOfTime' is not defined . you also need to import it at the beginning of the file from homeassistant.const import UnitOfTime For the current amount of sensors I don't think it is really necessary. There are some other components that do it the same way, with a class for each sensor, for example [minecraft server]( The use of EntityDescription was just a suggestion. you also need to import it at the beginning of the file from homeassistant.const import UnitOfTime Thanks, now it works perfectly. Thanks! Not sure if there is a pattern to support translation but done this way this would be hard coded to English. I have my HA in german and all entities that have attributes I could not find a single one that ha
Should these keys be moved to the const file for clarity of transfer into the library where the other SensorDeviceClasses come from, whenever that happens? bdraco what do you think? Should I move these to sensor-state-data, leave it here, or move it to const.py? If they are going to be used in other integrations sensor-state-data makes sense. If its only here than its probably best to leave as-is These binary sensors are very specific. Don t think they will be reused somewhere else soon. Let s keep it here. It would still be nice to extend the enum in xiaomi-ble so we don't have bare strings here. Ok, will do that tomorrow. bdraco If I understand it correct, it isn't allowed to extend a non-empty Enum. I tried that here, but it won't pass the tests. All I can do is create a second Enum with the Xiaomi specific sensors, I guess. To extend an enum you have to make a copy of it manually. The alternate solution is fine as well.
This could be a comprehension Look up attr has entity name Thanks for the suggestion. Fixed it! Please use the attr attributes to set the constant properties. Eg instead of defining a name property we set the class attribute attr name . Thanks for your feedback. I adapted the code. Additional question: can I do the same for the ones that return data from the pynuki package? Can this: Be turned into this? (Sorry, I'm new to HA development and haven't much experience with Python) Yes, but then we need to add an init method and set the attribute as an instance attribute on the entity as it's bad practice to set a mutable object as a class attribute. Also, this will only work if the attribute won't need updating after the entity is created. If the attribute needs updating, we either need to do that in a state update callback or keep using a property that is read when the entity state is updated. So further changes for this is optional.
Please remove this Im not sure this is needed. Do you mean the name attribute or the full class? I guess you mean the name attribute, and I agree that this can probably be removed. Removed from both sensor and binary sensor This could be a comprehension Change to list comprehension Please finish config flow tests all the way to an ABORT or CREATE ENTRY state so we know it can recover The test now runs the successful config flow after the initial failure. Please finish config flow tests all the way to an ABORT or CREATE ENTRY state so we know it can recover The test now runs the successful config flow after the initial failure. Can this raise an exception? If not please move it outside the try block No, so moved outside the try block. Usually we only accept a single platform for new integration merges 5-make-your-pull-request-as-small-as-possible I am not sure what to do about this. Is it okay as it is, or should I remove one of the platforms and put in a second pull request afterwards? Correct, only a single platform in the initial PR is allowed Instead of creating all these classes, please use BinarySensorEntityDescription s instead. I see how this may solve the device class issue, but how do I handle the different ways of fetching the entity state if not through subclasses? You could add a lamba to the entity description to handle specific cases. (search for value fn in our codebase for examples). Coordinators should be created in the integration entry setup, not in the platform setup. Removed from the sensors and placed in init .py. As per general standards we use, this should be moved into a coordinator.py file. Merged with HomelyHome and moved to correct file. I feel like this should have been the coordinator (extend) and not something that contains the coordinator. Moved to coordinator.py and redefined as a coordinator. - This looks like an entity in the Home Assistant world? Not device? - Should it be extending our base Entity ? - Base entities are generally placed in entity.py No, this is a device. I have cleaned up the class to make it clearer that it basically supplies the device info that is used by the various entities.
Should this be false? I thought about this, but I figured the sensor is pretty pertinent to multizone devices, in that it's the only way to know either the number of zones or the state of each zone. So I reckon it should be enabled by default. I thought about this one some more. I think its ok to do as sensors if we disable them by default otherwise we have a scale problem since things start to fall over once we hit 4096 entities If the answer to the problem is, "we'll do it the usual way, because no-one will bother actually using it turning it on" then somethingh is very wrong. You can implement them as individual sensors if you like, but I don't feel like making the user experience actively hostile. Each zone should be its own sensor entity instead. [We shouldn't put all the attributes for every zone into a single sensor entity]( diff-69691db0e3fa99416b32d19456ed5ab9fdd89264faba240b9e863017ad63fc81R83). Ideally we mirror what wled did with segments (zones) and each zone is its own light entity. L102 Except the WLED implementation isn't feasible because you're unlikely to have as many segments as you would zones on a LIFX Z or Beam. All of mine are 60 zones; most are 80. I really don't want 80 light entities in a single device. I wish I could give you a better suggestion but coming up blank on another option for this. The best I've got is to add a recorder platform to have the massive attribute excluded from the db, but that still ends up storing it in the state machine and frontend. I'll ask to see if someone else has another idea on how to represent this. The "one sensor per zone" option doesn't work either because there are actually four sensors per zone, i.e. hue, saturation, brightness and kelvin. But there isn't quite enough to make a light entity, because I really don't want folks to control individual zones like that (the protocol just isn't efficient for it). A picture is worth 1000 words: ![Screenshot 2023-03-07 at 16-02-20 Settings Home Assistant]( I have another 40 zones on this Beam and it's my shortest one. And if I make the value any longer (like adding legends) then it truncates the name of the entity, so it becomes impossible to see which zone is which. Next I'll try creating them as light entities that just don't do anything to see what it looks like. Having them as light entities is prettier but the user experience isn't that much better: ![Screenshot 2023-03-07 at 16-44-35 Settings Home Assistant]( Keep in mind there are another 37 light entities on this page. This is my favourite screenshot. It's the auto-generated dashbord at 4k with three screens worth of more entities hidden below the fold: ![screenshot-localhost 8123-2023 03 07-16 51 18]( Those are just my linear multizone devices. I haven't yet added my LIFX Tiles, one of which has 256 zones and the other has 320 zones. We need additional attributes that are not recorded in the state machine recorder. :) bdraco frenck I've been thinking about this and comparing it with 
Its a bit unexpected to have an in the human readable name I'd probably put this in data.py Please only catch exceptions that are expected here. It would be a bit cleaner to store SmartPlugData in async setup entry instead and use it here. r1064254925 Please complete all config flow tests to reach a FlowResultType.CREATE ENTRY or FlowResultType.ABORT state to ensure they can recover from a failure path Please complete all config flow tests to reach a FlowResultType.CREATE ENTRY or FlowResultType.ABORT state to ensure they can recover from a failure path stale logger In the future I'd switch this to use DataUpdateCoordinator to avoid the manual logging Yikes, looks like it really does swallow all expected exceptions We should check the connection also when importing the config. Log an error and abort the flow if there's a problem. I agree with you and did do this at first. These plugs commonly don't play nice with successive connections which will cause user confusion. So I removed the check to keep it simple. Ok. We do it for the user step though. Won't that have the same problem? I just manually set up four of these like new users will, not from yaml. They all connected fine. It's got to be something with the package then. But the authentication appears to work correctly with all the ones I have. The user step is working well and no issues appear during entry setup. Sounds good. Does that mean we can do the validation in the import step too? No. The plugs and the pypi package seem to work well when the user is setting it up. But we seem to run into trouble when more than one plug is being imported into the user step (starting two consecutive connections for each plug at the same time). Set attr has entity name to True in this case and don't prefix with the config entry title. Example: L62-L69 entity-naming Won't removing the default password break existing users that rely on that default? Nevermind, I see the default was an empty string. DEFAULT PASSWORD was an empty string to begin with. Our default deprecation period is two release cycles. Please change to 2023.4.0. This PR will go out in 2023.2.0. Don't pass in hass . It will be set on the entity when the entity has been added to home assistant. This means you can access hass with self.hass , after the entity has been added to home assistant. Pass the units instead. The data object was just moved but I will of course slim this down. PRs ought to me small hehe We should not invent a default value if the device doesn't return a value. We use None to represent unknown state attributes. Side note: The extra state attributes should be moved to separate sensor entities in the future. Would it be better to just not list the attribute if we have no value for it? Some plugs do not report temperature nor energy consumption. I wouldn't change anything besides returning None for unknown values, as we should break it out to separate sensors anyway. Add a MockConfigEntry matching the same user input instea
This was replaced by host in this PR. This file needs to be updated regenerated once the above comment is addressed. integration type is missing, please add it. For new integrations we require them to adhere to a modern naming style. This integration seems to comply, but is missing the marker for it.
A serial number isn't always the best title. It might be better to use the integration title name instead, especially since it is safe to assume one would generally use a single instance of this integration. The UI will, in that case, hide the title until the user assigns a custom name. If it just calls super, we can just as well remove it. Can we make Any more specific? Just Power would be enough, right? As in, the unit of measurement is already part of the entity, we don't have to describe that? Alternatively, assuming this is describing current power If this daily resets to 0, it should be total increasing . If not, this would probably need an attribute to indicate its reset time. The device ID seems to be an IP address, which is not a valid identifier. We should use the serial number instead.
EDIT: With the "experimental" group part for ExecuteIfOff, I changed this anyway. It shouldn't be needed to check if self. color channel exists here, as this part can only be reached when xy color , hs color , or temperature is provided. And it seems like that if the supported color modes don't include XY HS color temp, HA strips unsupported parameters from a light.turn on call. Explanation Note: Technically initializing this attribute isn't really needed at the moment, as the options parameter needs to be set manually anyway (for now) and the options property defaults to 0 if there isn't a cached attribute. In the future, when a configuration entity is added for this attribute, it would be nice if that attribute was already read initialized (so the configuration entity is created appropriately). (Hence why I added it here (cached, as it won't ever update on its own)) Question regarding tests: It's not too important here, but how would I check the message order? (messages are sent on different clusters) (That code doesn't care whether "on" or "move to color temp" is sent first) EDIT: Removed this code for now, as group support will be done in a separate PR. Is there a simple way for a LightGroup to check if all members have a certain attribute property set? The above code "works", but it's not really clean of course.
Any reason to not poll at 5s? Not really, I can change that if 5s is a standard. Can we use the stale advertisement constants from the Bluetooth integration here? Please finish all flows to reach either abort or create to make sure they can recover from failure How would should that be done? I borrowed this implementation from the nuki component since it was reasonably simple and did DHCP too, but I don't see it explicitly aborting either... call async configure again patching for the success case ... with patch gateway ok(), patch setup entry ok() as mock setup entry: I'm sorry, not quite following still If I call async configure again with the same flow id , I get homeassistant.data entry flow.UnknownFlow . We should set a unique id (usually MAC address) and update the ip address if it changes by using the abort helper We can only get the device's actual unique ID ( gw mac ) once we've connected to it once, and for that we need the user to enter the bearer token. How would that be done here? See r1059846560 The link has expired or something, I'm afraid... discussion r1060867006 We should update the host so they don't have to reconfigure if the up changes I'm sorry, I'm not quite following? self. abort if unique id configured(updates {CONF HOST: user input[CONF HOST]}) Please don't make this a bound var since it's a constant It can be overwritten by the DHCP flow. Looks unused ? Please avoid branching like this in tests. It would be better to do two separate tests instead or parametrize all the args instead. This needs to be added to .coveragerc or tests added for it This file needs to be added to .coveragerc or tests added for it This file needs to be added to .coveragerc or tests added for it From a maint perspective want the assertions in the test itself so we don't have to dig for the failure path when something fails. You could also do pytest.register assert rewrite to accomplish this but in practice its probably easier to copy them. In my opinion, this is clear enough (and you could clearly see the failure path in the pytest tracebacks anyway?). If you insist, I can inline the assert finalize setup function, but I have something against copy-pasting the same thing and inevitably ending up changing it in four places later... Please adjust. thanks!
Not sure I agree this is the right change, but i don't have a good reason to articulate why... Seems fine to just let the platforms load what they can load. (Aside: It's not explained in the PR description, and perhaps could be separate anyway from adding new functionality anyway...) This is the addition of the sensor platform (isn't it?) If there are not appliances on the account, why try to load anything? As we add more platforms, I suppose this would be more generic calling the platforms... There is a test for setup error where no appliances are found (that is the return False part of this code) - I suppose it's not really an error if no appliances are found in the account. Maybe there is a better way to declare that no appliances are found? I don't recall ever seeing this behavior before when reviewing other integrations. I don't have strong principles to cite for why, i just haven't seen it before so it seems odd. I could see having a check like this during config flow setup? Maybe my intuition is that devices may come and go and its ok, not sure Checking at setup in config flow sounds like the right place to do this to me. Just inline whirlpool data.appliances manager.aircons below in the for loop? While the existing code already does this, it is a bit odd to reuse the same variable for different types of objects. That's great observation - it really looks like a "mistake" that works but really isn't "good". There seem to be a few different changes in the PR.. - Adding an associated device and changing to use has entity name w the device name - Changing the callback and write state behavior - Bumping the library version - Adding the new sensors And I think this should be broken down into separate smaller PRs that we can review quickly following the suggestions in 5-make-your-pull-request-as-small-as-possible Can you pre-factor some of those out into separate PRs? I know.... this thing has been growing since August when the first PR of the bunch became hung up. I'll start breaking it up. Since the function below zips ups these two lists and that is the only case they are used, a simplification is to make an enum subclass that holds the function and the name, or just stick these in a list of tuples e.g. CYCLE FUNC [ (WasherDryer.get cycle status filling, "Cycle Filling"), ... Move this to the top of the function since it doesn't really depend on cycle functions? Also no need to assign the variable just to return it: This is an optional style suggestion, but I'd say for constants only used in a single platform just leave them in the platform Entity names should start with a capital letter: entity-naming From available-device-classes for DURATION says Time period. Should not update only due to time passing. The device or service needs to give a new data point to update. My impression is this is updating as the cycle is counting down (anti-pattern described there), and the reason is to avoid unnecessary updates from the state machine just counti
Please ensure that you also update NumberDeviceClass accordingly I think these tests are redundant Should be superseeded by 84808
These should be lower case and been put into translations. Addressed in 84977 Same as above Addressed in 84977 This is a coordinator that already has data, the True parameter seems unneeded here. The coordinator doesn't yet have data, at is it not (currently) initialised on setup. I will address this when I add the second coordinator. Addressed in 85039 has entity name is set to true on all of them... maybe just set it as a class variable instead. Addressed in 84977 85038 The coordinator can already handle this on first request refresh,thispart is thus not needed system get info is only called in setup - not via a coordinator I will address this when I add "system" sensors. Addressed in 85039 This can throw an SFRBoxError , which is unhandled? Addressed in 84977 85039 Please only wrap the line that can raise in the try... except block. Looks like we can move this line up. Addressed in 85037 Normally we only say that unknown exceptions are unknown errors. If we know the type of exception we can usually tell the user something about the error. Addressed in 85037 I'd make the box attribute on the coordinator public and only store the coordinator in hass.data. Addressed in 85039 Signal strength sensors should normally be disabled by default. Addressed in 85038
I recommend showing a negative change as well (i.e. -20) to demonstrate the reduction of time. You added blocking true , which means await hass.async block till done() became obsolete. Same as above same as above same as above same as above same as above same as above same as above same as above Should this add a match to ensure the error you expected was raised? unneeded block Should this match the error you expected to be raised? Unneeded assignment to None, it is being overwritten below. This is odd and incorrect. Let's say I have a 120-second running timer, assume 30 seconds are left. After calling this timer change with 30 seconds, I ended up with 60 seconds left, on a 150 seconds timer? The configuration is not allowed to be changed via service calls, so duration should not be able to change. This also raises the question if one should be able to go beyond the configured time or not? And what if I add so much negative change value, the timer becomes negative in its time left? Will the point in time become in the past? Will make "corrections" in an update PR and then we can discuss it from that point. Will send you the link in discord once it's made. Thanks
We can combine these two checks if we use a walrus operator for btn press event . The library needs to be improved to create a better interface for the events. The library user should not need to parse the events like this, eg splitting strings, accessing dict by strings, and doing log math. Please build a nice api in the library and return typed instances where different values can be accessed by object attributes. I recommend using pydantic to deserialize api data. Set up the integration while patching the library so we can trigger a library event that will fire a Home Assistant event. We want to access the callback that is used for the library events, on message callback . It will be inside MagicMock.call args .
I think we don't add brands where there is only a single integration We normally only guarg for TYPE CHECKING where it generates circular references. In this case it's better to remove the guard Same here, please remove the guard. Same here, remove the guard I'm not sure adding JVC prefix adds anything here. I meant on all three Oops, totally glazed over the others. Fixed. Same here, remove the guard The coordinator does the same checks? Why not combine it in the coordinator? This method is only used by the config flow, lets move it to the config flow file in that case. I was running into unit testing issues trying to mock the jvc projector dep in both config flow and init at the same time time (due to import paths). Spent many many hours trying to figure it out. This was the only way I could get the test to work. Why only update the host? And not the username password? Why is password a required item in this flow, but optional in the other flow? How would one set an empty password now? If we want to to be the same as the device name, just don't set it on the entity level. Required on new integrations. Let's not suggest fixed data in this case. This parameter is mostly used for upstream devices that are already aware of rooms or areas they are in. Instead of sleeping, change the debouncer of the DataUpdateCoordinator Instead of sleeping, change the debouncer of the DataUpdateCoordinator As the coordinator data is already there, and it handle the updates, it is preferred to just implement the is on property instead of this handle coordinator update . We do sometimes use the method you are using here, however, that is generally only used when more complex calculations are needed (and thus would prevent is over an over). However, that is not the case here. This error is recoverable by the user. Finish the config flow when that happens to ensure there are no side-effects introduced. This error is recoverable by the user. Finish the config flow when that happens to ensure there are no side-effects introduced. This error is recoverable by the user. Finish the config flow when that happens to ensure there are no side-effects introduced. This error is recoverable by the user. Finish the config flow when that happens to ensure there are no side-effects introduced. This error is recoverable by the user. Finish the config flow when that happens to ensure there are no side-effects introduced.
Lets not make this a bound method since it doesn't use self . Ideally this would actually be in the library instead Done, moved to the library We should validate this in the config flow so they can't ever get to this state It's already validated there, I guess I left it here as just in case something unexpected happens or changes. Do you think I should remove it then or is it fine to leave like this? I'd remove the extra code This check should be unreachable since the lock platform won't ever be loaded if its not a lock Lets leave out the link since the box already has a help ? they can click on and its one less url to maintain Lets leave out the link since the box already has a help ? they can click on and its one less url to maintain This line is missing coverage I added one more test for this I missed this before I merged it, but we should finish all config flow tests till they reach and abort or create state to ensure the flow can recover from an error state
Do we not need a CONF HUMIDITY COMMAND TOPIC too? Further it would be good to add CONF MIN HUMIDITY and CONF MAX HUMIDITY as well. The name of the function still says it handles a temperature received. Why would we need an Initial value. I would suggest assigning None if a state topic or command topic is set during initialisation. Oh, neat, I didn't know it could be None . I was following the convention set by CONF TEMP INITIAL . Sure, I'll set it to None . I think it is not needed to have an initial value. Initial values can be reported by the device. It might even be that I will sugest to remove those initial settings and deprecate them. Even the None assignments for all attributes ( diff-c8ebf96494fa4dca0f6c463949933572a837d982d5d9fbd8f042173bba03fbd1R466-R473) can be cleaned up since they are already initialized in the parent class. We do not need to reset those to None when a config update arrives. You do not need to changed that in this PR though, I'll open a seperate one for that. Can we add validation in min and max humidity like MQTT humidifier? Sure, I'll take a look at how the MQTT humidifier does it. May be set climate attribute is better? I Agree; I'll rename it. I think this one can be cleaned up Can be cleaned up Do not think we need this At self. attr target humidity None at self. init () instead if CONF HUMIDITY STATE TOPIC is None We can also set the target humidity if there is no state topic. In that case it will be set in optimistic mode. Just for the record It is okay to enable to setting the current humidity attribute, even if ClimateEntityFeature.TARGET HUMIDITY is not set. I think we should check here if ClimateEntityFeature.TARGET HUMIDITY is set. It is some weird that we can receive the target humidity but not set it. I suggest we add a check that CONF HUMIDITY STATE TOPIC is only allowed to be configured when CONF HUMIDITY COMMAND TOPIC is also is configured. We should check for ClimateEntityFeature.TARGET HUMIDITY to be set here and raise some error if this is not supported. The only line that seems to be de duplicated seems the log line, which is stale for humidity . May be we should just assign the attributes value in the specific handlers and dispose this one. diff-c8ebf96494fa4dca0f6c463949933572a837d982d5d9fbd8f042173bba03fbd1R606 Oops, sorry, I didn't realize that the doc error mentioned temperature ! We could also replace temperature with climate attribute . In the error, we could replace temperature with whatever template name is. So for example. this means that instead of: Could not parse temperature from [...] the user would see: Could not parse temperature state template from [...] which could be considered either more or either less user-friendly, depending on your point of view. Line 627 still shows Could not parse temperature from . This is not applicable for humidity attributes. As I already commented it might be better not using an extra function for setting attributes. Directly setting them perhaps wou
You could speed this up a bit more by not making this a function as the python function overhead for 1000s of entities likely has a performance impact here
please remove this and all other info logging. This is not needed to be printed as info to the user. fixed Don't store it until async config entry first refresh was successful. fixed This is a data update coordinator, not AsyncSeitronAuth fixed You're not using this Don't set a name if it's the same as device. Instead set entity name to True: All these info's in all files need to be removed. fixed These could be a lot cleaner if a mapping was used to look these up. The same occurrence can be seen lower, where another tree of if statements shows up during async set hvac mode . This shouldn't be needed to be logged. Additionally, it is logged at info level, which is to high for this. Similar as HVAC mode, could use a dictionary to look up translate the values. Same as above, this can just be left out. It most certainly shouldn't be logged at info level. Can this throw something? What if this request fails? I would expect some kind of error handling here. This seems wrong, it is using a coordinator; it should not be polling on the entity level? This can be set as a class attribute (as it is a constant fixed value). Entities added are already logged. This can be set in the entity constructor? This logging message doesn't add much value (and it is incorrect in its message, as the coordinator has been instantiated). Above all, it shouldn't be logging on info level. I suggest to remove it. There is not much use in logging a constant Resolved made clear by the updated typing suggestion above
These should be their own entities It doesn't have a model really, let's not add fictive data. When does it become unavailable? (instead of unknown) I unresolved this comment, as I realized this one is also unanswered. Can this throw errors? Should those be handled? Why add these? Is there a specific use case for them? Unresolved this comment, as the question has not been handled. oh they have been removed. ok. Why is this a state of the binary sensor? Maybe this entity shouldn't be a binary sensor , but a sensor with an enum device class. Unresolved this review comment, as it has just been marked resolved, without answering the questions. These seem to be unused. This is not a good unique ID in general, a small change and it will make it different (which is just as affective as not doing it at all). Let's remove the name. The less we ask, the easier it becomes. People can always rename the entries afterward. Besides, it is pretty safe to assume most people will only set up one entry anyways. We could use the location selector here, or, alternatively, use an entity selector based on zone entities (so the user can select one of their zones as a source). Please do not add additional languages. Those are managed and added later using our Lokalise translation platform. This file needs to be removed. The state by itself is already in the entity, what does the diagnostic add in this case? And why add only the state and not the rest of the data response? Considering: r1055371872 and what is happening here I think this is not correct to be a binary sensor. The upstream state clearly isn't binary. We should add a transformation from the state the library provides vs the state we output. That would also allow to provide state translations (which are not missing). The return value can be made more specific Should this sensor carry the enum device class? Setting unique IDs on lat long is IMHO useless, it can easily be shifted just a tiny bit. We can just as well just not do it. This is only used once, in a static place. We don't need to declare a constant for it.
Maybe this should be last known fan speed instead of fan speed since it's not reset when the fan is turned off? Also, we'll poll the state from the fan when the entity is added to Home Assistant, so the default FAN SPEED MEDIUM will be overwritten with the fan's speed if it's already turned on. I think fan speed is fine.
why is there a mismatch between there being an underscore here and no underscore in climate.py ? The Venstar API and, as a result, the venstarcolortouch library that Home Assistant is using, don't separate words in attribute names (similarly you can see self. client.fanstate in climate.py, where client is an instance of a type from the venstarcolortouch library). However, the other attribute names here do separate words with underscores, so I followed that pattern. I suspect that this is because the attribute names are user-facing in Home Assistant and this is the style they've adopted, whereas the underlying library is just copying the Venstar API's style, which is clearly not meant for the eyes of users. more specifically about the mismatch - why no underscore in schedulepart here? This looks correct to me actually, because that's how the API presents it. Yup, the comment in discussion r1053957632 cleared things up! What does the schedule part represent? Is it a time integer? I checked the docs PR and it represents one of the available schedule times, which are parts of a day. I think this should be an enum device class sensor instead. available-device-classes I think you're correct on this choice. I have pushed changes to create an enum entity for the schedule part. I will update the corresponding documentation PR once this is confirmed to be the correct path to take. Should this be a defaultdict(lambda: "Unknown") in order to defend against new values from the API? I think it's better to just blow up so we know as soon as possible and can fix it. Side note: This could be the default in the VenstarSensorEntityDescription . This would be neat, but the way the mixin is currently implemented means that there will be inter-mixed default and non-default arguments, which Python isn't happy with, so this would require more rearchitecting than I think is the goal here: TypeError: non-default argument 'key' follows default argument We would move the attribute to the VenstarSensorEntityDescription . This was a side note so we don't need to do it now. Side note for the future: We recommend existing integrations to move to adhering to our entity naming guidelines and let the device info add the device name to the entity name by default. entity-naming The options should be lowercase snake case and have a translation via the translation key . See eg: L41-L55 L67-L76
Shouldn't this be a switch platform as that's what we added for imaging when setting up the config entry? This change doesn't look needed. I suggest using entity descriptions and a single switch entity class instead of multiple classes. Pass the device and profile parameters to the turn on off lambdas of the description. Example: L24-L48 L113-L145 Good idea. Ok I think I have accomplished this in the latest commit. Are we still going to implement the custom services when we add the switches? I think it's wise to keep the service for now because of the massive breadth of the ONVIF protocol covering thousands of different camera models. The entities expose some common expected functionality, but if someone wants to do something that only their device supports, the services will allow that. I think most future development will focus on the user-friendly entities. If someone wants a new feature we can add a new switch (description) or similar. I suggest we don't add the services until explicitly required. Ok I removed them. This appears to lead to: during mypy. I struggled for a long time to get mypy happy on this and ended up on the general one above. Can keep trying. ah nm I think I got it. Please set the class attribute attr has entity name to True instead and remove this line. entity-naming We don't need these additions to the camera platform now, right? that's correct, thanks. Removing now. Please also assert the new state of the switch entity in the state machine after the service call. good idea, thanks. done.
Should this be a separate PR for beta? I created one as well. Maybe should be merged first? yes
Is this the right log level for this op? Good catch. It's debug left in I thought I removed but it came back with the merge squash and rebase. Deleted
Maybe 2023.2 as 2022 did not get .1 version The comment should not have been there at all, removed now. Should we also test adding identical aliases ? Good call, the test has been improved in 6a62dbc
Minor suggestion: if you define these indices as TEST SENSOR1 INDEX and TEST SENSOR2 INDEX that might add nice context throughout the rest of this test module where they're used. Thank you! I actually have this covered here: Probably better to use NumberSelector which gives you a float and then you can easily convert to int in your validation Does these give any added value? Not sure I understand the question. Are you speaking about this log message? If so, yes: it logs what the error was, which is useful during debugging. Should it not be LOGGER.debug instead then? Not sure the value of writing to log for a regular user as they already get feedback in the form This (writing errors to log) is a standard practice in config entries the entry will only show the translated string, whereas the log entry can show additional info. It is not debug-specific. This would not work (it would raise) if a user provided a non-number input e.g. a or something
Why is it RC? Unless we are fixing a completely broken integration and have no other way, we do not allow the use of dev alpha beta release candidates. Understood. The original Blink integration is not broken. But the 0.19.x versions do not work at all for those of us who don't use Blink's cloud storage. In that sense, it is broken unsupported. fronzbot : Are you ready to release blinkpy updates as v0.20.0 ? perdue oops just saw this comment now- yes, it will be released as a full version to 0.20.0 shortly. Completely fell off my radar This PR is now using the full release version 0.20.0 . It is ready for another review frenck. Thanks! I'm confused why you need this function which does the exact same thing as the function above ( write video ). I get that you need access to hass , but why not just add hass as a parameter for this function, move it outside of a function and make it a top level function (not a closure), and then use that in both places? That is the crux of the PR. The write video only triggers a single video (the most recent) to be written. I left it in so that current users' automations do not break. The new "save recent clips" adds a service for saving all clips generated since the last refresh. The documentation PR explains what the new service is doing: diff-c577c832ae063c20a34fc584e3112865f1b8023f3954d149f88b1284a30a6cf3R179 As far as your question about access to hass . I followed the same pattern as the existing async handle save video service function. I'm not trying to do a refactor here. thanks for clarifying what does this do? The blink integration was calling refresh multiple times. This uses a blinkpy method to check if an update should be called based on the last refresh time. L295
What catches vol.Invalid ? My impression is the http view does this: L137 This goes back to the debate we were having about ValueError vs vol.Invalid . You last suggested we take it to an architecture issue and i haven't followed up on this. Ok. It's a bit weird to raise vol.Invalid as we're not inside a voluptuous schema. But I'll guess we'll have to keep it like this until that's generally cleaned up from the views and an alternative added.
Could there be a problem in the name slzb-06? That is, in the symbol - No, it's just failing the JSON linter. Make sure you set up pre-commit : If you modify zha manifest.json again (i.e. add whitespace) and commit it, the hook should auto-format it correctly. Your JSON uses a tab character for indentation instead of spaces. Format it with pre-commit , it fixes this automatically. pre-commit throws an error in my case. I checked the source file, there are no tabs The linter doesn't lie . It was originally indented with a single tab. When you committed my suggestion, it also added two spaces: img width "266" alt "image" src "" Ok i got it. Looks like I checked the file after pre-commit formatted it XD
You can safely remove this file, it will be auto-generated from strings.json in CI Good to know, removed. Don't forget ;) Thanks for the reminder, added. It would be nice that attr device info is filled in. This creates the device entry were automations can be created easily. aah, didn't know that thanks. Added in the form of a property. I can change it to self. attr device info , according to the outcome of [this comment]( discussion r1052625272). This seems static, it can be added in init with self. attr unique id . Maybe this is also true for name(self) It is true for both cases and some other properties such as fan mode , fan modes , swing modes , hvac modes , etc. I chose overriding the properties mostly for the sake of readability and cleanness, do you see an inherent advantage in defining them in init as self. property ? It is more common to use attr ... and preferred when the value is static, as far as I known. If there's no clear benefit of having the self. attr (I assume there isn't since any caller outside of the ClimateEntity and Entity , would hit the property method, and there shouldn't be a difference hitting the super class's property, which simply returns self. attr or the overriden property), I'd rather keep this as is for readability. Otherwise, I'd have to move 15 other static properties into the constructor as self. attr , which makes it more difficult to read. To allow more climate types in the future, it is maybe nice to create a class for the Heater Fan (with all its options) and a class for others. But this works for now Great suggestion. At this point I don't even know what the common denominator is between different devices from the cloud provider. I will make sure to do so, as soon as a second device type needs to be added. We can work on adding support for more devices . Let's talk about this on.. discord? Definitely, I hit you up in a DM on Discord. Can this catch password (re)authentication? Maybe raise InvalidAuthError when auth failed? Otherwise users have to remove and add the integration. - The constructor of this class does not perform a login automatically, it needs to be called explicitly with api.login() - An initial login is attempted in the [config flow]( L33-L39) before reaching this point, and a proper InvalidAuthError raised there. - re-auth is a handled within the library itself (upon expired tokens). Ah, that is nice! But still, when the user changes it password we may have this issue when calling api.login() . I still a reauth flow should be triggered when InvalidHomewizardAuth is raised? Move this down a bit, after we are sure the init is successful. (above hass.data[DOMAIN][entry.entry id] {} for example Done. It would be nice if state changes are batched debounced to be a bit nicer to the server. Maybe add this to the API implementation itself. Good suggestion, I can bake a debouncing mechanism into the external library (most probably in a future version). Do you see this as a blocker for this PR 
If it needs a dict we should convert it to dict or the typing change change in ReolinkHost to accept the types for entry.data and entry.options Please only catch expected exceptions. We want the integration to fail to setup on unexpected ones I have removed the broad except and am only catching specific errors now during init. Ideally we store a dataclass instead of a dict since it makes it easier to type. Example [in lookin models.py ]( Thanks for the hint, I have updated the PR to use such a dataclass This could be a loop over a constant removed, since the custom services were removed for this initial PR. Lets leave out the custom services in the first PR to keep this smaller I have removed everything related to the custom services. Create a custom client session instead with its own ssl context by passing kwargs to async create clientsession The problem is that the ssl context needs to be passed as (ssl) option to the aiohttp.TCPConnector , while the kwargs are passed as options to the aiohttp.ClientSession L108-L121 L241-L258 I could not figure out how to properly pass the ssl context using the build in HomeAssistant funcitons. When using the aiohttp functions directly I would do it like this: bdraco could you please give some advise? I have some time to work on it today and tommorow... stale sorry, my bad, updated it. Unique ids are per domain, per platform You could use L432 Does it make sense to pass around the ReolinkHost object instead of unpacking it? This looks like a useless exception catch? Its not super friendly to make the user dig through the log to find the error: You could raise the exception and use placeholders to propagate the error to the UI instead example: L483 Please unpack multi line ternaries into ifs TYPE needs to be adjusted Partial suggestion will need to be completed. Same as below CoordinatorEntity already implements this as async update . You can drop this Please log at debug as the user doesn't really need to know this unless something goes wrong Please trap only expected exceptions
Can the default language use the home assistant language? I was just looking at the conversation API and I saw that it takes a language as input, but also uses the home assistant language as a default and that seemed interesting to take advantage of to simplify configuration for users. At the same time, this is a service call so it seems like it may not always be clear to the user how language works... Done. Used language and country to get the default language code. Did you intentionally decide to create the config entry with CONF LANGUAGE CODE based on the current home assistant default? Vs, say, having no CONF LANGUAGE CODE set and picking on the fly? I can see value in making it fixed to be consistent, but also value in not picking an default and adapting if the home assistant language changes. I don't know what users would want here, so happy to go with your call here, just wanted to point this option out. Yes it was intentional. If it was on the fly, after changing HA's UI language, automations and scripts woulld have to be modified as they will likely not work. E.g. if UI language is set to English and you set an automation "play rain sounds on bedroom speaker", and then change UI language to Spanish, sending this command to Google Assistant in Spanish will likely not work. I just had one thought: Translations for UI strings typically go in the json files, and was curious if it makes sense to use that for these strings too. I can also allow users to submit more translations via lokalize and allow this to get extended to more -- however i haven't seen that done before so don't know if that causes more problems. I could also see it's a security problem or something :) These aren't UI strings though. We can't let anyone enter whatever they want here in whatever language. The Google Assistant API supports a limited set of languages and the broadcast command is predefined. See the help center link at line 14 where you can replace hl to a supported language to get the broadcast command Google Assistant understands. To extend this integration to support more languages, whenever Google Assitant SDK supports new ones, we will have to update the SUPPORTED LANGUAGES set and the 2 failing tests will point you to a couple of dictionaries that also need to be updated. This requires code changes that we can't safely perform via localize.
Considering bsic is written out, should this be handled likewise for better understanding? Although this is probably so specific that anyone interested in it would know what it stands for? Expanded that and EARFCN in ee8192cc62501c3279d9c7701bbeab09aaf7212a. They're a bit of mouthfuls and we have quite a few unexpanded acronyms still, but :shrug:. Would be good if we had some way to submit both the acronym and its expanded form and have it end up as an abbr title ... ... abbr element in the UI, but I believe no such thing exists at the moment. So I have no opinion on either side here, I was just wondering what makes the most sense for users. Using acronyms is also just fine as long as those are google-able, IMO. Backed out the expansion of those two. I think what we have currently strikes a pretty good balance. Note: in 83904 I noticed there were quite a few multi-line lambdas. Is there a way they could be converted to single line lambdas or moved to stand-alone functions? Sure, at least named functions. I'm not sure multiline lambdas are a problem per se. c530a0e72a93f273748831a0ac644b9669c6ba67 converts bodies of ones that are used more than once to named functions; converting ones that are used only does not seem to be a net positive to me. epenet made the requested changes, any chance for a review here? :)
It would be a bit safer design if you saved the config entry here in case self.context['entry id'] ever gets overwritten removed. I'm seen that happen in other cases but sadly I can't remember the exact circumstances
Let's keep this dictionary sorted alphabetically based on their keys This change is unneeded, please revert. This change is unneeded, please revert it. We can just hardcode this? It is now hardcoded as well, so it will always be the same? Let's check the value and return "true" or "false" instead of string magic. How can it be None ? Should the sensor just be called "Weather condition"? This file isn't used anymore, please revert this change This file isn't used anymore, please revert this change
You could assign this (and also device class) as a class attribute attr state class It may make sense to use a class like However, the change is correct.
I suggest that you move the existing constants in a preliminary PR See creating-the-perfect-pr Please make the schema a constant, and use add suggested values helper instead. Please ensure that you implement an import step and create a deprecated yaml issue in the issue registry. This file is no longer required. Please remove it. Please ensure that you mock the entry setup. The easiest is to use a mock setup entry in a local conftest.py . See pytestmark pytest.mark.usefixtures("mock setup entry")
I believe this abbreviation could be some shorter Let me propagate that to the rest of the docs as well too As you can see the added code is not covered by tests. It would be nice if we could assert on the automatic assigned zone when we supply lat and lon coordinates. Existing tests can be found here: L351-L442 I would the special payload pl aut zn to be set here Update, I know you load the default now, you could add another test too Add another test? Sorry, what do you mean exactly? I could add an explicit config entry here that sets the payload auto zone to another custom payload (like "auto"), in the same test, is that what you're asking? Add another test? Sorry, what do you mean exactly? A test that asserts you can specify a custom payload. Then you could it leave as default in this one. Ill make another test that'll use the abbreviation to specify a custom payload This would be the place to publish the special payload Update: I see you do that later. When is the intention of this? I would use some other custom location name, not STATE UNKNOWN This is to test if it correctly sets "back" to an inferred location when switching between unknown unavailable and auto zone, should I make this STATE UNAVAILABLE to make this clear? Okay, The topic your are sending to is not directly setting a state. It sets the location or None to inherrit. You might use a string in stead of STATE UNAVAILABLE , Value payloads are: - PAYLOAD HOME ( STATE HOME is the default) - PAYLOAD NOT HOME ( STATE NOT HOME is the default) - PAYLOAD AUTO ZONE ( DEFAULT PAYLOAD AUTO ZONE is the default) - Any location string (if there are no other matches) STATE UNAVAILABLE is not used as a special payload. You could e.g. use "Work" as payload. (Just assign the string). To show the manual override works. Here you should assert the state equals the custom zone overridden zone. I had a discussion with emontnemery about this PR. May we we do not need a new option. We could use reuse CONF PAYLOAD RESET ( pl rst : payload reset ). We we want to allow is to reset the last location set. Ah, that may be a better solution indeed, yeah. I see the rest of the changes cascading into this change, I'll apply it and change documentation appropriately, thank you for the feedback We could import CONF RESET PAYLOAD from .const.py Use CONF RESET PAYLOAD here. May be rename the name of the default payload. Use CONF PAYLOAD RESET here. Update the tests to use CONF PAYLOAD RESET . You do not need to use the abbreviation here. Using payload reset is fine here. I saw number use it, and decided to de-duplicate it by moving it to const and instead import it in both modules.
This is now becoming a weird mix between how it used to be done, vs how we do it nowadays. Entity description can be extended to hold all this information, instead of having a custom attribute type that also includes the entity description. I suggest to avoid doing this, and instead migrate it to use entity description in the way we do everywhere within Home Assistant. .. Frenck You're right, but I thought this would be a step in the right direction and avoid too big a change. I'll adjust... Entity descriptions from different platforms don't belong in the same container. They are platform details and should really just be defined in each platform. Aaargh. This integration will need to be unpickled! Step 1 84089
Maybe this a weird question, but why does the library take a DateTime object and not a Date object? It is only interested in the date, right? This could indeed become a Date object, I just have to see if it still goes well in the python package because there is some magic with a replace and timedelta. Why is this optional? Why not just always provide all data available? Optional with the idea that not everyone may be interested in this data, because someone, for example, only has an electricity contract and no gas. How does this work with timezones? This class variable isn't used. It is set but never queried for. Removing it will not change the working. - Please avoid multiline-single-line if statements. - So, if there is no gas data, it becomes "unknown"; looking at the coordinator, wouldn't it need to become unavailable for this case? Same as above If you make this a data class or tuple, you can get rid of the hashed access and use it as an object across other places (which would be much easier to read, shorter, and remove d the need for constants). This looks like a sensor on its own and not meta data of the existing state. What does this contain? This seems to use the new entity style naming, but it doesn't set it as such? You can use a list comprehension for this one. This is used only once, so, using a constant is not really needed in this case. (I know many integrations still use this pattern, but that is more of a historical leftover)
Use BinarySensorEntityDescription here instead Done. Please only call async add entities once since each creates a task Done. Drop any languages except en.json since they will get overwritten by lokalize anyways That's neat. Done. You should probably trap any BleakError here Good idea. Done. Pass in the description and set self.entity description instead so you only need one class Updated, but I'm not convinced having a single class makes it more readable. It took me quite a while to unpick other examples in order to understand how to do this stuff CoordinatorEntity already sets this That's cool. Removed. You can make this a loop now with a generator expression over ENTITY DESCRIPTIONS Done. Good spot. Should this be populated at startup? It should probably be unavailable until read from the device, but the library will populate it to False initially. Changed to this anyhow. Is it possible to have the library send the exception instead so you don't have to set it here and if you need to change it later we won't have to do code review to core? This isn't really a bluetooth or device exception. async set update error takes an exception as a parameter, but in the disconnect callback (which is not exceptional) there is no exception, so I constructed this to pacify the call. You could have the lib pass back a LD2410DisconnectedError via the register disconnected callback and pass that back to async set update error so if you ever wanted change the message or raise a different exception based on why the disconnect happened it would be a lib update and no changes in core You could have the lib pass back a LD2410DisconnectedError via the register disconnected callback and pass that back to async set update error so if you ever wanted change the message or raise a different exception based on why the disconnect happened it would be a lib update and no changes in core There's a bit of a code smell there with the tail wagging the dog. The library never had an exception, so why should it construct one for this use case? At best, it should perhaps pass the disconnect reason to the callback, but the exception still needs to be constructed from it at the point of the async set update error call. You could instead get rid of the call to async set update error , call async update listeners instead, add a new property to the coordinator called connected and override available in the entity to check super().available and self.connected
I was going to suggest integration discovery, but we already know its valid so import seems to fit better I'm assuming this is for the from homeassistant.components.airvisual pro import DOMAIN as AIRVISUAL PRO DOMAIN I'm not sure it saves you anything making it a dep and they will have to pay to have both integrations in memory if they only have non-pro devices. I recommend using next and a generator expression instead. This test belongs in a module named test init.py . Won't this remove all user customizations of entities and devices of the old config entry?
Please remove everything except en.json as these will get overwritten by lokalize Removed. Please complete the config flow all the way to an ABORT or CREATE ENTRY result Test's contract changed to check new config, against the already configured device. Please use the enum value here We should leave the existing files in place without changes. lokalize will take care of updating after this merges Files restored, en.json changed only. Usually we only patch the place where its imported instead of globally Suggestion committed. Thanks, I'll keep that in mind next time.
I am not familiar with the cover domain, but after taking a look at [its code]( L266) I think its state is not really boolean, but rather an enum: it can have one of four values (STATE OPENING, STATE CLOSING, STATE CLOSED, STATE OPEN). The recommended way to export such state attribute to Prometheus is to add state as a metric label, exporting 1 for the currently-active state, and 0 for all other states. For example, if the current state is "open", the library would export the following metrics: You can see examples of how this is implemented in the [hvac domain metrics]( L433) Thank you! I will work on these in the next few days: the tilt position and position properties are not always available on every cover. I believe I have a solution in place, but I want to make sure my tests are expanded to cover the full breadth of this functionality. This should probably be 0-100 rather than 0 100 (same for cover tilt position below). knyar Changed position and tilt position descriptions to 0-100 instead of 0 100 , good catch. Does that require a new approval?
I think it would be nice if you could also add events for torrent start pause stop completed That might indeed be a usefull future adition, but I believe this to be out of scope of the current PR. As the proposed changes stand, a user could also create an automation that is triggered when the sensor attributes change and use that to check for each of the torrent start pause stop completed state changes.
I think this is missing coverage I think you could use format mac from device registry ha I was looking for that one but couldn't find it with grepping. Had CoPilot write this one yeah the codebase seems to have expanded a bit Sometimes too much time on archeology as above
I think we can drop this now much better!
I think it should be good practice to set them in alphabetic order No usage when coming from a config entry Looks like it will never be true so could be removed completely? With the change above you can move this to init with self. attr device info Move to init with self. attr unique id Why is it added here when you have implemented tests? gjohansson-ST , the test does not provide 100 coverage, I did not find the way to test the [async setup entry]( diff-a512bf42b37bf296aa4c7a4460458217d634f473106d25f58cb7dd0acc4b4553R33) so I added the file to .coveragerc (This is also inline with other Ecobee entities (climate, sensors, etc)) Let me know if there is a better way to do it. You need to mock a config entry and use that to setup the integration. Search the codebase for MockConfigEntry to see multiple examples or here is one: L23 See if you can make it to not add it to coverage for exclusion. Looking at this, Thank a lot Done Looks like it should be implemented as a switch instead of a custom service? removed Looks like it can be implemented using the number platform instead of custom service. Same with the one below. gjohansson-ST I thought about this but it does not seems to support time or minutes as a unit: available-device-classes It doesn't. Maybe you're right. It looks as there is a time platform coming so maybe do a custom service now and transition to the new platform when it's launched. Kept it as a separate function, I will keep an eye on future time platform and update the integration The time platform in progress is not for duration . Time represents a time of day, which is not a fit for this. it does not seems to support time or minutes as a unit: [developers.home-assistant.io docs core entity number available-device-classes]( available-device-classes) Units and device classes are not the same things. In your comment, you talk about the unit of measurement, but you link to device classes. This should be a number entity. Thanks frenck Happy to turn those 2 into a number entity. Done You might want to implement [this]( has entity name-true-mandatory-for-new-integrations) right away see comment on custom services Kept Custom services, for the 2 timers. Removed the timer on Shouldn't these be manual e.g. no timer? This type of ventilator does not offer manual on off only via timer and time per minutes on home or away
This file can be removed as it will be generated by CI Ahh Okay awesome, I didn't realise it was generated See Same for name "Today's Earnings" name "Today's earnings" Cool, I'll change that now I was once told that sensors with a device class should not set an icon. But maybe with the today earnings it is more clear. Thanks, updated the sensor descriptions I think you do not have to set this if self.entity description is set I was trying to set pleasing entity id s and name s but we can just let the sensor create those I think this is not required, can't find anything that changes the config entry. This is referred to from init .py line 30, do you think that should also be removed? Maybe I am confused because I use the an UpdateCoordinator for updates. I don't know if this is the way to be. You are correct, this piece of code is unused as there is no config to update. I have removed it Maybe we should handle authentication errors (in a future)? Good shout, I've added handling of InvalidAuth to the update function New integrations allow only one platform to be added to make the PR as small as possible. It is also not recommended to add new features to an open PR. I think the you should focus on one platform and open a follow-up PR for each other PR. Ahh yes, I remember seeing this on the documentation, I'll remove the button now and leave this as a sensor integration for now What happens when the validation fails? Why don't you only return the title as a string? New integrations entities must support [translation of names and attributes]( Please adopt your code accordingly. Why don't you use the DataUpdateCoordinator ?
You shouldn't retrurn an OverkizCommandParam directly. I think you should use OVERKIZ TO HVAC ACTION here Please use kwargs[ATTR TEMPERATURE] Do we need this in core? I would say that we now know which states are there; and otherwise it will be in the log. If we do add it, we must also in other core Overkiz entities, which do not have that at the moment similar remark for all others as well, than you can just pass in a string I would prefer to not wrap everything with OverkizCommandParam, we don't do this in other implementations.. Same You can now avoid the cast with something like: self.device.states[OverkizState.CORE ON OFF].value as str I don t think this case can happen. you can do: self.device.states[MAP PRESET TEMPERATURES].value as float To keep the same alpha order Thanks for the great description And therefore can't be get programmatically ? I assume not, we tried to gather this from attributes where available, but many devices don't have these attributes. egguy do you have your diagnostics file? We can have a look. Have checked the diagnostics file, unfortunately these values do not exists programmatically. Please import LOGGER from .const , no need to declare again. nit: perhaps a bit more descriptive name? It seems this device works with frost protection, as or or That can be done in a new PR as it needs tests.
POWER WATT is deprecated. Use UnitOfPower.WATT . Thank you. I have fixed it.
Is this used? This is so that removal of a device untracks the corresponding sensor. removing-devices Of course. Guess I shouldn't have looked at this at the end of the day Would this make sense as a general purpose helper for the integration, or just breaking it out into a function to better show intent? What do you think of 53518b618fe4? That normalizes the logic to work for both the options flow and for deletion of a device. Should we raise here if the entry is missing? I'm torn. We won't ever have a sensor index separate from a device so, that exception won't ever get raised. Is that cast too weird? I'd probably prefer an assert that its not None over the cast since the cast could silently hide a future issue (although unlikely) Not sure its better but you could do device registry.devices[device entry.id] Should we raise here if the entry is missing? I recommend using next and a generator expression instead. I'd avoid including language besides names in the options as they can't be translated. Do we really need this check? Can't we always reload when the options are updated? It probably won't happen frequently. Without this check, deleting an entry (and subsequently attempting to reload the config entry) logs this error: Adding this option feels like a workaround to solve the race. It would be better if we can stop the race from occurring in the options flow that is the source. Open to suggestions on how to do that. When I originally encountered this, I didn't see any other options flows that deleted devices and then reloaded. Maybe we need a device entry registry helper that can await the removal of a device with all connected entities? That sounds much better than my idea of await asyncio.sleep(1) . We've discussed this in the NabuCasa core meeting and said that we don't want to add a helper until it's a more common problem. Another way how we could solve this in the integration could be to listen for the entity state change event in the config flow. Do the listen after we remove the device and not exit the flow until the entity state is None , ie the entity is removed. An asyncio.Event could be used to await the state change callback. I noticed the setup purpleair fixture uses async setup component and passes a config. That's not useful. This integration only uses config entries, so it's better to use hass.config entries.async setup to set up the config entry. But I don't always want the config entry to be set up automatically. Using hass.config entries.async setup will cause most of my tests to fail because they'll be attempting to duplicate an already-existing config entry. async setup component ensures that I can detach platform setup (including entities, devices, etc.) from where the config entry exists. I'm not following. hass.config entries.async setup will set up a config entry, it doesn't create a config entry. Where do I get that config entry ID from? From the existing config entry fixture? Yes. Ah, okay then, in my config flow te
I think this is a great idea, but my initial feeling is that it should be implemented as a custom service, not part of play media service Sounds good! I'll have a look into how to achieve this. I've amended this commit to introduce a send keys custom service, that works as per this code: ![image]( ![image]( Agree it makes much more sense this wasy epenet ! Seems like a rebase removed some commits pushed during review. Great catch. Apologies for that Should this entity be marked as assumed state , since it doesn't know its state? It could, but then we also need to update to the assumed state. Currently the state is always unknown. I've left this alone, as it's not clear to me what the right change (if any) is You should bail out if shutdown is in progress. Good point. Done! Missing fixtures causes test delays. Done Missing fixtures causes test delays. Done I would prefer this test be splitted in half. - one test for turn off, and send keys during shutdown (failing to send) - one test for send keys For this to work, you should follow With the injected fixture, you shouldn't need to patch SamsungTVEncryptedBridge anymore and instead simply check remoteencws.send commands (see test turn off websocket in test media player.py ) Split tests and have removed the patch
You can call this within the constructor. It will avoid to loop for every property. Is it a good idea to store the gateway as a property of the entity, regarding memory consumption and thinks like that? gateways cannot be None. You can remove this condition. I don't think we should do this. Let's just link the update platform to the available states, we can do this like select sensor binary sensor entities. No need to directly link it to a device. Move to PyOverkiz constants eventually Perhaps we should just loop here over all devices and check for widget or UI (why both?). Or just check for update command, so it can work with other update command as well in the future. Do you need this? Look how we do it in our HomeKit sensor. This should be possible here as well? The gateway information is not refreshed in our DataUpdateCoordinator and I am not sure if the new data is broadcasted via events. We would need either to enhance our DataUpdateCoordinator, or add a second one (with different polling interval) or just add a time interval function that will poll every day. duplicate img width "241" alt "image" src "" Unfortunately Somfy does not provide the new version. Can we leave this empty? How do other integrations do this? The update entity can't be used in that case at this point. frenck how could we make it work in HA world? I'll marke this PR as draft in the mean time. As I said, you can't. It requires the latest version. We have discussed and explored how we could allow for updates without latest version identifiers with the core team, but this has some issues we haven't got good solutions for. Until that is solved (if ever, whenever), the pattern used in this PR should not cannot be used. nyroDev I see you keep rebasing this PR and bringing it up to date with latest core standards. If you are still interested in this feature, you could see if other integrations would benefit of such a change and make a proposal at frenck I can see that you made the same comment [on another PR]( r973683525) that came [to production]( L53). After reading the code of update, I can see 2 problems why using a string is a bad idea: 1. [ version is newer]( L187) will probably not work correctly 2. [Skipping version]( L312) will basically skip any new updates Did I miss another point? One hack that I can do on this PR might be to return a version build from the current Date "2023.11.0" to match the corresponding format of overkiz version. That will works correctly with 1 downside: if the user skip it, it will come back the first day of the next month. Otherwise, at a higher level, maybe we can : - Allow latest version to be set as a new constant NEW VERSION AVAILABLE NOT KNOWN - If that's the case, the version is newer should be skipped, considering always new - If that's the case, skipping it could store as skipped version "VERSION NOT KNOW YYYY.MM" where YYYY.MM corresponding to the current month. - The skipped version would have been rewritten to handle this speci
Do we need the state subkey? The purpose is to allow providing translations for an attribute name in the future. Sounds good There's also a fan modes attribute, do we need to translate that too or can frontend have the knowledge that the two are connected? I don't think that is needed. This specific case is handled by the UI in a special way already. (Climate) I look at it a similar way as the select entity, for which we have a state in the translation, but the list is provided in the options attribute. Yes, that's not needed in the front-end. Only the singular one is needed. Should this be state attribute instead? Maybe we can fully drop it even? Just thinking out loud, for example: Maybe not the best example ever, but it shows the gist? I think it's better to keep all the attributes in a separate dict to be sure there are no collisions. In 77028, attributes are in a state attributes dict, here it's called attribute , we should choose one I think. ok agreed, and state attributes sounds good We are using state attributes in the front end for preset mode translations. This might suggest it needs to be domain prefixed, and also maybe change the value of climate to make it less confusing with the entity domain. So, wasn't the consensus above that this should be renamed to state attributes as per frontend usage and consistency with 77028? Yeah, it sure was, I'm not sure how I missed that.
It might make sense to make self.coordinator.device.status[self.key] a property so you don't have to write it out every time I already made this a property, no one knows why it is not used (first result in your search is the property) This is duplicate code. It would be nice to make it a function duplicate code as above
You could simplify the adding of entities with a comprehension: There will be another lock sensor in the near future. So maybe it gets too complicated to read with different classes? What do you mean by "lock sensor?" If there are going to be different lock entity classes used, this is still valuable in that case, you should have something else (a dict, a method, etc.) to look up the correct class based on incoming data. Can you please explain, what i have done there? The sensor is called HmIP-DLS and is just a sensor on the state of the lock. It has lockStates, but no motor to change them. I am not yet sure in which device class platform i gonna put that device. I think putting it in lock platform could be the wrong place. Maybe sensor platform. The sensor is called HmIP-DLS and is just a sensor on the state of the lock. It has lockStates, but no motor to change them. You can't alter the lock state? You've implemented those methods: L69-L75 What does, say, await self. device.set lock state(LockState.LOCKED) actually do? There will be another lock sensor in the near future. So maybe it gets too complicated to read with different classes What do you mean by "lock sensor?" You asked me, what other lock entity class i gonna implement. I told you. The lock device, which this PR is about, could open the door. So everything okay. What is the purpose of overloading init here? You're not doing anything except initializing the parent class. I'll remove that Do we need to do any sort of error handling here? What will happen if this call fails? I had a look on other solutions and the documentation and took the same way. Sorry, I'm not sure what your comment indicates. Exceptions are handled by the upstream lib. If there is an error, the state just does not change. I think it's okay. A debug-log would be nice. Even if exceptions occur in the upstream lib, the user cannot know if something goes wrong (except for looking in the logs). You can raise a HomeAssistantError to show a popup. Good point. I will add the error handling. You should be able to simplify this with a comprehension: I am kind of new to python. So this notation is completly new to me. I will assume your code. This can be simplified: We shouldn't dump the whole response as part of the exception. Is there an errorMessage key (or similar) that contains what we need? I have changed that. Just the errorCode is written to the output. Depending on the errorcode, there are different other dict entries, which describes the output. Example: { "errorCode": "INVALID NUMBER PARAMETER VALUE", "minValue": 0.0, "maxValue": 1.01, } I added a log output, which contains the json dump. Totally up to you, but since you're replicating this same error handling logic multiple times, you could centralize it as a decorator. Please break long strings around 88 characters per line. If we raise an error we don't need to also log.
Curious why the leak sensors themselves are diagnostic? I got it from the RainMachne integration which was the only other ref to leaks I could find but on reflection I think you're right it shouldn't be diagnostic. I will amend the PR
Could not potentially both color and brightness be set in the same turn on() call? Same with brightness and effect . They can both be set in the same turn on(). Color and effect would be mutually exclusive as they set different modes, but then we would need to prioritise using the principle of least surprise. What should happen if both color and effect is set in the same turn on()? Should we also set a client.default mode here to ensure that the right mode is set when client.turn on() is run later? I'm updating the in the , and only if the mode is not "off" This won't be right. It will set mode to color (briefly) also if you try to set it to movie. You should rather set client.default mode to "color" based on ... something. But i have a feeling this is relted to some subset of firmware versions, possibly between 2.5.6 and 2.7.1 or something. I think this needs a bigger refactor to get right... Please remove this. It has side effects. This indicates that you're checking for characters in a string; is that accurate? Does this statement mean that device info[DEV LED PROFILE] will be one of A or W ? I was using it to search a string in a tuple. I need to revert it to the previous version, but should be working anyways. Isn t? Python idiosyncracy: (DEV PROFILE RGB) isn't a tuple. If you're wanting a tuple that contains only that string, add a comma: (DEV PROFILE RGB,) . Do you need to check for "AWW" or do you not? If the device led-profile for some devices is really "AWW" it would make sense to check for that and apply the correct settings for that profile. Fixed This can be removed You don't use this. You need to add this back: You should set client.default mode instead.
This file is not up to date You should use generic keys if existing. It seems you previously used them as seen in the en.json file. Plus, a field label should not include documentation steps, add a description if you want, but the user actually need to look at the documentation for this kind of client id secret config flow. On the labels, stay simple. Remove empty keys Those consts aren't used. Haven't check the rest. This exception is not raised. On tests you mock get access token to raise CannotConnect but that's false, it will raise some kind of HttpException This log can't help anyone, you need to print what happens for us you to fix the issue later on. See the PR checklist: "There is no commented out code in this PR." See the PR checklist: "There is no commented out code in this PR." See the PR checklist: "There is no commented out code in this PR." See the PR checklist: "There is no commented out code in this PR." See the PR checklist: "There is no commented out code in this PR." Title with the name of the user if possible Possible in one line ? You can add CONF REDIRECT URI CONF CODE to the const.py file You can use from homeassistant.const import CONF CLIENT ID, CONF CLIENT SECRET in your integration const file. On all the file. You should use device info to group your entities under one device and remove redundant infos from attrs. Better add a SENSORS: tuple[SensorEntityDescription, ...] ( const and add all of them at once instead of append all of them one by one. Exemples: - - - You can separate the coordinator in a coordinator.py file Yours is always set done line 43 As you wish: you don't need to create variables for them, fill the coordinator parameters directly Instead of defining multiple loggers in different files, define it once (in const.py ): This should be a constant. Could you simplify this object's initialization by just passing the entire config entry? You could further simplify initialization by grabbing async get clientsession(hass hass) inside that method (vs. passing it in here). This is a weird statement. Also, it feels burdensome to have HASS initiate a token refresh if we can't get all vehicles shouldn't bounciepy handle that?
Not sure what's the fanciest way to do this, but can we also only initialize child lock for TS011F ? Done but I do not know if this is the fanciest way :) Why not this instead ? I think it's the fanciest way ( TheJulianJES discussion r1041409678 ). Pretty elegant.
Why only temperatures? Perhaps leave this out of the config flow? Type domain as domain: str list[str] Type domain as domain: str list[str] I'm not sure it's useful to have the type default to max, make it a required parameter instead Is filtering of unknown unavailable really needed here, hasn't that already been done? Shouldn't this be sensor values: list[tuple[str, float]] [] ? Why is this initialized to 24 hours earlier? It was to calculate last updated entity and it's state but there was a miss there. I now changed to initialize to None and then use it in the calculation a bit down in the code Will this log at every state change? If yes, we should keep track of already issues warnings to not repeat them. This comment is misleading since also non-numeric states are blocked I still think this comment is misleading? Removed the comment as it adds nothing. Please type these lists: Also, I'd suggest to rename the 2nd list to valid states or numerical states . We should be lazy here and not calculate things which will never be used. For example, if user has specified a device class, we should not calculate it. See if my changes is what you would expect Looks good Instead of this, maybe: - Modify all the state calculating functions to return a dict of extra state attributes native value, including adding a new calculator for last - Add a new member self. state calc: Callable[[list[tuple[str, float]], int], tuple[dict[str, str], float None which is set to the correct function in init - Call it like so: self. extra state attribute, self. native value self. state calc(sensor values, self. round digits) Can we try to move this to calc last ? What about if sensor values is updated to sensor values: list[tuple[str, float, StateType]] [] : Then calc last has access to the complete state and can pick the newest one? Has been adapted The other calculation functions don't debug log. Can we type Callable more precisely? The dict in the return value is typed as dict[str, str] in the entity init method. This can be a generator expression. The comment doesn't match the logic. This adds "All" and "Rounding digits" when adding a sensor group for the first time. This isn't needed. Let's only show them in the option flow. This is a very confusing property compared to what "all" means in other groups. In other groups, all affect toggle behavior, while here it is used for the availability of the included members. IMHO, this should be renamed, e.g., to "Ignore unavailable"? Also, it is confusing in a sense, like: Ignoring unavailable vs unknown?
FYI, you will face a delayed merge timeline if the initial PR has multiple platforms. Understood. Thank you! Instead of defining a new logger in every file, define one (in const.py ): We shouldn't store anything in hass.data until we're certain that the setup succeeds (in your case, after anything that might raise ConfigEntryNotReady ). See above. Is success not already a bool? Do we need to pop the coordinator out of hass.data , too? To confirm, does the creation of the API object block (such that an executor job is needed)? I see below that you're authenticating it afterward, so I'm curious what this does. We shouldn't store this in hass.data until we're sure the coordinator has a successful first refresh. We shouldn't store these in hass.data until we're sure the coordinator has a successful first refresh. Remove the , so that this formats more nicely. Remove the , so that this formats more nicely. What does this statement do? We shouldn't stuff a huge amount of code into a single, broad try except. Use more, smaller, specific try except blocks so that it's clear what can cause an exception (and what type). This nesting can be avoided if you reverse the logic: Is local id the unique characteristic between config entries? If so, we should check that one doesn't already exist (so the user doesn't create duplicates). Be consistent with typing on user input (like you have elsewhere). This can be simplified: Nested loops indicate a good spot for a dict comprehension. I can't tell your logic, so I can't give you a specific example. Nested loops indicate a good spot for a dict comprehension. I can't tell your logic, so I can't give you a specific example. Argument typing (since you do this elsewhere)? If you store the unique ID in attr unique id instead of unique id , you can avoid redefining this property. If you store the unique ID in attr name instead of name , you can avoid redefining this property. Why not make this a property? python property def device manager(self) - RointeDeviceManager: """Return the device manager.""" return self.coordinator.device manager We don't generally use the ATTR ATTRIBUTION attribute anymore. Why is the dispatcher needed when you're using a DataUpdateCoordinator and CoordinatorEntity ? Why is there a SCAN INTERVAL when you use a DataUpdateCoordinator ? Why is there a SCAN INTERVAL when you use a DataUpdateCoordinator ? You might want to include the parent class's check, too: This will ensure the entity gets marked unavailable if the coordinator fails to get new data. This check seems replicated between multiple classes should they share a common parent?
This feels hacky (and spans multiple lines inline, which we should avoid). It might be better to build the URL, for example: - Add import of YARL: - Build URL: - Assign in device info: Suggestion was implemented.

This also needs handling in the effect property above. I'm not sure that it does, because a playlist isn't an effect, it is all effects. So if I have a playlist of 2 effects, "Snow" and "Twinkle", when playing the playlist, the current effect is either "Snow" or "Twinkle", not "playlist". Shouldn't this me a mode switch or select entity instead? I feel like this is misusing effects to trigger a playlist mode. I'm not sure if this is the best way or not. A playlist is a list of effects, so I can see it being available in effects. It is essentially "all effects". I'm expecting some Twinkly products to be delivered any moment now, so I'll await that an see how it would generally fit compared to other integrations. I agree that this might not be the best way, but I don't know what would be the best way. Possibly, "Playlist" (and maybe "Music") should be added to class LightEntityFeature(IntFlag): in the general light component. But then one would also need to have ways to handle those in the UI and service calls. Anyway, you should also check if a playlist is actually created before adding this. Currently get playlist is not in ttls: get-playlist But [jschlyter]( seems to be pretty responsive, so it should hopefully be an easy fix. Another option is to create some Twinkly specific service calls like twinkly set mode("playlist") but I don't like that either. A related problem I have seen in the GUI is that if you are using an effect, and then select a static color, and then want to go back to the effect you previously used, you need to first select another effect. No "turn on" is sent of you just select the same effect as you aleady have active. This is fine as long as you have more than one effect added to the device, but if you only have one, you can't easily get back to effect mode after being in color mode (using the GUI). So there should really be a "Mode" selector in the GUI (but I guess that is more of a frontend issue and maybe architectural, so not that much of an easy fix). Ok, so it seems like a Twinkly device can be in all kinds of modes: - color - demo - effect - movie - off - playlist - rt Considering this, I don't think this should be mixed with the effects; it is especially odd to pull in a single mode into the effect list. Besides that, music mode could be enabled too which is not part of the default "modes" but more a separate functionality - with a confusing name - that can be applied with (some) effects, so that probably deserves its own dedicated switch entity. So there should really be a "Mode" selector in the GUI (but I guess that is more of a frontend issue and maybe architectural, so not that much of an easy fix). It's not an issue. That can be created, we have select entities for that purpose. Considering this, I don't think this should be mixed with the effects; it is especially odd to pull in a single mode into the effect list. I agree. But to be honest, not all of these are relevant. Color is a static color, that is fine. 
This is breaking any blueprint out there right now, we cannot do that. Did not think of blueprints So we keep the old params and add new "min" and "max" to be used for Kelvin and potentially at some point in the future phase out the old ones with "mired" in the name?
This was an arbitrary release. I'm not sure when is the proper time to schedule the removal of ted5000 . As I remember it's minimum 3 releases after the code release. So it's good now if this PR is merged for 2023.1.0 Perfect! I'll keep that in mind if the PR is merged after the January release. With the good import Multiple things here: - [ ] All show should be removed - [ ] Use options translation key to translate your keys into a label for the UI, exemple here L52-L62 - [ ] Use those keys in the test Optional: - your conf keys can be consts : name starting as CONF After previous comment "All show should be removed" : this is should also be removed After previous comment "Use those keys in the test" : Use options.async configure to test the option flow. Exemple (or maybe find a newer exemple) L555-L562 This const is not used I won't use "raw" sensors function name, but some kind of [get build ]sensors descriptions . Same for mtu Should be replaced by this. attr unique id in the constructor Should be removed as: - name is present in the entity description and automatically fetched by SensorEntity - icon is pre calculated by the device class into the entity description , and should not be overridden by the entity to keep consistency between integrations. An icon can be added to the entity description if no device class . Should be replaced by this. attr unique id in the constructor Usually the flow is on the init step, please move it here Eventually create a dedicated TedUpdateCoordinator : - - Apparently you took the exemple from IPP I made it a bit too obvious, didn't I? Oops. This file is not in sync with strings.json file. It also should not be modified manually, but only by a command line (don't remember which). That said, I don't think options needs a description title. Found it! python3 -m script.translations develop Thanks plus coordinator I couldn't see what this was for. It looks like async setup platforms was something used in entities when I first wrote this code but is not replaced with async forward entry setups(entry, PLATFORMS) . The add update listener I believe is to trigger a refresh of entities if the options change. I still see many integrations using this line. Could this be done using abort if unique id configured() rather than a custom function? Is there a specific reason you need to catch generic exceptions? What exceptions do you anticipate? This type of catch log will hide what the exception really was, making debugging difficult. You're right. I don't think there should be any types other than HTTP Errors. If you inherited config entries.OptionsFlowWithConfigEntry , you wouldn't need to do this. OptionsFlowWithConfigEntry is a very recent addition but looks applicable here. Is this a copy paste error? Recommended to add type hints.
I don't agree with exposing this to the template engine, as it might expose a security risk. There is currently no other way to generate signed URLs for notifications. The notify platform has been a state of flux for a while so there is no real solution in there that can automatically sign URLs. Do you have a different suggestion solution for generating signed URLs for notifications? I could expose [async process play media url]( L29) instead of internal external URL, but that is essentially doing the same thing adding all 3 of these. The notify platform has been a state of flux for a while so there is no real solution in there that can automatically sign URLs. Let's improve that instead of working around things. Not sure why you wouldn't be using the notify platform in these cases. Do you have a different suggestion solution for generating signed URLs for notifications? I don't, but this does impose a security risk, as template (Blueprint) can open up sign any URL at will. Which IMHO is not something that belongs here.
This is a binary sensor. Why do we use a custom device class? We don't allow that for binary sensors. For sensors we currently use it to allow translations of the sensor state. stringssensorjson It can still be used as a selector for Automations Blueprints and I do use it the blueprints I made: Please remove it. That's not part of our design guidelines at the moment. I'm missing a strings.sensor.json file for this integration. stringssensorjson There is actually nothing to translate here. The value of this sensor is a license plate which is not translatable. Ok, then just remove the custom device class. Thanks!
Maybe a command topic should be required if TextEntity doesn't have a read only flag? A read only TextEntity would be better represented as a sensor? Maybe include the entity id too in the error message Shorter? Why does this set the state to None instead of to the empty string? Why do we default to None ? Can't a text entity be set to the empty string?
The addon manager already has an error message in the exception. L58-L60 I would prefix this method with or else you cannot guarantee it is only run during async setup entry and so cannot raise ConfigEntryNotReady . Any reason you don't inline this method? The async setup entry function of these integrations have a tendency to grow and become hard to read unless we break it down. Add a note that it can only be called as part of async setup entry.
let's fix this typo too Just removed the comment. It seems like it was a copy of the comment for rgbw. Please don't do side effects, like logging, in entity state properties. Either move the logging to a callback or remove it.
You could just Addressed Use cv.str instead of str . Import from: import homeassistant.helpers.config validation as cv Addressed, I didn't know. I'm wondering why the scaffolding script doesn't use it :man shrugging: Do we know? L21-L23 Use the LOGGER from const.py instead of defining a new one for each module. Oh right I missed that one module indeed, good catch thanks Please remove the folder translations Addressed Please remove empty keys Addressed This is essentially doing bluetooth discovery in the climate platform, that's really strange. Understood that the edilkamin supporting library is not BLE based, but: - Let's go the standard route of one device per config entry, the config flow should discover devices and offer the user which one to pick - What happens if the user does not have a bluetooth adapter, does edilkamin.discover devices helper not work then (that's a very odd cloud API in that case..) - Can we add bluetooth discovery? Are we authenticating with a local host or with some cloud API? Please move this to climate.py . An entity.py is expected to contain a base class, shared by several kind of entities. Please look into the [updated entity naming rules]( entity-naming) and set has entity name to True Doesn't the cloud API provide something better than a mac address? Delete this, it's already stored in attr unique id I strongly suggest using a [ DataUpdateCoordinator ]( coordinated-single-api-poll-for-data-for-all-entities) instead
Can we adjust upstream to avoid needing this? In general, we should not access protected private APIs from within Home Assistant Sure! I wanted to add an additional option to that Notification class anyway, so I'll change that too in the next release of xknx.
Why is this configured and not just read from the device (which I think it can looking at the code)? This is an optimization for setups where swing support is not needed: - Without swing support, it's possible to query all properties of all units in a single request ([here]( L71)). - With swing support, there is a need for an additional request per unit ([here]( L89)). So, for example if there are 5 units there is a total of 6 requests instead of 1. However, it's true that the new config flag is not needed for logic correctness (it can always be enabled even when swing support is not needed or not supported by all or some of the units.) Maybe I'm not reading it right but it appears to me that the bridge knows if there is swing or not and you could use that? [here]( L90) What you're linking to is exactly the bool that's being passed from here :) The coolmaster API documentation does not show any way to get swing support other than per unit, and a single instance can have dozens of units. Alright. I think I get what you mean now. I would anyway call each unit in that case on init for each entity to get all properties and functionality. Seems as this is local polling so not sure why we would need to save on api requests likewise you only have to do it once per unit to get the full function if I understand well then. Having to ask the user if it has swing or not seems not the way to go. I don't mind to remove this new config flag. It was done to reduce the amount of requests when they are not needed (with the assumption that it's costly). OnFreund , are you ok with this proposal, as I think you recommended otherwise. I'll implement whatever is agreed. I think it's an important optimization. Instances can have dozens of units, and despite being local, coolmaster is not always responding quickly. This can easily get to seconds during HA start. Ok. Leave it as is then but I guess then you also want to make the default False or this discussion does not really make sense. I agree - I also believe the default should be False : pullrequestreview-1211747599 Changed the default to False . Would it work to query all the device information during the config flow and then store the option in the config entry data without asking the user? Is the upstream package returning the unit itself as response set swing ? Seems a bit strange and what happens if the call fails? Yes, the upstream package always returns a new unit object (these are immutable), as a result of every mutating function. If a call fails, an exception will be raised. This is the pattern used throughout this integration. Happy to have a discussion about it if you find it strange, but I don't think it should block amitfin's PR - it's simply following the existing pattern. Then I think we should at least handle the exception to raise HomeAssistantError to give the user a proper response if the command did fail for some reason. Done. (Note that we catch Exception since it can be raised by the call [here
can't we use the dns name here instead ? when using supervisor each add-on has its own dns name based on slug The default url here will only be used in the manual step, ie not when using the official add-on. I'm not sure what's reasonable. Maybe just localhost ?
I cannot find windows state in the linked documentation. Potentially this is missing from the documentation then as it is returned by the API. Consult the API response: It could be a customization created by the manufacturer, would be nice if there was a specification. In general, we want to avoid adding these. The device works well with Tuya's Smart Life application (and within this application these values are exposed), hence I assume that it is intended behavior. This is quite common model I believe, Moes HY360RT TS0601. I've also checked the Tuya IoT portal and all these parameters are there... frenck After some extra investigation: 1. The link refers to Standard Instruction Set only. 2. I've checked the Tuya IoT platform and noticed that the platform allows selecting Control Instruction Mode : - Standard Instruction : "Control devices with standard instructions after mapping. Various devices across manufacturers can be controlled with a single set of instructions, but note that some functions might not be compatible." - DP Instruction (it's selected in my case, not sure at which point, maybe it was a default): "Control devices with original DP instructions. You can access any DP information." The IoT portal suggests both sets are the same (different from [Standard Instruction Set]( DP Instruction Standard Instruction -- -- temp set temp set temp current temp current mode mode child lock child lock fault fault roomtemp calibrat roomtemp calibrat lowtemp lowtemp hightemp hightemp wind wind boost boost valve set valve set comfort temp comfort temp eco temp eco temp valve valve power state power state week state week state Prog Workday Prog Workday Prog Restday Prog Restday Temp holiday Temp holiday windows state windows state Auto Lock Auto Lock Days Holiday Days Holiday 3. I didn't get any reply for the tech support ticket. 4. API allows discovering the instruction set supported by the device - [doc]( frenck any update? Note that adding the DP instruction set is rather safe as on the startup, the actually available entities are discovered. I know that there is a performance impact, but this is only for a set of string comparisions. Moreover to fully utilize Tuya Thermostat, it definitely makes sens to enable the DP instruction set. I cannot find this data point in the linked API specification above. Am I missing something? As above. As above. This is a bug fix and should be in a separate PR (not mixed with PRs that add new features). This is also hinted at in the PR template you filled out when creating this PR. OK. Resolved. I cannot find this data point in the linked API specification documentation above, could point me to the right location? As above - shared the API response. I cannot really be responsible for the accuracy of Tuya documentation. It seems like an issue, as in, the device is not communicating according to specifications. Have you contacted reported it with Tuya? Please note comment on the Standard Instruction set. No reply f
Don't use magic strings, import the constants instead Fixed in commit 7eff9d95c97bd05e65ceed363be9e2c318553409 Is the ID unique to the window sensor? Yes the id is unique ![2022-11-30 12 34 56]( Right, but there is a chance there will be a need to create multiple binary sensors in home assistant for a livisi window sensor in the future. For example, maybe we want to add a "low battery" binary sensor? If that's the case, we should consider formatting the unique id to avoid future collisions, for example: unique id f"{device['id'] window sensor" , or whatever is appropriate. We could also leave it as is, and just use the ID as is for the "primary" function of the device. Edit: This has been fixed You are right. I have not yet thought of this possibility. But with the window sensor of livisi rwe is not known to me that there is something like battery status or brightness. But I have added a postfix the id. A device class is not a state class. Use the state class enum for state classes. We don't have state classes for binary sensor. We don't need to set is on to False when setting available to False. This isn't used. This is a binary sensor not a switch. Not all Livisi Sensors are connected to a window. device["tags"]["typeCategory"] may be either "TCWindowId" or "TCDoorId", so the class could also be set to "BinarySensorDeviceClass.DOOR"
My impression is the best practice here is to use the config entry id as the input (which newly has a selector) rather than a device then getting config entries out of it I would think config entry is to be used when there is no device or entity available to distinguish one entry from another. I believe the threadsafe error is because this async start reauth has to be called from the async thread context, but this is being called in a background thread. I think you may need to move this try except block until set vacation so that its thrown from the sync context back into the async context. (I see this is how you are doing this in GoogleMailSensor below) When doing that, you can also change this function to accept an access token or Credentials object rather than the config entry since it will no longer need the full entry. While I think what is here is totally is equivalent, getting the token from session.token seems like it may be a bit a little more consistent with the API design to not have to dig into the config entry details. e.g. first call await session.async ensure token valid() then session.token to get the token that has been ensured has been valid. I think this lets you avoid needing to keep around the config entry in GoogleMailEntity since you already have to get the session anyway. I'd suggest dropping the scope checking. The original motivation for this in google calendar was when someone added support for changing read vs read-write, and this only has a static list of scopes at the moment. I don't think full access to the mailbox is needed so drop? I'm think readonly and compose will be good? Or I can just omit it for now since it is not needed for Vacation settings. I'm definitely a fan of requesting just what is needed. However, if there are followup PRs planned and the primary function of this is to support reading and composing emails and just getting vacation responders is less of the focus, then i get that just having the broader access makes sense (e.g. many ui options etc would not worthwhile if its not the primary point). I think i'm just messing what the larger plan is here vs what is possible, but we have no intent to actually do. To make this integration have a bit more meaning on release, I've just added the email part. Would be kind of silly to release without the features for it's namesake. These seem out of place in sensor.py . Perhaps init .py or their own file? Does this make sense as a notify platform? It seems similar to other notification services. It could but the from, to, and send options will have to be part of data which makes it less user-friendly in my opinion. I am not sure when notify will get an overhaul. I can extend the notify schema, then maybe that will work although I haven't tried. Notify does not seem to support extra fields from services.yaml ? Again, not too friendly IMO if it doesn't. The sender option is good to have as someone can have a shared mailbox and may like to sender from there as
Is the params struct documented somewhere? If it isn't please comment the code to explain what's going on We have two types of outlet, one with only one output and the other with multiple outputs, There will be some differences in the API outlet device: multi-outlet: This is too much protocol details in the integration. The library should abstract the protocol details into a simpler interface of objects and methods. We shouldn't need to pass dicts with specific strings and do bitwise operations to get api values. OK, so this builds an array which the value lambda can then fetch the right value from. It seems like a quite roundabout way of doing things, can you try to come up with something simpler? Maybe, instead of the value lambdas, add a helper function which takes as input the state , the device type , and the plug index and does the needful based on that? If the state is a string, just use that, and if it's a list, pick the right index. This is for compatibility with update entity state method which update entity state via mqtt data push, Add helper function with device type as input, maybe i need to change the update entity state function logic or add an unnecessary input parameter to all device I'm not sure which way is better. Yes, I understand, but making a temporary list is quite useless. I would just remove the value property from YoLinkSwitchEntityDescription , since all the switches anyway check the same value and replace that with calling a function similar to this: I'd recommend defining each method instead so that the library user can easily know the available api and have a typed interface for each method. like this ? Yes, that's better. Note the typo on request. Where is the device type description attribute used? device type is useless, I have removed
Very interesting finding! Care to take a look at r1032892143 for firmware v12 ? Do you think we must create a second model for firmware v12? If yes, we must add ZLinky TIC FW V12 if your PR is merged Ok, I guess I misunderstood how model info works. I've reverted to using ZLinky TIC as returned by basic cluster for model attribute.
I guess this means all gree devices will get a health mode switch, regardless of if they support it or not. Is there any way to check if the device supports health mode? According to there isn't. Many (most) units don't support Fresh Air feature either, so I thought it wouldn't be a problem, plus from my testing it doesn't affect anything, unsupported entities can be simply disabled. If you tell me how to disable an entity from the start, I can do it, but mt knowledge with python and HA is limited. Just add attr entity registry enabled default False to the class definition, and the entity will be disabled. Maybe that should be done also for other features which are rarely supported? To be honest, I'm not sure what can be considered as a reasonable minimum featureset that can be enabled. I'll make health mode start off as disabled. BTW my ACs came with a remote that supports multiple features my AC units don't, so I'm guessing this is a Gree thing. emontnemery Check out my changes, I've made health mode not load by default updated tests. I've spent a long time trying to enable an entity through entityRegistry and various other means, but finally settled for this. use entity registry enabled by default mocker as in async def async setup gree(hass, entity registry enabled by default, enable health True): It will then automatically enable any disabled entities for you Thanks for the tip, new commit coming up!
This is not something we should do in Home assistant. This will add more noise to the notifications screen, causing users to ignore all notifications in HA. I suggest the HomeWizard app creates a persistent notification with their app if they want this feature. Hmm okey. We will see if we can add this to the app, but we can't see the difference between "offline" and "disabled" which makes this a bit hard. But I think that the documentation itself will be sufficient for now, we will see what the impact is at HomeWizard support. Is a message in the log allowed? Nvm I think that this name could be better. Maybe Cloud connection ? Better Stale comment This means the JSON is loaded every time for every test that uses this fixture. That s inefficient. Use a side effect with a lambda that loads it on demand. It's nice to collect all possible entities in a list first and then make a single call to async add entities .
Can you move the existing constant in a preliminary PR? Unrelated to config-flow, can this be done in a preliminary PR? Unrelated to config-flow, can this be done in a preliminary PR? Unrelated to config-flow, can this be done in a preliminary PR? I think this should create a deprecated yaml issue in the issue registry. Quick question regarding this: Should I create the deprecated yaml issue here instead of in async setup (in init .py )? yes This file is no longer needed. Please remove it. I suggest that you move all these fixtures inside a local conftest.py You can then use pytestmark for auto-use within test config flow.py Please rename to mock setup entry for consistency I think this is much cleaner: CONF NAME is not useful in the data. Please move the schema to a constant at the top the file. Please also remove CONF NAME which is not useful. Should I just use DEFAULT NAME for the name of the config entry and completely remove the use of CONF NAME in data? Edit: To my understanding, I should only use CONF NAME from YAML to generate the config entry's title during import, and I should not ask user for CONF NAME if a new config entry is created in the UI? This is not a valid unique id. Please remove it. That's unrelated to config-flow. Should be another PR. Please keep these three constants inside the file. Please keep PLATFORM SCHEMA until YAML support is full removed. Not needed. Do not make this autouse as it will likely collide with future tests. Instead you should use pytestmark inside test config flow.py You should either mock the Client class (from python-qbittorrent ) Or you should be using requests mock.Mocker to mock specific URLs, and not patching the Session object directly. Please combine the user flow tests into a single end-to-end test: - Open flow with USER and no input - Patch cannot connect and set input it should fail with error A - Patch invalid auth and set input it should fail with error B - Patch ok and set input it should succeed and create entry
Attributes are not for debugging. If extra attributes are needed, they can be added in a controlled way (as in specific). Just dumping in all data is not what attributes are for. What data are you trying to expose? .. Frenck frenck in this particular case I will find the valve attribute useful for heating automation, but there are many other useful parameters, such as power state - I will know if the batteries are not discharged in general - I don't see any justification for hiding data. frenck : I've added filtering although as Santanachia mentioned I don't see why hide the data. Depending on the firmware and the settings in the Tuya IoT portal different sets of data can be shown: - standard instruction set (temp set, temp current, mode). This is missing some really usefull data, like valve position, valve setting, etc. - DP instruction set (used eg by Tuya Smart Home application). This set includes much more usefull data, including attributes that I use currently: - fault - to alert on fault - roomtemp calibrat - to automate calibration using another temperature sensor. - valve set (one of normal , ForceOpen , ForceClose ) - allows tracking the valve state - valve - valve open percent. Allows (in conjunction with valve set ) detailed tracing of the Thermostat efficiency - power state - to alert on batteries These shouldn't be attributes, but their own entities. In general, attributes should be used rarely. in this particular case I will find the valve attribute useful for heating automation, Rule of thumb: If could should be used to automate on: It should not be an attribute. These shouldn't be attributes, but their own entities. I can understand this in the case of quiet mode in air conditioning - a separate switch, or night mode in the lamp. But these are the states we can change. The valwve or power state describe the state the device is in. They are neither switches nor sensors. They are just attributes of the device Unfortunately, our architecture does not agree. As stated, please don't use attributes. frenck Thanks for the clarifications. Could you please validate my idea in the mantime regarding the enities: - valve sensor (showing the valve position) - power state binary sensor - fault binary sensor - temperature calibration number entity (this is the main thing here, currently available only in Zigbee2MQTT, ability to easily recalibrate the built in temp sensor based on external in-room thermomenter) I'm not sure what you want me to validate on that? In your opinion, are these the right entity types I have no context in that little piece of text. Feel free to develop and test it, figure out the right things and open up a PR that motivates it. That way, we can discuss it.
I'm not sure if this is correct: - Is the detection needed? - If detection fails, should the config entry not be updated, even if it's configured to use the USB connected radio? The current flow is to connect to the old radio, read its settings, then start the flashing. Shouldn't this be independent of the migration data? I think this has been resolved puddly ? Let's switch this to ezsp . The config flow has logic to translate efr32 to ezsp . What about baudrate and flow control , do either of them have any meaning when using a socket to communicate? They don't. I think they can also be removed. We only need to start the add-on if the user is using multi-pan. If it s not, it should do nothing. I don t see that case handled right now? It's handled, this case starts the addon if it's installed but not started. If the addon is not installed, we won't start it. Where do we check the SkyConnect config entry data ? The check was added in b3926a7 Is this the source of truth if the user wants multi-pan or not? I think that we should store it in the config entry options as HA is the source of truth. And it should setup the add-on correctly based on that. No, that was indeed not correct. Updated so we check if the addon is configured to use the USB adapter belonging to this config entry How will this work for container and core installations that do not have the supervisor ? Fixed This flow will always assumes that if the add-on is installed, even if it is not running, that we want to use it. That means that the user installing the add-on and then restarting Home Assistant, will end up with using the add-on. I don't think that the add-on being installed should be the indicator how the SkyConnect should be used. Instead, we should rely on data stored in the config entry. The code checks if the addon is configured to use the same serial port as provided by the current device (i.e. just the existence of the addon isn't enough). Is data in the config entry necessary in this case? No, additional data should not be added to the SkyConnect config entry. If the Multi PAN addon is configured to use the SkyConnect, we should never discover a ZHA USB flow which will only interfere with the Multi PAN addon if the user tries to finish the flow. well the question is, what do we want the source of truth to be and what are the pros and cons of storing the user preference in skyconnect config entry vs ZHA configured port vs if the add-on is installed? For now, I think this stateless approach will work for any common setup. Once we get firmware swapping working I think it can be revisited. Storing firmware state in the config entry would help switch back to EmberZNet firmware, since keeping the SkyConnect integration stateless means we can't tell what's running on the stick until we observe ZHA running the addon successfully start with firmware flashing enabled. On the other hand, it would not work when the SkyConnect was flashed externally and then plugged back in. Honestl
If we add UNIQUE ID, then I think we need to remove DeviceClass, StateClass and UnitOfMeasurement. We should probably also make it a string: Why would we remove those? Perhaps we should consider not allowing to change them (mess up statistics) but configure them initially we should do. If there is a unique id, then they can be set in the frontend. We can therefore default to None, and let the user customise afterwards (smaller config flow) Looks like we should remove UoM but I don't see how a user would set DeviceClass nor StateClass? I must be mistaken - I can't find it either anymore. Let's leave all three in for now. We still need to ensure we store the unique id as a string though.
I think this would be easier to maintain if you made a base fan class and this inherited from it so we don't have mostly duplicate code between here and the fan class Thanks! I ll hopefully have time to look into that at the weekend. Now done. Please take a look at the revised version and let me know if I should make further changes. Maybe I miss something: why this check ? Good question. Without this check, it complained that state was optional (type None) so it couldn t resolve the references. That could be because I added types into the constructor (guessing, I m not a Python expert).
I think that it would be good to provide multiple base classes for the SensorEntity. So this logic would move to a EnumSensorEntity for which options is a required attribute but no unit conversion logic exists. I've played with that implementation after it was quickly discussed earlier. While I think from this perspective, it makes sense, however, when implementing integrations, it will become less "beautiful". When implementing this on an integration level adds an additional complexity. Right now, most integration implements a tuple list of entity descriptions, iterates over that and spawns sensor entities. This is all pretty flexible and straightforward. Let's assume we split into an EnumSensorEntity , and later a TextEntity , and maybe even NumericEntity and RangeEntity . The entity descriptions need to be split as well in a similar fashion. Now the implementation at the integration level becomes messier. An integration that needs more of these types now all of sudden needs to either create multiple lists and loop over multiple of them and implement multiple entity classes to inherit from their integration sensor class; or use different descriptions (or mix them and later use isinstance() or an added property to their descriptions) to figure out which of their entity sensor subclasses they need. While adding options in its own subclass makes sense in this place on the code, it will force the implementation down the line to become a little more complex. I'm not sure if that added complexity is worth it. I discussed it with MartinHjelmare emontnemery today, we came to an agreement not to split this any further, to keep the integration implementation less complex. I'm going to add more validation to avoid weirdness. These two I will extract and make them more generic in a separate PR, as these checks can be applied to all device classes that are marked as "not numeric". Just so the demo doesn't cause confusion, maybe make use a more specific key than mode ? will adjust What's inserting this empty dict? Is it required? I dunno? I just ran our translation script. It is a generated file, so I didn't put much attention to it otherwise. Yes: ![image]( a unit of measurement Thanks, MartinHjelmare I'm moving this to a next PR (as these can be used to validate other non-numeric sensors too) and going to fix that in the same go. a state class
Thanks for your suggestion - Ok with me :-) Thanks for your suggestion . Ok for me This is protocol details that should be extracted to a third party library. This integration has existing code that also violates this rule. Further changes to the existing code or new code that adds protocol details won't be accepted. 4-communication-with-devicesservices OK, I'll do that when integrating these new features - thanks for your comment
You can have Python do the isinstance with Unless you mean these to be shared between Connector instances, don't define them here you can leave them as type hints, but assign them in the constructor: Is there a reason why some of these are private and others aren't? self.hass (without the underscore) seems to be way more prevalent in the codebase. This will leave data possibly unassigned in this function. I don't think that's what you want...? Should there be an else for a message that's not understood? I wouldn't call a function get ... if it returns None. Feels a bit weird for this function to have two signals to send depending on whether the argument is None. I'd split these to dispatch value update signal(evse id) and dispatch grid update signal() . Is that a warning? Would probably be more readable to split these: This sounds like you'd really want two classes, a ChargePoint entity and a Grid entity, instead of one that can act as two depending on the flag? Copy-pasted docstring? Same here: if you don't want these to be instantiated once and shared between ConfigFlows, don't initialize them here. Would be nice to document what delays these are, either by comment or by a better name. VALUE TYPES is a string with the value "CH STATUS" , so this becomes a substring search. Probably not what you meant. By the looks of it, these are related to the WebSocket API response. Maybe they should be named to that effect, or if they're not really constants you need to even know about in the rest of the integration, they needn't be here? (Perhaps they should live in bluecurrent-api?) Same here if these are only related to the API, I'm not sure they need to be shared consts. I think these should use the constants from homeassistant.const , e.g. ELECTRIC POTENTIAL VOLT here. Ditto for device classes. Not sure timestamps need a native unit mentioned at all..? You iterate over keys when you iterate a dict anyway, so Yep, definitely seems to me there should be more classes involved According to their website, it is written as Blue Current . Their entry at the chamber of commerce is also "Blue Current B.V.". This needs to be corrected throughout the whole integration.
Platform.SENSOR Can you seperate invalid auth and other exceptions? It is a lot more helpful for the user that way This is done in the config flow ( async step user ), where the connection is tested. When the Piko is first created, there is no actual request sent. So there is also no way of knowing any auth issues, since its active polling. Only in the config flow is it allowed to catch the bare exception. In the rest of the code, please only catch specific exceptions. You can combine these type in value? type data type errors type user input should be in domain, name, alphabetical order remove this file - no longer in use remove this file - no longer in use remove this file - no longer in use remove this file - no longer in use you need to type hass and have a return type for all of your tests I don't think this is correct - i'm not 100 though, I'd double check Change the string keys to CONF HOST etc. Did not expect these 2 functions to be in const.py Shouldn't the manufacturer also be a constant? Check against FlowResultType.ABORT Check against FlowResultType.CREATE ENTRY Please catch only specific exceptions raised from the library. The whole part of splitting API requests should be done in the third-party library as it is too implementation API specific. Can you please open a PR with this functionality there? Log entries on level info are reserved for the core. Please change the level to debug Could you point me to the document where it says that the default IP address of these devices is the suggested one? Please don't use ternary operators, as they make the code harder to read. Please move this class and the SENSOR TYPES to sensor.py as only that file used them. In const should be only code, which is at least used in two or more files.
Stale comment Whoops, fixed in stale comment So... why is this a number and not light ? I have considered this, but this is only a control for when the socket is 'on'. And you can only control its brightness, not the on off state. Also, it is a status light, not a light. For example, if it was a light and you turn if off, then you only set the brightness to 0 , if you turn it back on, what should be the value then? It feels more logic to me to make it a configurable number. But of course I am open to other opinions . If you can't control the status light on off, it cannot be a light , so makes sense. Thanks I think that calling it Light level seems confusing. Shouldn t it be something more like Status light brightness ? Agreed, feels better. Fixed in Why 255 ? You also don t set a native min and a max value. The API's internal level is 0-255, but I think it's more intuitive for the user to make it a percentage, hence the mapping. Native min max defaults to 0 100, so it is not set. But I can add this to make it clearer? I think it makes sense as is right now
Not every entity needs to have device info. You could just link it up to the main one by just providing the identifiers key. Awesome, did not know that. Fixed in This fixes the failing test. When not added the button is not linked to the device. I have no idea why it does not work, or why it does works here L51-L53 So if you don t add the full info, the full info still needs to be given to HA via another entity. You can either have it in each entity, or you create the device as part of setting up the config entry and let each entity link to it. Do you accept this change now and that I open a follow-up PR with fixes for all existing HomeWizard platforms? yeah Side note: Please sort . We should test the press service call too.
Can someone confirm what the OS name is for iOS devices? I don't have an iOS device to test on, so have made a guess. I couldn't work it out for myself from this line, as it's using a system call: L462
Move this above the connection attempt. We shouldn't try to connect if we are going to abort anyways bdraco done in f23e96d1ffb0b4479034621aa2b4cbdb3be6a237 You can reference the id in the user flow so translators don't have to translate this twice. There is an example in homekit strings.json Done in 464be71c021926535dacaebdbda7d097441486ed Usually we want the title to have the stable identifier instead of the ip since that can change the stable id can't. You could borrow this L30 Done in c7a266a5cb79d5f30f2f99c2507e6e36b426056d I think it would be a bit nicer to show the user the short mac in the title since thats enough to tell them apart I think it would be a bit nicer to show the user the short mac in the title since thats enough to tell them apart Done in 02c9dd79ce0e032525d64951583ad8789645a224 We should finish the flow until it gets to a final result here and assert the result type is either an abort or create Should I call hass.config entries.flow.async abort to get to a final result? I mean, this test isn't getting to a final result because the user is allowed to change the port and try again... I'd feed it a good port to verify it gets all the way though, the re-attempt works correctly, and the resulting config entry is what is expected I'd feed it a good port to verify it gets all the way though, the re-attempt works correctly, and the resulting config entry is what is expected Done in f3e80e85170ae3fa047774ffdfd73a0659dc67be Please use the enum here Done in 10e683b629f6d66a20af91a4343dcfe3d5bfc606 Since you are patching setup this check is likely redundant but it's not hurting anything
Do you want to allow multiple config entries? We can use a unique id of the oauth ID then it would let the service target different accounts. However, not sure if that makes any sense in practice given you are just talking to a microphone and likely just need some default account selected. Just mentioning this for completeness. I'd rather not allow multiple config entries. I don't see any benefit in doing so. The google assistant integration doesn't allow either. It would complicate the usage of the exposed services. Users would need to specify the config entry when calling send text command service and the integration would need to expose multiple notify services suffixed with the oauth ID or better with some other user friendly name that would complicate the config setup since users would need to associate the ID with the notify service suffix at setup. I would suggest that you can exclude this required scopes check. This was originally added for google calendar because it had both a "readwrite" and a "read" scope and it needed to support re-auth if you changed the options settings to know to ask you to re-auth. Google sheets copied it, but I don't think it really needs this easier given it had one scope last I looked. I think you should omit this, then add back later if you introduce new scopes that need permissions. I see. However I don't see harm in keeping it. It validates the token has the proper scope in case someone manually modified the config text files. In google calendar it has had bugs before (the code looked ok, but i found it wasn't working properly asserting the wrong logic), which is why I am weary of this. It's also a "virus" as people keep copying it around so I feel like it should just be removed given the unnecessary complex, extra test coverage needed etc and I don't think people should continue to copy this. Done.
The last argument to async load platform should be the original config passed to async setup . Example: L106-L119 L65-L71 The config entry id isn't an entity id. We can pass the coordinator directly in the discovery info to the notify platform.

FYI, I'm storing sensor indices like this in anticipation of a future options flow that allows users to add remove sensors to this same config entry (for batching API requests). It would be nice if this was named instead of a generic exception, but since you already have named expectation, I'd drop the FlowError and trap InvalidApiKeyError and PurpleAirError directly instead. I did this extra layer because I was thinking ahead to where I use the exact same logic to add remove additional sensors via an options flow. So, for example, this code: diff-a008ccd8fb551b7193ac448801f14b0909d2993985bc0bf486009fc7b53c8e40R171-R195 ...gets used for both config flow: diff-a008ccd8fb551b7193ac448801f14b0909d2993985bc0bf486009fc7b53c8e40R225-R238 ...and the options flow: diff-a008ccd8fb551b7193ac448801f14b0909d2993985bc0bf486009fc7b53c8e40R308-R321 That way, the error handling based on specific exceptions can be centralized. Does that change the thinking at all? Maybe you could pass unknown errors as a second argument string so the user gets some more feedback if its not something we thought about ahead of time example L473 This isn't just for unknown errors, though I'm trying to handle errors in a way that will work identically for both config and options flow. I suppose I could adjust my validation methods ( async validate api key , async validate coordinates ) to return a dict of errors... EDIT: Returning out of validation functions becomes weird if I have to return API results and a dict of errors. Will see if I can think of something else. bdraco What do you think about This removes FlowError while still allowing me to not replicate exception-handling in that future PR. LGTM Is this a default or the only value? Is it possible to patch these where they are imported in the integration instead? Can this be moved to the library? Its nicer to avoid adding anything to hass.data until the setup is successful. Does this really return everything in StateType ? We should finish the flow all the way to either a CREATE or ABORT result Please finish the flow to ABORT or CREATE As above Is there a reason we don't inline the data schema in the form call? It's only used once, right? Now that the options flow has been merged, it's used in two places. Maybe use the duration sensor device class? available-device-classes The VOC device class should use ug m3 as unit. available-device-classes
it's
Is there ever a case we need to write state when the status has not changed?
Maybe? I tried that but in the frontend, device class BATTERY means that the battery sensor has a value between 0 and 100 . With my sensors I have ok or low instead of a number. So the icon is mdi:battery-unknown Ummmm, you are right... No device class for RFLink batteries If a sensor only has two possible values it should probably be a binary sensor instead. Maybe? Done Maybe? Done Also: Done added unit of measurement DEGREE What's the unit of measurement for the CO2 sensor? When using a device class we need to know that the measurement is using an approved unit of measurement. available-device-classes I've open to add unit of measurement where missing
Please collect the entities in a list and make a single call to async add entities . OK, here:
This look fine does fro need to be added to the exclude list? L20 ok i just pushed a commit Should this be or similar..? Should these also have underscores? (Or be named better - they seem to be lists of some sort of product IDs..? (Looking further, ditto with GLOW and ELEC PRO SOC .)) Do these need to be lists (do their order matter)? Could they be sets instead? Should they live in const ? Indeed I don't have to make constants because I use them only once to value the attr hvac modes and attr preset modes attributes. I fixed this Should there be an else case that warns if a device is not supported..? Maybe add exc info True so the full traceback is captured? Good idea To keep things DRY SSOT, this could be computed with a dictcomp from the other dict for brevity? Not the best docstring I've seen... this is the model name. I added the name of the manufacturer as for the other classes The idiom self.coordinator.data[self.unique id].get(CONF ATTR, {}) repeats so many times in all of the subclasses that it would be good to lift into a property (naming could be different) here: it's actually cleaner. It is done. Could use an f-string for brevity. What is a Lock Switch? Is it something Heatzy specific? Should that be documented? Does this... really register an account? If not, maybe..? Please limit this PR to a single platform. For more information see: 5-make-your-pull-request-as-small-as-possible I removed the switch notion from the PR Please extract the coordinator into its own module ( coordinator.py ). I don't think this will ever be true did you mean Is this overriding the superclass's hvac mode property on purpose? Effectively it overloads the parent class
Are you expecting more variants of entities in the light platform? Else just using the device id would be enough as its unique per platform Look up entity name in dev docs Should you also enable has entity name ? If the light is the main feature of the device we want to set the entity name to None . The friendly name will then be set to the device name by default when we set has entity name to True . entity-naming If "state" key is not present should the entity be considered unavailable? normally, "state" key must be present, it should be unavailable when "state" is not present Should you manage self. attr available in those cases? Could this be consolidated? You want it in sequence to make sure the call succeeds? I'm thinking as you're only calling write ha state after the call succeeds there is no issue to set the update the brightness value as suggested. We can set attr has entity name as a class attribute above the init method. The color modes can also be set as class attributes if they are static.
This integration does not connect to a device or service itself, not does it do anything else as defined under ADR-0010. It does, however, consume existing entities or devices in Home Assistant. This makes this a helper (and not an integration), IMHO. As a helper, we should therefore support both YAML and UI in this case as well. Do we have a concept of a virtual device BTW? I do not understand that question. Could you add some context? Well, that's probably a topic for architecture discussion.
Missing serial number out-of-place comment. What happens if the value is not given, or should this rather be required? good catch, thanks! The docstrings across and in separate files use wildly different casing, it would be great if these would be consistent: demo time, demo Time, Demo time, Demo Time? First Demo uppercased, second one not. Here also. Maybe test also that the native value and value differ for datetime, i.e., value does not leak the native datetime obj? as with the other PR, we leave this proxy in because then we don't have to handle time as a keyword argument in the service method of the entity class This file can be deleted This file can be removed.
This doesn't seems to be used anymore? Should it just be removed omitted? None values should be kept. More recent policies (about a year now), is that state attributes should constantly be present (and maybe be None , just like states). I do wonder, if these attributes are needed? At the very least we can exclude them from being recorded by adding a recorder platform. Override attr state typing, to prevent it from being used (well... prevent... it will be caught by mypy in that case) Override typing of attr device class preventing it from being used. We should implement the device class property method returning None and mark it final. This prevents it from being implemented (as this class currently doesn't support has no device classes). We can just use the iso format in this case (which is consistent with what we do for sensors too): These are only used by the state attributes, so I guess we can omit these? Just a tiny suggestion to make it a little more clean mean This is currently a proxy method. If we have nothing to validate here, we should just omit it. decided to keep this... If we use the alternative approach, the attribute name gets passed as a keyword argument which makes date a keyword argument to the service method. This would require ugly workarounds where we rename the date module to something else to make it work, this simplifies things. Partially unrelated to this PR, and no longer needed with the suggestions made in this review. Add translations strings for the entity component (this currently does assume we keep the state attributes around). The tests for the date entity component should cover pretty much the whole component. For example, I would have expected tests here to see if the service call is actually calling the set value method with the expected parameters. While technically the demo integration does that in this case, it should be covered by the entity component itself. This file can be removed This file can be removed.
unix epoch isn't timezone aware; it is always defined from UTC? Should we make it default to hass.config.time zone here? I guess ideally we should have a timezone selector available yes as that is the expected behavior rather than implement the default here, we will implement it in the service function. This will handle the typing coming from dt util.get time zone as well Actually we already default to the configured timezone in the service function. Should we move that into the schema? L119 I think the practical use for these in, for example, automation and such, would be very low? What's the implication of that thought? Do we need the UTC conversion here? good point, we should leave that up to the integration to decide how to handle it cv.datetime actually also supports timezones (the offsets format), for example: 2020-12-13 10:00:00 01:00 would be valid to use in this service call. However, due to splitting date time that gets lost and in async set value it would end up setting the local system timezone instead at that point. I think I would recommend turning it around and making this the main input method for the service call (and thus not split in this case, but combine in the other case). Knowing that, one could argue the need for a separate time zone parameter in this service call as well maybe? good point, so I will remove time zone as a parameter. The split logic allows the user to specify just a date or just a time and to use the existing time or date value respectively as part of the update. Do we want to preserve this functionality? I will update the PR based on the assumption that we do but can always remove that functionality if necessary. ah so one issue is that the date time selector doesn't include a timezone component. So if a user is using the UI to call the service, the only way to input timezone would be to have a separate parameter. Thoughts? So if a user is using the UI to call the service, the only way to input timezone would be to have a separate parameter. Thoughts? I think from the UI perspective, it is fine to assume local time? I think this isn't fully resolved at this point. I think the UI perspective is fine, but we still not handling a given timezone. A service call providing the following: 2020-12-13 10:00:00 01:00 , will ignore the given timezone and overwrite it with the one configured in the system. I wonder if we make this simpler by removing the separate date time timezone service version and just raw accept the single datetime, in case the timezone is missing from that object, replace it with the system one (otherwise skip it). why do you say that? we store the offset at ATTR OFFSET so that we can reapply it in the service handler My oversight! The frontend PR has been adjusted by bramkragten. These splits isn't needed anymore now, so we can just keep it at accepting a single datetime field. Let's remove the split.
It's better to use the available constants to set the state class , e.g. state class SensorStateClass.TOTAL INCREASING . Ok Will fix that I don't think that the state class total increasing makes sense for percentage values. Shouldn't it be measurement? Thank you. That's right
This seems like an unneeded change It was needed to get the pre-commit hook to pass Sorry, I cannot re-produce that locally. What error do you get? ![image]( sounds like you have an outdated pylint installed. OK, I upgraded and it's ok. Strange though, because according to pip the requirement was satisfied with my previous version. I don't think this makes sense as a filter. It is also out of sync with is state and is state attr , which are also not available as a filter.
I don't think this is needed, the super method can be called directly done, 6a439485fced4041fa7dc5434f87ab3c9bc09c1c device is not used here done, a3069e83a8387476d253c62327761747b1015e27 Not really happy with this change, but I don't have a better idea for now... Well it does mirror the hierarchy on pyfritzhome site, so I think its okay. My alternative was to differentiate if a device is a template inside FritzBoxEntity . this device info property seems to be very special to the FritzBoxTemplate class, so should be moved there. further we should add manufacturer "AVM" and model "Smarthome Template" to the device info done, 60fae165a86c47097f0fc5de20fdd6fd197b2e2d We should not use the term entity for anything else than Entity instances. Please rename to something else. done with 82369
It would be a little more efficient to turn this around? As in, this might save a few isinstance calls, which are relatively inefficient. wdyt?
This function should return None when in heat cool mode. fixed There is a separate PR with just this fix in which will be going out in a bug fix patch release, you'll need to rebase on dev when that lands ( 81868). The only values we can ever support are these 3, so the LOGGER.warning and this whole if clause can go away. Does your device have all 3 of these? TEMPERATURE TARGET isn't in the spec for heater cooler .
Maybe just check for falsy? Why doesn't the library raise an exception if there was a failure? It would be more clear to do that so we can catch that and re-raise to retry as appropriate. Yes, I think we should change pyTibber to raise an exception if it is a failure. Danielhiversen do you want to wait for the library change or should we merge here meanwhile? I guess it is ok for now. I actually started that work too but I believe this will help a lot to ease the pressure from the users in the meanwhile Don't log the warning. The exception argument will be logged at warning level by default and will be deduplicated. Yes, I saw that but it will be a log line from the HA core and I thought it's a good idea to have it logged as tibber component too. What do you think? No, we want this to be handled by our helper in core. It's ok to log a debug log with more information, but only if there's actually more info.
Move this, SUPPORT LANGUAGES and MAP LANG TLD to a new file homeassistant components google translate const.py The long constants have been moved to const.py . This is fine. If you want to, you can help the type checker by specifying the type of MAP LANG TLD : Or stricter: The dataclass was a neat way to make this work. Took me a bit to understand how to get it converted from the dict. Thank you emontnemery!
Looks like the underlying base class already has hass L422 Lol. Of course, it does. And I never even use mine. I think we might be able to drop this now I would still need to move [this line]( diff-18ed302c3a0144b0a47a86f87d879c8e573cb344aad2c1d793c969841c08011bR150) out of the try except block. I originally added it though because if one of the entities platforms error, it causes more exceptions to try to unload them when they were not loaded. But I guess that is okay since we already told the user at this point there was errors and issues using the EA version. I think this is the same as the one in async setup entry ? We could make a async protect client from entry(entry) to avoid writing it here as well It is the same one, and refactoring it out to another function is a great idea. The API client cannot be serialized and passed through the Websocket so it needs to be recreated. It looks like this is hard coded on the frontend Maybe make the url a constant in case it ever changes? I'd check that its a subset in case new fields get added later
Maube you could use a constant for "silent" and use it here and in FAN MODES TO OVERKIZ ? I just fixed that :) Can't we use the Away preset from HA? I would prefer to keep them similar to Somfy. Away vs Holiday Mode is perhaps a different meaning? At this point, you already know the protocol, so you could use SWING STATE[self.device.protocol] to check only the state you expect. Good catch, I have to fix this anyway, since I forgot to change this.
This is not an option in your strings.json Why are you creating a private member variable here? This is a variable being cleared, not defined. It's defined in the init For some reason i thought it was self.errors in the init. That being said, I believe one of the linters still views this as defining. I think you should do self. errors.clear() I believe it can just be installation id - depending on what installation id is unique-id-requirements The installation ID is generated by the combined energy API. Safer to prefix it with a known value to ensure it's uniqueness. I'm not 100 but I don't think descriptions should go in const, I think they should stay in sensor.py Looking at the codebase again, it does happen a few times, it's just not super common, so this is probably okay This pattern was taken from the Solar Edge API component. [Supported overview sensors]( L29) make these local imports from . from .exceptions combined energy is not a local package. It is the external async client library for combined energy. Ah, my bad, I took too quick of a glance at it. I'm a bit confused, why are you not just using a coordinator object? Feels like you're over complicating this. I could be missing something This is due to the underlying API, which is actually multiple data services. Since they all utilise the same basic pattern I provide a generic base class that each service inherits from providing the concrete implementation. should be in domain, name, alphabetical order CoordinatorEntity[YourCoordinatorName] is ideal, but I'm not sure how that works with your services system you built Also this is a binary sensor, you can't have this in here your initial PR. PRs are limited to one platform, aka only Sensors or only Binary Sensors Instead of generating device info, you should be able to just create a CombinedEnergyEntity object, do it in the init there and then make all of your other entities based off of that one instead of doing this, you can add a mixin to your sensor entity descriptions of a value fn that does what ever operations you need it to. There are plenty of examples in the code I've never seen someone build a factory for this task and I'm not sure how the maintainers will feel about it. A factory makes sense when devices need to be enumerated from the combined energy API. They are not known before this process is completed. You don't have an unknown Is this supposed to be unknown? Remove this file - no longer in use needs return - None needs return - None You are not supposed to access hass.data within test writing-tests-for-integrations - None writing-tests-for-integrations I'm not going to continue to comment it on each one, but you need a return type on all of your functions
More succinct (and a tiny bit faster): This implies the duration always has two digits, which sounds like an assumption that could break at any point. Additionally, this will happily match e.g. " ," because of two bugs: d matches any decimal digit, not just the ASCII 0-9, by default. You can add the re.ASCII flag, or explicitly specify [0-9] . (The characters above are Devanagari and Kannada decimal digits.) You don't need commas in a character class. I'd go with and then maybe upper-case the duration string in parse duration . As an aside, maybe this transformation (and the function) should be in aioweenect ? It sounds like it's related to the remote data format. Thanks for the feedback. Currently aioweenect returns data from the API "as-is". But does make sense for me to turn the response to pythonic data structures. Is the .get() necessary, since you're .setdefault ing anyway? By the looks of it, user input could be None at this point (or if it couldn't, why bother checking on line 39)? If so, this could raise a KeyError. self.coordinator.data[self.id] could maybe be lifted into a local in this function. hass.states.get("device tracker.test") could be a local here? Docstring seems to disagree with the name of the test.
If they uninstall early access we should make the warning go away (which I think its the desired outcome). The issue is not persistent, so it would simply just not be created again.
It might make this a bit more manageable to make SensorEntityDescriptions for user sensors in a future PR agreed, I want to split this out so the sensor logic is easier to understand but definitely belongs in a new PR
Not sure, but: should it be STATE ON ? right again. fixed. STATE ON and STATE OFF should be imported from from homeassistant.const I think you can add STATE AUTO to the main homeassistant.components.water heater component, it won't be an issue on the core repo, seeing the usage of the consts. But could be a frontend issue, so we should wheck that first. Only places I see usage of water heater constants (byGitHub): - mostly econet : L28-L36 - atag : L16 - hive : L41 Quentame Not sure if this the right time for that. See this 81913 and the corresponding discussion and all of it's replies [here]( discussioncomment-4101948) Let me know what you think. Yes sure ! That was an idea, but changing a base entity should be in a separate PR anyway, even more if there are architectural discussions about it Why a list for one value ? For 2 reasons: 1. To have the same code for boost or away modes 2. To ease the add of new boost modes of a new device if needed This entity is able to handle a lot of different devices. I only find 3 different setup for a least 12 differnts devices. I'm pretty sure they're will be devices with other boost mode aliases. Let me know if you want me to revert it and use a simple string for now I understand your vision of a generic entity and preventing future evolution or fixes, but I'm afraid we are not doing this here. A PR should serve one purpose of a current issue or feature. Fixed. Can you explain me why ? I don't get this condition. Why not using operation mode ? or else ? at this point, we're setting an operation mode which is NOT boost (see previous if with a return) This if check if the device is currently in BOOST mode And all code inside this if disable boost in all possible way reardgind device. I'm adding a simpler comment in the code to explain that. Should we also do something like from 81536 ? Done there and in all other places. For max and min temp, I had to add a cast because value as float could return None and the water heater required a float I would prefer to do this in the init instead of at runtime. Done, the code now creates a specific self.overkiz to operation mode on init Could you use the constants from pyoverkiz for this? Otherwise we need to add these constants. I did add them [a week ago]( and was waiting a new release to update it. It's done now ;) Please break long comments around 88 characters per line.
Why do we cast it to an int here, but on line 52 we cast it to a float? And here we set the value, so we don't need to cast for type checking. If you want to change the value, you should make it: Here is the set of the temperature to the device.. The precision attr from the device says it supports only WHOLE temperature. The previous code did that, I guess in order to send only valid value for this device. Regarding the get of the temperature, casting it as float to respect what water entity is excptecting [in the doc]( a float We should have this validated by someone, I am not sure what the old component did. However it does not make sense to use cast here, since self.executor.async execute command does not care about the type for type checking. You only should use int() or float() here if this is required by the command on the Overkiz side, but we need an user to test this. In the past sometimes it was a bit confusing where Overkiz wanted a float (even with precision whole). But please note that cast does not type cast the variable like float() does. Fixed. I have to add a cast when getting the temperature because of mypy : Argument 1 to "int" has incompatible type "Optional[Any]"; expected "Union[str, bytes, array[Any], mmap, CData, PickleBuffer, SupportsInt, SupportsIndex, SupportsTrunc]" [arg-type] I am not sure if I understand this. Why can we not use the operation mode ? Why do we need to check if the device is off? If the device is currenty off and we want to turn it in something different than off (see first if with a return), then we should first put the device in RUN mode. Code coming [from here]( L82) in other words, device could be already running, but in another mode. this if ensure we don't send a non useful command to make it run. Now, you know better our model, can you try again please value as float ? self.device.states[OverkizState.CORE DHW TEMPERATURE].value as float done there and in others places too Why this cast? Because of mypy and the need to send an int See discussion r1013944622 Using dict.get can return None . This cast isn't correct. When there is only one state, I prefer to be more explicit: Done there and in others places too. Great it will ease the code. Not sure, but: should it be STATE ON ? You're right, it should be ON, I messed up while rewriting it. STATE ON and STATE OFF should be imported from from homeassistant.const Just to confirm: there is no way of getting those programmatically ? Quentame Yes, no way to get it programmatically for this device. In the only overkiz setup I found using this device, there is no indication of these values. These values was set like that in the ha-tahoma code.
Is this not the same as the code below? I think you might have missed changing temperature to humidity instead here Thank you. I've put the correct code in now. hi timmo001 I've corrected the incorrect upload. Would you be able to look it over? Side note for the future: Please refactor and don't include the device mac ID in the entity description key. Just use the suffix. The entity unique id property can be changed to compose the unique id with the device mac ID and the entity description key. We want entity descriptions to be declared as constants at the module level so they are easier to read.
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Although unique IDs are exempted from this, the ping integration connects to a device. In that case, ADR-0010 applies, that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision Therefore, we cannot add the proposed change. Instead, this integration should move to the UI first. See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: I thought this would be exempted from ADR-0010 as the scrape sensor had a [similar change]( that was exempted 2 weeks ago. Conceptually the two sensors seem similar, providing data from a remote server. The scrape sensor connects to a remote service, of which the protocol is defined by the user (by providing selectors), similar to MQTT, KNX and similars. Those are explicitly exempted from ADR-0010. Ping however, doesn't define its protocol and connect directly to an existing device; thus, ADR-0010 applies here.
Refactoring new features should not be put into the same PR. Please split it out.
Please generate these dynamically using dataclasses.replace based on what the device supports Thanks for taking a look at this Pull Request, it's my first one on the Home Assistant project so I'm hoping you can be patient and understanding with me. I am happy to do any work that is required to get this working and done properly, but I have no idea where to start when you say that you want me to use dataclasses.replace . I have my NUT output direct from the upsc commands or from the Diagnostics File that can be downloaded from the device page via the NUT Integration itself in Home Assistant. Not sure how what Python code I would need to run to generate the SENSOR TYPES for const.py as you requested. For my testing, I just made the changes to the const.py file manually and brought it in to my docker instance to test. After Restarting Home Assistant, Deleting the current UPS, re-adding it as a new NUT Integration, it was properly reading all the values and reporting them in Home Assistant as valid entities. I have 3 different model Eaton UPS's that I can generate data for and a handful of APC units as well. I'd make a new constant list for the dynamically generated once and check to see if the value exists by enumerating the number of potential outlets and then call replace on each of the matching ones to generate a new list of descriptions for the device. Okay, I'll have to take a look at dataclasses again as I haven't seriously touched those yet and play with some of my old Python code snippets I have currently parsing my upsc output for a Grafana dashboard. That's going to be at least a few days before I can report anything back. I'm thinking if were going to iterate through the list of values pulled from NUT, I will need to template some descriptions based on the measurement type (voltage, current, power, realpower, powerfactor, etc.). My thought process here is: 1) Define a list of measurement types (voltage, current, power, powerfactor, etc.) with their default values for that predefined measurement's SensorEntityDescription : (key, name, icon, native unit of measurement, entity category, entity registry enabled default, etc.) 2) Parse full list of key: values from NUT 3) Look through keys starting with outlet 4) Look at last part of key for a measurement type in a predefined list (voltage, current, power, powerfactor, etc.) 5) Generate new SensorEntityDescription with the default values for that predefined measurement (key, name, icon, native unit of measurement, entity category, entity registry enabled default, etc.) Could use that same code for keys that start with ups , input and output as well to get rid of some of the existing definitions as well to ensure they are all being handled the same.
It looks like there are unrelated changes in this file The sort order of the file changed. (See 81331.) Please keep the sort order the same as the branch this it targeting since has not merged We do need tests for the config flow, but you can likely copy them from another one of the ble integrations It's exactly the same config flow as tilt ble with TiltBluetoothDeviceData having been replaced with RuuvitagBluetoothDeviceData ... Usually we don't accept beta or rc libs for production merges Can you re-upload this without the rc1 ? Yep, sure can. Will happen tomorrow Updated to 0.1.1 (non-pre version). r1015716554 Doesn't look like the replaces are used The latter one is, but now that the name is short enough, I'll just const this. Well, the line is unnecessary, sure, since the default set in the dataclass is None , but it doesn't hurt. I'd rather keep it there so it's Explicit Is Better Than Implicit (via the Zen of Python), and symmetric with the other registry entries. bdraco The "wasn't visible" bug wasn't isn't caused by this though, but rather L116 which was copied from tilt-ble (since all of its measurements do have dimensions). That's fixed in a future revision, I just wanted to know whether None is correct for a dimensionless quantity. ![Screenshot 2022-11-08 at 16 29 55]( None seems to be correct alright. None is correct, but our standard is to not set it if its None Changed. This is using the wrong class. We should use the Home Assistant sensor integration device class enum, not a 3rd party name. L88 The description key item member should be the 3rd party instance, but the entity description attribute should be the Home Assistant instance.
This is violating ADR-0010 Reverted in 82184 As this PR is also breaking our CI at this moment. The errors looked unrelated to this. But maybe i missed something. Sorry should have realized it was in violation of ADR-0010. tests test config.py::test merge uses wake on lan for testing; the changed syntax caused our core config tests to fail.
What can it be besides a string? Yeah, it could only be a string. I was battling with the linter insisting it might be something else at the time, but it's gone away now. The title can just be name . It will already be shown on the integration card next to the TP-Link logo and integration name. Makes sense. Can you add a brands file for TP-Link to group the TP-Link integrations Done Could we move this to a 2nd step and list the actual available sites skip the step if the user has only 1 site? (probably most people) Done. I might need to revisit this to support multiple sites, but as you say, 99 of people (including me!) will only have one site. Don't catch a generic exception. Catch the ones you expect to come. Can you distinguish if it's an invalid authentication error? If so, we shouldn't raise ConfigEntryNotReady. For this PR you can return False . In the future you could add a re-auth step and raise ConfigEntryAuthFailed to trigger it. I went ahead and did this now. You shuold still not catch all exceptions. Instead you should catch whatever base errors Omada can raise OK, now catching just the Omada errors. I also changed ConnectionFailed to raise ConfigEntryNotReady, because we can assume the Omada hub will come back online later. move this outside of the for loop instead of a wrapper to create a closure to keep a reference to the switch, you can also consider using from functools import partial . Got it - much cleaner, thanks! C doesn't make this nearly as neat. first refresh is only for in async setup entry of init .py . No need to pass in the client, it's already available as self.coordinator.omada client Removed the key is actually not used. I would suggest you use the instance properties attr name , attr has entity name True . The static ones can be moved out of the init Done. There are a few ways to do the same thing, so advice on which is the "right" approach is appreciated :) Why pass the credentials as input to reauth confirm ? They are no longer valid, or else we wouldn't have gotten into reauth to begin with, so trying them again here will trigger an error again (and maybe count as a failed login attempt in case Omada keeps track). Good point. Not sure why I left that in there. You can use assert entry is not None to satisfy typing. If you really expect the entry to be gone (it's theoretically possible I guess), you should add an else: return self.async abort( ) Yeah, I think it's fine to assume async get entry will get something back, so this was just to shut up the null warning. I'm still learning python features one at a time. This should be LOGGER.error because you know where it was raised based on the error message. Done. Ah, I should have used that magic "Commit suggestion" button. Not used looks like it's missing a test for re-auth
This seems to allow only a single sensor. Is there a way to enable multiple sensors on a resource? That should not be too complicated but I was thinking better to do that in follow-up PR as for a reviewer that might be pretty complex to follow. I still think we should use a list. Can we implement as a list with a single item, and implement adding removing as a follow-up? I would love to have this included in 2022.12 Can we validate using the COMBINED SCHEMA instead? You can use a lambda instead here for next step You can use a lambda instead here for next step You can import the schema to validate the resource config. You can use schema to validate the resource config. You can use a validator to convert to convert to a list with a single item. You can use a validator to convert to convert to a list with a single item. For async config entry title , you will need to adjust to return options[CONF RESOURCE] . You could also use options["sensor"][0][CONF NAME] but I think using the URL is easier. For async config flow finished , you should probably pop the sensor config: If I pop the sensor then it would never match with the config entry so I would have to leave it for testing a full match. I don't understand your comment. If you pop sensors , then it should match on (resource method auth user pass headers ssl timeout) The matching is done on all items passed in match dict , even if there are extra items in the options. But ultimately maybe it should abort after "user" step not after "sensor" step. Maybe we should be even more explicit about what goes into the matching dict makes it match". SSL and timeout shouldn't be part of matching dict. I was reading the test in the function backwards so it's clear. Good suggestion also to test only against specific keys I think you still need to wait for the result: Unused constant I think we can simplify for now with a single SENSOR SETUP schema Is this needed?
Small nit, but might make this more readable to have the comment on the preceding line so black won't wrap the code. I'd pass these by kwarg names (and maybe make the constructor kwarg-only past hass , i.e. (self, hass, , url, ...) These could use type info? mypy gets annoyed if I specify types, because they're all technically Optional[Any] since they're extracted from the config I'd probably just go with and logging what i assume is status 200 would also maybe be unnecessary... Good idea. Was largely copy-pasting from the REST notify integration. Going to utilize requests truthiness. Type annotations wouldn't go amiss here! You could make this whole component .strict-typing compliant from the start. discussion r1010724642 Considering these are optional, .get() could return None . Casting a None with str() returns "None" , which is not what you'll want for auth ... ... IOW, here and . . . Good catch, resolved ... this here. What does this comment mean? What does this comment mean? Reminder to readers that the title is already populated, in case they think it's not getting added to the kwargs. What does this comment mean? Standard code comment, just an explanation to readers about what getting to this line of code implies So if the value is not a dict, it's assumed to be something you can call async render on? Sounds strange, and even more so that that'd be a parsing error. On second thought, this method doesn't make sense. I don't think I need to do async render at all (what does async render actually do in terms of a notify service in HA?) Resolved
writing-tests-for-integrations Make sure to not interact with any integration details in tests of integrations: Please don't modify hass.data in tests. Instead patch your library
copy paste error :) EK ! Flick Electric Kiwi Sensor Setup This is defined twice, here and in const I would recommend adding a unique id to this sensor, so it can be renamed etc in the UI. Could probably use account number for that. Can you point me to the documentation for this? Yes account number would be good but I can only retrieve that after setup, so not sure how easy that is. nevermind sorted it out This import looks a bit odd, can probably just be homeassistant.util NAME , DOMAIN DATA , VERSION , and ISSUE URL are being defined but not actually used anywhere. Thanks for the constructive feedback, yeah not merge ready yet and appreciate the eyes over it anyway. Was hoping to get some feedback on the Oauth process mostly then tidy up. But after finding their documentation and actual function for refreshing is different I need to go off and create my own refresh process that matches theirs. Just realised - should this be service instead? From [the blog post]( A hub provides a gateway to multiple other devices or services. service and device are integrations that provide a single device or service per config entry. You'll also need to add that to the flick electric integration :smile: think hop select.py would be a better name? Nah the way the HA platform framework works, the file name has to be select.py understood, thanks :) From my experience, it is easier to move the entire api code in a pypi package and referr to it in the manifest.yaml as requirement. This also removes non-home assistant specific code from the core codebase (beside the advantages, api specific code is not wanted in the code base) see I will need to investigate that as its a common pattern I took out of other components including a google one. It also requires from homeassistant.helpers import config entry oauth2 flow The api.py is only for oauth a session. I followed I should add I did write an entire API client externally that is referenced in manifest.yaml on a different note the issues with mypy is resolved now. Lurchi70 I don't think what I've done is wrong, I think you may be assuming I've got the API in the PR which I don't. Welcome feedback. thanks. The comment is on a super old commit (which does have the API code), that might be where the confusion is coming from. Correct. Sorry for the confusion. Hae seen that there was a lot of progres later. Please reduce this PR to a single platform, as per: 5-make-your-pull-request-as-small-as-possible And: I would recommend keeping the sensor platform and remove the select platform for now. The coordinator already has the API available, why store it separately again? The coordinator call can't throw an AuthException ? Why is it in this try except clause? This method seems unneeded, as it returns self.data, just use self.data in that case?
I suggest that you add type hints right away. Are they all str None ? Do you mean adding typing for attr variables? They have types defined in the UpdateEntity class. doh sorry!!! no worries
This should probably verify that the scheme is http or https too..? Sorry I'm not sure if I follow. This should verify that the scheme and netloc portions of the URL are valid in the format scheme : netloc path ; params ? query fragment . Are you saying it should check that it's only an http or https scheme? I haven't tested any other schemes myself, but I don't see the need to restrict it to only those, maybe I'm wrong though. Yeah, sounds like that would make sense. With the additional allowlisting from HA core and requests not having an adapter by default for other schemes, it shouldn't probably make much of a difference in the long run, but... probably wouldn't go amiss. With the additional allowlisting from HA core and requests not having an adapter by default for other schemes, That's true. I pushed an update, I just need to figure out the Git ownership stuff.
Does this mean that the device will actually report a new measurement every third second or just that some measurements can be reported at that interval? It's important that we don't allow the device to spam irrelevant measurements to the Home Assistant state machine. Most measurements are probably not interesting at a 3 second interval. Thank you for your reply! I completely agree with your point, that the device should not spam irrelevant measurements. Ideally, one could set the update frequency in the configuration of the edl21 integration as proposed in this thread However, I don't know, how one could achieve that. I would be very willing to help in developing that, with some hints, how that would be achievable. As long as the rework to config flow is not finished, you should consider to accept this PR as a polling intervall of 60s is way to long for energy monitoring. My question above hasn't been answered. The EDL21 devices push new messages every 2 to 5 seconds through their optical interface, depending on the model. Therefore polling is not the right way to access it anyway (afaik technically you can not poll the device), but this is a topic for a rework of the sensor integration. You should also not get duplicated messages when using a shorter polling intervall but a more detailed information about the energy consumption. So every 3 seconds we're potentially going to record a new state for power, voltage, phase angle etc, besides energy? That doesn't sound useful at all for the majority. Based on the current information I'm not going to approve this PR. I'll ask for a second opinion though. You're welcome to clarify the situation more regarding what messages are coming in and at what frequency. It looks like the data is being pushed over the serial port to the integration. What was the original reason for limiting accepting new data to every 60 seconds? It was added to limit excessive state reporting: issuecomment-559828892 From a user perspective I can not see the benefits of limiting this component to 60s, best would be to add a config option (which was declined in 66405) or do a rework to avoid polling and integrate config flow and let the user customize the time between two data record processings. In the Volksz hler project (which seems to be the reference for the 60s delay) you can change the polling rate to whatever you want. Any chance that an experienced home assistant developer would rework the component at least to the point that the user can choose how many data should be processed? It was added to limit excessive state reporting: [ 27962 (comment)]( issuecomment-559828892) From the original PR in 2316f7ace4f1c081211cf8a32c9b82329292e223 : [edl21] Add 1 minute throttle to the sensor With we don't want additional options, but since there is no way to change this one since its an internal throttle I think it would be reasonable to add an option to disable the throttle but we would need to convert it to a config flow first. Unfo
Constants should be all caps. Should this not return the list of all modes that can be selected rather than just either current mode off? So something like: Unfortunately no, we think that changing device mode shouldn't be allowed through HA. Also to keep consistency with previous integrations, the method async set hvac mode is used to make the device operate(eg. run heating), not to change the mode. I don't think None should be reported as a valid mode for user to select. Device specification allows the case when a newly installed device mode is not set. The (complete logic) feels overly complicated, shouldn't it be OFF when the device is off? Basically: 1. OFF if the device is off. Or when does it happen that the action is set, but the device itself is off? 2. If hvac action is not None , read from BLEBOX TO HVACACTION . I assume this does not report the heating correctly as the fallback is needed? 3. Fallback to heating or idle. This integration is serving two types of devices. The first one doesn't have hvac action implemented. It has two states(ON OFF), but the purpose is always heating(saunaBox). As the other(thermoBox) device has this property. In the next commit, I'll propose a more legible version of this method. When does this happen? The code below checks for a boolean on this property. This is unlikely to happen. Although blebox uniapi might return None . Setting up the integration like this seems not needed: L84 Nothing will be done with config . This integration uses config entries. Set up the MockConfigEntry instead with hass.config entries.async setup . We need to adjust all the callers of this function.
Can't we have the user mention "video" and "thumbnail" instead of "attachment" and "thumbnail" when adding a video under "attachments"? This way you can directly use the "attachments" key. If I am not mistaken the "attachments" key entered by the user would be like this: yaml attachments: - - video: thumbnail: engrbm87, thanks a lot for your review! Your suggestion makes a lot of sense to me. engrbm87 I implemented your suggestion in commit 9bc18c3e2d58eb618d594d0de244e763860200c3. Added a comment based on the last commit A better approach would be to raise an error if the attachments key values are not as per the documentation. If no errors are raised then simply use attachments attachments data . for lines 85 and 86 I believe a video key should only be provided with a thumbnail. The documentation should mentions this clearly so no need to check for a video only key in the attachments. Thanks, makes a lot of sense. Please see my latest commit for the implementation of your comment.
This is a breaking change and not a deprecation, right? Correct.
This is much better than the original design
Is it possible to map the commands to individual services? Like rather then having a single run command service that requires users go look in the NUT documentation to see what values are allowed for name , could we have nut.beeper disable , nut.beeper enable , nut.beeper on , etc. services? Then the user can easily see what services are available and how to use them without copying and pasting stuff from documentation. Also what about other inputs? This service needs to accept a target of a NUT type device for one. The user may have HA connected to multiple UPS's. If so it's impossible tell which one to send the command to right now. But besides that, do any of the commands accept other inputs? If so then I would strongly consider taking the approach I suggested above of mapping the commands to individual services rather then having one generic service. This will get very confusing if you start adding additional fields like input 1 , input 2 , etc. to handle the possibility that a command might have additional inputs. Ideally these should be device actions as well since the NUT integration creates a device for each connected UPS. Thanks for the quick response, mdegat01. Yes, your proposed approach of registering a service for each command is definitely a way that we can go. The main challenge is that the supported commands vary by UPS model, meaning that the list of all supported services is dynamic (although I assume that it is always a subset of those described [here]( What I had in mind was exposing later on a sensor with the list of all the supported commands by each unit, so that it was clear which were the valid values for the command name. Regarding your proposal, I see a few options, but please let me know if some of them don't make sense as I'm still familiarizing myself with HA: 1. Have a list of common commands and register those as all potential services. 1. We could also keep the generic run command service as a fallback option for those commands not on the list. 3. Dynamically register services based on the available commands for the units. 1. That limits our ability to create the services.yaml file and I don't know how we would handle having multiple devices with commands that are available to only one of them. 5. Keeping just the existing run command service. Some commands do accept a single parameter, according to [the documentation]( : :text 3Ccmdparam 3E 20is 20an 20additional 20and 20optional 20parameter 20for 20the 20command.), although it is unclear to me which of them are. If we go with the option of the generic service, then we can have a generic optional parameter cmdparam or similar. I was planning on tackling this a future enhancement. What do you think? Which of the three options should we go with? I will fix the missing target, good catch. I need to test it using a system with multiple UPS devices to ensure that it looks good. I will also take a look at the device actions. It was not very clear to me from the docs ho
Is a hard migration necessary? I think what you've done above will appropriately update the options: L251-L253 Originally I had mimiced the other option logic (moving from data) but was getting errors before upgrading. I changed it on the second iteration and never retested if I could get away without a migration step. I will retest. Removed. No longer required after the 2nd update I made. Am I correct in thinking this logic is this? 1. If a duration has been configured, use it. 2. If not, and if (a) we want to use app run times and (b) we've saved the app run time from that coordinator, use it. I would actually expect the reverse: if the user checks the "use app run times" box, that should be the default (falling back to the duration option). That seems like a cleaner way to understand how those two options interact. Thoughts? Might be worth taking the breaking change and only using the times from the app so there are not two sources of truth You've got it backwards, but that may be the choice of naming. 1. Use a duration parameter if provided (from a service call, assuming they want to overwrite the duration). 2. Use app run time if enabled and we have one. 3. Use CONF ZONE RUN TIME, which is the default for all zones. My thinking is if you want to call a zone for a specific time from Home Assistant, you would still pass the duration as a service parameter. Otherwise just flipping the switch on a dashboard calls the zone with the app's time. Just like setting a default on level for a switch, you'd want to be able to overrule it from a service call. If all else fails, use the default time for all zones (10min). bachya bdraco Commented code to clarify and revised string literal name for default global zone (did not change value so shouldn't affect any existing configs). I think your comments with the doc update in are good. Although correct, the way black styles this conditional is ugly. Can we save the provision settings in a variable, then access the zone duration from that variable (to avoid a bunch of indention)? Updated.
Please avoid calling utcnow() twice. Well that seems like a I wasn't paying attention: 0 - time or -1 time should suffice. Is the -1 needed? I would expect it generates a TypeError since -1 is an int and parse datetime returns datetime Youa re 100 correct... 2022-10-29 14:29:52.285 ERROR (MainThread) [homeassistant.components.flume] Error fetching flume data: Error communicating with flume API: unsupported operand type(s) for : 'int' and 'datetime.datetime' Well it seems to work ok with just time We should keep platform specific objects in their respective files. Otherwise I think you can rename this to be more generic This gets used by both binary and normal sensor so I wasn't sure where to put it. Suggestions? I'd rename it to FlumeNotificationRequiredKeysMixin so its not sensor specific Looks like this was marked as resolved but no code change. Did you forget to push? I'm on my phone at the playground so yea prob an accident click. I'll get to it by Monday likely tomorrow MONDAY IT IS!!!
Couldn't these three dicts ( info , device , state ) be read from the fixture JSON files instead of repeating them here? Sure, the data exposed by diagnostics is a subset of the fixtures, but perhaps this test could compare the extant keys of each dict only... Good thinking. I guess that would do for testing? Not sure as I am not an expert on testing. But other integrations are doing the same as here. (see my previous copy mistake) So I guess this is alright? If not I'll take another look and change it. Ok I took a look and saw the error. Added a fixture for diagnostics. Thanks for the review! akx
Shouldnt this share the parent lock? Strictly speaking, this coordinator doesn't actually need a lock at all as it doesn't modify any visible characteristics, i.e. it doesn't visibly change the state of a light except when applying a theme and that hands off the application to the aiolifx themes package.
Won't utc from timestamp blow up if this ends up being None ? Yep. Resolved in the restuctured method. See comment below. Same. Feels like we have a bunch of replicated logic throughout here what would you think about some easy helper methods (attached to this class) that centralize it? I would look at anything you're replicating between sensor types (e.g., the round((clicks 1000) clicks per m3, 1) calculation [and the data points fed into it]). Restructured the method to be less redundant. Take a look. Looks reasonable to me! Is this only applicable if there's a sensor attached to the controller? If so (and we can assume that's not the norm), I would make it disabled by default (similar to the other flow sensors): Same.
vol.Optional thanks I tried looking for something like that CONF ACCOUNT is that the home assistant suggested naming Why re specify on reauth? probably because I wasnt sure on re-auth the underlying library it uses doesnt reset the account if not specified Since account id is used for the unique id:s of entities, this is not allowed to be changed on a re-auth. So please remove this from reauth. thanks will do, looking at other integrations Im not sure why the original code is even using user input in this step, shouldnt it just be reading the config settings? Im getting confused over what to do here. My limited understanding of the reauth step is that HA uses it when the component fails its initial authorization for some reason. If this is the case if I remove the account value from the call the the OVOEnergy client "authenticate" call then the OVOEnergy client library will choose the wrong account OR are you saying this step should not be getting the value from the user input but instead read it from the config, if so I was following the existing code which is also therefore not correct and Ill need to change. Apologies but Im new to HA so have a lot to learn about standards It should get it from config. It already grabs username from there. then I have no idea how to get this code to be what it needs to be, the current code does not get username from config it does gets its from user input as well (line 67ish): Do it the same way. The initial call to re-auth will contain the original config entry data as user input. ll do that then, but still cant see how getting it from user input a few lines earlier and setting self.account in the same method is any different than getting it from user input when calling the client.authenticate what am I missing here? The dialog the user get shown should not include account, thus the second time into that function the user data will not contain account. what happens if the reason the auth failed was because they entered an account id that is not valid? The underlying authenticate method has this code: Which as far as I can see means if I enter an account id that is not returned in the data from the provider then the authenticate method will fail and therefore the user might need to change the account id? That should have been handled by the standard flow. It should have validated the account. If its a new account, the user need to re-setup. Ok now I've worked out how to trigger async step reauth and can see how it works I believe these latest changes are what was being requested. Please can you confirm this is now as expected None is the default value if the key is missing in the dict, when using dict.get . The config flow tests should be updated with a test that uses the new parameter. Does the user know what the account id is? Is it not possible to let the user choose between existing accounts?
You could speed this up by turning it into a set (since we're merely looking for presence). Also, let's alphabetize the entries. You actually don't need a custom validator see below. Thanks. I knew there was a voluptuous function for it but for the life of me I couldn't remember how. I need to go back to change the one in isy994 too. This should be sufficient (instead of a custom validator): The value is required (per the schema). These three lines can be simplified: Reminder that this new call doesn't return an int it returns the entire payload. All that said, you don't need to do error code checking here: call with controller will catch an errors and do the correct thing. Let's genericize this (since "pushing from Home Assistant" might be confusing). Copypasta. Sorry. Let's alphabetize these. Just realized: let's use Home Assistant constants where we can. L561 L559 L564 ...and create one for clicks : I was going to use these, but they don't match what Rainmachine is expecting (e.g. litre vs L ). So either we use the RainMachine versions or we add another step to convert them before calling from the controller. What's your preference? Ah, good point. I don't think a conversion step provides real value, so okay to ignore and go with what you have. Make sure to replicate the actual values of the constants discussed above. Even though it's functionally the same, a quick return here feels odd not really guarding anything. I would just use a straight if else. Change made. Blame bdraco for beating quick returns into me previously.
Moved to the select entity, as we now have an entity for the hub as well. Not sure how to avoid a list comprehension here since we append to the list. The list will in any case be short - typically at most one zone per room of a house. There's no need for f-string, why not just this: Done same Done Do we really need a separate device for each zone, shouldn't these be included in the hub device? This is how I was adviced to do it for the climate entity. Each zone can consist of one or more heaters or floor thermostats, so the actual physical devices are not included. This identifier matches the device info in the climate entity. (I've since discovered that some floor thermostats requires a separate zone. A possibility is to use the actual device in device info when a zone only consists of one device, but this would require a similar change in the climate entity. We would also need to decide what device (or none) to use for zones that consists of multiple devices.) Ah, I didn't realize this device id is already used in the climate entity, in that case it's fine shouldn't we break out of the for loop? Done
Ah, didn't realize I could leave these out. Thanks! async discovered service info returns BluetoothServiceInfoBleak objects. You can grab these off of them instead L49 Handy, thanks. I've switched to that and updated the relevant test init to build BluetoothServiceInfoBleak objects, which cleans up this code. You have bluetooth set in the manifest.json so you should implement async step bluetooth Example: L31 I had vaguely been hoping to defer digging into that for a future PR, but I've added it now and tested it (both via automatic tests and manually). It would be a bit cleaner to use the name field in the SensorEntityDescription Sure, might as well. It seems I still have to set entity names in the PassiveBluetoothDataUpdate , but at least there's only one dict with all of these keys. Probably rename this to raise for advertisement errors This entity should have been disabled by default as it's not useful for most people. aschmitz would you be able to PR that change?
We're missing an init module in the test package. We don't allow scan interval as option. Every integration that supports config entries allows the user to turn off automatic polling and then the user can automate the update interval as needed with the entity service homeassistant.update entity . This should not be part of the config flow module. The config flow should not leave any api instances behind in hass.data. We should set up the client in async setup entry in the init module. Create a new client to validate the config in the config flow and then again a new client when setting up the integration. Just make a single update with the client to validate the config. Can we distinguish between connection error and authentication error? So far i don't think so. Question for meichthys . Original python module is returning just one exception correct? Hadatko sorry i just saw this. Yes, currently nextcloud monitor only returns a single exeption: NextcloudMonitorError We should keep the config schema for a deprecation period while we import the legacy YAML into a config flow with an import flow. See other merged PRs that added config flow for how to use an import step in the config flow and how to create a repairs issue to notify the user. Please move these constants to the respective platforms. I recommend using our data update coordinator to help fetch the data and keep a data cache. coordinated-single-api-poll-for-data-for-all-entities
This is contrary to your implementation. The implementation only supports open close (it even says so in the comment), but here you are checking if the entity only has set position which is absolute positioning of the cover. Whoops, should be fixed in Stale comment? jredd CI Check flake8 (pull request) is [failing]( because these assignments are never used. Are you sure the functionality is actually being tested correctly? I wasn't able to test my code so the tests are pretty important here, to make sure my changes work as intended. Are these the right chars?
Guys, I'm not sure this part. Maybe there is a smarter way to reconcile ReceivePayloadType with str ? ReceivePayloadType is the correct type, CONF ENCODING will be used to decode the message. if CONF ENCODING is None the raw bytes will be passed to the function. In any case the result of the template should be a string to be processed, If the result is an empty string, the result payload should be ignored. So you can leave away the else case. It seems it is not covered by tests either. Decoding happens before the function is called. It uses CONF ENCODING to decode the message. If encoding is set to None the msg will be a bytes object. Only a str object should be processed. There is no need to add an additional decode here. Only do a write state request if installed version has a value. When using a template it is possible to use a shared topic. If no value is supplied we do not want to write the state. Same here, decode is not needed. Only write the state if latest version has a value (after rendering with the template). If we would have a command template as well we could build the payload using the backup and version option. You can pass additional parameters via a dict to the command template. That would be more usefull than a predefined payload. backup and version require the support of SPECIFIC VERSION and BACKUP [features]( L10-L17) This solution doesn't support them. I wanted to simplify this PR as much as possible and add more features in the next steps. emontnemery yes, Shelly should work with this PR for users which are using it via MQTT. emontnemery My goal was to be able to create update entities for Shelly devices using MQTT. Initially, I also thought that one topic and template would be the best solution. However, It turned out that for Shelly Gen2 devices it will not work because these devices send installed version and latest version in separate topics ( progress is also sent in a separate topic). In my opinion, separate topics and templates are definitely a more flexible solution. If we decide on one topic and a static payload scheme, we will close access to this platform to devices services that are not DIY and whose firmware is not easy to change. Perhaps it is an idea to have a optional state topic that can also accept a json dict (like the siren platform has), so the state can be overrided and has the capability of providing installed and latest version. But for this PR, may be it is a good idea to have seperate topic's as it appears this is also a pattern in real live. I thought of one more possibility. state topic can be used for title , entity picture , release url , release summary properties, and for installed version and latest version will be separate topics. I think optional the value template could resolve all of them if they are supplied, May be for some other cases they are all supplies in one tipic. The state topic accepted payload could be JSON only. The separate topics are should then be optional probably. jbouw
Is there any chance there is public personal information tied to this UUID? I wouldn't expect so atleast in the ways I've used jellyfin. It's a local account tied to server. There maybe be ways to use like LDAP or other auth mechanism that could log it and perhaps the streaming devices could store it on login. It's geared for local private usage primarily. Remote access even takes a bit to setup. from the website: "Jellyfin has no tracking, phone-home, or central servers collecting your data. We believe in keeping our software open and transparent. We re also not in the media business, so the only media you see is your own."
If you use the async method then there is no need for the executor job.
This is just weird. Just check the device class directly here. Needs a none check with empty return here. done! Need a none check with empty return here. done! Data can't be none here. Also it looks much of the data is common between the two cases? Looks to only differ by descriptive capability. Would make more sense to just condition that on the class. Great point! I was moving too fast. I consolidated some of the logic and updated the tests. Should be much better now! You end up re calculating the int:ing here. will adjust! State is always a string type. So it will never contain a numeric value. So you are sort testing the wrong thing here. Should be "0", "75", .. ah I had missed that - makes sense. fixing!
This sensor provides the expiry date, you can turn that into anything you like (e.g., the number of seconds until the expiry date). Additionally, we don't allow these things to be put into attributes.
Please solve the pylint flake8 warnings. Thanks for the heads-up! Removed CALL TYPE REGISTER HOLDING , as not implicitly used. The holding register only holds 1 bit ??? I would have expected it to contain 16bits just like the coil and discrete input. Updated to behave the same way as Coil Discrete
It appears that you will get the image, save to disc, then open it again, edit it to add annotation, and save back to disc. Is it possible to edit the image directly in memory before saving? There is some issue consuming the raw byte stream without knowing the image size in advance, I was not able to pull that but might be missing something obvious, You can consume it to a BytesIO object rather than write to disc. I needed to solve the same issue here: L132 It just uses a ram buffer instead of file system storage. Typo here and probably should remove the word 'template' as this message will print the rendered template, not the template itself. done Looks good. Can this deal with all image types e.g. SVG? I have a series of samples in the generic camera tests directory, maybe you could verify they work in some pytests? I am not sure, but to be honest I also have not seen any existing test cases for svg.. I do think PIL treats images for raw and compressed differently. If you do PilImage.open() on an SVG file or byte stream, I think you will get an error. So you either need to explicitly block this with some sort of not supported exception error message or find a way to support it.
We already have this sensor, as the same data is exposed as printer.telemetry.temp-bed The same is true for the nozzle temperature. But since the target temperatures are not exposed through telemetry, I wanted to harmonize the sensor data source. Removing printer.telemetry.temp- would be a breaking change. I am not sure how to resolve this. It's same data, and removing the other one is breaking, so let's not add it here. I guess removing it could be fine until more Prusa Printers use the Prusalink API and the API is more stable. Although it would lead to the actual nozzle temperature being available through printer.telemetry.temp-nozzle and the target temperature through printer.temperature.nozzle.target . And the same for the bed. Should instead the target temperatures be made available with the printer.telemetry.temp-target- prefix? The duplicate values are removed and the target temperatures are moved to printer.telemetry. Let s disable target temperatures by default. It s not so useful. Target temperatures are now disabled by default. Is this interesting? I think we can disable it too by default. Z-height is now disabled by default. There is no need to add this, as there is only a single integration Thanks for the remark. I was trying it locally and while resolving the wrong commit email it must have slipped by. Prusa as a brand is removed. Please only capitalize the first word in the name. entity-naming I fixed the naming scheme for the new entities and the existing ones with a name containing more than one word.
Please add type hint Done. I thing it's logical to have turn on if we have turn off at least for consistency purposes. Please add reason for type ignore. Done Base on this change, I think you can remove lines L217-L129: L127-L129 Done Please try to add type hints to all tests: Done Can you please also update the english translation file? Done There must be a way to cover this line in tests... even if I'm not sure how. Sorry, I have no idea how to test this line. There is already test for trigger existence.
We should only store the coordinator in hass data once the first refresh succeeds. Let's move this into a new module: models.py . However, I'm a bit confused why this class even exists? Isn't this functionality that the coordinator should handle do? It is the task of the coordinator to fetch, pre-process and hold data. No need to log this info level Let's move the coordinator into its own module, coordinator.py Should this be using asyncio.gather() ? Don't catch broad exceptions This error will show up in places, maybe add a message so it is clear what is going on? Do we really need a method for this? Please use f-strings I'm not sure if we need all these methods variables? Those are sets, isn't easier to intersect those? Those are sets, isn't easier to intersect those? This is why I think the proxy method for getting the current race count isn't needed :) Why replace the timezone of utcnow by UTC? This replaces the timezone, shouldn't it be converted instead? I don't think these methods are actually needed? Don't use a broad exception (silencing the linter is not a solution ) The data it holds is missing, right now, it is None , but it should hold the actual data (as mentioned above too). This basically contains no logic, let's move it directly into the flow below instead (remove the need for this validate input method) and make the CannotConnect error unneeded. This is static, no need to return a dict here. Instead, just set the title directly on the create entry. If you flip this around: You can remove the duplicate async show form call This can be removed if the suggestion above is processed.
For attributes that don't change, you should set this on the class. E.g. put it below the attribution line (and then you won't need the self either). Ok that is now done
All these Sensor share the same code... just create an OralBSensor class and inherit from it Great idea! I will fix this. That is a great improvement but check the pattern in other integrations that use SensorEntityDescription Let's not make this info. I suggest for the first PR to remove manual set up. In a future PR you should adopt what BTHome has done: L135-L158 these errors are not used. This needs to be done inside an update coordinator or else each entity will make a connection and trigger an update. See this example: L60-L86 Once you have an update coordinator, let OralBSensor inherit from both the UpdateCoordinatorEntity and SensorEntity like here: L67-L72 Then make a list of entity descriptions like this: L35 And finally, the native value property can live on OralBSensor and be: [There is a sleep in async code.]( L116) This will block all of Home Assistant for 3s when it executes. This should be removed. Removed the sleep. Use entity naming so it adopts device name. Add spaces to the unique ID and have it be based on the entity description key. Once you have adopted entity descriptions, make it: Don't forget to also add a device info so it's all nicely grouped in the Home Assistant UI. L77-L83 You can use the mac address as identifier. Uncomment this line and store teh update coordinator there. This code currently errors, but when you store the update coordinator as per my above comment, it is correct. I don't see the test file for the config flow. Please add it back. How and where do I create the test file? Do not hold on to the ble device . Fetch a new BLEDevice from the bluetooth.async ble device from address API each time a connection is made. Alternatively, register a callback with bluetooth.async register callback and replace a cached BLEDevice each time a callback is received. The details of a BLEDevice object may change due to a change in the active adapter or environment. [See the Bluetooth docs for best practices]( Is this going to work ? You initialize ble device with fetching it with connectable True . The async update ble callback device might not be connectable? Is there a reason why you need to keep a handle to the device and can't just get it each time you want to connect? you need to catch Bluetooth specific exceptions and raise UpdateFailed exceptions instead. This is not awaited. Also, what is the use of doing this in response to config entry updates? We should never keep a connection open. There are only limited connections available, especially via the Bluetooth proxies. We shouldn't dedicate one to just 1 device. Home Assistant requires a minimum of 5 seconds between polling. Why do you need to store the entry.title? You can already access the title as coordinator.config entry.title Or even better, since you need to access the oralbdata by entry ID, you probably already have the config entry ? No need to add domain to unique ID, that's automatically included. You can drop unique ID and set it to address key in the 
This data isn't needed locally I noticed self. dev id in self.coordinator.data.devices was dropped from this check. Any specific reason? If the device drop from upstream, while still in HA, HA should mark the device unavailable right? Without that check, wouldn't we raise key errors? This test did not make sense to me before. But you're correct, when a user uninstalls a device in the Plugwise App, the corresponding entry in the various xml-files will be removed, or put in a "disabled" state. And the backend code will no longer find it. Only an integration reload or worst-case an integration delete and re-add will fix this. I'll put this back.
Let's make another dictionary that is the reverse of POWER SUPPLY TYPE instead pushed some changes - aligned with the button implementation Unused ? not required Since it's static you should be able to define options in the description instead That was recently added see you may need to rebase arent they only static because we have a single select dropdown ? ie - would you still have them in the description dataclass if there were two select options implemented ? Yes. Examples: L152 L52 L19 no worries - just commiting those changes now Should this be a cast instead of str ? I think its already a str casting to str was only because it is also possible for "unassigned" if the user has not set the value in the app - casting an empty str resulted in the dropdown providing no selection. Powerview app treats 'unassigned' as battery wand but i thought it best to not assign a type if they are not set so the 4 values i have seen in the batterykind are '1','2','3','unassigned' I havent mapped unassigned as i coded to treat anything not 1 2 3 as not set Not sure how it would behave in the UI but we usually use None to represent no value pushed a change to default to None and removed the cast Will adjust since I'm likely not going to have time to come back for reviews for a bit and I don't want to hold you up
supports stop is introduced in Once that's shipped, we'll need to bump the version here Hey balloob, do you know what the value of supports stop here would be, in cases when this new version of HA is running alongside an old version of ESPHome? I think that as-written, there's a risk that the stop feature will be disabled for all ESPHome covers (even those that already support it), just because those old versions would not be sending supports stop True . For correct backwards compatibility, we would need to treat a missing supports stop value as True jesserockz what is the default for supports stop in the library in case the device doesn't share it? It will be false if an older device does not send the value L164 So I guess I should flip that to supports stop: bool True before shipping this, right? Done: I have bumped the api version so that we dont care to check that flag if an older esphome device is used with a cover. - [esphome esphome 7283c85 ( 3897)]( - [ 3a04927 ( 80104)]( Ah, interesting approach. Is there any risk for other non-ESPHome consumers of the API? Thanks for putting this together. As you can tell, I'm still learning my way around :)
This doesn't look like a related change? Was it intentional to include this in this PR? I see you added it to the docs so it looks like its to support the new shade type
Should we make these title case to be consistant with the rest of the entities? img width "674" alt "Screen Shot 2022-10-23 at 11 20 42 AM" src "" img width "528" alt "Screen Shot 2022-10-23 at 11 21 05 AM" src "" I'm a bit on the fence about that though since its probably easier to automate if we don't Commented code. We could collect the entities in a list from both cases and add them in a single call to async add entities . Yes, thats much better as it avoids creating multiple tasks Since I already had this open I took care of these
This looks like generate unique id ... This yields the same string but using a different underlying data type. The function operates on ListPortInfo but this code utilizes a UsbServiceInfo instance. The field names are the same except the UID GID, which is stored as a number in the former and a string in the latter. IMO, designing the a function to deal with both data types would result in more code to do the same task. This ended up happening in 9eba9f6. This user input is repeated identically many times in this test file; should it become a constant (like DISCOVERY INFO already is) or a fixture..? Done in 329c19e. Thanks, done in a061588. Please remove translations folder Done in d4e82a9. I did most of this in 9eba9f6, but there are a couple of changes. The VID and PID should be separated by a colon to maintain the pattern used in other extensions, and I needed to handle the None value on usb.UsbServiceInfo to avoid an exception. In the end, I kept the f-string over the join. Reusing the function reduces the complexity and improves the maintainability and readability. I'm still not convinced this is actually more maintainable, but I took a stab at it in 9eba9f6. This code should go into the third party library I moved the synchronization logic into the library. I'm not sure I agree that the rest of this code should go there. It's opening the device, getting the list of programmed meters, and getting the type of each of those meters. These are all discrete operations and I don't see much value in lumping them together in the third-party library and breaking the one-to-one relationship between library queries and device messages. Exceptions like these should be handled in the third-party library and the code that raises them. Can you clarify what you're looking to see here? The underlying library needs to express communication errors somehow. Would you like to see errors like this surface under a library-specific exception class? The library should raise an specific error for these exceptions. These exceptions are implementation details and they should be transparent for the caller. In our [developers docs]( we have written the following: One of the foundational rules of Home Assistant is that we do not include any protocol specific code. Instead, this code should be put into a standalone Python library and published to PyPI. Okay, the library should only emit RAVEn-specific exceptions now. Please rename it to coordinator.py Done in 99ac2cf. For new integrations, we require the following: - Support for [the new entity naming]( has entity name-true-mandatory-for-new-integrations) - Services must be [translatable]( - Entities and their attributes should be [translatable]( Please adopt your code to add support for it. Added translations in d4e82a9. Still working on the typing change here to CoordinatorEntity[RAVEnDataCoordinator] . Alright, the typing change is done now too. Please use a SelectSelector instead Your integration code is not using iso4
Can this be a set, in alphabetical order? You don't need list type for remove I think it is needed... In adguardhome 0.5.1 You are correct. I added this comment because it didn't match SERVICE REMOVE URL SCHEMA I don't think you need SERVICE REMOVE URL SCHEMA and you can always use SERVICE ADD URL SCHEMA epenet I think we do need SERVICE REMOVE URL SCHEMA because vol.Required(CONF NAME): cv.string, So CONF NAME is required with ADD URL and isn't needed with REMOVE URL gieljnssns I have reviewed this again, and I think the reason for the confusion is that previous implementation was wrong. CONF NAME was required by the schema, but ignored by the service. This is good now. Could you use a select selector here instead, listing the options? I think this should match the LIST TYPES you are right... Since 2023.8 the name and description of services have moved to strings.json, please rebase and move them and move the strings You're using these strings often, you could make constants out of this
This is a change to our main entity models functionality, which requires an architectural discussion and approval before implementation. I could not find an architectural discussion in our architecture repository about this. Could you point me to it? .. Frenck Apologies, created a discussion here:
Reviewers, please take a look here especially and do suggest better patterns! oischinger Is this how you imagined it to work? If the command is not supported, it should not be suppressed, the error should be propagated This looks static, please set the attr unique id in init instead. You really should reraise errors here. Preferable HomeAssistantError class, so the service fails. Also static, please set in attr device info in init. Instead of running in executor one per instance, would be better to get all entities in one call to executor.
Use the STORAGE DIR constants as you did with the generic PR as well. yeah, i implemented the previous changes, but forgot about these ones This cache is not the same as the cache that uses the config entry id to deduplicate? Yes it is the same Ok
If you set attr should poll to True and move this to an async update you can drop async added to hass but either way its a bit messy because you'll have to implement exception handling and maybe a separate available property This seemed like the less convoluted option and is way less complicated than the last time I attempted this. Also, I didn't want this to poll as often as the LIFXDataUpdateCoordinator updates but I also didn't want to create a whole new coordinator for one sensor. Yeah it's definitely a sea of not so great options. I would probably still do another coordinator since it avoids a lot of the boiler plate That will have to wait until later in the week, then.
It might be a bit nicer to store a dataclass in hass.data[DOMAIN][entry.entry id] if its not too much work to refactor Example in lookin models.py that's a great example thanks. converted over to such a pattern Should this be decorated with abstractmethod ? We don't need to raise here when the method is marked as abstract. The return value typing doesn't match the type of the generic coordinator on line 59. 80222
Isn't the point of diagnostics to communicate raw values? Yes, we want the raw data so we can use it to debug. Generally we don't want diagnostics to update the device again as its changing the state of the data which makes it difficult to capture a problem if the user is trying to get diagnostics because something is broken at a specific time.
Caseta does not send the name of the buttons for Picos, just the button number. This looks up the button name from the device triggers. The bigger question though, is do we want to expose buttons on caseta systems? Will a caseta user ever care to push a pico button from within HA? RA3 HWQSX users need this to trigger scenes, but I'm not sure the same need exists with caseta. We could simply not create entities for caseta buttons. I'm not sure what the right path is. bdraco, I'm curious about your opinion on whether or not to create button entities for caseta pico buttons, or to exclude them. I think its fine to create them but they probably should be disabled by default with entity registry enabled default False great idea. I've implemented this Reverse the conditional here and continue so you can outdent below ok, done It would be a bit cleaner to write it as this or if the value for parent device can never be "" or false you can do yes, overzealous with the conditions. Left over from testing different ways of handling. I've simplified as you recommended Are you overwriting this to avoid the zone id in the parent class from being set? Yes. I've changed this to now just return None for zone in the LutronCasetaDevice class. We shouldn't mutate the data coming from the library as it makes it more difficult to maintain when the library changes ok, I've moved this to the entity class, so I don't have to mutate the library data Override this property in the button entity class instead done If the property doesn't exist we usually don't set the key instead ok, I've adjusted the property to exclude zone id if it isn't present instead of returning None We should set the name in the entity class instead I've moved the naming into the entity class. Also the handling of parent child into the button and switch entity classes. slightly faster as it only does one lookup Let's move this logic back to async setup entry and pass in the result to the constructor instead so the entity knows a little as possible about the implementation details of the library should I make a copy of the button devices, and add the "device name" key to it, so not changing the original library data? button devices bridge.get buttons().copy() don't see how I can use this simple loop if I'm going to pass in another variable with a different value for each button If I use the copy method: I'll push up a suggestion shortly Untested but something like this should do it Looks great. Tested beautifully on my system. Originally I had tried to use the DeviceInfo type in the last PR, but couldn't get the dr.async get or create() to work, but I see separating out the config entry id does the trick. Thanks! I guess this could actually happen but we don't have a test for it? It really shouldn't be able to happen, as we're building the parent device info from each button. Can I just remove this if statement? I think i'm just being over-careful If you are sure its not possible it better to remove un
In the device registry, the model is a combination of {model} ({device type}) PJ2-3BRL-XXX-L01 (Pico3ButtonRaiseLower) The model and device type are extracted from the brackets and the spacing. However, homeowner keypads return "Homeowner Keypad" as the model, adding an extra space, which breaks the current method of parsing it out. Homeowner Keypad (HomeownerKeypad) This change extracts the device type for the last word in the sentence only, and re-combines all the previous words to re-form the model. Please use a f-string instead of a join done Can you pick a name here that better shows the intent ? updated to handle none keypad serial Maybe split this into a list, and then pop the last value out so we don't have to do the model list ? I use this model list in the return line to re-form the model. Is it preferred not to use the notation? Is it preferred not to use the notation? While, its is perfectly fine to use it, I generally prefer to avoid if there is another option. I'd probably write it as: ok, I like that. Sounds good. I'll adjust. I've updated using your suggestion You can drop the str() as the f string conversion will do it for you done
This was changed to be aligned with Gen1 devices and to avoid confusing with the external sensors L85 We use this to generate the unique id , but this is not a breaking change since the final key will get appended with :0 , see L297
We normally don't place coordinators in the platform files (sensor, switch, ...) since they are expected to be shared. Place it in init .py or coordinator.py Type the stored data of the coordinator with DataUpdateCoordinator[DwdWeatherWarningsAPI] Ps, if you want empty dict aa base type, then this need to dict as base instead of th api class This is implicit in the base class, so can be removed. Why remove the type hint here? It wont be needed once the base class is fixed as above. We don't want configurable scan intervals. Just set a sensible default. Ahh forgot to remove that one, the option didn't even exist anymore Sse the SelectSelector directly. Use EntitySelector directly. This need to validate the stored entity id using entity registry.async validate entity id since it could be a UUID. Can you elaborate please? I don't understand what you mean When you use an entity selector, you are not guaranteed to get a entity id, it could be a unique identifier of an entity. It needs to translate that here use mentioned helper. Search codebase for that function. api is not a dict Can I just remove the return here or change it to an empty dict? I'm using the coordinators api variable directly in the entity class anyway. Otherwise I'd have to build my own dict with the data I guess which is not that clean imo Yup, you can return empty dict. You should make the schema a constant instead. It will be easier to read review. You mean as a variable somewhere at the top of the file? Yes, for example CONFIG SCHEMA vol.Schema(...) Could you please move the existing constants in a prelminary PR? It will make this PR easier to review. SENSOR TYPES are platform specific. They should be in sensor.py data-coordinator and config-flow are things that are often more complicated to review. Having them in the same PR makes it really complex to review. Is there any way this could be done as a preliminary or follow-up PR? See creating-the-perfect-pr Can the dependency update be done in a preliminary PR? This file is no longer necessary. Please remove it. Please create a mock setup entry fixture in a local conftest.py file, and auto-use it here with pytestmark .
Since LaMetric entities set has entity name to True, shouldn't this conform to [the standard]( Device, Area, and Entity names all start with a capital letter, the rest of the words are lower case (unless it's a word that represents a brand name abbreviation of course).
This logic is duplicated and would be really nice to have as a constant somewhere because otherwise it seems pretty likely to get out of sync. let's move this: to a helper. Something like def is hue motion sensor(channel: ZigbeeChannel) - bool: I've created a new helpers file in the channels folder and moved the model check in there now.
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: frenck, if I removed the second commit (the commit with the behavioural change), would you be willing to accept just the test suite I added? The tests may be helpful for future refactoring. You are absolutely welcome to open up a new PR to extend the test suite, sure
Can you make the assign func() method wrap this automatically. It looks like filter is always wrapped for require hass. Actually it's not clear to me what this is supposed to be doing. hassfunction already calls pass context on the provided function so is this actually doing anything extra? Actually it's not clear to me what this is supposed to be doing. hassfunction already calls pass context on the provided function so is this actually doing anything extra? There's a bit of pre-existing magic happening here that I just retained from the original implementation and I don't fully understand what it was doing. The function wrapping is clear enough from the comment (ensure that the result isn't just baked in when the environment is constructed), but there's clearly more to it. Can you make the assign func() method wrap this automatically. It looks like filter is always wrapped for require hass. This is some of that magic. I'm sure that I'm missing some Python nuance, but I haven't been able to just pass in the function and do the wrapping later based on a parameter because it fails to get the name of the function: I'll continue to noodle on it. Pfft, I figured it out. Will update on the other PR. Haha, glad you figured it out. Hooray for random magic! I'm not sure I see the advantage of creating an array of Ext objects as opposed to just directly calling a function for assigning stuff. Is there something odd about providing optional parameters for a func that's different with the obj? If that's the case then I see the advantage of this method. Otherwise I think the helper functions pattern would be cleaner and more understandable. That's just where my brain went first, but I can see your point. I reworked the whole thing to simply call a helper function that it's both working and arguably clearer. I'll upload the new changes tomorrow. Incidentally, as you might imagine, the issue that this PR is intended to address only requires minor changes to the device attr function that are totally unrelated to restructuring the way extensions are added. Everything that you reviewed is really part of which fixes a larger issue preventing many tests filters from being used as intended. My intention was to get that PR merged, and then this would build on that. To that end, I'll upload a new commit based on your comments in Thanks for reviewing!
Per [ADR-0010]( we no longer allow integrations to be configured via YAML they must be configured via the UI. We allow existing YAML configuration to persist, but not alter that configuration. In Home Assistant 2022.10 unique ID has been added for universal media player. What is different h re? I did not review that PR, nor am I a user of universal media player , but after perusing its docs, I guess that a special exception was made because that platform can't be converted to a purely UI-based setup straightforwardly. [From the "Decision" heading in ADR-0010]( decision): Integrations that communicate with devices and or services are only configured via the UI. In rare cases, we can make an exception. I don't think that applies here, but I'll mark this PR as needing additional review. It looks like this platform reimplements template switches setting-up-custom-irrf-switches It should probably be deprecated and removed instead. Template switches already allow setting a unique id.
Copy paste issue? It's a button. The manual states that a single press means "turn on" and double press means "turn off", but I guess that doesn't make sense with HA. Well the device trigger will be something like double click "on" button, so it would be weird if the buttons name is different between single and double press This should fix black
English is weird : :text pronunciation 2C 20not 20spelling.-,It's 20a 20unit.,the 20indefinite 20article 20 E2 80 9Ca E2 80 9D. Probably yes, too little focus May be less ambiguous to use CONF SOURCE SENSOR which is what other derived helpers like integration use L72 I did actually start by using the min max helper as the base e.g. copy paste so it's not streamlined thorugh all helpers. Also it does not neccessarily need a sensor but could be other entities so I would not agree to change this. OK, fair point See discussion r993773501, can be resolved as above
Should this be something like ikea ? It may not matter functionally, but it could help future devs. Yes, it should be but this seemed to hint that the domain should be tradfri: Indeed: exits but does not. Got it. That change was before brands existed, so I think the better long-term change is to update the brands repo to contain ikea assets that are linked to tradfri (as an example, see what I'm now doing with AirVisual as a master brand: OK, creating a brands PR. If I am renaming a domain, is there anywhere else it needs to be changed? In the tradfri integration itself? You aren't renaming the domain used in code this is a brand domain. So, in the brands repo, you'll establish that under core brands , then symlink that to tradfri (similar to what I shared with AirVisual). Hopefully I have done that now in Althogh I've not worked with symlinks in git before and have been unable to test on my machine Sounds good. FYI, I'm fairly new to brands myself, so to make sure we're looking at this correctly, going to mark this for a second opinion. We have a similar thing with Hue , which we also didn't apply yet. The reason is, that "Add Zigbee device" could be confused with "Add Zigbee device to Tradfri hub". Until that is solved, I suggest not to go this route. Ahh, I see. Makes sense. Do you have a link to where this is being discussed? So I cant out it in the PR for reference. Do you have a link to where this is being discussed? Nope, sorry.
We don't need this return statement, please remove it.
Let's use attr at init moved to attr name in init I don't see where attr name is used. it was used in the device registration, but I changed it as it was interfering with the entity naming. attr name for the entities will be implemented in Ok. For the future, it's good to avoid removing features until they are replaced with another implementation. I'll tag 80021 for 2023.2.0 to avoid losing the entity name. This shortening makes it hard to read. Let's move forward with device registry and entity registry removed the shortenings A bridge (the 3.0 which is in sell now long time) can have more than 1 lock device. Does that still work? Mine has a lock opener connected, that works. I guess the limitation here is that the integration can only connect to a single bridge, but since the integration can be created multiple times I don't see this as an issue. I've just tried it with a mock API to have one opener and two locks, works flawlessly for me ![image]( We didn't implement self. attr name as far as I can see. discussion r1087751212
Use PERCENTAGE constant?
Per should this be changed to something like extended options (see similar situation w RainMachine: That PR has not been approved.
I could not find this value in the specifications, could you point me to it?

It really shouldn't be possible to get to a state where there is a reauth flow active but we can call reauth again. Starting reauth should probably unload the config entry and put it into a ConfigEntryState.SETUP ERROR state Won't unloading the entry prevent us from responding if the API recovers? From part 3: If the API recovers and returns an HTTP 200 response after the re-auth flow has been created, we assume that the prior HTTP 401 403 responses were a service issue and abort the re-auth flow. Short term I fixed the check that would allow multiple reauths for the same config entry I don't think we should unload the entry on reauth. Possibly re-load it so it's only every in it's setup stage. I think we should handle transient auth errors. If the error from an update coordinator goes away any started reauth should be cancelled. Just realize that is just what this integration is doing. Feels like that ought to be moved into main coordinator. elupus I'm unclear on: Just realize that is just what this integration is doing. Feels like that ought to be moved into main coordinator. All of this occurs within a single object that our two coordinators share. I don't think we should unload the entry on reauth. Won't unloading the entry prevent us from responding if the API recovers? From part 3: I agree it doesn't make sense to unload it unless it happens during setup All of this occurs within a single object that our two coordinators share. This makes sense to me since you'll never know which one is going to hit the auth problem first. This looks like we could move this into the base config entries class as will make it do the same thing. In a follow PR we could replace diff-bcb932c3549daf52e1d6d8b02211ed0cc15557f5d17968f33a9daacf7ddac81bR663 with something like this code that yielded matching config entries than we could call that new function from both places and eliminate the duplicate code between here and the config entries Can you clarify the recommendation? Wait for 81753, roll forward with this, then do a follow-on PR with your second comment? Let's merge this now and and then in a followup it would be good to make a new function that in homeassistant config entries.py that takes and and makes a new function in homeassistant config entries.py that yields matching flows (I should have left it [as async progress by handler as it would have been a bit more efficient]( which both places can call instead of writing it out. I think the typing on this should be a config entries.ConfigFlow ? async progress by handler returns list[FlowResult] : L194-L201 Absolutely it does. Sorry about that. I didn't context switch well from looking at 81733. I think this isn't reachable for the reauth flow? We don't want them to be able to change accounts unique ids in the middle of a reauth. Not following. Agreed that this isn't reachable by reauth we'd only reach this line if we created a new entry. What am I missing? Sorry I did a poor job of explaining (jet lag was 
No need to override - these are the same implementations as in the superclass. Thanks, this is now removed.
Why does this also accept any int?
Are these changes meant to be part of this PR? It is the result of running python script.translations develop , the output is managed by HA's scripts. So yeah, this looks fine.
The naming is kinda misleading, as it does not just check for availability but also the unknown state. Something unknown doesn't mean it is unavailable. Someone suggested is nominal within the forum. Would that work? Docstring should be improved Think we should rename the test to just nominal . is nominal is fine for the filter and the function but the test will read better without the is at the front. Currently you will use this test like this: This reads better and is more fitting with the other jinja tests: Only half true as there is an equally good counter example: {{ is nominal(states.sensor.test) }} , which is in line with all other is x filters: Of course I agree that your shown jinja test syntax is sexier I'm okay with any verbiage as long as this PR gets through. I constantly see people not understanding how to use 'unknown' and 'unavailable' on everything they check because they don't understand it. e.g. checking attributes for 'unkonwn' and 'unavailable' when they should really check for None. This And this Can both work simultaneously. You specify the name to use when you add it to filters, tests and globals. It does not have to be the same name. Basically I'm saying change the above code to this: Then when used as a filter or a function it is is nominal and when used as a test it is just nominal Just like how we did with regex match and regex search . When using them as a filter you do this: L2016-L2018 When using them as a test its just match and search : L2068-L2069 What me to change it to use for tests? Easy change just want to confirm. :-) Yes please do So if you pass in a list of entities like ['sensor.a', 'sensor.b', 'sensor.c'] it returns True only if all of them are nominal and False if any are not? That seems strange, its basically the inverse of how these [states are handled in groups by default]( binary-sensor-light-and-switch-groups): - The group state is unavailable if all group members are unavailable. - Otherwise, the group state is unknown if all group members are unknown or unavailable. - Otherwise, the group state is on if at least one group member is on. - Otherwise, the group state is off. I feel like if you're going to allow a list of items as input this should be inverted. It should return True if any of them are a nominal state and False only if all of them are not. But also, do we need to allow Iterable as input at all? What's the use case for this? Correct, if any of them are not nominal then it returns False. One of the use cases for this would be the availability of template sensors. Regularly one then makes the template sensor unavailable if any of the entities it relies on are unavailable. So by allowing a list and only returning true if all of them are nominal makes this easy. For example, template sensor that adds 2 sensors together Hm. Ok well that use case does make sense. I don't think the behavior in this situation is particularly intuitive though. I guess the question is do we think people will fig
Normally we require components to have a static mapping between "component device class" and "home assistant device class" For example: and then I see that this isn't applied in the existing code so maybe there is a reason. I am just pointing it out. Agree, I'll be using class based of EntityDescription to fulfill static mapping requirements. This way I'll be coherent with sensor platform. Method removed, EntityDescriptor used instead. This class doesn't add anything that BinarySensorEntityDescription doesn't already provide. This is bad behavior. It shouldn't be part of init and the logic should be moved to async setup entry epenet Can you elaborate? As I see in major other integrations, self.entity description is set on the entity's init. I would like to keep it consistent. Your suggestion would only resolve descriptions for BleBoxBinarySensorEntity , but there is BleBoxSensorEntity which also uses entity descriptors. Also visible prospect application of entity descriptort in other blebox platforms f.e. light platform. self.entity description is always set on the entity's init. BUT it is normally passed as an argument, not looked up during the entity's init. The lookup should be done BEFORE the entity's init. Regarding BleBoxSensorEntity , in a follow-up PR I suggest that apply the same logic that I recommended here and remove reference to the central create blebox entities . I just don't feel that create blebox entities method adds much value, and just makes it harder to review the code. Or maybe add a new helper method so that you share one loop between all platforms, but keep the class instance creating inside each platform: I don't think you should delegate this to init I think you should instead do something like this, so you can pass the description during initialisation: You misunderstood me. I was refering to BleBoxBinarySensorEntity. init () not refering to init module. I think that you should NOT reference create blebox entities , and instead move the logic here. You don't need to adjust create blebox entities in this PR. You don't need to adjust create blebox entities in this PR. You don't need to adjust create blebox entities in this PR. Can you add generic type? Can you use list comprehension (untested)? Tested, added in a commit. Isn't it self-explanatory over-zeal? You are right, it's inferred here. You can use Note: please open a PR to adjust the other platforms (I think at least sensor ) to use the same logic. As you know, I am a big fan of type hints, even in tests. It was not compulsory for this PR, but it would be great to add here Type hints should be in same PR with sensor description refactor? Smaller PRs are easier to review. I suggest to split from sensor description refactor. Same here, type hints would be good in follow-up PR.
This looks really strange. Why do you construct the mock from an instance of a http client.? I copied it from another test. Without it the test would error out in the diagnostics test helper. If there s another way I d appreciate the help. Just removing the http client bit causes the diagnostics to actually try to query using the network. Then you are not patching replacing the object somewhere. What is the error without that? I take it back. I just removed it and pushed again. For reasons I don't understand (I fought with this for 3 hours) this line would fail its assert L15 Maybe something in my environment was borked?? I don't know. But it is working now. Thanks for your review! Please use a fixed date. Its likely to break at some point. Same here, use a fixed date.
You could use walrus operators here ok, I'll look it up I've simplified it by doing this: if (parent device info : device info by device id.get( device["parent device"], None)) is not None: We should type the set here Not sure what you mean on this one. Do you mean avoid the "Any" type? I think you can write this as or if parent device info will never be undefined great! I like it. I"ll make the change. Are these always strings? oh, I see. That was existing. Yes, it will always be a string. Serial number of the Keypad. no problem. I think this would be easier to maintain if we passed in a data here instead so we don't have to unpack it and feed it into every entity. Ok, no problem. I've updated the the init method to pass in the data variable instead of the bridge, bridge device, and device info by device id parameters. We should use an f-string here instead black may complain about this suggestion
I dont think water heater generally have am on state. Its all weird heatpump, eco, ... states. I was going based off the action type s in strings.json: But I can update this with the states in water heater init .py : I think you have to. Or trigger on OFF and NOT OFF
These could be problematic in the sense that they'd reset what they were even in cases where that might not be required. I'm not sure if such a scenario actually exists, just a hunch. I would hope the backend library (or the device) handles it accordingly. Those are just wildcards for the corresponding network type, but I think I tested that changing between modes including 2G 3G 4G works. import re-sort Perhaps a "best-to-worst" ordering would be a good thing here Actually maybe better to use the new NetworkModeEnum constants as the keys here. I will change that now that the enum is extended, this was just a quick fix as the enum had previously a rather limited selection of modes. Using the NETWORKMODE TO STRING mapping now. As discussed, let's keep the sensor. We could convert the formatter keys to NetworkModeEnum values here though, like in the select. I suppose we're missing something here to set the select's name, for me it shows the device model there the UI now, instead of "Network mode" or something. It should be (or at least was) read earlier from the entity description object, I'll take a look soonish to see the necessary changes made. Looks like it wasn't, so I added post init hook to fix this. Tests still missing. Moved this from sensor.py to allow sharing among platforms. Changed in 4c31317c0645f74d7d4b6a2f09e049258e2f8e46 Good catch, that's why my tests were not working. I was trying to do something similar to and to make the tests cover the whole initialization procedure, but I'm stuck in a situation where there are no services registered... What do you think, does it make sense to move towards using fixtures (instead of manual patching as done in test switches )? In principle, would very much like to head towards fixture based approach. Much appreciated if you're willing to do the ground work for that here : 1: This should probably be moved into a custom entity description to be consistent with other platforms.
Since you are only using 3 const, it's probably best to just import those three by themselves. I think this should be addressed Just for ease - would probably be good for these to have typing Why do we have this? I thought the car icon represented this entity better than the default device tracker icon. The documentation shows this as a recommended shorter form pattern to override the default platform icon. I'm trying to make it so that the name of the device tracker entity is just the vehicle name, and the entity id is device tracker. vehicle name . If I don't include both of these lines, the device tracker either fails or is assigned an unfriendly entity name ( subaru vin location ) and entity id ( device tracker.subaru vin location ). Please let me know if there is a better pattern to use to achieve this. I was trying to follow these guides: entity-naming name needs to be attr name

Can you move these into aiolifx ? I don't think it would fit there: this has nothing to do with the actual workings of the protocol. It might suit aiolifx effects though: I'll give that a whirl during the week. Perfect
I don't think this is needed? Explicitly re-export the "public" API, e.g.: Let's add native min , native max , mode , pattern to the description We have a lot more "modes" when I look at the TextSelector , should this be extended? Eventually yes but that would require frontend changes too right? If so maybe that should be in a separate PR. Also begs the question, should we have predefined regex patterns for some of these types? Eventually yes but that would require frontend changes too right? It does require that now already? As in, to support password , we cannot rely only on the backend? doesn't the text input component already support password? Yes, but it uses ha-textfield and mode directly passes in as the type : ![image]( Which is the same as the selector does as it seems. From the ha-selector-text : ![image]( Which is defined coming from the MWC Textfield: ![CleanShot 2022-11-21 at 22 30 17]( So... I think it can just be extended and it will work? instead of redefining it, should we just reuse the existing class? Maybe define it in homeassistant.const since it will presumably be used in mutiple places? also should we exclude date , datetime-local and time since they will be supported by the other new platforms? instead of redefining it, should we just reuse the existing class? Maybe define it in homeassistant.const since it will presumably be used in mutiple places? The number of places is very limited at this point, so wouldn't go that path just yet. also should we exclude date, datetime-local and time since they will be supported by the other new platforms? Agree, number, date, month, week time, datetime-local, and colorsare maybe odd.. Hmmm ok that removes a lot. OK, convinced we should maybe just stick with text password for now This can just be the state method, right? The existing state property is now a proxy, I suggest to merge them. These are not existing properties of Entity , so we don't need to define these as None . Same as above. Should the default be 255? Which is the max? Should we warn in such cases? Or maybe even throw a ValueError ? I'm not sure if we should just truncate. Instead, I think we should error and make the integration themselves responsible for those cases. They would be better at deciding what is best for their integration. Additionally, if we do this, we basically will be accepting storing longer values in memory, which we should not. attr wins over entity descriptions. If we set the default here, we can remove the need for allowing None . This is not an error from the underlying service, but an error caused by incorrect user input; thus, a ValueError . I think we should avoid compiling it every time, instead, we should compile it once and re-use that pattern. Not exactly sure how we should do that. Should maybe we require a regex object on the pattern property instead of a string? I made this switch but I think it is better to handle this internally to make it easier for the integration author. I've got an
The capitalization here isn't correct. Besides that we don't need to add these two words here and adding two surplus words to our Readme isn't the kind of PR we want to see during Hacktoberfest.
maybe better as SwitcherCoverEntity class attribute Thanks, moved maybe make this string a constant ?
Done in [3be9456]( Done in [3be9456]( I think maybe you should raise HomeAssistantError so the user get's feedback to UI Thanks for the suggestion. I've actually decided to completely remove the check as the motion status is supposed to always be returned by the low-level API library. The underlying coordinator has been updated accordingly. Done in [0f167c5]( I think you should move this to just after LOGGER Done in 64b1d06fd17b21a96bcf56d2d16cedabfeb31723. Move this to the cover platform itself. Let the cover platform decide if it adds entities or not (in the platform setup). Done, addressed in 182a67378bfda2e4eae61cb04f3a3147ae2dc98e Does this logging bring any value for the user? Point taken, log removed in commit b2a3de793644624af75d34f84c3d85a60efa5dfc If the panel is offline don't you want to add cover anyway if it comes online later? Seems to be guarded in the device discovery below On Elmax panels, the cover feature is available only if a specific hardware module is mounted on the panel itself. This installation is performed by an authorized personnel and cannot be done by the end-user. In other words, it is unlikely that the feature gets available later on: the user must replace the panel or change its configuration. In that case, the advised procedure is to remove the integration from HA and add it back as its hardware configuration has changed. Looks like it should be raise HomeAssistantError if it should be alerted to the user (show in frontend) You're right. I've initially added this log entry for debugging purposes. For this reason I've changed the severity to DEBUG so that it is still available within the logs for debugging purposes but not shown to the user. Handled in commit 8b1d26ef390dbe8a4d820996530bf1f798f57751
This seems unused and can be removed here and below yeah, this dict is unnecessary, removed.
Alternate implementation approach. This removes all items in the second set from the first set and returns the result You could also do xor since the add entities uses or ( ) That's how it goes when overthinking it. I'll change this
Should the iot class not be calculated ? calculated : The integration does not handle communication on its own, but provides a calculated result. """Set up the sum sensor.""" This should not be using a platform schema (ADR-0007) Right. I though maybe helpers was seen differently but wasn't checking the ADR. Will change this This should be a normal CONFIG SCHEMA ? This should be ensured by the config schema sync call in async context It is used only once, let's use it in place in that case. Should these go into const.py? I'm not sure if this is the right thing to do. If I want to sum two sensors, and one isn't available, I think it would make sense if this sense wasn't available either. Otherwise, the values can become quite unexpected. This is an assumption. It could be a total increasing? Why is this a float? I don't think these add value (but they do add database size). Make sure we add the recorder platform to this integration to ensure this attribute is excluded from the recorder (as it is configuration). This is odd thing to do. If I sum two sensors with different units, the unit will jump between those depending on which one last updated. Why is that a problem and need to become a warning?
I think icons should be removed if a device class is set. But please verify that defaults look correct. I may be wrong but from my tests and search in the frontend repo this device class has no icon set
Return should be typed to DeviceInfo, and constructed using that class. Added in next commit. And moved to right place in alphabetical order as enforced by commit hook. Yes, proposed this in a comment but were not sure it is allowed with constant return values. If so I'm positive to the change. You can add it Don't seem to have "write permissions" so had to do it in an own commit.

Please grab this data in ipp init .py, when the integration starts instead of the sensor. I would prefer if this had no default. This should be done after first refresh, since that is weekend we know printer is available. We can't patch that here. Then no tests are being made of the new code. It needs to mock the actual return. Do the existing bin files have the correct info in them or do I need to make a new one?
Could you take a moment to reorder these in alphabetical order?
this line and the next must be removed
This would be best as a StrEnum ( from homeassistant.backports.enum import StrEnum ), so then you don't need to use .value to get the string constant. Can you please make this a Final constant? Can be: Can you help me understand in more detail how the read and write scopes will be used? I get the general idea of read vs write scopes, but I don't quite get how these will be used compare to the file scope. The way it appears right now is that I see is the user will create a single sheet (using the file scope) -- but it's also given a read-only scope for everything in the account. I don't see a way to access the other sheets or why giving broad read write access can even be used. The read scope gives read access to all spreadsheets. The file scope ensures users still have write access to the document that the integration created. I plan on extending the append service to allow the user to add a document id so they can specify a different document other than the integration made one. The plan is to add an edit service which makes more sense for any other documents that people have access to that they want to modify. It should be the same schema for both services. Yeah I understand the scope differences, just wanting to see how they connect to the feature to ensure they all make sense together. Ok, I'd say let's do the scope changes with the features it will enable? I don't mind viewing the larger PR. I just want to make sure it all connects.
Please use hass.config entries.async setup .
Why do we pass in old unit? That's already stored in metadata. We pass it in to not have a race where metadata has already changed before the conversion happens.
Is the else now an expected code path? If not I think you should consider raising an error or logging something here. This integration has existing code that has too much protocol details. We won't allow changes that add more protocol details. Those should be moved to a 3rd party library published on PyPI.
This works fine but personal preference for me would be to call the super method instead in case it ever changes and needs something else Should this raise before attempting the write if STATE HIGH DEMAND isn't a valid operation mode because it was never appended to the list in init ? Should this be the same check as diff-390ba80a508c7be861a9d7c3549ee9ae8b018b540ba521cd3b4ef49a8e871250R101 ? Probably, seems platform didn't check. I've added a mapping with check.
Is there a particualr reason not to call async get calendar directly and fetch all the events at once? Large databases could time out but testing this again now seems to be improved. Their database management might be more efficient since I last tested. But still, I think there is a benefit to caching the events. It seems more clear and easier to reason about to return events and update self. events only once, in the caller Returning multiple events in a single event is not following the design standard of the CalendarEntity . The design is that it only reflects a single next event (for better or worse, see various architecture discussions on improving this which would welcome input) (These attributes are already set by the parent entity from the CalendarEnttiy ) Want to send these misc cleanups in another PR? They seem separate from the calendar entity if i understand right This has to do with the while statement. This is to prevent the tests from hanging. This seems like an hybrid between a coordinator entity and regular polling entity. Should all of this move into the coordinator for this entity? or not use a coordinator entity? It seems a little surprising to mutate the properties of an object in a property method. Perhaps it needs to be updated once when the coordinator callback fires? (Aside: since we're talking about state updates -- calendar is now fixed to no longer need a separate poll interval for data fetching and a separate interval for state updates as events start. this is now handled by the base class. i don't think this needs to change anything, but just wanted to mention that if you hadn't seen it) Does this need to be cleared if there is no upcoming event? Our current standard is to always include the state attribute item and set it to None if it's unknown. By using kw only True in the dataclass decorator we can avoid the mixin for required attributes. We're not allowed to send CalendarEvent with additional attributes currently. We should improve the parsing code in the calendar integration to access the allowed attributes explicitly so we can remove this limitation and review burden. Ie we still won't send additional attributes, but it will be possible to subclass CalendarEvent for internal use, as done here, and not worry about the API usage upstream. CC allenporter L665-L670 L418-L428 You're saying we should prevent extra attributes on the data class from being returned in the API? (E.g. extra fields added when subclassed). This didn't occur to me. Makes sense to me, we can only return fields from a fixed list. Yes, exactly. Return the events here instead. Don't access hass.data or the coordinator in tests. Those are details. writing-tests-for-integrations Move time forward instead to trigger a refresh. L404-L408 What does this value represent?
Can you provide links to documentation? Unfortunately there are no documentation links for this device, as far as I could search for. perhaps? Should this be a sensor with an enum device class instead? My coding foo is not strong, could you please an example? It is fairly new, so no example in the Tuya integration yet. Create an entity description and set the "enum" device class, additionally, we need to set the "options" parameter in the description to a list of possible options this sensor can provide. Does this actually count down? Yes, this returns the remaining seconds for an one-off session. In the app, you can set an arbitrary time duration and the water timer will work for that duration, while reporting back the remaining time. Number entities are not allowed to do that. They represent a setting control. Maybe add an icon? - Or is this "Mode"? - Translations? - Entity category missing - Maybe set the enum device class? - Provide a list of possible options? "Mode" is indeed more appropriate. I can only provide accurate translations to Greek and Portuguese. Please provide examples for Entity categories and Enum device classes. - Maybe add an icon? - Time in seconds may add up quickly, not sure how viable this entity is in general. Maybe disable by default? - Entity category is missing - Looking at a similar PR 69188, it has made this a select entity, not a sensor. Which one is right? - How is this a measurement? What does it contain? You can't set select the weather last time I checked (both in the app and in the Real World). The weather is reported based on the location you have set up in the app, but it is also not possible to set the location with the Tuya API. So, this is something being reported back by the API based on the location you declared in the Tuya app. It therefore contains the weather forecast for your area. So why is it a measurement? Is it better suited as diagnostic? If yes, I have no problem changing it. Now... this is the reason we have a total increasing :) Is this correct? This shows the last duration of the water timer, and it is not adding up continuously - it resets every time the timer starts; so I don't think TOTAL INCREASING is correct, but I might be wrong and I don't understand it. Maybe add an icon? e.g., mdi:sprinkler-variant Just an idea, some options are a timer e.g timer-off or timer a weather symbol e.g weather-pouring, weather-rainy or weather-cloudy-alert
Use STATE ON constant from homeassistant.const Copied docblock, please change. I feel like it make more sense to keep the list in the coordinator and do the any check in the entity onstead.
This is not how supervisor discovery works. Instead, the supervisor should announce push the add-on being installed. For reference implementations, please see adguard, mqtt or deconz. Had a discussion with balloob on Discord. He says we won't get discovery messages. "That's only ones we've allowed currently." Right, so this is working around it? We should not add workarounds.
Support for toggling switching for humidifiers should be provided by the humidifier entity, not the switch domain. Formatting sounds like an action, thus should it is not a switch? Device restarting is an action, and should thus not be a switch but an button. This is the default, please revert this change. We should not add todos to code. This change seems incorrect? According to specifications, this is sos state , see: This doesn't seem correct according to Tuya specifications. Nor is it visible on the doorbells I have available. Unrelated changes, should normally not be in feature PRs and split into their own PRs. This is incorrect, Diffusers are category xxj , not jsq , please revert this comment. This change is incorrect, it should inherit the device name as this is the primary entity. Please revert this change. This is a primary entity, we generally do not provide icons for those. Additionally, these chips are reused for other things and thus may not be accurate in this specific case. Let's not add an icon here. Not sure why this is remove? This is a light and should thus be part of the light domain. This entity will count-down (as in, actively change state during the count-down is going on), which is not allowed. This entity will count down during the timer running, which is not allowed. Why is this a number entity? These values are provided by the API and should not be hardcoded. These values are provided by the API and should not be hardcoded. These values are provided by the API and should not be hardcoded. This is part of the light mode of an light, and should thus not be a select entity but needs to be handled by the light entity. New entity naming styles requires to use of sentence style casing everywhere. Fan speeds need to be handled by a fan entity, not a select entity? Missing translations mapping? This is already handled by the device class? This is already handled by the device class? This is already handled by the device class? This is not a measurement. The SD status is a code that translates to an actual human readable state. Same as above This DP actually has a fixed unit of measurement, should it be added to the entity description? Couldn't find the specifications, what does entail?
We can remove .keys() . Will fix on next lib update since this should change slightly.
I'd move all the magic numbers to the lib. They are really just as magic in the library thou. My pump have about 900 parameters. Adding them all in library makes little sense. We do have string names for these like "prio-43086" and "cooling-with-room-sensors-40171" which we could use instead. They are a little bit better, BUT they stem from a DB export from the pump that is language translated. So nibe could decide, oh we don't like that naming and we end up with new names. Also the names are not always consistent, which sort of make it more confusing. The number is consistent within a series of pumps. I've been a bit back and forth on this. The library have no need to know these constants. Only a application that want to expose a climate entity in the format that home assistant exposes. I will ponder it some more thou. I've moved them to lib This might be a bit more readable if you did coordinator self.coordinator at the top of the function. It would also save quite a few lookups (not that performance is going to be an issue here) Operations like service calls and entity methods (e.g. Set HVAC Mode) have proper exception handling. Raise ValueError on invalid user input and raise HomeAssistantError for other failures such as a problem communicating with a device. silver- I think this should be ValueError Since these are constants you can define them above init r1015786246 None is the default for get Is this expected to happen under normal circumstances or should it be a higher log level? It is expected to happen, but it's not an issue. Some pumps define many of these climate systems some don't. The name got me when reviewing this since it took a minute to realize it was being defined by the integration Maybe change the message to "set temperature" requires "hvac mode" when passing "temperature" when "hvac mode" is not already set to "heat" or "cool" Please decorate this method with callback as in the parent coordinator entity. Bad grammar. Please apply the suggestion below. discussion r1036580942
Why do we want unique ID? This is only used in combination with platform and component to generate an ID It's used by the script api : config script config {id} .
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries.
Maybe this should be required too? Why would we have two?

Can we make this self.active effect instead so we don't end up with a lot of these if there are more ? I refactored this to use an Enum so that it supports the Tile effects ('MORPH' and 'FLAME') as well. It would be slightly more efficient to only enumerate self.hass.data[DOMAIN].items() once and build your coordinators and bulbs list in a loop instead of second list comprehension built from the first one. It probably doesn't matter unless you have 100 bulbs though
It would be best to set self. attr unique id at this point with [a unique ID]( as that makes it a lot easier to manage the entity. I don't immediately see anything unique that could be used, other than the config entry's id, so that would probably be your best bet. I added the self. attr unique id , not sure if that's enough. That should be enough The API seems to be very easy-going in its matching, so I can imagine people getting a different station they expected from time to time if the first result is always chosen. Maybe only take the first result if there's only one matching station, or when if the search query matches the first result 100 ? And in other cases list like the first x matching stations in the error message. In theory, you could also provide HA with a list of stations to limit the results only to valid options, but I suspect that might be a bit too much to handle in the UI. I didn't like the error approach so I added a second form step, with a dropdown of the suggested start and destination stations. This doesn't seem like an extremely unexpected exception, as it's based on user input. Or did you put it like this because the API hardly ever refuses to return at least one station? The API seems to always return values. I tried to input a lot of garbage, but there are always station returned. Though that probably depends on the hafas API implementation. To clarify the purpose of the stations step in the config flow, it might be a good idea to add a description like "Verify the selected stations:" I added a title, great idea Remove empty keys Remove this file Why aren't you using the old domain name? hafas is not from DB, it is from a different company and it is a different interface. It would not make sense to use the db domain name. Please describe to me what "Ha" stands for. HaFAS stands for "HaCon Fahrplan-Auskunfts-System" (HaCon timetable information system), so "Ha" ist part of the company name from the developer of this system.
Since we only need this file when adding an integration, let's load it from a JSON file so Python doesn't keep it in memory? Sure, fixed in 440f13d31183d97a1e6d0534f9e3e96d5d5f60d7 Shouldn't empty entries also have "integrations": { "gogogate2": ... } } or is that something we assume if omitted to be filled in ? I guess omitted works fine here. Yeah, I think we should omit it to keep the size of the index down. Bluetooth is not a standard that can control things directly so that's not a valid option. homekit and matter are. homekit added, we should add matter when we have a working matter integration in core. It's unclear what shadows means here. I'd be explicit and just say that brand.domain is an existing integration and brand.domain is missing in brand.integrations as that's the check we do. The comments don't describe what we're doing here in a clear way. As I understand it the primary domains is the union of the actual integration domains and the key domains of the brands collection. Why do we need to filter out the domains that are in brand.integrations from the primary domains? I tried to improve the comments rename some variables to make the code easier to follow. We should mark the custom integrations by setting a flag on them. Can we put it in a standalone data structure? top level key custom and then add it there. Makes sense, the response to WS config entries list flows is now: We don't need a name if we should translate it. We can just omit this. Maybe we should even just have a list stored at top-level of this file with integrations that need translated name. And then we can remove translated name too. Fixed It should be Google Calendar? CC allenporter Yes, the product is called Google Calendar I assume I need to update homeassistant components google manifest.json to fix this, is that right? yes This is I O and not allowed in the event loop. Also, this cannot happen? Removed guarding for this I O this is listing brands.
Could be a dataclass Can this be removed? Usually we expect ValueError and HomeAssistantError to be raised instead when a command fail silver- left over debug This affects the global state so we don't want to change it in an integration. Can the library be fixed instead? Are you suggesting making [logs like these]( L130) debug level in the library? I'm suggesting this is a bit of hack to do this since one integration is affecting the global state of the logger. The library shouldn't be logging at this level in the first place. I'd probably pick a different library but its probably a little late to do that so if there isn't a better solution its ok to leave as-is. I agree that we shouldn't be affecting the global state of the logger from within an entity file. Is there any way to enrich the default logger component settings in the build system? Something to the effect of We do this in bootstrap L335 but only for base requirements so there isn't really a place you could add it since the library appears to only be used by this integration (or at least I have nothing else installed in my dev env that uses it according to pipdeptree ) I think we are stuck with this. Let's move it to async setup entry in init .py and add a comment I'll also see if I can submit a PR to make the info logs become debug by default since I think it's a reasonable ask for this type of scenario. After some digging it seems like this was already brought up - It looks like these could be lambdas instead since you don't care about the arg? We could, but pylint doesn't seem to like the lambda. ![image]( Not sure if this is what you had in mind. You could write it like that but honestly its not any better. It might be nicer if you have events subscriptions returning callables to cancel subscriptions so you don't have to track the references to the function in hass Please split any multiline-ternary into an if block Since Home Assistant has both sync and async function in the codebase we usually prefix any callback functions that are safe to call in async with async The callback decorator is also a hint to Home Assistant to not run the function in the executor Since you are setting percentage and is on its better to use percentage and is on since attr has special meaning to the parent classes Please remove empty data Should not be needed We aren't allowed to access hass.data in new tests as its considered internal integration details. writing-tests-for-integrations I think you can drop this Please move to const.py Can you avoid passing the loop here and use asyncio.get running loop() instead? Pass asyncio.get running loop() instead of hass.loop , or remove the parameter and call asyncio.get running loop() from the library? Remove the param In general python is moving away from passing around loop so we are trying to do the same This could be a dataclass which would allow you to avoid writing out init This could be a dataclass There is one more hass.data access here. The entity id s
Should this not match line 300? Or you might get unexpected behavior when gen is neither 1 nor 2. This is correct. Gen2 devices username is hardcoded to "admin". For older Gen1 devices we did not store the Gen so it might return none. We can change however here or in line 300 so that the if path will be the same (reverse the if else and compare to 2), but I don't think it worth the change. You're right if self.entry.data.get("gen", 1) ! 1: will be cleaner and more understandable. Don't we need to catch errors here? Yes, we need to catch errors here, similar to L207-L212 Oh you're right. I'll open a PR to fix this. Done
Normally we don't ever poll faster than 5 seconds. You're right. This is in short bursts. Their own frontend does every 2 seconds but that didn't feel right. Don't patch the coordinator but the library.
Is this correct? I don't think we should have these kinds of options. The user shouldn't be able or need to tune the noise floor. If this is a problem, I don't think this is a good way to integrate this device type. I added this because users complain about being able to see their neighbors' devices, but maybe this is a bit premature as I don't think iBeacons are common enough that might actually matter and they could just disable the device if they don't want it. My neighbor only has one that I can see so maybe we can just rip this out. Will do some more testing at other locations An alternative would be to just ask users to disable all the devices it doesn't want to track. Thoughts bdraco ? Did we move or remove the option to disable devices in the UI? I can't seem to find it on any of my installs img width "889" alt "Screen Shot 2022-09-20 at 5 17 10 AM" src "" It is there. I just forgot where it was since there are two places on that page Let's rip out the min RSSI setting. They can disable any of the ones they don't want. I don't expect it to be enough of them that it matters. Splitting a dict update without parenthesis inside a call on more than one line is hard to read, as the indentation is missing. Is MAX IDS part of a specification? This sounds fragile. This is to filter out devices that do not follow the spec. We can't know they violate the spec until we see them violating it. MAX IDS is the threshold where we consider it a violation. It sounds fragile if we have defined this threshold ourselves. In practice this is fine as the threshold is quite high. Since bluetooth data is always raw binary data without any encapsulation we end up with filtering in many places. I think this is just the nature of dealing with bluetooth data that we will never be able to get away from. We don't have to integrate every kind of device if the API is bad. :shrug: I think the same could be said for the entire Bluetooth LE spec, as seems to prioritizes energy savings and compactness over data validation at every turn. MartinHjelmare the API spec is fine, but not every device implementing it is fine. Hence they are being filtered out here. Well, the problem is there, regardless of it's the API or the API users. I don't like workarounds like this. How will these attributes be used in automations? Per the iBeacon spec, major and minor represent a position in a home.
Unnecessary space? You need to exclude this from codecoverage in .coveragerc , or you would need to write tests. Done. You need to exclude this from codecoverage in .coveragerc, or you would need to write tests. Done. Done, sorry for the wrong copy paste Done. Done. Attributes are alphabetically ordered, move this line to 68 As the is boost mode on condition is the same as the default return, this condition isn't needed. Or maybe the state isn't correct ? Fixed by updated the regular code. thanks. Not like boost away modes ?
If commands is just a list, why not instantiate it with all of the commends we know we need (vs. four subsequent append calls)? I'm pretty new to python, sorry about that. I just fixed it. No need to apologize! Same as . Could you do a PR to to add this as an enum? Done: I am wondering if we should wrap it with Command() in the python-overkiz-api, so that we don't need to do it here. For the async execute command we allow passing a string, so that you don't need to wrap this with Command() every time. Indeed, it would reduce the verbosity, and now we have also OverkizCommand we can use instead of the string. So you're saying I should update the new async execute commands to receive an Array like: And then instantiate the Command inside the async execute commands . Is that what you're asking? I'm not a Python dev at all, so I might code it the junior way. I updated my PR. Please let me know if it's what you're excepting for. If it's ok, I'll update my other PR 78665 as well. nyroDev We are talking about this [method]( L622) within the overkiz client API. tetienne that's the method I'm using in the new async execute commands I wrote in the executor here. This new function do the same as async execute command : expect commands as strings (or list if parameters are needed), wrap it into Command and call the execute commands function API. I could do a PR on the API to do what you're saying, but I guess it will be a breaking change, requesting more changes in many other projects I think. Closing this thread in favor of splitting to another PR 79576 Please remove or mark the PR as draft :-). PRESET not used Can you please check if you can use [value as float]( L304) to avoid the cast. self.device.states[OverkizState.CORE TARGET TEMPERATURE].value as float(): If mypy is OK with this modification, you can replace all the cast. While doing that, I'm getting the error: AttributeError: 'float' object has no attribute 'value as float' I'll let as it is now Can you please show your code and the full stack error? With the current code, here is the error if I remove all the cast(float : Type is not correct? Second parameter should not be a string probably? And it should be allowed as well to pass a list of OverkizCommands. Second parameter is an array of all commands we want to execute. Each command could be : - a string to execute a command without parameter - a list to execute a command with first element of array is the command name, second parameter is a list of parameter for the command See diff-91dd0349008bdb0dc5b517ae3e72ccd729ca1800ec222dbfcddef82040775942R93 for an example usage I could add an option to pass Command in the list of commands too, but you asked to not do so here discussion r973760583 in order to be consistent with async execute command. Maybe async execute command should allow Command as well too? Hi iMicknl, could you let me know what you me to do in order to be able to accept this PR? nyroDev I did not have time to fully review this yet.
Please put this in a separate update to the dict instead of this complex looking expression.
With the new naming system we don't need a default name. The switch inherits the device name. Future switches will have their own naming suffixes to differentiate them but the default switch will always be this one as it controls the on off state of the valve. It looks like you use this pattern elsewhere. Maybe add a helper to get the valves? This is a good idea. I'll spend a bit of time consolidating the common bits It looks like this code is shared with number.py Can you move it into a base class? Please use UPPER for constants Yeah, my bad. I know better than this We want to avoid sensors that write state frequently Usually we use SensorDeviceClass.TIMESTAMP and set the time when it will be done instead. This ensures we do not spam the state machine with lots of updates or fill up the database as it ticks down For this use case I'm going to have to strongly argue against using TIMESTAMP . Resolving the remaining time to seconds is crazy, I agree. I've added a little bit of extra math to snap to the current number of minutes remaining instead. This removes the excess noise from the state machine while retaining a useful history view for end users. The history view for a 60 minute runtime with Timestamp img width "595" alt "image" src "" View of DURATION with a resolution of minutes, rather than seconds. img width "594" alt "image" src "" I'm afraid there isn't flexibility on this one. I can't merge it as-is. Here is an example of one that was recently converted. L183 Updated. Frustrating that the user experience on the frontend is so poor for this sensor class, though I can respect that a friendlier representation is non-trivial given how broadly defined a timestamp can be. I'll add this to my list of core stuff I'd like to see improved as I'd like to swing that way once I wrap up this current work. If you drop the UOM it will look like this on the frontend img width "537" alt "Screen Shot 2022-09-19 at 6 43 39 AM" src "" For clarity, if you delete the old states from the database that had the UOM it should change how its represented. The frontend is showing a graph since the first state in the time window had a UOM of seconds. Yeah I did that. I'm not in love with the full ISO timestamp being the state on the chart. A duration type of UOM that tells the frontend to say 15 minutes or whatever on the history chart would be a good start. Or synthesize an actual graph view. I don't see a way to avoid setting a secondary attribute that drives the behavior given you can represent so many things with a timestamp. Anyway the idea is quite fluid in my head yet and this isn't the place to hash it out. I'll figure out where the put a GHI once the idea is more formed. Might be best to start with a frontend PR as a GHI will likely be a candidate for stale bot unless someone else is passionate about it. Good advice, thanks! Leftover debug print. 78870
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
Why is the return type removed here? Sorry, my mistake. This function does not accept a return value (Y) Strictly this is not related to your PR, so you can leave it here. But the unsubscribe handler is returned while there is no return value supported here. Unsubscribe is only needed if the integration supports reloading, which it does not at the moment. E.g. The class will act as a dict and you can use .update() to update the current state. Also you will not need create record() any more as you can pass the inital values to the typed dict. I see. I think it might be a little more complicated than that: a) The source device dictionary also contains an device id key which is discarded and not stored in the room state. b) the updated attribute is computed and I would like to avoid having to compute it in multiple locations to pass to update I.e. I won't be able to fully get rid of some wrapping update state or similar function to call the TypedDict's update method. But let me take a stab at it nevertheless. May be you are right, I think it is possible to add the device id, you can alway covert to dict then pop the device id when needed, I leave that up to you. If you use a TypedDict for holding a state you can update all values at once. I'm not 100 sure what you are suggesting, but let me update the code and let me know if that is in the right direction. Just to be sure. Is this option strictly (the number) needed. I suppose we can support the new format coming in and also support the old format at the same time? I cannot see where you use this option, may be it is not needed after-all. jbouwh CONF EXTRA ROOMS is (ultimately) being used on line 115. The reason I decided to make this configurable is primarily the "Danger" box in this section of the developer documentation: generic-properties Basically I want to avoid adding additional extra attributes for users who have no intention of actually using them. It looks we can support the additional rooms feature and keeping the primary state backwards compatible, so we are just appending the secondary states here. For use with templates it would be better to keep extra state attributes a single level dict. Even more I like the idea of creating additional entities for the additional rooms. And register the device in the device registry. This makes it easier to cleanup single discovered devices. We can do that in a future PR, but even better would be to do it now. I thought about just appending the additional room states to the dict directly using the room name instead of creating a sub-key "extra rooms", but decided against it primarily because I cannot guarantee that the remaining namespace of the attributes won't clash with the user chosen names of the rooms base stations. I.e. if I have a base station called "distance", it will override the distance key in the dict. We'd have to deal with potential collisions of any additional attributes that may get added in the future, too (e.g. raw signal strength
Can the MAC address be changed? If not, wouldn't that by itself be sufficient? MAC can't be changed, however historically the switch platform used both of them, so when adding new platforms I am trying to keep the same format, although I agree it is not needed. Could this technically throw an exception? If not, put it outside the try except so it's really clear where the exception could arise. Yes, this can throw RuntimeError if the command does not exists, in theory it can happen if the integration is trying to request a command which is not supported, most likely a bug in the integration or upstream report incorrect device capabilities sort
I think this falls under ADR 0010, and changes to YAML schema are no allowed. If I am correct, you would need to migrate to config entries epenet is right. I plan to migrate the integration to config flow soon and we can make this option in the UI. Drafteed if you would like and could give me a pointer in the right direction, I could look into migrating it, too. I would first plan to rewrite the backend to use fully asynchronous code, such like as Started draft PR 78613.
We need to support Python 3.9. Match case is only in Python 3.10. Thanks, I have replaced the match case by if then else in a new commit. This is protocol details that belong in a 3rd party library. I have only added a new type of binary sensor based on the existing component. Not sure if that are even protocol details, they are just the received bytes of another model product of binary sensor. The bytes types are protocol details. That should be handled by a 3rd party library and abstracted to a human readable api. I am not the owner of these component. I would just like to be able to have it support another binary sensor. I have not the resources to re-write the whole component if the base is already "wrong" - it should have had been rejected originally. Ok. Should we close the PR then? If there is no interest that new devices are supported (the same way as existing devices are supported) and other users can benefit from it, then you have to close it. or bdurrer wants to refactor the component? Ok. Thanks for your contribution.
We don't need to prefix it with the domain.
Need to make sure this is the right key Something is wrong here because I'm getting this on my HAOS box bluetooth still gets setup before hassio even if I add it after deps Might need to use a different api Can we limit this to when a USB adapter is being used? It already is since it should return early if there are no config entries present and config entry adapter in this case. But could use a test for no adapters present. Or were you asking if we shouldn't enter the function instead of retuning early? I missed that check. All good For future me ;) Can we delete the issue if we see it s not needed on startup ? Also can we link the more info link to the updates tab in HA, or is that not helpful ? Can we delete the issue if we see it s not needed on startup ? Thats a good idea. Will adjust when I finish next round of testing img width "573" alt "Screen Shot 2022-09-17 at 6 56 19 AM" src "" 6bc74ebc8771b1dbeb3ab1564b05c5b1e56cdf90
Can you please try to order the files? We should attempt to keep the list in alphabetical order. Please keep in alphabetical order if you can Could you add type hints here? - hass: HomeAssistant - device: ??? - coordinator: ??? - return type should be None There seems to be a typo on line 121 CONF DEFUALT ALLOWED Please add the type hint to the coordinator: Is the zone needed? Existing switch platform has it set to only device.name you are correct, the switch has device attribute which suggesting zone, in scenario I added the zone name to the device name, but I'll remove it. The type hint is not needed here, as it is (or will be) inferred from the library. It is recommended to avoid using the attribute property when reading the value Side note: I think you should keep the carriage return here - it makes it easier to read with the carriage return kept in place how? can you suggest? Suggestions don't work on "deleted" lines. You'll have to edit the file I know, I am just looking up carriage return and I understand its the special character ' r' which return the console cursor to the beginning of the line, I don't understand how it fits here... I added it back in. The coordinator was moved to a separate module button mac formated is misspelled, missing a t.
If you set this at the class level you will avoid a new list being created for each instance of a device. You could really do this way any constant value that doesn't depend on the device, but in Python the int and string values will point to global instances rather than create new ones anyway, so it won't make a difference there. Thanks ViViDboarder, how do you suggest handling this? I think this needs to be adjusted similar to SwitchBeeSwitchEntity , with a local TypeVar : These are already defined in the base class, you don't need to override them: L384 I know but I override them with specific return value as they were failing mypy as they returns Optional[ Type ] It is better to add assert ... is not None to help mypy in those cases. They are typed in the base class Please use similar logic to the one in light.py I think the code will be much cleaner and easier to use if this is merged into operate bellow Spelling mistake here: I would use climate here as you are setting up the platform. I think you should make this an internal function: If you add a type hint here, then line 157 can be converted to assert self.hvac mode is not None The same can be done on FAN HASS TO SB: I remember it is not recommended to use ternary operator over multiple lines, so this can also be modified to: Yes I forgot about that. I was focusing on the type hints too much. I think in this case what would be better is to avoid the four new variables: I agree, you suggestion is also more clear to understand It is recommended to avoid using ternary operator when it spans over multiple lines Another short option is to assign a default and update it:
device class is static, so it can be a class attribute: No need for type hint here, it is defined in base CoverEntity I think this needs to be adjusted similar to SwitchBeeSwitchEntity , with a local TypeVar : I wonder if it wouldn't be more readable if there were two classes: - SwitchBeeCoverEntity which inherits SwitchBeeDeviceEntity[SwitchBeeShutter] - SwitchBeeSomfyCoverEntity which maybe inherits SwitchBeeEntity[SwitchBeeSomfy] Let's see how this plays out after you rebase on latest dev. I'll just note that SwitchBeeSomfy has no state (its not pulled by the coordinator), it only can be controlled. I still think that instead of having a condition inside every function if self. device.type DeviceType.Somfy it is better to have two classes. I'll try attr supported features should now be a class attribute I'm not sure if these two are any use anymore. Maybe look at attr assumed state . Unable to find examples Since both are unknown, I think you should: - set attr is closed None as a class attribute, because CoverEntity doesn't have a default. - remove attr current cover position and leave the default value None from CoverEntity - and at this stage you should be able to remove the init method since it doesn't do any customisation anymore attr supported features should now be a class attribute I think you shouldn't call async add entities twice. There should be a way to use itertools.chain for this it works :) I can do this: But mypy doesn't like it: This check is no longer required. It can all be un-indented. This else is not required. It can be un-indented. You can create this helper in the base SwitchBeeDeviceEntity : And replace this with:
I think this needs to be adjusted similar to SwitchBeeSwitchEntity , with a local TypeVar : Why not use SwitchBeeDimmer type? this is the only type expected here If it's the only type, then TypeVar isn't needed. You can use: I think this can be private I think this can be private Adding tests is great, but maybe keep those for a follow-up PR to reduce the size of the PR Adding tests is great, but maybe keep those for a follow-up PR to reduce the size of the PR Ok, I'll remove them from this PR for now Unless required for this PR, please keep for follow-up I think it is preferred to have "sentences": I think it is preferred to have "sentences": I think it should be possible to move this to SwitchBeeDeviceEntity I think it should be possible to move this to SwitchBeeDeviceEntity I think it should be possible to move this to SwitchBeeDeviceEntity so the code isn't duplicated Should we do the refactoring here? or in a separate following PR after having the other platforms in? I think that you can also add handle coordinator update , and a stub for update from coordinator Please also remove adjust the corresponding code from switch . Edit: removed incorrect suggestion Cancel that, don't add handle coordinator update , and update from coordinator . Please do remove adjust the corresponding code from switch . This is static, so please make this a class attribute You will also need to add attr color mode ColorMode.BRIGHTNESS as a class attribute What is the point of this? True is the default else is not needed here. You can un-indent below. You could invert the check here and return early. Then you can un-indent a second time: else is not needed here. You can un-indent below.
I know you'll probably put this in the documentation page, but it would be good to have some comment indicate what value is expected here. In digging I found that this passes through to the [Requests library]( client-side-certificates) and appears to expect either a tuple or a single string path to a certificate file. In this case, it'd be a single path I suppose and would need to include the private key and the certificate. ViViDboarder, yes, its the path to a file. I created a PR for the documentation here There is also a feature request here: where I talk about the change. We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
Please explain what these attributes represent. Some of them could be eg binary sensors instead, perhaps? Sounds like the integration should be refactored to represent different partitions as different entities. The fire alarm and alarm sounding reports should be binary sensors, if I interpret them correctly. I don't find any info on panel type. What is that and why is it needed as a state attribute? The changes in the PR are geared towards a short term solution to provide users with a mechanism for working with multiple partitions. Longer term the alarm decoder library would require changes to facilitate a refactoring of the HA integration. - mask - having an entity per partition this attribute would not be required but could remain as metadata for troubleshooting debugging purposes. - fire alarm sounding - a binary sensor is ideal . Exposing the attributes now is also more of a short term solution. Having an entity per partition would require refactoring of some of the existing attributes as well as they are not partition specific, but applicable to the alarm system. Current Attributes: - panel type - the idea was to expose more panel metadata. In hindsight, not sure how this would be used. At a minimum if included, it should probably return the literal value. It appears to distinguish between ADEMCO DSC panels. None of these attributes are in line with our entity design rules. We shouldn't add any of them as a short term solution. The solution is to expose the values as separate entities. Without the 'mask' exposed, this integration is almost unusable for a system with multiple partitions. The Alarm Decoder repo (not HA integration) does not appear to have much activity which is concerning. I'll look into making changes into the Alarm Decoder api, and maybe eventually more on the HA integration. I'll just close this PR. Thanks Martin!
We should add tests and not reduce coverage Well the update.py is a new file that did not yet exist, but I will look into tests. Alright I finished writing full tests for the update.py file Since the installed version is identical for both entities I think we can remove it and hardcode it in the entity property done Since the installed version is identical for both entities I think we can remove it and hardcode it in the entity property done We can remove the Shelly from the lambda as it is not used done This can just return the version instead of using EntityDescription done Shelly is not used so no point passing it to the callable I removed it Same as for block device, can be hardcoded and remove shelly done I wonder... currently, when the user clicks the Install button, nothing happens in the HA, there is no information about starting the installation. Maybe we should set here True for in progress property and reset it to False after the next update of installed version value? installed version will get the new value after installation when the device is restarted. I can do this, I will make some simple True False logic. I implemented some basic true false logic for the in progress. Can we track the installation progress based on NotifyEvent? Probably, but I am not so familiar with the shelly code, so I would like to leave that to a separate PR. Maybe someone from the shelly codeoweners is willing to implement that? Maybe lets try to make a True False logic same as for block devices? so at least we have some minimal user experience and we add progress in a future PR. I implemented the basic True False logic, however I can't test it because I updated all my shelly devices in testing this code. So I don't have any updates left. I know the rest works. For Gen1 devices you can downgrade using I am using it for testing, just make sure to take your correct device model and it is also recommended to downgrade only 1 version back to eliminate change in device settings. This is already included in the EntityDescription This is already included in the EntityDescription Yeah I'm blind. Why convert a string to a string rather than cast to a string?
Is it guaranteed that this function returns a list with at least one element? I was just about to fix that ;) Same question here I think ideally, some of this logic should be moved to the underlying python library (pyhafas) Not really sure, which logic you are referencing here The string generation and such in the native value function. That could be done in the python library since it's not inherently specific to home assistant You are right, that this is not inherently specific to home assistant, but it wouldn't fit into pyhafas . The library seems to focus on being a source of data and not a fronted. Therefore, it does not output any data, other than received from the endpoints. We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries. I suggest starting over from the beginning by running our scaffold script to get a solid base to build on.
This could be slightly simplified: For me as Java developer this looks strange but for python developers it looks most probably better. I changed it accordingly. Instead of recalculating mode.lower() three times below, store it in an instance variable. Makes sense to do lower() just once, I changed it accordingly Is there a world in which prop contains neither "supportedOperatingModes" nor "supportedModes" ? If so, op modes won't exist here (since you have an elif without a default else and you don't initialize op modes as an empty variable beforehand). Good point, I changed it to else instead so op modes is always available I would store this tuple as a constant so that it isn't regenerated fresh each time a new thermostat is instantiated. A class constant makes sense to me, but a module constant would be fine, too (be consistent). Yes that's more readable in this place, I extracted the tuple I would store this tuple as a constant so that it isn't regenerated fresh each time a new thermostat is instantiated. A class constant makes sense to me, but a module constant would be fine, too (be consistent). Yes that's more readable in this place, I extracted the tuple Store self.fibaro op mode.lower() in an instance variable instead of recalculating it. Makes sense, I also change to read fibaro op mode just once as this operation is far more expensive I don't know what type fibaro device.properties is, but if it's a dict (or a subclass of a dict), you can generally shorten situations like this from two lines to one: If so, take a spin through and see where else this makes sense. If not a dict, disregard. Unsure what class it is, python is just scripting so there is not always a type. If we do such a change I suggest to do it in a separate PR. I can try this if I find some time. Do you want to explicitly test for None , or is it sufficient to learn whether self.preset modes is empty? If the latter, this can be shortened: Here the idea is to check for None explicitely, so I didn't change it. To be slightly more explicit and self-explanatory, how about this? Also correct, I changed it. The auto HVAC mode is defined as: "The device is set to a schedule, learned behavior, AI." This is not the case, essentially, we don't know the actual HVAC mode at this point. Therefore it should return None (as in: Unknown). Changed as suggested. We can just try to instance it and return and suppress it failing. Changed as suggested. We are doing this quite a bit, should we just look this up in a dictionary? After applying the proposed changes in the code review this does only happen 2 times and with quite different code paths. So I think we should keep the current implementation. Changed as suggested. Let the enum try to resolve it instead Changed as suggested. Changed as suggested.
This isn't strictly necessary. Just to clarify, it's the as WEMO DOMAIN that isn't necessary? Changed in [e3de035]( Correct. That would only be required if you were importing a different DOMAIN constant from elsewhere.
IMO the name of this const FEATURE FLAGS FAN P10 P11 should be changed to FEATURE FLAGS FAN P10 P11 P15 P18 . Done
We should clarify that this is a config entry id. Just entry id could mean any entry id. We have many registries with entries in Home Assistant.
Why or instead of something like this? Being defensive in case user input would happen to contain the key, but with a None value. I'm not sure if that can actually happen in reality, but the price to pay for taking care of that scenario is so small that I haven't bothered to look deeper into it. I'm not sure how to trigger the reauth flow what triggers it, Changing the password in the router user interface does, and should be the only thing doing it. but I'm wondering if one can accidentally cause this by using other ways accidentally (e.g., by spamming the device with huawei-lte-api)? Preferably the reauth is not triggered by temporary login failures caused by such, right? Valid concern, and there's no way to be 100 certain. However, repeated attempts elsewhere using incorrect credentials do not to my knowledge make this integration receive any of the three exceptions we trigger reauth with. I would not be surprised if they caused a LoginErrorUsernamePasswordOverrunException to pop up -- that's what we receive when the router puts an (the) account on hiatus for a while before accepting new logins even with correct credentials -- but we are not triggering reauth on that. Okay, that's fine by me. I don't have a test device until some time next year, so I cannot now test this. For me this PR looks good to go : 1: See my comment above wrt default values for get() . Same defensiveness in action here. Consolidating the errors to have a single base class (like InvalidLoginException or similar) would simplify the code, especially when they are handled the same, if the upstream is perceptive for such changes. Good idea, let's see: I suggest we don't wait for that though, because it would balloon the PR scope a bit by requiring a dependency upgrade. Upstream was quick, upgraded to 1.6.3 and addressed in 733d96e041bc9efcfbba6639620f19d97bc6bd6e Why not simply let the potential exceptions to bubble up here? This will swallow them for anyone who doesn't have enabled debug logger, making logs less useful. I don't think a successful logout is an essential part of a successful config flow. In that sense, we shouldn't make the flow fail even if it fails. And it arguably isn't something to bother users about in the usual case, even in form of logging it. Debug is there to make it possible to diagnose without code changes in case we happen to run into a case where this matters. Unless we have a case at hand that shows this behavior is actually wrong or suboptimal, I think we shouldn't change it here -- this is what we've been doing for normal config flows already, with no problems reported that I'm aware of. Fair enough, that sounds good to me : 1: We normally patch the integration setup function in the reauth flow tests on success to avoid setting up the integration when the config entry is reloaded.
consider using self. attr unit of measurement Can you elaborate, what is the motivation behind this suggestion? I tried to replace the property with assignments to self. attr unit of measurement whenever our self. unit of measurment changes, but it doesn't seem to be working. Is there something more to it? Likewise for the native value and extra state attributes suggestions below. The base class already handles the property: L334 Ah, I had to use the spelling attr native unit of measurement for it to work correctly. However, I do find that the code becomes less clean, since now we have to remember to do two assignments any time the the unit is changed. consider using self. attr state consider using self. attr extra state attributes Don't think it makes sense to add static configuration values to state attributes Right, I see now that this is discouraged, I've removed these now. CONF UNIQUE ID missing ? I have added this now.
Can you use a dict mapping here? Can you use a dict mapping here? If Platform.LIGHT isn't last, Home Assistant uses the wrong name for the device. That seems like a bug in the integration. Its not expected to matter which order that are loaded in. We usually load them in ABC order for convention. It looks like it is using .label . Is that not populated until light.py has been loaded? Let me test and adjust accordingly. It may have been quietly resolved since the last time I changed the platform order. The label should be known given how discovery occurs. What should they do instead? Set the value using the Infrared Brightness entity. Sorry for the lack of clarity. We should tell them that. Let's make this a property so its clear its not expected to do I O None is the default value returned if the key is missing in the dict. Right.
Note to myself, we need to move attributes to the entity description. This device class should have unit ppm. available-device-classes Thanks for the review :smiley: I think the usual device class usage of carbon monoxide is in the context of indoor personal exposure measurement (e.g. smart CO fire alarms), in which case ppm measurements make sense. However outdoor air quality measurement of CO and other harmful gases are overwhelmingly reported in concentrations of g m , as is the case with this Airly integration. IMHO we should expand the device class to encompass both ppm and g m units. If you agree I'll gladly put this change into a new PR. Just had a quick look at UnitSystem and understand that this change is a bit more complex than just modifying the carbon monoxide device class. My approach would be to create a CONCENTRATION UNITS or similar consisting of the concentration units already defined in const.py . This could be used by the various device classes that measure concentrations of gases or particulate matter. Or am I maybe overthinking this? Changing the unit of a device class or allowing the user to change it, requires an architecture discussion. changing-the-entity-model It's ok to start one, but first we should address the issue here and remove the device class where we've used an incorrect unit. Understood, thanks for the guidance on this. I'll create a PR with some conversion logic in the Airly CO sensor so it'll report ppm correctly with the updated device class unit. I'll also have a deeper look at the UnitSystem design and put together an architecture discussion, after sleeping on it I realized that it can't be a straightforward unit to unit conversion as the calculation between ppm and g m varies for each chemical compound due to different molecular masses. See requested change in PR 78649
I don't understand this formula. Why do we add the number of installed files to the progress quotient? the idea is that if there are multiple files, we need a way to track progress to 100 across all of the files, but we don't know the total number of fragments in advance and the callback is separate from the place where we track when a file is done installing (the logic is in the service function). So if there are two files, one file is done, and the next file is 50 complete, this formula would work out to 150 2 75. The first file is 50 , the second file is 25 because it is halfway done. Does that make sense? Yes, with your explanation it makes sense. Thanks!
Should be not too bad to get re-auth working for this. I think the config flow docs for this are not ideal, so happy to help with this part and tests. I've added tests for the config flow, and i'll add reauth support now. I thought we were going to wait for the next PR but this is good. I'd suggest adding an optional table range here too table range in case someone wants to append to a specific column other than the first. I would keep it simple, in what scenario should a user be so specific about it? Also, can we insert the current timestamp as the first column? I think that if we want to support a table range, it should be configured at config entry level. But I suggest we start without. date and time of recorded events is also important. balloob do you have a recommendation for how we'll present this integration from a user perspective? We previously talked about having everything in google but i know we're moving towards moving related integrations at the UI view instead. (Plus there are big auth differences since calendar uses device auth, though this integration has the right long term approach using web auth. Users can likely share creds web auth with nest so we could also merge there if we want) Integrations v2 seems like a good solution to keep these all separate. Is that in proposal state or something real? I really like this first simple implementation where the integration only has access to a new google sheet that it created. That is great from a security perspective. I imagine for your use case you you told me about, you need to open this up to give access to other specific sheets? I am curious if you have thought about what the config flow would look like for this (e.g. config flow can either create a new sheet, open an existing sheet w read write access, etc) or if there are other principles here you are thinking about? The point is to keep this PR small. I plan on adding support for access to all spreadsheets from that account. I could not gather from the Google docs how to grant access to a specific file other than just creating one with the app itself. The current scope would be the default behavior. I imagine being able to flip the switch in config options like you have it in calendar. Yes, i'm not suggesting you add this now in this PR, i agree with keeping it small. Was just trying to get a feel for where you thought this might go in case it comes up in the future (people will ask for it so wanted to be prepared) use ConfigEntrySelector from homeassistant.helpers.selector For easier reading, you could move this method outside of the append to sheet definition. Add the call to the executor call Should you trigger re-auth if you get 400 status 500 like during setup? Yes but I'm sure how we handle that outside of entry setup. In a future PR, we should think about how to handle rate limits. Perhaps cache events in small batches will be a good idea. I think we do this: L255 shouldn't the reason here be cannot open spreadsheet? Up
I think calling set confirm only() is not needed here.
Move the updated field value to the iterator items.
What does None denote here? Indeed not needed anymore. I previously needed it to also be able to handle devices without HVAC action, but the new way defaults to None in any case This comment is not accurate, I don't think we're setting up light groups here :) Adjusted! Can we pass TEMP CELSIUS and TEMP FAHRENHEIT in directly? That way we only have a single-line assignment Can we use statistics.mean here? statistics.mean Done!
Would this be better as functions: get astral event and get location astral event with a next boolean argument to indicate next or previous? A lot of the code between the two functions is common. The existing functions get astral event next and get location astral event next could just call the more general function with next True . Thanks for your quick review. I considered that but was worried that it'd make the logic harder to read and understand. For example, it'd lead to lines similar to: I'm ok refactoring as such if you still believe it's the right choice for the codebase. What do you think? Swamp-Ig Sorry didn't mention you in my prior reply. What are your thoughts on path forward? I don't mind. Although I am listed as a code owner, I don't actually do a lot of HA work anymore. Unless one of the other devs has a strong opinion it LGTM.
"serial" here is just a coincidence, right? It's not a requirement of this PR, right? That's indeed just a concidence This should have rang a bell IMHO, as a serial number IS an identifier. A serial number IS an identifier, for which we already have a property.
Please drop all the translations except en.json as these will be generated by lokalize Will do. Copied all from another BLE integration since the strings were the same, but I wasn't sure how that was supposed to work. Thanks! Definitely no rush; enjoy the holiday!
I don't think you should use self. attr icon here. I think it would be better to use either or Sounds good! I am not sure if adding the "sensor" prefix is needed here, but anyway you should avoid accessing self. attr unique id for reads. I don't think either of these are good practices, if we don't like how the super class sets the unique id, either: 1. rewrite it: here: 2. Don't set self. attr unique id, implement a unique id property method instead. I think what I'll do is set self. attr unique id on the base class, and then on each entity I'll create a unique id property to massage the unique value into the fully namespaced unique key for that entity. How does that sound? has entity name is redundant, as it is already set via attr has entity name : Same here, has entity name is redundant, as it is already set via attr has entity name : I think this is the default when entity category is set I don't think it is. I'll double check. Confirmed. If I don't set this property the entity remains enabled. It doesn't seem like the super class sets self. attr icon ? I just fixed this locally to fix the tests We should not both set attr unique id and implement a unique id property, do only one. Yeah this was an oops. Caught it while self-reviewing. Already pushed a fix. Just returning None here is clearer IMO Sure! This can be removed since all sub classes now implement a unique id property I think I would still move this to init and use the attribute (in both switch and sensor platforms): emontnemery thoughts? I don't have strong opinions here myself and am happy to go whichever way is more proper. I think (but I may be wrong) that the original issue for the request from emontnemery to override the property was with the call to the parent value (via super().unique id or super(). attr unique id ). Since that no longer applies, I think it's ok but let's wait for his confirmation. This is the logic that I normally use to decide on attributes: - if a standard property returns a constant, then it should be possible to use a class attribute - if a standard property returns a fixed value can be defined in init then use an instance attribute - if a standard property returns the value of a variable, then that variable can usually be replaced with the instance attribute Makes sense! I'll make the change! Minor tweak to make it fit on one line: If you use an intermediate variable to get the valve id, you can reduce this to three lines instead of four. Also, slightly unrelated but valve index: int on line 39 is not needed as it is inferred from the definition in init Made the first change. I'll address valve index in another PR (because you're right) as I rework the switch platform to use entity description and add more switches. Does this need another update before adding the entities? I think my tests were failing if I didn't have that at the time. Let me take another quick pass locally and see if I really need it. removed these We generally aren't allowed to acce
Could you add type hints here to enable type checking? The other async send message calls in the same file are missing type hints. I'll add type hints to all of them: like so: async def async send message(self, message: str "", kwargs: Any) - None: (I copied this from one of the other notify integrations) That's the idea, but if you are not feeling comfortable with this change we can add them later. I'm fine with that. I just wasn't sure if you were looking for more accurate types than those so I wanted to confirm.
Do we need an explicit False check here? It's there because I find "if x is True False" syntax far easier and quicker to parse than "if not X". Is there a particular reason why "If not X" is better in this context? For me, it is less to read, but I agree it doesn't make much different though. The async register entity service should wrap this for you
Should already have a type from the parent Please split up ternary operators that span multiple lines Usually we don't use a list comprehension to mutate data I needed a way for MockLifxCommand to return specific values without having to define a class for each mocked command. If you have another way of achieving this, I'm all ears eyes fingers. Ah, gotcha. All Light objects created by aiolifx get this set to None, but it will also cover the case if a HEV bulb hasn't managed to have its HEV state retrieved yet. I still need to write a test case for this. Why change this to not raise UpdateFailed anymore? Because according to coordinated-single-api-poll-for-data-for-all-entities: And this is being called from within async update data() Stale docstring. I'll fix this up in 77546
You could probably use a lambda here as well to avoid the getattr If you implement generics, this can be highly optimised. I am not sure if it would work, but maybe you need a double-generic to handle cast type separately from RobotT. ie. Generic[ RobotT, CastTypeT] You could then also set options fn to return list[ CastTypeT] I was just about to ask this question as I haven't been having luck here. The problem I'm then running into is you can't instantiate something of TypeVar as it is only for type hinting, or so the errors seem to suggest I've run out of time today. I'll try to have another look tomorrow if you still have difficulty.. Thanks for all your help today. Also, maybe cdce8p has an idea to implement this in the meantime Two lines Two lines
As with button entity, I suggest that you use a RequiredKeys mixin class for the compulsory items If it's a required key, you can keep the old return: Mmmm. Maybe two lines is better than three As above Ideally, if possible it would be nice to get rid of this assert in a future PR. I did this in
I think press fn should not have a default value. Instead you should create a Mixin class. Something like this... This can be reduced

I plan on adding these as supported brands in the future once I have a few more of the devices in hand. ... Aliexpress shipping is slow Maybe even make it more user friendly: This isn't used. Dropped here
If this is added here, it should be removed from entry ext dict below
And therefore we can drop lines 307-311 dgomes thanks! Addressed, mind taking another look
You can use a config entry selector instead This should not be targeting devices or entities.
This one is old. You should use I've updated the scaffold script in 77429 Also, you should start ecowitt first before setting up the platforms or else the platforms might hit an unstarted ecowitt API. Can you raise ConfigEntryNotReady if we cannot connect? We will get the data pushed over the ecowitt protocol at this port. We don't call the device Add the return value of this to entry.async on unload so it's removed when config entry is unloaded (removal reload config entry) Why make mapping values a tuple if you always get the first entry ? Make sure that this callback is removed when removed from HA Instead of a tuple, instantiate SensorEntityDescription objects here. Inside new sensor , use dataclasses.replace(description, key X, name Y) to create a new object. That way you get type checking for your sensor definitions. pylint not alow elif after return What is the path used for? Any reason this should be chosen by the user? Can we make it the config entry ID. Also, the default here will be the same for each user The ecowitt protocol is without authentication. Everything can push the data which finds the port over a port scan. It allows us to set an Path, and that gives a bit of security if the user wants this. you can't assume that only the ecowit identifiers are attached to a device. Filter it out by looking at first entry being DOMAIN . Not needed as this is provided by the entity description (or it can be removed from entity description). We have this helper to check for existing entries with the same data. L1281-L1285 It's more appropriate to abort with already configured reason than saying it's an invalid port. Not used. Why is the library using calver? How will we know if there are breaking changes? strings.json file is missing. What do we mean with this? Use the Ecowitt App (on your phone) for your Ecowitt WebUI at the device Do we need a title? patch uses an AsyncMock by default if the target is a coroutine function.
I think raising HomeAssistantError here (and catching in the websocket) would be a good approach rather than checking the type of the return value. Not sure if its right to call these "exif orientation" values in a comment but i think something like that can be helpful for looking up what each of the numbers mean. I could also imagine a comments like this: if orientation 2: Mirrored and if orientation 3: Rotated 180 degrees, upside down (or using constants... but likely not needed) I ended up moving the transform functions into a tuple for fast lookup, but I put the comments in there. Is this related to the orientation change or can be a separate PR? You got me. We can remove this and submit it as a separate PR. I suggest splitting this up into a few different tests (e.g. with unique id, without unique id, etc) -- just for making it easier to follow exactly what state is under test for each scenario. Ended up splitting it into two tests, one for preload and one for orientation (the case where both values are updated simultaneously is no longer exercised, but the frontend does not send that anyway). It is typically preferred to not dig into hass.data during a test. Can you use the websocket to read prefs to verify pref state? Please only wrap the line that we expect to raise in the try... except block. Sending the result shouldn't raise, right? Thanks Martin. I'll make a follow up PR to change this and the comment below. It doesn't return a string on error.
I don't think we should have a colon in the name, just a space. I think we should remove the dash too. Shouldn't the entity name just be device name Motion detection? I don't know enough of the use cases to speak to it but that sounds reasonable
We were actually writing state twice here. We don't need to do that until the advertisement has been processed so I moved the super call to the end. It wasn't noticeable until we added lights since the state could flip-flop This comment is now on the wrong line Thanks Fixed in a3e6f50c23 Is it intentional to change the timeout from 55 to 30s? Yes. It was way too high. It was left over from when we had a much less reliable bluetooth stack
I'd recommend implementing a method, instead of a string, that calls a specific api method so we get typed calls. The library should preferably be extended to use pydantic so each api call response get completely typed. Added TypedDict to the lib now and typed this call. Ok. I'd still recommend extracting the api call to an abstractmethod so we don't need to cast here. Done. This could have a TypeVar as return type which is set by the child class. Change to all lowercase? Should this sensor implement a custom device class? Can we guard against the same printer getting set up more than once somehow? Only when using dhcp discovery do we get a MAC address. I could add that in a follow-up PR.
You might be able to simplify this a bit and offload the heavy lifting to native code with something like I just realized from reviewing the documentation PR, that this is actually a comma-separated list hidden in a single text field. I think this should not be allowed or merged (and maybe reverted). Instead, lets use a multi-select, allowing users to uncheck items from a list (instead of having to deal with unfriendly string). What's the difference between this option and being able to disable a device which the user can already do? Unless I am missing something, you cannot disable devices only entities. I see some code referencing in device registry about disabling devices, but I cannot find anywhere in the UI that allows it or integration that does it. It's available under the device name edit. So, it is. Really inconsistent UX that Disable Delete are in different places across the board. That would make this PR completely redundant then. That would make this PR completely redundant then. Probably makes sense to revert it now before it goes out to 2022.9.x and then we don't have a breaking change later. I was thinking there was a reason we needed to ignore it from coming back though. Never-mind, that was from an earlier iteration. Assuming there is agreement, I think we are all good with a revert and the prescribed method should be to disable the device if they don't want to adopt it.
Please also change the type annotation of the platform parameter in async setup platform . We should probably use the new entity naming guidelines: entity-naming I thought about that. Do we want to start here and then do a separate PR to clean the rest up? I thought we could do it all in one PR but I guess it makes no sense since this is independent of the other entity classes If it's a user input error we normally raise ValueError. should we raise HomeAssistantError from ValueError(...) ? If I recall that's how the service UI picks up the error We don't want users to be able to ignore bad input. Understood! Are the release notes useful for automations? Are these links or just text? How many characters could there be? just text in markdown format. I'm not sure if there is a limit on this. Maybe this doesn't need to belong here. I would ask though, where would a user go to learn about the different versions available so they can understand the differences? Maybe we need a firmware DB? AlCalzone thoughts? No limits so far. Some examples can be found in L20 and the other files. I expect most of them to be similar, see e.g. [Zooz]( or [Inovelli]( V157 - 06292021) for examples. I think showing the changes where the update is makes sense, so users can easily decide whether they need it. I don't think we should add the release notes to the extra state attributes. We'll show the release notes for the available update. got it - maybe a feature request then to add a URL to link to to get more details? Right now if a user wants to install a version other than the latest, they'd have to chase down what that includes. Here maybe we want to raise HomeAssistantError as it's an api call error and not a user error? Maybe include a message as exception argument? I can just wrap the error in it right to get that text back? Yes, if the original exception has arguments stored they will be used as string representation. Can we check for sleeping device first? Otherwise it will be pretty common that this fails. To limit the parallel updates, you can use a shared [semaphore]( asyncio.Semaphore). btw. I think that it's kinda wild that this command queries the actual device for it's current firmware? I would expect that to remain cached and maybe queried every time we first see it (on startup, whatever). This should only query the FW server If we support release notes we need to implement that method. release-notes I realized that release summary is wrong, we don't have one, so switching the property to be used there instead Maybe with a link? I don't think that we have to keep these around in the state machine. Write the state or else it won't show up in state machine. Why do we need to send all the individual files. I would have expected the Z-Wave JS driver to be aware of the Z-Wave JS Firmware Update server and be able to send some identifier to let it do the file handling in the driver. The driver doesn't keep state about available firmware updates. It returns the in
Can we drop this ?

We don't allow a scan interval option. The user can turn off automatic updates on all integrations that support config entries. Then the user can automate updates at the interval they want, with the entity service homeassistant.update entity . That just seems silly to me that a user would need to create an automation to update something more frequently when it can be easily added as an optional configuration instead. Just does not seem "user friendly" to me. Sure, we get your point of view; however, we also have been flooded in the past with requests on other variants. For example: Slower interval during the night, a higher interval during the day, no polling when not home, or more polling during the weekend and many other variants ideas. The homeassistant.update entity was introduced to provide a single way for everybody to create whatever they want or need. .. Frenck
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. More information about this can be found in Architecture Decision Record: - ADR-0010: decision

I recommend raising a ValueError with the message as exception argument instead. The message will then show in the frontend. We prefer doing this nowadays over logging errors in service handlers. For some reason the message from the ValueError exception thrown in remote.send command is showing as Unknown error in frontend. At the same time, 2 errors appear in the log, in which it is difficult to find our message. logs: Throwing an exception for example from select source is displayed correctly. Can you tell me what is the problem or is this normal behavior? The simple error was much more readable as it doesn't contain a traceback. I made changes but the problem remains. Doesn't the message, ie exception argument, show in the frontend after it says unknown error? Doesn't the message, ie exception argument, show in the frontend after it says unknown error? Nope, only unknown error. ![ezgif-3-b6d6004764]( I've asked the frontend team if they have a clue. This should work. If you print the exception instance before raising it, does it print as expected? Yes, the message prints correctly in logs: This is currently a consequence of the dev tools implementation in the frontend. The message will show in the normal frontend outside dev tools. Is there an entity card for remote entities? As I know, there is no special remote entity card for sending commands. If wrap the call in a script and run it, the message is displayed. img width "600" src "" P.S. It's hard to read such a long text as the popup disappears after 3 seconds even though I hover over it. It's ok to log an error if that's more user friendly, for now. : 1:
Please only wrap the line that can raise in the try... except block. Store the connection.update return value in a local variable that we can check further below. Store the config entry here instead. Please keep this test. Can update successful be falsy without raising an exception? Indeed it can not... Thank you, and fixing now. We want to raise UpdateFailed in this case.
What is the correct format? Are these always boolean values? Yes they are always boolean - the boolean is whether the notification exists or not. What does default mean in this context? Default would be the initial notification state. So if the notification isn't present its what the value is set to. So for bridge - its going to be TRUE (connected) Where as for the other notifications it will be FALSE (no leaks detected)... Should I update the comment accordingly? Can you pick a name for the variable other than default that better describes the intent? Does initial value work? Since you are mutating them here, maybe make notifications by device a set() instead and only add the ones that are in the notifying non-default state. I was thinking you could make this a set() and then only add the ones to the set that are in the on state. Then your binary sensor check becomes a simple check to see if its in the set or not So the main issue I'm running into is I need to process ALL notifications first before I can turn them into a set. I did, however, make updates that stores a set of active notifications Bridge notifications are basically: "Is it disconnected", so a True means disconnected but if it reconnects you end up with a False notification - so after processing through that (via a dictionary) - I can then capture a set of active notifications (which I've done). Here is an example of how the bridge stuff comes in: So by dropping into a map dict you get just the "latest" notification I think you can make this much simpler with something like the above (you may need to adjust it for the bridge notification key) Looking much better Can we avoid adding it and then discarding it ? The issues is we get an array of notifications and if the user hasn't cleared them in the past we could get BRIDGE DISCONNNECT BRIDGE CONNECT BRIDGE DISCONNECT I guess if need be I could filter the entire set of notification on BRIDGE NOTIFICATION and take the last one.... and if its disconnect add it, and if its not don't... I'll try to mock that up and you can take a look. But I'm not sure if that's more or less elegant than removing a notification... I think I may have messed this up actually... because I'm not looking at device id... Ok rewrote the code a bit better this time. I think there was another PR where this key could possibly be missing and we need to skip ones without a location. Maybe move that into a new function which returns only valid devices and use it everywhere? Was it this PR? I just did a little list comprehension instead of dropping a new method in: Untested, but you should be able to write it like this which is a bit more efficent You could write this is a single expression This could be written as a single expression although its not much better since the long properties chain makes the code less compat
This is what an alarm control panel is for? It supports the triggered state. This is not for the whole alarm, but for a specific zone (e.g. motion sensor). This is the only way to figure out which zone triggered the alarm. In other words, when the alarm is triggered, both the alaram control panel and the relevant zones, change their state to triggered (initially it was an attribute on the zone, but I was asked to separate it into a new entity) This is not for the whole alarm, but for a specific zone (e.g. motion sensor). This is the only way to figure out which zone triggered the alarm. In other words, when the alarm is triggered, both the alaram control panel and the relevant zones, change their state to triggered Right, so, why isn't its own alarm control panel entity again? Because I do not understand the reasoning behind it being a binary sensor. The only defense given right now: Because the other thing is already an alarm panel? But, nothing is stopping us from using multiple alarm panel entities? A Risco system is comprised of partitions and zones. Partitions are actual alarms - they can be armed, disarmed, triggered, and are represented by alarm control panels. Zones, on the other hand, are detectors (e.g. a window sensor, a motion sensor in the kitchen). They cannot be armed or disarmed individually. Zones are already represented as binary sensors that reflect when they re detected. This PR adds an additional binary sensor per zone (each zone also has a device) to signal whether this specific zone triggered an alarm. It s a single binary value per zone, that s not directly related to the state of the alarm. Initially I had this as an attribute on the main binary sensor for the zone, but was asked to split it into a separate one. Hope this clears it up. frenck does this address your question? While we're waiting, some additional context: The proposed binary sensor acts nothing like an alarm - it acts like a binary sensor with two states. The only way in which it's somewhat close to an alarm control panel, is that its on state can be interpreted in the real world as "triggering", which is close to triggered . However: 1. Its off state does not map to any alarm control panel state 2. With the exception, perhaps, of triggered , none of the alarm control panel states make any sense here 3. None of the alarm control panel services are relevant frenck anything we can do to move this forward? I'd hate to miss another beta If the zone can only have two states, triggered and off, it makes sense to make it a binary sensor and not an alarm control panel entity. To be fair, the zones itself can have multiple states - it's a collection of several binary sensors that are each independent: Not detected detected (this is the main binary sensor entity for the zone) Triggering an alarm not triggering an alarm (this binary sensor) Bypassed not bypassed (currently an attribute, will be split into a binary sensor in a future PR) Armed disarmed As far as I'm aw
upper isn't needed here. If you copied it from switchbot its only because of legacy libraries that we had to mutate it to upper upper isn't needed here. If you copied it from switchbot its only because of legacy libraries that we had to mutate it to upper upper isn't needed here. If you copied it from switchbot its only because of legacy libraries that we had to mutate it to upper Make a copy instead of mutating the constant as it will affect all other copies We can use connections here instead. CONNECTION BLUETOOTH What do you mean? Saw that it has a connection field, but should I replace another field with that? Just replace DOMAIN with CONNECTION BLUETOOTH . Just so that HA knows airthings device.address is the address of a bluetooth device. Oh, got it. What functional benefits does this have? :) If other integrations also talk to the device or the a device tracker integration is tracking it they can link the device This code is unreachable since you'll never get a discovery without it based on your manifest.json Please trapped the named exception and translate them to errors so the user gets feedback about what went wrong instead. UpdateFailed isn't intended to be raise in a config flow Do you mean that I need to specify exceptions to catch on ln 62 as well? Or just raise the exceptions using AbortFlow like in switchbot config flow? Normally when a config flow fails you return an error that is shown to the user - look for things like this: The "reason" is a key into strings.json, which is translatable into the users native language. That means you can't use string substitution like you do here. Instead, you have to catch specific errors, and map those to specific translatable keys. So try and catch common exceptions for things like "connection failed" and then map those to strings.json keys (adding new ones if needed). You can have a catch all for unknown failures too. It looks like AbortFlow does the same thing, though i've always factored my code to use the return self.async abort form. You still need to give it a key that exists in your strings.json, though. Alright : 1: added cannot connect and catching BleakError instead of just Exceptions. keys is the default commented code True, might seem like I haven't coded in Python for a while :D Looks like this test needs to be adjusted. We should test the result of the config flow. These aren't expected to raise exceptions since all the responses are sent over the websocket api which can't handle exceptions. Yeah, forgot to change the test. Also added a general exception handling now as well. Saw that there's an "unknown" reason too. Maybe make 820 a constant? Is there something else you can check as well. Many devices abuse this field and put random data in it so you might pick up something close that isn't actually using this field correctly Since there is basically no more data, I am a bit unsure. We're connecting to it for name S N anyways so could check: - Is connectable even? - Do we have 
As this will be one of the primary (and only media player) entities of this integration, we can just leave out the name. Add support for browse media? This will unlock the play media action in the automations and scripts editor (including TTS).
As this is pretty much core functionality, lets make sure we add tests. Added tests for common errors in automations and scripts. Are there any other tests or issues you would like to have fixed? Or can I resolve this? You cannot change a generic config validation method to support automation script specific config. ID is not always mapped to entry ID. Would it be appropriate to wrap this message-supplement in a simple if domain in ["automation", "script"]: or do you mean I shold split out the validation of those in a completely separate function? Not clear what can raise AttributeError here. Thanks for the review. This might be an artifact after some test I did before. Probably related to the comment regarding the previous lines. I just looked at the code, and it is a mirror of the code a few lines above: L482-L485 Because config is sometimes a string, and sometimes a dict. So without this, you sometimes get errors like
No other integration does this as far as I know. Please remove it. The start of the integration is already logged. fabaff removed The metadata of the module are outdated and paho-mqtt is pinned to 1.6.1. Please be more specific. Inels-mqtt module is latest release, so what do you mean metadata is outdated? And, yes paho-mqtt is pinned to 1.6.1 as same as for example mqtt integration. Inels-mqtt module is latest release, so what do you mean metadata is outdated? is 404 And, yes paho-mqtt is pinned to 1.6.1 as same as for example mqtt integration. At the moment is Home Assistant using paho-mqtt-1.6.1 . The module should have a constrain if it doesn't work with 1.6.2 otherwise the pinning should be removed. is 404 Module was in private repo. I change it into public The module should have a constrain if it doesn't work with 1.6.2 otherwise the pinning should be removed. I'll change it into paho-mqtt 1.6.1 . Will be released in version inels-mqtt 0.0.36 Changes to this file should be reverted not part of this PR. In what instances could this integration get configured with a blank host? You're setting the device class to the same thing in both places If the battery level sensor is only 100 or 0 this is probably better as a binary sensor This is not necessary, the frontend will already give a switch entity a switch icon Additional translations should be removed from the PR, they are automatically included at build-time. True is the default value of should poll, so this can be removed.
When it's None we're shutting down. Should we still send all other messages? Seems to work fine. Assuming non of the tests break, thats a much better design e7510cb21d78838dea136db0423d218d758398d9 Should we have a max? I threw 1000 message per second at it and it performed well. Not sure what to set a max to or if its needed this is only breaking out of the while loop to get all the messages. Not the while not self.wsock.closed: loop in loop fixed Put this in a finally and we can call return when we see a None We need to let the client opt-in to this new functionality? Otherwise things like Node-Red or the mobile apps won't work anymore. Added a supported features call to tell hass which features the websocket connection supports Let's type it. Should supported feature be int or float? I don't think we would ever overflow this so int is probably fine
It is better to use CONF HOST to avoid spelling mistakes. Either define in const.py, or in this case, it can be in homeassistant.const as it is a standard one same here - should be CONF HOST also, CONF HOST CONF HOST :) in most places in HA, the steps are not used as constants, but if you do, better to be consistent across all steps is this manager for entries or entities? both seem to be used I don't understand the difference? I could use some help here. this is a constant that you define, so it can be anything. usually, entries relate to config entries (usually one per who system) where entities are the various lights, switches, covers, etc. Just thought the code would be more clear if you define what it manages I think I got it. Fixed. you shouldn't patch the homeassistant component. Instead, patch the functions it calls for async setup and replace them with mocks to make it successful and return "True" We don't want readme files in the integration. This should be in the PR text It looks like a lot of the certificate logic could be moved into the hassmpris client library. We want Home Assistant to know as little as possible about the integration implementation details The thing is, this code (casting certs and keys from bytes to objects) is only needed because HASS insists on storing strings bytes -- the integration only deals in actual typed Python objects, like Certificate and Key . Short of moving these casting functions into helpers within the client, this actually belongs here and not in the MPRIS client. All of the logic of actually obtaining the certificate and pairing with the remote end is fully sealed up in the MPRIS client. What should I do? I'm 100 new to writing HASS code, I need your help. Thanks in advance. While we want to store configuration data in the config entry, certificates are a bit large to put in there since everything has to be serialized to JSON and back. Config entry storage isn't a database so every time its loaded saved all the data for all the config entries has to be processed. You can storage large data in .storage You can accomplish this in two different ways. You can pass the storage path to the library with hass.config.path . git grep for a few examples in the code base, and let it be responsible for reading the certificates from disk (in the executor please!) Also you can use homeassistant.helpers.storage to store the certificates. There is an example in homekit for aid storage. I almost always prefer the solution that has the least code in HA itself and offloads that to the PyPI package code since it reduces the review time to make changes to an integration and keeps things moving along. Roger that. The client module has no provision to store anything on disk -- it is stateless -- so I will factor out the certificate load save code to their own separate functions and proceed as you advised with regards to mirroring what homekit does. You don't need this. ConfigEntryNotReady already does all this for you. 
would be equivalent. If the given host is invalid, you may raise in try create and except it here to populate an error dict that can be passed to async show form so a user can eg. correct a typo. That is, if your connection test can differentiate why the connection didn't succeed. thanks. this is done only once in the configuration of the system and is not part of a big form, so I believe adding the extra checks will just add unnecessary complexity to the code the suggested change above makes sense. will commit it this is duplicated in async import step . not exactly, as async import also needs to do an async update entry, and this is also called from async step user. I can try to generalize, but they do behave differently Why would you cache in "dev", but not in production? you are correct. changed to using default value (true) I'd use build id ! "dev" done I think cv.deprecated should be added here now. thanks. added and pushed Should it perhaps validate config before saving? not sure I understand. the schema is being validated by the websocket api (homeassistant components websocket api connection.py line 200) just before the callback. I can run it through the schema again but I believe it will only add complexity. in addition, how would i test it? homeassistant will not forward a command that fails the schema. Ah okey. So the config will be validate by websocket. Then its fine.
You can replace this property with the use of self. attr extra state attributes instead of self. attributes Done (throughout the class) Don't double log... Thanks for the feedback! Should these be cleaned in the RESTful sensor code L143-L150 as well? Preferentially in a different PR, right? BTW... logging as a warning might be too much... I would use debug only Have removed double logging and downgraded to DEBUG level don't double log Have removed double logging and downgraded to DEBUG level you probably don't need attrs Do you mean to change it into: as attrs is not referenced anymore? Removed the uneccessary assignment startswith argument can be a tuple, so no need for all these call to startwith str.startswith I would make a constant and import it in both binary sensor.py and sensor.py (the latter in a separate PR). (or XML MIME TYPES ?) Is that ok - or would you rather duplicate the tuple in both files? or maybe use python's mimetypes ? I am not really able to utilize mimetypes in a helpful way in this case - I was not able to initialize an empty MimeTypes database (if I understand correctly, one would need to initialize it and then empty the dictionaries?). Any help is very welcome. Is it bad practice to have this in const.py ? completely acceptable :) Great - thanks! Has been implemented. I have realized that we are now missing text xml (which is not at all in included in mimetypes.types map ) -- from a quick survey it seems that the usual type is anyways application xml , yet I have read mixed opinions. Is that a problem? Shall we just drop text xml (will adapt the tests in this case to use the correct MIME type), or manually inject it to the tuple? (Sorry for all the noise) Should the state of the binary sensor be unknown under this circumstance? You mean in case response is None ? I would have thought so too, but this was the original behavior and changing it could present a breaking change for some users. The logic behind it might be that bool(None) gives False . So no response is an implicit False response. well considering the const.py approach, you can also revert back to use the full type...
This could have been public to mimic device and entity registries. Then most of the wrappers could be avoided perhaps. Not anything i require, but a thought. I'm trying to keep the underlying implementation from leaking out as much as possible since we have already changed it a few times (heavily with the split of the manager and scanner) and avoid breaking changes (most of the time) since I expect we will have to change it again when we have remote connectables. I think we generally avoid abreviations. adjusted in cfb5fe1a8228c704a88f7e4ae9f9a58dd7f2d6d4
Since you only use it to track first. Why not make it a boolean? Why not completely remove it instead yiha! It feels so dirty. Is there any way we can use [ shutil.copyfileobj ]( shutil.copyfileobj) ? I guess we can't because aiohttp is async. As far as I know we can't... Instead of including a large file in the repo, generate one on the fly in the test. You can use [ StringIO ]( io.StringIO) I think that you can even just implement BaseIO and generate the string on the fly. I used tempfile for it and made it a fixture. Same result without a checked in file. The problem is that this does a lot of I O. At least uploading we should be able to use a virtual file. Open the file in the executor and keep it open. Then do each write in the executor. Make sure you close the file handle if anything fails in a finally Thanks! Implemented it like that and it actually makes everything look much cleaner. Don't assign to self , this view could be invoked multiple times. Instead use nonlocal Good point, adjusted Move the dir creation code to when you set file handle. That saves a trip to the executor. Adjusted doesn't have to be nonlocal anymore. You should call [ task done ]( L290-L298) instead of using an actual file to upload, can we just pass a TextIO text-i-o Oh upps, you mentioned that earlier, should be fine now! Instead of doing an open like this with a finally, use a with statement: it will automatically close when you're done. it's always none. an empty byte chunk will now stop it too. Not sure if that can happen. Better to test for None ? Dont think this will happen but I tested for None now anyway Don't really need a fixture for this, it's only used once. You can do btw: I actually am thinking if we really need to write such a big file. Instead, can we patch out ONE MEGABYTE and so read out smaller chunks to test out all the queue stuff ? That way we avoid memory jumping and huge I O during tests Was on vacay, will have a look this week :). Brilliant idea, that works flawlessly! This puts the whole file in memory twice. Should we do this streaming ? With the file now being really small anyway I would assume we can ignore this? MQTT also depends on file upload, which now has janus as an additional dependency

How would this work for a motion sensor? As far as I am aware, motion sensors from Tuya are events, and only send the "on" state, not the "off" state. The Motion sensor within the light sends an off state event based on no motion being detected by the PIR within a defined time, The timings for this are defined in the "PIR delay" entity - which in essence defines the time the Light will remain on after motion has stopped being detected. Time can be defined between 5 seconds and 3600 seconds (1 hour) The problem is: Most Tuya devices don't send that. Hence it has been removed. Do you mean most Tuya devices in the GYD category or generally? The PIR STATE attribute only seems to be documented against device categories gyd (Motion Sensor Light) and dgnbj (Multi-functional Sensor), the documentation isn't that clear, but does suggest that pir state can contain one of two values ("pir","none"). The binary sensor does work as noted above against the LEDLIT LTFLPWIFI (reported as PIR-WIFI-2WAY) which I have tested against. Do you mean most Tuya devices in the GYD category or generally? Any Pir sensor in Tuya. Regardless of the product type. The implementation details you list, as manufacturer device specific, not Tuya rules standards. Please provide translation functionality for these values, by defining a custom device class and add the translations to the strings file. Translation facility added Please provide translation functionality for these values, by defining a custom device class and add the translations to the strings file. Translation facility added What would these provide for your device? The CDS level is predefined by Tuya to various lux values "2000, 300, 50, 10, 5, now" (reflecting Day, after dusk, after evening, after night and dark) . It defines the maximum ambient light levels the PIR will trigger turn on the light and trigger the Motion event when motion is detected. Translation facility added This is not needed to set. Additionally, this device type isn't just used for floodlights. Please remove these 2 lines. Okay yes that makes sense - thanks, will remove these 2 lines. sec is the official abbreviation for seconds, however, we just use the full name: seconds . Does this count down actively? As in, you do see the number going down while the countdown happens? The number counts down every minute if the PIR sensor is "switched off" when the device is in Auto mode. At 0 the PIR sensor is turned back on. The Tuya documentation suggests that this is a attribute that can be set, but in the case of the floodlight I was testing with, this field seems to always start at 5 minutes - so possible should be exposed to HA as a "sensor" rather than "number input" The number counts down every minute if the PIR sensor is "switched off" when the device is in Auto mode. A number is for settings and should not be used for countdowns. You can use a countdown sensor (sensor with a targeted date the countdown would be finished) and a number sensor for sett
Please limit the initial PR to a single platform. See also: 5-make-your-pull-request-as-small-as-possible Alternatively, pass the full ConfigEntry to the coordinator. Is that the preferred approach? I'm relatively new to Python but I figure having a class expect things like URL instead of taking the entire config would be preferred Don't use relative paths outside your own integration package. Good catch! I've noticed sometimes VS Code will use relative imports for homeassistant modules, I wonder why it chose to do it here Either extract the name from the device, or give it a default name. We like to keep the number of options questions in a configuration setup flow as low as possible. The suggestion is to remove the name field Integrations should have a default sane polling interval. If a user wants a customized polling interval, the homeassistant.update entity service can be used in combination with an automation to create any update schedule they can imaging. please remove this option. Can we detect this? Is this needed? The default link speed format is bit s, which I don't find particularly useful. That said, I also didn't want to lock users out of betting the raw data, so I figured a config option would be best. If you would still like it removed, I can just lock it to Mbit s Can the uid be used as unique identifier for the configuration flow? Won't this throw raise errors when the connection fails? The error is caught by get device id and None is returned, indicating the device doesn't exist. I have tested this manually by inputting a non-Starlink terminal IP address :) I have kept the separate variable to pass to async set unique id Maybe just inline this in the config flow above? Ideally this will be used for auto-discovery (since the typical Starlink setup has Dishy on a fixed IP address), I just haven't figured out how to do that yet Maybe move these to the constants? This could be part of a base entity instead (create an entity.py file and set the device info in that base entity. Extend all other platform entities from this case entity). I like that idea! This can be inlined into the update data function above, it is what it does. I'm not entirely sure why this dataclass is needed? get status already seems to return an object that can be used passed instead? It does return an object, but there's no type hints (yet). dataclass is there just so I get nice autocomplete outside coordinator Doesn't seem to be used? I don't see a confirm step? translations seem to be missing string.json is a source file for specific translations like this en.json file, yet, they seem to be out of sync. I see, have you got a link to any relevant documentation? I wasn't able to find much in the integration guide re. translations Did you consider using SensorEntityDescription pattern for these sensors? Would probably avoid creating a class for each sensor.
It is possible to make the code more compact and readable maintainable. Before the params variable, add: Now you can simplify the code: Please also adapt it for the other attributes, where appropriate. It can be removed if the suggestion above is applied. Services do support now be [translatable]( For consistency, please adopt the new service attributes to be translatable too. In the docs, you wrote that the following attributes are required if ATTR SUPPORTS STREAMING is set. Please add validation for it.
Excluded attributes should be invalid. How would that work in the backend tests? As this is a frontend feature? Nothing is filtered here, it's just configuration stubs. What balloob means is that we should fail validation of the selector if the selected attribute is an attribute listed in "exclude attributes" OK, I get the misunderstanding. Attributes are not banned, just not shown. Maybe I should rename exclude attributes to hide attribute ? Would that make more clear? If we don't want to validate in core: It is not about being willing, we simply can't. The attribute selector allows custom input, which includes ones that are not shown.
We generally avoid the use of state attributes as much as possible these days. What would be the use case to add this? (Also, storing a JSON dump in a attribute isn't really end-user consumable output). My particular use case is to allow support for room and zone level cleaning within HA. In order to do this you first have to setup the rooms and zones withing the iRobot Roomba home app. Internally the iRobot Roomba home app assigns a numeric values to each room zone. The problem is it doesn't expose these values. The current method to get these is to either use the dorita980 or rest980 (based on dorita980) APIs and retrieve the lastCommand. FWIW, the HA Roomba integration is based on these same APIs. Once you have the lastCommand you use that info to call the vacuum.send command service in an automation. Current steps to obtain this: 1. Disable the HA Roomba integration 2. Start a docker image of rest980 3. Repeat (In my case 8 rooms and multiple zones) 1. In the Roomba app, initiate a individual room zone clean. 2. Retrieve lastCommand from rest980 4. Stop docker image 5. Enable the HA Roomba integration 6. Update your automations. With this update you can eliminate steps 1, 2, 4 and 5. In addition to eliminating of the docker images. I used json because it is the same format required for the vacuum.send command service call. Storing this data in the state machine is going to write it to the database every time there is a new command. That could get large quite quickly. That seems like it would be better added as logger messages so you could enable debug logging and get the data. Leaving for anyone interested. I enabled debug for the HA Roomba integration as suggested: logs: homeassistant.components.roomba: debug Then running from a terminal window: tail -f home-assistant.log grep lastCommand I got the data I was looking for when issuing commands. 2022-08-21 09:09:42.938 DEBUG (Thread-3) [homeassistant.components.roomba.irobot base] Got new state from the vacuum: {'state': OrderedDict([('reported', OrderedDict([('lastCommand', OrderedDict([('command', 'find'), ('initiator', 'localApp'), ('time', 1661087382), ('pmap id', None), ('regions', None), ('ordered', None), ('user pmapv id', None), ('params', None)]))]))])}
I'd make this a standalone function as it doesn't need to know anything about the flow. It makes it easier to test this util function. This context manager does I O when exiting. We should schedule the whole call on the executor. I'd extract the backup handling to a separate function that we can schedule on the executor from this step. Raise exceptions from that function to represent errors. Instead of a form, can we use a "menu" ? [Example]( L82). Will allow translations too. ![image]( Oh nice, I wasn't aware there was a component for this. Should we use it as well for selecting a serial port (the first dialog shown when you try to add ZHA)? img width "397" alt "image" src "" It looks much nicer. However, there is no longer a default: it's only suggested by the order of the menu options. Is something like a (suggested) suffix good? It doesn't appear there is a way to hint to the frontend to make on mwc-list-item more prominent than the others. What if it's not a valid backup file or invalid JSON? Ah I see now that async step upload manual backup guards for ValueError . Does NetworkBackup.from dict also raise that? It does. It will fail if the wrong JSON file is uploaded. Should we split this out into a confirm step and only show when we detect that the backup has a different IEEE ? That works. It's an extra step but it does make things clearer and can be used for both automatic and manual backup restoration. Can it be that choices is empty here causing an IndexError for choices[0] ? choices will always contain at least one element because the "automatic restore" choice won't be displayed unless there are backups. Can we improve these titles? Maybe in a different PR. Most people just have 1 stick, can we call the first one just no title so it is shown as integration title in HA? If there is no way to overwrite the IEEE address, what is the effect of restoring a backup? If it won't work, we should abort maybe or show an error and pick a new option? Why is file upload not a hard dependency? This should inherit the base flow class as we're using that api. This needs to go in the executor thread pool. I recommend completing type annotations for the changed code in the module when working on the integration. We try to avoid multi-line ternary operator expressions. We're going to fix this in a next PR with a bigger overhaul of the titles. Why do we need to handle this? Doesn't the core take care of finishing tasks before closing the loop?
These changes are not related to integration and should not be located here. Thanks for spotting! It wasn't meant to be included. Fixed. Same as above. Same as above. Same as above. I don't think we want this kind of general TODO-type comment in the code. I went over the PR and cleaned up such comments, which were intended for our internal use and which slipped through. Sorry about it. You can't await in init . What you can do however, is to add an async method async def async setup to AirWCoordinator and call that after you've created the object. Thanks for the suggestion! Done. Instead of this comment, you can define a typed dict AirQData and do: Thanks for the idea. While I like it in general, I stopped seeing the need for such clarification anymore and thus removed the comment. Instead of asking questions in comments, please do your own review of the code where you ask questions or add some more detailed explanations which shouldn't be in comments. This should be debug or info since the user will get feedback in the config flow already Fixed You shouldn't have to do this, the base config flow handler should handle it and give a reasonable error message to the user already. Try raising some arbitrary exception and see what happens. Perhaps, I am missing something here. Simply omitting this except-clause fails tests.components.airq.test config flow.test form unknown error . Am I testing a wrong thing there? There's no zeroconf step in the config flow? Thanks for spotting it. Unfortunately, I had to retract this as our zeroconf support is not yet quite ready. Only en.json should be included in the PR, other files will be automatically generated. Remove these empty sections as well. Do not log errors there. The user will be notified of the error in the config flow UI. Sorry for missing this one in prev commits. I am assuming, LOGGER.debug is appropriate still? LOGGER.debug is ok. This can be removed (with test also). Otherwise, specify the error and set the appropriate message. I think such comments are redundant. get() returns default value None if key is not available. Thanks for the hint! I think this comment are redundant. Or you can make it more shorter. Catch ClientConnectionError at top level instead inheritance. Right, thanks! Done.
Do all hive alarms support this, or does it need to be conditioned, for example depending on the model of the alarm? emontnemery hive only sell one alarm model so yes all alarms will have this feature
While this all makes a whole lot of sense to me, I do think the method name is misleading. It is not waiting for an entry to load; it is waiting for a component to load. Good point, renamed to async wait component
This removes the logging, as previously done below. However, the script itself already logs this too. So, previously, unknown services would show up in the logs twice.
This is advice, but not something one should repair. Repairs are for things that should be actioned, otherwise causing issues now or in the known near future. Relying on the cloud integration can cause issues, e.g. 64497, so there is a strong desire to push people towards the local API. I wonder if repairs should be extended to general recommendations like this. I wonder if repairs should be extended to general recommendations like this. I think logs and docs are better places for that. If we push everything into repairs, it will result in people being annoyed. We currently reserve them for things that need fixing. PS: 64497 is about hitting rate limits, which should be better controlled by the integration in that case. We cannot fix that by saying, "Use local", we need to fix that by preventing we hit those limits.
Could this potentially leak internal network details? I guess if you are to access it over it's external IP address, it could respond with either internal or external configured URL. So yeah, that's not good. Removing the endpoint.
This is a workaround to cope with psutil storing state between calls in module global variables. Alternatives could be to reimplement psutil.cpu percent ourselves. Yeah it s not so clean but the alternative would be to reimplement or monkey patch. from a maintenance standpoint this has lower risk of breaking vs patching and it doesn t add the additional burden of maintaining it ourselves It likely means system monitor is an issue as well though. Maybe it makes sense to make a PyPI that does this under the hood so we get a clean copy for every integration that needs it so we only have this code in one place This is now exported to a library: Should this be mqtt? or copy paste that was missed it's indeed a copy-paste that was missed :) Should we do something like this to keep the naming consistent with itself Better place for the comment Can we add the date time this is sent? I can add it in the frontend but may be best to get the timing from when its polled in the backend Please add type annotations. Can we patch the library instead of hass.data? Are the psutil calls async safe? The calls are opening and reading files in the proc virtual file system, I'm not sure if such calls can block? Reading proc can block agners thought it wouldn't block, at least not for the files our calls will read from; please see comments in the code: Do you think that's not the case bdraco ? Yes, reading from proc can block. But the two particular files we are reading proc stat and proc meminfo seem not to, looking at the source: L32 L108 There seem to be no sleep in these functions or functions it calls. The data is simply printed from current variables. The only return value is 0 (success). It's better to wrap all the sync calls inside a function and schedule that once on the executor.
It's inconvenient for the library user to have to pass the client session to every api method. Pass the session to the library client when instantiating it and store the session as an instance attribute on the client instead. We don't need properties for just returning the instance attribute. We can remove most of these properties. This function shouldn't return anything. What's a block, concept wise, in this integration? Renamed this method. Max debug level please for these kinds of messages. Don't pass in hass . It will be set on the entity when the entity has been added to home assistant. This means you can access hass with self.hass , after the entity has been added to home assistant. Please remove translations except the default English translation. Use the translations develop script for local testing to get an English translation. Please only wrap the line that can raise inside the try... except block. Use an else: block if needed. Please use our shorthand attributes instead of properties in the entity. entity-class-or-instance-attributes Where is the Device used? Removed the unused device. Why is this a singleton if there's only one config entry per SHC instance? If we only allow one config entry per integration we should have a guard in the config flow. Regardless the singleton pattern here looks overkill. This is not allowed. If there's no valid unique id for the config entry we don't set a unique id. unique-id-requirements Please import the livisi library errors as a different name. We normally use errors for the dict of string form errors. Why not use the controller serial number as id instead of the config entry id? I'd disconnect the websocket before popping the controller from hass.data. Please the the whole signature when adding type annotations. Please run the scaffold script for integration config flow to generate best practice code including test template. We need to check the host ip address in the same step that we enter the host ip address so we can give feedback there. Merge this step with the previous step. Please don't log at info level if it's things that users shouldn't need to care about. Users will see that the flow succeeded in the frontend. We don't need to log that too. Please always use lowercase snake case keys in the config entry data. This class doesn't inherit Entity so it's not allowed to be part of the entity class tree. I'd remove this for now as it's not needed for a single platform. We can add a common base class for entities of this integration later when the next platform comes and we know more how the platforms will be structured.
Was this file meant to be committed? It doesn't really matter. It's the output of python3 -m script.translations develop It will be overridden once translations update at night. Leftover debug print. 76865 Oh lol :D Thanks!
I'd reverse this conditional and continue here and below to reduce the indentation level to make this a bit more readable Done in ee03a0308519d6f7c7b3765b99288dcf642fa22d Is this changing any existing sensors? Is this changing any existing sensors? Nope, it isn't because sep key is by default, so it remains the same for the existing sensors.
This is probably left over from some copy-pasting To keep this in line with the other imports: This if statement should probably include a check for "media-source: jellyfin". Currently, when you using the Media tab to browse to the media player entity, an error is printed because the integration is asking for items with parent id "media-source: jellyfin". For these kind of commands you are likely going to get the feedback from the maintainers that this should be handled in the API and not in the Home Assistant integration. I got the same kind of feedback. You can submit PRs to and they usually respond very quickly. Will do. Then I can also improve the artwork API. That could allow the integration to provide the watched checkmarks and percent. I would indeed move these to const.py. Also note the typo on line 404 Use a separate list for this. The current selection is not complete, at least "Track" is missing (if you indeed intend to support music libraries). I'd like to support music libraries but I currently don't have any digital music to add to my instance to test with. I should probably set one up and test, or avoid showing it at all... You may want to add a check for supported folder types here. At least photo libraries do not seem to work at the moment. You can browse, but when selecting a photo a 503 error is thrown (in my case at least). This filters out the image and music libraries now. I might add support for those later, if I set them up on my instance. Though I doubt that the image server is better than photoprism :) To keep this in line with the rest of the code for future PR. moving these nested methods to browse media.py file is common practice and may be desirable for maintainability. I mainly considered merging this with the existing browse media code, as they do the same jellyfin side, and are similar, on the HA end. Iirc. (it's been a month or so) that should work well with a constructor function passed in, instead of hardcoded types. I just considered this PR large enough for now. so I kept it where I wrote it for now. also future but could move this to coordinator.py. for future might consider indexing the sessions by id so you don't need to loop in the media player coordinator uses events no Polling required Is there a reason this is done as second step? I'd assume the API rerturns the object with a missing field if it can't statisfy the childCount, and avoiding an API call should be preferrable to avoiding some bytes in other calls. the first call fetches the item by id, the second one gets children of item ID if type is a folder. I think before it was always making two calls based on if it was certain library type, I just use IsFolder instead. let me check again if ChildCount is available when you query item and we could maybe save the second api call it seems the child count can be unreliable when you first call the get item based on my install atleast. Not sure why but i have a few other bugs to report to jellyfin as well
Shouldn't we keep it at the best IoT class of all ways it gets data, or is all local push gone? It previously only had a push notification out of HA. Now it polls data into HA, so want to make it fair. The coordinator entity already inherits Entity . 77260
We generally put the coordinator in its own module. Please consider moving this to a coordinator.py file. We generally put the base entity in a separate module, please move this into an entity.py file. This should raise an ConfigNotReady as this is not a platform. Additionally, consider moving this logic into the coordinator (making that the central place of communications). The logic will stay in init .py as the coordinator is not the central place of communications, it only handles the sensors. The setup of the coordinator and its first refresh should be done when setting up the entry for the integration (in init .py ). Same as: discussion r947094925, I will keep it there as the coordinator is only relevant to the sensors. The only test requirement is a 100 test coverage of the config flow. You should add a test to this one. I think you should avoid adding mypy specific config. Try without first
Unused, thus can be removed. That said, please limit the PR to a single platform. It really makes things easier in follow up reviews (and this review). Not a real benefit to use a temp variable here Shouldn't the domain be: ? This is kinda implied Seems unused.
PlatformNotReady can only be raised from a platform. We can raise ConfigEntryNotReady here. We need to pass the original config from async setup as last parameter. L74-L78 L108-L119 This is code from webostv, I still dont understand what am I missing. Store the original config in hass.data and then pass the original config to discovery.async load platform as seen here in the webostv integration. done Please move this line down out of the try... except blocks. Done We don't need this function if we implement async get service . Done We only want to set up from discovery. If I do this change, then the yaml configuration will not be read. We can outdent here after removing the else block. We don't seem to pass the number in the discovery info. We don't seem to pass the number in the discovery info. Can you elborate? Are you saying that there is a bug here? Yes, we do not set CONF RECIPIENT in the discovery info when loading the notify platform. The discovery info is the fourth parameter to discovery.async load platform . But, if I do this change, then the config from yaml does not work anymore. E.g.: Yes, we shouldn't support config yaml anymore. That's legacy. The recipient can be passed in the service call as target. Please add this feature in a separate PR. This needs to be the hass config passed to async setup We don't need to do this change. This config will not be used. For a future PR: Nowadays we prefer raising a ValueError on bad user input and HomeAssistantError on api call failures, in service handlers. Pass a string argument to the exception when raising to show a message to the user in the frontend.

Mark the battery sensor as diagnostic? Our PM10 and PM 25 device classes should report in g m . available-device-classes I mapped it correctly in the lib, but messed it up here. Thanks for catching 6bb07747ad558ead5bb41d60bbfcd345d1b2a185 Looks like we need this to guard against multiple concurrent user flows creating an entry with the same address. Good catch. We probably need to fix that in a few more places. Will audit for that Oh its unreachable because we don't offer the device if its already configured in the vol.In But still good to add because they could delete it in another window between steps 0f4b7fd330e7a573e5cda3738b98d981d017d9af Should this also change? Yes that would help. I did get it right in the library at least 616bd742043f3c2877d6e1f0e50cf92dff4ff910 Thanks
Since this is an internal discovery, should this be done via a method exposed by yalexs ble ? Will make it after dependencies and add a toplevel callback
Please remove unrelated changes Stale docstring Stale You can use attr icon and attr name here instead You can remove this, its the default Usually we use the address for the unique id Do you need to override the coordinator entity property here? The switch shows as unavailable if I don't? Is a retry count needed? Can we drop this option? Please catch named exceptions and set errors based on the named exception This looks like a small amount of data (tokens). Please store these in the config entry data instead. This is doing I O which will block the event loop L161 Please store the tokens in the config entry data instead Please await platform setups so there is no race where the integration gets reloaded while setup is in progress You can use The callback decorator should not be used for coroutines There is a helper for this There is no need to implement this. A reload will already unload and set it up again Core integrations should get issues in the core queue Please move the connect disconnect handling to the lib Please move the connect disconnect handling to the lib Please fix the typing here to be the same as the parent platform Please fix the typing here to be the same as the parent platform RestoreEntity doesn't look like its being used? Why is there a pylint: disable import-error here? Please make this a single call to the api Please copy the typing from switchbot switch.py This was for legacy compat with older BLE libs. We can use the address as-is without this We should use async timeout.timeout instead.

I don't think this is really needed maybe, as in, the frontend will use the WebSockets against the collection directly anyways? Left it here for discussion purposes. Yeah the frontend doesn't need it. It's a bit weird to have the whole config in there. We don't do that for others I think? It is a bit of a mixed bag. I'll remove them for now; we can always add them when needed. Alternatively, it could be translated as "Active" "Inactive" Active Inactive would be the most correct. Definitely will be confusing when setting up triggers. Should we just make the actual state active inactive ? let's add some comments to help future readers figure out what the code does The problem with this approach is that 2 exact overlapping periods will not be detected. You can verify that by updating the test to be: A different approach to validate this would be to sort the schedule by CONF FROM and making sure that the CONF FROM always starts at or after the previous CONF TO . I changed it to that approach, added the given example as a test case. Added some more checks in the process. Since editable never changes during runtime, can we assign attr capability attributes ? We don't have such a thing :) Adding the class attribute: Done I wonder if next change would better explain it's value. I've played with multiple. Also just next . The thing with next change is that we don't know it's a change (the next block could start at the time the other ends, thus the state remains active). I went for event in this case, as it resembles an event on a calendar. That said, I have no really strong feeling about it. This will schedule a new point in time listener without cleaning up any existing one. Same, but smaller I was going to comment that midnight is evaluated as False but looks like that was [fixed in Python 3.8]( Let's split out the fetching of day schedules to make it a bit easier to understand what's going on. Rewriting this to using a for-loop makes it a bit more readable and saves 2 lines. Actually, this doesn't work, as it needs to break out of two loops now, which makes it harder to follow and needs more lines actually. Personally, I have fewer troubles following the previous, which looks for the next() valid option. Ah I see what you mean. Ok yeah, let's revert. Should we use idle here? It is an easier word and more easier to distinguish from active when scanning a list. Idle sounds like a device state. As discussed on Discord, changing it to On Off.
I suggest we require kwargs when we have so many parameters. We do the same in DataUpdateCoordinator . Should we allow the poll method to be implemented by a subclass instead of passed as a parameter to this coordinator, as we do in DataUpdateCoordinator ? L160-L164 Shouldn't last poll successful affect the available coordinator property similar as last update success does? Good question. So it doesn't on purpose right now because it's meant to be used for data that is polled infrequently alongside data that is passively received frequently. So it shouldn't be marked unavailable if it's still receiving data from broadcasts. I can make the variable public so the integration can make the choice though. Sounds good to make it public. : 1: Maybe rename to go with poll method ? Done in 86e2f2622499b9f22356c1591b05e4cef5f87ddd
This can move outside the loop That does not work unfortunately. The permission check is optional, if it does not exist, it should not skip adding the entity. This would be a good place to add a match statement once we are on 3.10 only. Black will complain about this suggestion This could probably use a refactor at some point to get rid of the linear searching It is only for a single device (no loop) so it is probably not a big deal at the moment to fix. async get registry is deprecated and going away in the future This can be a callback now This doesn't need to be a coroutine function since we don't await inside. Make it an async callback using the callback decorator. Leftover debug print.
I expect these will put quite a bit of data in the database. Should these be disabled by default? bdraco yeah, probably, I can disable all of these by default :) (Excuse me for not replying before, but I'm currently on a trip) bdraco done in 464049d67593533d402aa0ab8e45d53222edbe2c We shouldn t mutate the data here. We should display it in the format that the library provides. Changing the unit to something else is a front end concern. Also if you want to mutate round it before it gets to HA in the lib that is also an ok solution. We shouldn t mutate the data here. We should display it in the format that the library provides. Changing the unit to something else is a front end concern. Done in b72de801e19b78743db3bc31e80aa3823170ac36
Would it make sense to use extra restore state data here? On second thought, probably not since users probably find the attr values useful This doesn't look like valid extra state attributes for this entity. They, mic level and recording mode, should just be sensor values if needed. If we just need to store them to be able to restore the settings on the device, please implement extra restore state data instead. They do not make sense as sensors as there are already sensors for mic level and recording mode. These values are what they get restored to when this entity is turned off. Also, there is zero documentation on extra restore state data and on what it supposed to do. As far as I can tell, the data is not exposed to the user. While the values have limited use to the user, it does show the user the values will be restored when Privacy Mode is turned back off. Hiding the data from the user serves no purpose except implement a flow that is more confusing to the user. These measurements are not device native, right? The device doesn't report previous values, but the current values. We are not allowed to create new state like that. Yes. The previous state is expected from a user experience though since when you turn off a "Privacy Mode" you want the entity to return to the previous state it was when it was turned on. Privacy Mode turns off recording, disables the microphone and adds a black screen in front of the camera so you cannot see anything. Adding removing the screen is simple, but there needs to be a to persistently the previous mic recording settings so they can be restored when it is disabled. While none of this is "native" to UniFi Protect, this is one of the most used features and there was a reason it was added. People want fast and simple toggle to disable recording for a camera. Persisting the values means it now can survive a HA reboot since previously they were only stored in memory. It's ok to persist the values but not expose them as state attributes as it's not device native state.
This could be a comprehension but I'm not sure its that much better since its so deep I prefer to keep it this way if possible... I'd make this a named function so you can return as soon as you find it and it will better show the intent I'm not sure if 1e102f433c0440dd3148e3ff5b2ee113ab3ea9bd is what you are suggesting... Please lowercase the var name since you aren't using it as a constant at the top of the file (or inline it in your patch since you don't reuse it.) Fixed in 7e35dbc38cb4063c862ff25c5fd5e58b8e96fc80 Options is now provided by the base select but it needs to be a list L102 bdraco should be addressed in 7b112fe178929f5057e7ed4392d0a8c0ecfbaf31 It took me a minute to figure out this was a base class for your Zone entities. Done in ed144810a6f7bfef84998ed3747d44fc49e6ff17 Done in ed144810a6f7bfef84998ed3747d44fc49e6ff17 Might be nice to make these translatable in a future PR but since they are mostly numbers I'm not sure its worth it ex L49 Copying a dict to a list copies the keys by default. We can remove .keys() .
Is there no API key needed here? Not for the currencies endpoint. You could create the TimeoutConnect exception and transform that into the AbortFlow exception. Sorry, I'm not following what you mean. I've removed the custom local exceptions now. You could probably drop the format string here Personal preference, but I'd probably let the existing typed exceptions raise and trap them below instead of wrapping them again.
Looks like a lot of these got reformatted, probably want to format them as before Fixed Probably want to reformat to match codestyle Fixed Please store the runtime value key in an attribute on each entity description instead. Use a mixin dataclass to add a required attribute to the sensor description. Example: L34-L45 I m not sure I entirely understand. I would define the mixin class which would just contain a string attribute, and put the actual values in that attribute when the SENSOR tuple gets defined? Yes, we create the sensor entity descriptions as constants in SENSOR TYPES . So I would create a mixin class with a single attribute: runtimeKey: str then at the SENSOR tuple define it as derived from SensorDescriptionEntity, and the mixin, and just set that runtimeKey there? Yes, exactly. Please name the attribute runtime key . We follow PEP8 and use snake case variable names. Can you give me a less complex example? I'm trying this, and am trying to figure out what's wrong: dataclass class EcobeeSensorEntityDescriptionMixin: runtime key: str dataclass class EcobeeSensorEntityDescription( SensorEntityDescription, EcobeeSensorEntityDescriptionMixin ): SENSOR TYPES: tuple[EcobeeSensorDescription, ...] ( EcobeeSensorEntityDescription( key "temperature", name "Temperature", native unit of measurement TEMP FAHRENHEIT, device class SensorDeviceClass.TEMPERATURE, state class SensorStateClass.MEASUREMENT, runtime key "actualTemperature", ), EcobeeSensorEntityDescription( [etc...] nvm, need a pass statement for empty class. Is there a reason that you're not setting to using self.thermostat here? Thought I got them all... Guess not. To be clear what I was thinking was seems redundant to create a local variable now that we already have self.thermostat. This could be shortened down more, but I figured self.data.ecobee.get thermostat(self.index) was needed to update the values? Let me know if I am missing something self.thermostat should work. Let me test. It was acting funky without the local variables Ok. It's working. I think those were all the issues. Nope, it broke it. We can t cache the thermostat. I don't believe we can cache the data as an instance attribute without updating it. When the ecobee client updates it replaces the object that holds all the thermostats. So after each update we need to look up new thermostat data from the client. L202 We could use an instance attribute if we also update this instance attribute after each update. Yeah, that broke the updating. Need to call get thermostats() I just got finished doing isort and the docstrings. Guess you beat me to it :)
Should we put the poll update code in the top level coordinator in case we need to poll data that would be consumed by multiple processor in a single connection? That's a good idea. In that case, the processor wouldn't need to know about the poll. But we would need another mechanism to trigger an update that just took a SensorUpdate. If there was a async process update that took a SensorUpdate on PassiveBluetoothDataProcessor , then async handle bluetooth event could call it. And then I wouldn't need a different DataProcessor subclass, just a different Coordinator. I'd also like to figure out a way to pass a list of entity key to needs poll . The idea would be if you turn off the MiFlora battery sensor, it doesn't need to poll it. It looks like the DataProcessor has that information via entity key listeners . But I don't think coordinator currently does. If i was going to do that, entity key listeners.keys() contains: It's created "just in time". So there is no battery key until we first poll the battery. So i'd have to pre-create a battery sensor in response to advertisement data. We'd also need the opposite of device key to bluetooth entity key . Right now the coordinator does not really know about the sensor device class at all. This means it's hard to do both ideas at once. If it makes sense to pull the polling up to the coordinator, maybe it would make sense to lift the parsing out of the data processor into the coordinator. E.g. for xiaomi if get an advertisement with an encrypted battery event and motion event in one packet. We don't want to parse that once in sensor and once in binary sensor, especially as a bindkey problem might trigger a reauth event. For us, it would make more sense to have the coordinator to the parsing (and polling) and the processor just maps data between what our device class has parsed polled and how that is represented in HA. The coordinator shouldn't know about entities or entity device info. The processors handle those. This is the design separation we need to keep. I'm not proposing that the coordinator knows about home assistant entities. Im proposing that it drives the library that does the parsing and decoding, and only do that bit once. It just so happens that the underlying library uses similar terminology like entity for its parsed representation. Right now the coordinator just forwards the raw binary data to each interested platform. So we have to decrypt multiple times, potentially trigger reauth from multiple places, etc. Good! When we add multiple platforms, I think we could solve the multiple reauth by registering a dedicated processor who's sole job is to check if the bind key needs to be updated and trigger reauth. Other processors could reject the data if it can't process it knowing it the reauth processor would eventually lead to working data 76384 will let me pull the polling up to the coordinator (i'll be able to test the advertisement to see if its a MiFlora, then start allow polling if it is
Minor nit: is resize keyboard and is one time keyboard are not used unless keys is non null. So it probably better to just fetch them directly where they're assigned instead of pre-loading them outside the if keys: statement. At minimum, just move them just inside the if statement if there's some other reason these are separated out into their own staments. Ok, thanks! Nit: whitespace. :)
I have been testing with this. If the hass is needed during the config validations in the platforms, we need to set this right after setting the hass variable (line 102) and not the end. diff-7f269b55a61696a8682452bbeb39f29e4f7065f1a03cc990b8f46cd2efb9726dR102 This is a concept, and might not be the path we take at all; another option we are discussing, for example, is making HomeAssistant a singleton. Please add the expectations when it's ok to use this function in the docstring body. Updated to explain we still prefer passing hass around. Should we mention that it's only available after creating hass during bootstrap? Yes it would be good to explain the limitations. It's possible to call asyng get hass in scripts too even though they don't use the bootstrapping code. How to explain it in a concise way? Maybe we can just mention that the function can be called if a HomeAssistant instance has been created and will throw if it hasn't? Sounds good.
This device class requires ug m3 as unit of measurement. available-device-classes
I still can't see how to tell the user that the repair has been failed. If the repair fails I just get a popup and the repair is removed: img width "595" alt "Screenshot 2022-08-05 at 14 20 52" src "" Every time the coordinator triggers the async create issue() line, the repair panel is closed in the frontend. I think I do not need to call that function every time, is there a better way to do this? I think the coordinator can just stop, but that brings the problem that this issue it not repaired by itself. The 'learn more' does not show up in a repair flow. What is the intended behaviour?
- This can be moved further down below, as the config is already guarded for having a domain there. - If you make this a version with an issue creation that it is "being removed" we can include it in a patch release. I'm not sure about your second bullet point. This should be in 2022.8.1 so users with the integration get to warning now and I'm about to open the PR for removing the yaml for next release. Made suggestions. If we send out the issue "happening" in the patch release, existing users will be notified in 2022.8.1 already. For 2022.9.0 we can use the removed yaml version. The setup entry actually expects this one to always happen. The PR in its current state, the integration will break in case the user has no YAML.
Is this change intentional? Roger: the version data is now included in a coordinator, so we only need to hit the diagnostics one here. You could switch the order by reversing the condition and returning early to save some indent
self. attr name f"{switchbot name} {sensor.title()}" should probably change to self. attr name f"{switchbot name} {sensor.replace(' ',' ').title()}"
I think we don't categorize this as a critical issue. It will just cause an error with this integration. The system still keeps working. Critical is for severe system issues or high threat security issues. Where is this issue created? Should have been removed app auth , missed during rename.
A follow up PR should add a reauth flow. reauthentication Please add type annotations if not too hard. We can use config entry.async on unload to call the unsubscribe callbacks. I recommend using a dataclass to store multiple instances in hass.data under a single key. That gives type annotations for free. What do you mean for free? Wouldn't the type definitions simply move to the class? The attributes will be typed once we know that we've got this dataclass from hass.data. Instead of needing to type all the items all the time, after looking up hass.data, we just need to type the dataclass after looking that up in hass.data. Nowadays we prefer using our short hand attributes, eg attr unique id . entity-class-or-instance-attributes Cool. What about the abstract base class? Do I simply remove this property? Yeah, I'd do that. It's only ourselves that will be using the base class so it's not that fragile. It's better to pass on not used parameters to the parent via super() than calling different parents specifically. Not sure I understand - is there an example? I'd do it like this: thank you! What do these state attributes represent? We try to avoid adding extra state attributes as far as possible. alarmed is whether this zone is currently causing an alarm, groups are the arming groups the zone belongs to. The former can arguably be a separate binary sensor, the latter is fairly static (requires reprogramming the alarm, which typically only installers have access to). We already have bypassed , which today would have been a switch, but requires some restructuring (and is a breaking change), so I suggest I split off bypassed and alarmed to separate entities in a future PR. How will the users use the groups info? We shouldn't add alarmed now if we plan to make it a binary sensor. Either make it a binary sensor now or later. I imagine groups will most likely be consumed in the UI as a guide when building automations, e.g. if I arm group C, will I need to bypass this zone first? BTW the fact that we're exposing groups is really cool - the Risco app doesn't show them anywhere, which means people can't even understand how their home is configured. I'll probably drop alarmed for now and add it in a future PR where I also break bypassed out to a switch. Need to first figure out the best way to have multiple entities subscribe to the same zone update. If the user wants to bypass a zone in the automation based on which group is armed, shouldn't the info relationship be the other way around? Ie we expose the zone entity ids that belong to an alarm group on the alarm entity that controls the alarm group, in the extra state attribute. Then it's easy to check the state attributes of the alarm that is targeted in the automation and it should work to bypass all those zone entities programmatically in the automation. There are no entities for groups. Groups are just sets of zones, but partitions are the units that are represented by individual alarm control panels (R

No need for the default value? There were some linter errors related to this so I had to make it this way. ![image]( What does empty string mean? This attribute doesn't seem optional. If it's required, break it out to a mixin dataclass. We are not subclassing ValloxNumberEntity (yet), so we can remove this field for now and instantiate everything as ValloxNumberEntity unconditionally. We create a repairs issue for these cases nowadays too. Example: L265-L279 Thank you for the example. Implemented. Couldn't the fan settings be different fan entities? Ventilation unit has a fan speed and temperature settings per each profile. If I understood your question. Why not create three fan entities instead of these three number entities? Ahh HomeAssistant has FanEntity. Did not know. Now I understand. MartinHjelmare If I extract fan entities, do you want it as a separate PR or I can add to current one? Please add it in a separate PR. Thanks! Do we need the type annotation? It's the same as in the parent class. We don't need a helper unless we need to create an issue for more than one service. We can inline the code. Can we add a test for the set value service? Sure. Done. Test passed.
Is it correct to return False if no metric exists for the given key? Should we return None in that case? Is better now. Another similar test for SERVICE TURN OFF would silence this warning, right? And probably give us 100 coverage of this file? img width "1070" alt "bild" src "" new test should cover both. Do we need the type hint in this case? VS Code auto populated. I wasn't against it ) Add a separate parameter for the expected state instead of using conditional logic.


Please remove the added translation files. We download translations from Lokalise, so adding them here won't have any affect. removed the files. Unless it's called "4Pro" we should separate words with underscore in variable names. updated naming Why do we change the favorite level feature set here? Bump. In the python-miio library the set favorite level function for MIOT purifier checks different levels(1-14) compared to the default(1-17). Would trigger exception for levels bigger than 14. If this is a bug fix, please move the change to a separate PR. We want to separate fixes from new features. Each PR should only do one thing. Thanks! ok, but it is also needed for this PR because otherwise exceptions would be thrown for the purifier 4 on level change. We can merge the fix PR quickly. I just created the PR 75814 for that, please check. I will merge with this one once that one is on dev. pushed the update with the remove of FEATURE SET FAVORITE LEVEL MIOT Is ATTR FILTER LEFT TIME added intentionally to the existing PURIFIER MIOT SENSORS device? Updated to be only for Purifier 4 and 4 Pro
The garage door controller has no state and no other controls than a single button, is that correct? Yes thats right. Just a simple button. No states. I don't think we need to test this. i removed the test
This one seems to be unused. These seem to be only used by the config flow, let's move them into the config flow.py file in that case. Not a real requirement, but we do generally place custom coordinators into a coordinator.py file. Maybe consider moving this class into such a file. Stale code doc We need to clean up hass data (where the coordinator is stored) We should set up the client just once, and call get data() on that for the future. Maybe create an single instance of the JustNimbusClient in the coordinator? We should not as for a name when setting up the integration. Ideally, we extract the name from the device service data, OR we use a default name. This was a placeholder and should be removed :) This one is also defined in const.py This one is also defined in init .py We don't have to pass the entry id. The config entry is already available via the coordinator ( self.coordinator.config entry.entry id ). You can set the device info in the constructor directly. A hardcoded suggested area? This is the same as the identifier? We need to check with the parent class as well, as that available method triggers based on the polling state of the coordinator. Stale file comment This has no use? This integration uses a coordinator to handle the polling. This is exactly what the key is for. Please use that one instead. The frontend provides a default icon for the pressure device class, there is no need to override that. Consider setting the appropriate entity category and state class on these entity description (if applicable).
If this is always a string You may need to import cast from typing All sensors in the file use the type ignore hint. Just tried to keep it consistent. Will change it when I find my way to a PC. Please create the sensor only if there is a value to show Code updated should also work, but do not need to import cast I'm not really happy with this description ... maybe something like: we should use the already existing property self.fritz status.external ipv6 - no need to do a "low level" call here
We don't want measurements to be state attributes. These should just be separate sensor entities with our current design. Some older integrations still have the legacy pattern of exposing them as state attributes. Thanks, Martin! I didn't realize the ClimateEntity was not a good example to reference given that it uses the legacy pattern. Would you suggest that generic hygrostat expose a device instead of just an entity? The current humidity would then be exposed as a sensor within the device. This would allow integrations like HomeKit to pick up the current humidity correctly using [this]( L954-L961) code. Maybe. It would require a config flow to set up the integration. I think it's a question for our architecture discussion forum: Please search before posting for related discussions. Until the architecture discussion is resolved please close this PR. Thanks! Thanks! Started a discussion at Feel free to chime in with your thoughts. Closing this PR.
init async is also used during config validation, should lines 31-33 be moved into its own method? I'm not sure we should move them. Gateway.init async() is a method to initialise Gateway instance. Initialisation means we setup all internals and populate all its properties. So it's fine that we set these properties in the method. But, yes, we will do it also during config flow, far from perfect. What options do we have, if we don't want to populate these properties during config flow: 1. Add another method, like Gateway.async init device info() which will init these properties. 2. Add a method Gateway.get device info() which will return a dict with these properties. But what if we will introduce another platform, like binary sensor.py ? Then we will need to call this method twice (in sensor.py and binary sensor.py). Weird. What do you think? Leave it as is or one of the options? Let's only add a minor comment that this will be called during config flow. done

Stale comments? If this is needed for tear down, I'd move it to an autouse pytest fixture that yields and then stops hass .
We should start a new user flow here and continue that. Good catch: That would actually test what I was trying to test Fixed in d20d125212611a3d1d66446b4d8fa0c3096ddb95 I realize now that we've gone against a design principle that we normally follow: platform details should be kept with the platform. If we ever want to support more than a single platform with the coordinator, the current design doesn't work with that. It's not flexible that the coordinator handles entity details, like entity descriptions and names. I think it could be possible that passive data could be a binary sensor as well (haven't found one yet though). Will think about how to refactor to handle that I pushed up a prospective change to the coordinator to handle multiple platforms. It really doesn't belong in this PR, but it seems liked the easiest way to get feedback, and I'll pull it out after we decide on a direction. This could be any description but it doesn't have to be a single dict if we wanted the function that converts it to a PassiveBluetoothDataUpdate to call into each platform. The integration could register a processor per platform to central class if it needed to support multiple platforms so instead of sensor update to bluetooth data update we have a class that builds the PassiveBluetoothDataUpdate from each platform, but that might be a bit more than is needed. Even if the platform itself doesn't have its own specific EntityDescription class this would still work because the callback would only accept the entities we want This could be handled by each platform if we ever needed it. But that would be 100 in the integration I think the filter is the only thing that would need to be added to the coordinator to support multiple platforms. Everything else would be in the integration itself This could be required instead since it wouldn't be a breaking change at this point Can we remove this module? Yes, that would help
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
I think there is a "normal" Xiaomi integration as well. I assume the integration now picks up all sensors that send temperature, humidity, pressure and battery. This might add all sensors, as almost all of them have battery messages. Does this mean that these sensors are added with only a battery entity? Not a problem, I guess, but we can also decide to comment out the sensors that aren't fully supported yet in the pypi package. Pressure isnt used yet, but yes. I've left all the parsers active and able to capture fields that aren't turned into entities so we can do a second pass and capture them. The can ignore any devices they don't want to add in the UI, so i'd slightly prefer to leave as is I think. I m just a bit afraid of all the issues that are going to be created, when people notice that their device only shows a battery entity. There is also one device that has added a counter in the battery data. Like every tenth advertisement, it will send a counter (as battery data) that is increased with one. I had some filter in BLE monitor for that (not in the parser, but in sensor.py. It will look it up, which one it was ) Eh, I'm less worried about that. It's been that way with homekit controller for a few years. We can add some boilerplate to the docs about what device classes are support and or a whitelist of devices we expect to work. (I actually have a dashboard just for batteries, so I'm totally up for battery only sensors). The CGPR1 is the device with the odd battery sensor. I made a workaround in BLE monitor by storing the last 5 readings in a list, and only process the battery reading if it is in the list (only for the CGPR1, the others work fine without the workaround) L259 The counter is actually counting downwards, this is what you get without the workaround. ![image]( I've moved this into and will handle it seperately to this PR. alphabetic order to fix the PR tests Please add tests for already configured and already in progress abort reasons. Done in Please also test to start a user flow while there's a bluetooth discovery flow in progress. The user flow should take precedence. My bad for for missing these in sensorpush . Jc2k Just added one to the end of this PR you could copy This should start a new user flow, right? Yes it should. I'll copy the first I just did in the other one Fixed. I'll check the others as well and open PRs if they need it I managed to screw up a merge conflict resolution and then copy the incorrect code to multiple places. Sorry for the churn. I opened PRs to fix that
The comment for this function specifically says: Make sure date is not in the future, or else it will return None. But it doesn't look like that's actually the case with the existing code. And I'm not sure what the new code does either. Can we verify the behavior and update the comment to make it clear what the expected result is with a datetime in the future? Ditto with the comment for this. Make sure it's updated.
There are a couple of things with this PR causing it to be non-acceptable for this project. - Communication with a device or service needs to be abstracted into a Python package, published on PyPi. This PR makes requests and processes the results directly in Home Assistant, which is now allowed. - The data is gathered using web-scraping, which is not allowed in Home Assistant (see ADR-0004: For those reasons, I will close this PR. Sorry! .. Frenck
It would be nice if the bytes flags could be abstracted to some constants that we can import from the bleak backend. What do the bytes mean? It's a matcher that is effectively "match everything" since the underlying kernel apis require a matcher even if one isn't desired. There is a callback you can implement to indicate no options flow L1275-L1278 Thanks bf9271a5746f10308ef8bc4ee7555019317a65fd
Set self.entity description description instead This should be disabled by default so it doesn't generate too many updates in the state machine Heh, it was initially, but I turned that off for testing purposes so I didn't have to manually turn it on for 60 bulbs. You can set this as self. attr device info We shouldn't poll this unless at least one entity is enabled that needs it Yeah, I wasn't sure how to work that out from the coordinator. All my attempts to override async update failed. You could keep track of it by adding having the entity tell the coordinator it wants it in async added to hass and tell it, it no longer wants it in async will remove from hass Similar example L217 We shouldn't poll this unless at least one entity is enabled that needs it This is only available to HEV bulbs and they would all have it enabled by default, so if this is called, it's needed. Users can disable the entities Please move code out of the coordinator that won't raise. Then process it in an else We normally don't set an icon if the device class is set. advanced-properties We normally don't set an icon if the device class is set. advanced-properties stale debug ? No. Moving LOGGER to .const makes all the logs look like they come from homeassistant.components.lifx.const and not the actual file in which it is called. It makes more sense to define it for each file to make debugging a little bit easier. It would be nice if this was a separate function We try to avoid using Throttle in new code If we need different intervals, usually we use multiple coordinators (example in synology dsm) or write a custom coordinator. It's a bit more difficult here since we need a shared lock but that can be created when all the coordinators are and passed in. Since they are all similar we could have a base coordinator class and subclass it into a light, hev, and signal coordinators The advantage is if you have multiple coordinators you don't have to worry about subscription management since the coordinators don't poll if there are no subscribers. Strictly speaking, we don't need different intervals but then we also don't need to poll for sensor data every 10 seconds either. I'm more worried about the amount of data potentially being stored by the logger for no good reason if we poll too often. We probably don't need to share a lock either: that's only really needed for discovery. Once the transport is unicast UDP, the bulbs tend to respond pretty quickly and can handle up to 20 pkts second. As a reference, the Tile animations generated by Photons send 320 HSBK values every 0.075 seconds. :) We would be better suited with a global limit of 2-4 inflight (unacknowledged) packets per endpoint, which is automatic in Photons but would have to be added to aiolifx. Reducing the polling frequency makes a lot of sense here. If you have a lot of bulbs the additional wifi traffic will make a difference on how much reliable your 2.4g network is. Agreed. And it would reduce the amount of pot
Still trying to wrap my head around how to test this Async Event based stuff ... any suggestions or other integrations to look at would be helpful :) This test is still failing because it is not exciting within 9 seconds... currently working on understanding how to mock this out correctly Apparently it works now :) It would be nice if the following line could be added here to allow a running count of lightning strikes similar to rainfall amount. natekspencer - thoughts? Yeah, we should add it. It was probably just an oversight from me on not including it in the first place. STEP MANUAL DATA SCHEMA is never used and can be removed. This warning should be removed. iot class should be local push iot class should be local push Add "integration type": "hub", "loggers": ["pyweatherflowudp"] here as well CONF HOST is required in the config flow schema so it's not possible for it to be None Moved it as the default into the config flow and took it out of here. Can combine to one line I suggest you use self. async abort entries match() instead of this complex way of checking config entries and matching. Why can't it always be f"WeatherFlow {host}"? I guess it could be, however, the most common case is that an individual will have a single weatherflow device in their house which is sending out UDP packets on the local network. Being that its UDP we don't need to actually know the IP address of the Weatherflow device and we will be using a value of 0.0.0.0 for CONF HOST which is actually better described as a host filter rather than a specific host we are getting data from ... and in this case just saying Weatherflow I believe is clearer than Weatherflow 0.0.0.0 We have two options: - UPD Traffic from a single specific IP - UPD traffic from anywhere (this is a much easier setup case because if your weatherflow device changes DHCP it will still wokr) Makes sense. Didn't check the constant actually as it seems wrong to have a default which can not exist. Clean out not used keys Remove it here and set directly on the sensor class Can you elaborate here? I'm a tad confused as to what you want me to do. Some of our sensors are Temperature sensors and they have their own class. Others are more general... We currently have: WeatherFlowSensorEntityDescription WeatherFlowTemperatureSensorEntityDescription WeatherFlowWindSensorEntityDescription Should I have an Airflow one as well? In addition to that we have a variety of other "custom" ones like this below? Happy to make whatever changes but need a tad more clarification thanks. Specifically you can set has entity name on the sensor class instead of repeating on all the sensor descriptions We should just add this in the native way it's coming in and then the user can change themselves on the entities. Can you elaborate what you mean? I tried to pull some stuff back but it didn't exactly do what I expected. Being in the US for example the wind was still rendering in metric. Some of the weather specific units dont seem
We might need to make this configurable but thats a feature we can add later The return value of update method isn't typed as optional. Removing the guard are we don't need it anymore f0158b6fb2f98e1a6cb1e96ecf316cb8d4bc2098 I think we should add a comment or extend the docstring explaining what the different kinds of keys mean here, PassiveBluetoothEntityKey vs None . Good catch. I don't think we need this anymore since I split the listeners into two lists to avoid the None case but forgot to remove it. d2949eda802491e5d51c6ce5c2680d2eda862af4 Instead of listening to an interval, shouldn't this be using a track point in time that is set to "last update" UNAVAILABLE SECONDS ? With the coordinator in Shelly we do something like this by having the update interval be used as a fallback while relying on push notifications being pushed using async set data (that's on a normal coordinator) Probably need a guard for hass stopping as well 17991a9564055fe6ff366cdf938c0f6df5cdea74 May need some tweaks but will work that out in the tests Can this be rewritten like this? Although I don't see any filtering happening so maybe the code is wrong The value is always a list, and if empty the key is removed. So I think we can also drop if listeners . Yes, much better Let's enable entity naming by default. The govee data isn't used. The govee data isn't used. It will be in the next test. Sadly I ran out of time since the A C went out and required my immediate attention so I never wrote the next test. Texas Summer no A C
is this supposed to have changed in this PR ? Yes, this correction is required as a result of the library changing from version 3.1 to 4.1. Why not just return None when the model is not known? HA can handle this and will also localize this, where 'Unknown' cannot be localized. Good catch, this has been implemented as recommended. Is there a particular reason that you don't use the AdvantageAirEntity ? L9 Only because that PR was raised after this one, but merged before it. I'll fix this up. This has been implemented Perhaps add a docstring to explain what this inline function does and why it is necessary? The docstring has been added. The function is a factory that returns another function wrapping the API call in a try catch. bdraco does this change the behavior of pulling refreshes? My Tests are now failing like the refresh is not being done. Refresh will wait a bit to see if it can batch them. Right, ill update tests Yes, it has a debouncer so you don't overload the device L153 You may need to call async fire time changed or lower the debounce time on the coordinator Usually we re-raise as HomeAssistantError silver- Operations like service calls and entity methods (e.g. Set HVAC Mode) have proper exception handling. Raise ValueError on invalid user input and raise HomeAssistantError for other failures such as a problem communicating with a device. Do you want me to address that here or as a seperate PR. This code block is functionally the same as whats currently in core and this change isnt related to the lights platform addition. If you want to change it now or do it in a followup, either WFM I'd prefer to not complicate this PR further given its age, so Ill raise a code quality PR to address this.
We still want to assert the unit of measurement, I think. This device class currently mandates ug m3 as unit: available-device-classes
Should we really expose this subclass in the callback? Or should it not just be a potential bleak subclass (ie either a bleak variant or standard type) I'll make it a union so its clear it might not be there at some point 4def8476be5c2b3cf9680c793639c50c80080aad
You could condense this into one expression if you wanted to. Done, hope it's better now. Trying to understand the need for this. How would come across devices that you've already configured after the integration is set up? This is a way of handling the configuration changes of Elmax devices without requesting a full restart of HA. In particular users can enable disable devices via the Elmax web interface. When they do so, the coordinator will receive a state object which contains the new entities: by intercepting that and fetching the new devices, we can directly add them in HA. Does this clarify? Let me know if it doesn't. Ah, got it! You can simplify this with a comprehension: Agreed. Added via 68649f17957c4def78894ba6d8482843a76f5cf8. Could this return None (the default of get )? If so, we should update the method's return typing. Good point. It shall never return None, therefore I've changed the way I access the state dict: using the squared-bracket operator instead of GET(). That makes the type hint consistent. Nice spot! Addressed via 8c6fc786257f6b18380ffc5f60d7900abf42792e
This is protocol details that should be part of a 3rd party library. Agreed. Fortunately the used EnOcean-library already has better high-level functions, please have a look at commit [3dd3a08]( Here there are also protocol details. Agreed. Fortunately the used EnOcean-library already has better high-level functions, please have a look at commit [3dd3a08]( Do we need an option for the timeout, or is a sane default enough? Thank you very much for your review! In my view an option is required, as the timeout depends on the open close time of the connected device. Is it expensive for the device if we send a telegram to it? Ie, is it not good to set a short timeout and send a telegram frequently to the device? Good idea - see commit [a1631a5]( Some more remarks to that commit: - Due to the shorter interval, I also had to adjust the status detection (because now two subsequent received statuses might have the same position info even though the roller shutter is still moving). - Moreover, I also added a query limit, preventing the watchdog to run forever (i.e. if a device is unpowered or defective). Finally, I have also added a status query after (re)start of Home Assistant - see commit [80caa02]( In my view, all your comments change request should be covered now - please have a look and let me know if there is anything that still needs adjustments. To also answer your question: no it is not expensive for the device (except, probably, some negligible additional energy consumption). However, in my experience EnOcean transmissions are a bit unreliable (probably due to collisions) and hence I try not to make too many too frequent queries. I have tested the changes suggested in my commits in my current setup (ten roller shutters) - they seem to be working fine. If there are more devices we won't list them all in the docstring here. Don't pass in hass . It will be set on the entity when the entity has been added to home assistant. This means you can access hass with self.hass , after the entity has been added to home assistant. Thanks - see commit [c85fc44]( Thanks - see commit [c85fc44]( We prefer using our shorthand attributes nowadays when possible. entity-class-or-instance-attributes Ok, see commit [9b62de4]( We're not allowed to call the async api from sync context. We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Thank you, frenck, I'll see what I can do about that. However, looking at the provided link, there is also a cross-reference to ADR-0010 ( stating that "Integrations that communicate with devices and or services are only configured via the UI. [...] Existing integrations that should not have a YAML configuration, are allowed and encouraged to implement a configuration flow and remove YAML support. Changes to existing YAML configuration for these same existing integrations, will no longer be accepted.". Hence: Do I underst
A device measuring humidity is called "hygrometer" with a g . A "hydrometer" measures density of liquids Fixed it. Thanks! The unit is already defined above Updated in a new commit, because the dictionary for sensor types needed to change along with this Please revert this change. You may need to rebase on latest dev branch. FlowResultType is the new way and RESULT TYPE FORM is legacy. Consider modifying the data structure before it's returned from the coordinator instead since we don't seem to need the original structure here in the sensor platform. Makes sense. : 1: Pushed a refactor for that.
I think this is fine, but it would be good to get a test for this. Ok, no problem. I'll figure out how to add a test for it. Wow, not sure where to start on creating this test. I've read through this: but it's a bit over my head. Can you point me towards other documentation to help create a test for this? light isn't needed since ids are unique per platform Please use comments instead of doc strings here
Can you set this as self. attr hvac modes ? No because the available HVAC modes change depending on which preset is selected. We aren't allowed to change the hvac modes after the start event. If the hvac mode can't be set in the current state it should raise an exception instead. See the silver requirements in the devs docs for which one to raise So what I've implemented works perfectly in the platform and the UI, so is this an unwritten rule? Would the acceptable implementation be to show every HVAC mode but just throw errors if its not valid for the current state, despite the UI showing all options? So what I've implemented works perfectly in the platform and the UI, so is this an unwritten rule? All the states are sent to the voice assistants forwarding integrations at the started event. If you change the model out from under them they won't be able to access the states that were not visible to them at startup. Would the acceptable implementation be to show every HVAC mode but just throw errors if its not valid for the current state, despite the UI showing all options? Assuming you mean every HVAC mode the device can support, then Yes. Is there any way to differentiate what is sent to forwarding integrations at startup and what is shown in the WebUI, because obviously this is going to degrade the user experience showing options that don't work. It is not common to change the operating mode, so I was willing to accept that voice assistants may not work when the preset has changed. Is there any way to differentiate what is sent to forwarding integrations at startup and what is shown in the WebUI, because obviously this is going to degrade the user experience showing options that don't work. Each of big ones would have to be rewritten to be able to support that. At least for homekit, it doesn't like changing the supported features of the entity since it has to resync with iCloud. I believe alexa and google assistant need similar resyncing when the features the device supports changes. From an architecture perceptive there isn't much we can change here since most of them only build the devices structures once for performance reasons, and that seems unlikely to change in the future. Voice assistants are just the tip of the iceberg here though. It is not common to change the operating mode, so I was willing to accept that voice assistants may not work when the preset has changed. Its also fine to require a restart to change it if you want to set the modes once. I understand the limitation from Voice Assistants, so can I instead just accept as a design decision that voice assistants may not work when the preset changes, and it requires a restart (or sync) for voice assistants to understand the new mode? This product has its own direct integration with voice assistants, so the goal here is to add full functionality to Home Assistant , not to the voice assistants. bdraco is this what you mean by raising ValueError? L166-L175 Can you set this as self. a
Same comment as 75234, let's fold this logic into coordinator. Why does the integration need to know about the reboot? See comment [above]( issuecomment-1203021577). In short: 1. We have multiple coordinators, each of which needs to react to a reboot by marking its associated entities as unavailable right away (indirectly, of course) without this, entities would appear online until their next coordinator poll. 2. One coordinator (the one with the shortest update interval) waits until it can ping the API again; once it can, it "notifies" the other coordinators. This ensures that all the entities come back online simultaneously (vs. in the piecemeal fashion that would occur with each coordinator having a different update interval). This is precisely the same as what we merged for [Guardian]( (except in that case, each coordinator has the same update interval, so we allow their entities to come back online naturally). Since they don't update at the same interval, its possible that the shortest one won't see the reboot first because it happens to align to update later than one of the other ones. ie. it gets unluckly. Should all of them watch for reboot and whoever sees the reboot finish first sends the signal? I thought about that... Thoughts on whether I'd have to asyncio.Lock that somehow? Trying to envision a scenario where coordinator A comes back and notifies, but then right after, coordinator B does the same. Ultimately won't damage anything, but potentially lots of extra traffic. Does it matter which coordinator sends the signal first as long as you only accept the first one? No, doesn't matter.
This looks like duplicate or very similar code as with async setup entry Can you break this out into a function to make it a bit more DRY?
I think this may mean the calendar page async get events may return an empty list of a request arrives while async update is paging through events. I think it may make sense to update the member variable at the end of this function only We could have a temporary list and then set self. events to that list once all the events are fetched. This is a pretty tight scan interval for a calendar. Do you have thoughts about that? I was reading the nextcord library and I can see that it also appears to cache the events fetched inside the Guild object. Does this use that or is it always polling? Using the fetch method always calls the API. Creating a longer interval would make homeassistant less responsive to changes but would also save bandwidth. Would a five minute interval make more sense? There are two things to consider here, given my experience with cloud calendars e.g. Google. I also realize there is some interplay with triggers to consider. What google calendar does is: (1) polls the API every 15 minutes ([update coordinator]( L243)). This means that you don't notice new events for 15 minutes. So if you rely on an automation running as soon as an event is scheduled it won't catch it. I'm not Sure how true that is for this use case, but i assume a guild event would be scheduled far in advance of the event. (2) The other interesting part is around the on off state of the calendar entity. Google calendar run async update every minute so it notices when the next event fetched in 1 has started. (See [should poll]( L307) which will use the default 1 minute update and see the calendar entity [state update method]( L283) So this is a little complicated as it both uses two types of polling. The last thing to consider is that triggers also have a 15 minute poll interval using async get events . Triggers get the list of upcoming events in the next 15 minute window, then schedule alarms at the right moment based on when they start, and iterates through all the events. This may stack up your delays here... The assumption was that async get events may actually send an RPC itself, like it does with google calendar, todoist, etc. (I was thinking of moving google calendar to do something like what you have here to read from a local cache, but haven't done it yet since we need to support search). 1) I think you're right about the use case, events typically are scheduled well in advance, so just from that, a longer scan interval would make more sense. 2) Assuming we figure out how to access the status of events, we could do two types of polling here as well. A) We fetch Discord events with async update every 10 minutes and add them locally without removing them. Then have async get events convert them into homeassistant calendar events. B) I'm async get vents we poll the status of the events and if the event is active we say the start time of the event is now when converting to homeassistant calendar event objects. If the status is completed we remove the event local
This seems not to be part of the specifications? As a matter of fact, according to Tuya specifications, this device only has reporting capabilities and no functions. ![CleanShot 2022-07-13 at 21 08 59]( Could you share more information on this change (and fill out the PR template fully as well, including changing the title of the PR to something meaningful). Thanks! .. Frenck Sorry for wasting Your time, I was trying to begin to contribute but looks like I should go back to the drawing board! I was trying to add support for the pir sensors. There was quite a few issues raised in the old tuyav2 that were trying to get it working as well as in the official 68706 and 63356 Sorry for being a nuisance but hoping to begin to support contribute to this amazing system (I literally have 100s of devices and sensors in my house(mostly Tuya based). That is OK, but I'm not fully understanding the change made in this PR, hence me asking if you can elaborate on this change. You can reject this change. I thought I need to add PIR to this file has it was missing here. Looking through and trying to understand how this component works I see PIR is already added to the binary sensor.py. When I check the API in postman it shows value pir for only a few seconds before going offline to which is shows value none. { "result": [ { "code": "pir", "value": "pir" }, { "code": "battery percentage", "value": 100 } ], "success": true, "t": 1657849874540, "tid": "9c1e18cb12e011edbf867eeb5c0b2a02" } In Home Assistant it just always shows as unavailable. Its as if because its 'offline' the motion detections never make it through or automatically make it disabled. Postman shows this for the device details. ![image]( "result": { "active time": 1655738863, "biz type": 18, "category": "pir", "create time": 1655738863, "icon": "smart icon ay1536534747810ekKBj 1565841334dae0a2029d5.png", "id": "bfaafef50c0c067fb51ab7", "ip": "", "model": "YIDONG", "name": "Motion Sensor PIRB Office", "online": false, "owner id": "3335541", "product id": "6xcrb0jp", "product name": "Motion Sensor", "status": [ { "code": "pir", "value": "none" }, { "code": "battery percentage", "value": 100 } ], I really hope I can be able to assist in adding new devices and attributes! You can reject this change. Ok In Home Assistant it just always shows as unavailable. Its as if because its 'offline' the motion detections never make it through or automatically make it disabled. Interesting Could you please rais an issue in the issue tracker, adding a device diagnostic dumps downloaded from Home Assistant in both pir and none state values of the pir data point? .. Frenck
let's consider either folding the source into BluetoothServiceInfo or adding a new data class to hold that data so we can easier expand in the future. Will adjust after
Is this needed here? We're not directly updating any state, and if we're counting on the coordinator to update as a result of turning on off, then there's no need for this call. I included this so that HA would call hvac mode() to get the updated HVAC mode after it was changed. If I remove this, then when I change the HVAC mode, the new HVAC mode is not reflected in HA for a while. It takes some time for the API response to update after a change. I see. But what does self.client.get assumed hvac mode do? The coordinator should be fetching new state, and properties should just be reading it. self.client.get assumed hvac mode returns an "assumed" state value. Normally it just returns the HVAC mode from the mode recent API response. But if the HVAC mode was recently changed, it will return the new HVAC mode, even if that hasn't been returned in an API response yet. When the HVAC mode is changed in HA, the coordinator doesn't seem to run its update function, and the properties don't read a new value. So that's why I need self.async write ha state() , to make the properties read a new value from self.client.get assumed hvac mode() that will reflect the newly updated setting. The lock entity in this integration works the same way. so self.client.get assumed hvac mode is a cached value? It's not entirely clear from the code. In any case, the correct way is probably to call on the coordinator to update again. so self.client.get assumed hvac mode is a cached value? It's not entirely clear from the code. Yes, it's a cached value. In any case, the correct way is probably to call on the coordinator to update again. The Mazda API has rate limiting, so I don't want to trigger a coordinator update every time the user changes the HVAC mode or target temperature. I only want to update the current state from the assumed values returned by the library. To avoid rate limiting issues I only want the coordinator to update every 3 minutes as scheduled. This still seems off to me to decouple fetching the new value and updating HA like that. It's confusing to see self.async write ha state() in a function that doesn't directly update the state. My 2c - I would store hvac mode in the entity, and return it from the property, rather than call the library. I would then update the stored value both from the coordinator, and from this function. The problem is that there is some complex logic needed in order to determine whether the value from the API or the assumed value should be used. Right now this logic is located in the pymazda library, but if I followed your suggestion, I would need to move it from the library into the integration. In my PR where I added the lock entity, I actually originally had the state stored in the entity like you suggested, but was asked by a reviewer to change this and move the logic out of the integration and into the library. See discussion r631556364 The logic would still stay in the library, but instead of being called from hvac mode() , it wil
Config entry title isn't stable (it can be changed by the end-user). This can now move up to the class attributes, as it is static. Entity descriptions are automatically picked up, no need to set this :) Lame change maybe, codespell linter triggers on it and I don't see a simpler way around it right now. I was trying to respect the official name of the government department.
All entities seem to have a "prefix" in their name. What is that prefix? Based on what I just did with the Environment Canada integration, I now understand that the prefix can be removed as long as the device info has the proper name. I will make this fix and also drop UPB from this PR and create a separate PR. upb seems to use self. element.name for both its device and entity? That seems not correct in the new schema of things. If an entity should be the same as the device name, set the entity name to None .
This is provided by the device user configurable, right? So if this was, for example, "Device from Frenck" it would become "Device from frenck"? It comes from the device, but wasn't nice in the past. In the past we stripped the sensor type if you could map it to a device class. However with the new entity naming I found it prettier to always use the the sensor type. Sure, but that didn't confirm nor debunk my example above. Could you clarify the behavior? Let's imagine a door window contact device having some additional other binary sensor, that did not fit to a device class and the device is called "Device from frenck" in the devolo world. Then up to now the entities would be called "Device from frenck" and "Device from frenck other binary sensor". Afterwards they would be called "Device from frenck Door" and "Device from frenck Other binary sensor" and the new logic again decides when or when not to strip redundant information. Right, my concern is capitalize() in this case. If the name comes from the device, and I named it "Device of Frenck" it should not lower the case on my name, as my name is with a capital F . It doesn't, because the capitalize is only applied to the sensor type (door in this example). The sensor type is a device property that the user cannot change. The name the user gave the device stays untouched as set in devolo device.py L41 Hmm this was previously not prefixed. What does this have to do with the new naming style? The device, that I have in mind here has 4 buttons to press. With the old naming it showed four times the device name on the UI (so you could not really tell, which is which without looking at the entity id). With the new naming this was easier to fix, because the new logic decides on it's own when to add the device name and when the device name is redundant information.
I believe the convention is that if we raise an error, we should not log it too. The same goes for this one. Maybe use a constant for "library"? This can be moved to your separate const.py I moved it to const.py , but feel like this makes the code somewhat harder to read. I conscientiously defined that value there directly as it fits the flow of the code, and as the constant is not used anywhere else. Writing keys[-1] seems to be a bit convoluted way of writing keys[1] since we already know len(keys) 2 at this point. Please break long strings at 88 characters per line or shorter. According to PEP8 docstrings shouldn't be longer than 72 characters per line. The docstring header should also fit on a single line. Fixed in 82969 Thanks!
Don't check in commented out code (here and elsewhere) This is already set as self.hass so this hass can be removed. Done. Presumably this does blocking I O here and should not run in the constructor. If the idea is to get a value right away the i think async config entry first refresh is what you may want. Thanks for the hint. - Moved. It stack is None then would the update() method would have failed above? Rewrite of pylontech lib to pass exception up to homeassistant in case of failing connection and update. Is this ever used? The return value of this function is ignored also. Removed return values. Exception propagats connect errors.
Can this function be moved into the library? Will create a new library version that includes this functionality ( and bump the version accordingly. Sorry I didn't point this out before, but I didn't think about it at the time. this does I O which needs to be run in the executor to avoid blocking the event loop I understand that open() could be blocking IO, but shouldn't that be already taken care of by the async function definition? EDIT: Nevermind, googled it. Should have used aiofiles in the library. If implementing it using the executor, could it still make 2022.9? Otherwise I would rather update the lib to aiofiles. The code in should satisfy the async requirements, right? rikroe it does not. You're creating a temporary directory and opening reading files inside the event loop. Ideally there would be no I O. Why can't it just load it from memory? Otherwise, move that code into a new method that is executed in the executor. Just to make sure: bimmerconnected bimmer connected 489 satisfies your no I O requirement, if the fingerprints are retrieved using MyBMWAccount.get stored responses() , right? Hi balloob , could you maybe give me an indication if the above mentioned library PR is sufficient and this could be merged if a new library version is released? Thanks so much! frenck, sorry for pinging you... I was utterly confused... Please don't assert things in hass.data. Removed. Can this raise an exception? Shouldn't be possible, errors would occur before. This function just does a list(collections.deque()) and collection.deque().clear() . Side note: Nothing will catch this exception. We don't have a proper specific exception to raise in this situation yet, so it's ok for now I think. It's not likely we'll hit it. We could raise a KeyError instead if you prefer. Let's keep it like this for now. Where is AssertionError raised? It is raised by the diagnostics helper function if a device is does not exist (HTTPStatus ! OK due to the HomeAssistantError raised if a device is not found by our diagnostics). I'm checking if we should go ahead with this for now or if we want to change something in diagnostics integration to handle this better first. To be honest, I only included it because the [subaru integration]( L39-L56) is built the same. However we also could remove it completely - the only reasons why a vehicle as loaded device cannot be found (i.e. why the HomeAssistantError could be raised) are: - BMW API is unavailable - car was removed from the MyBMW account In case get vehicles() tries to get a vehicle that is not available anymore, it will return None and everything should work without any issues (only diagnostics data.data will be None which is correct). Tested not raising HomeAssistantError . Works as expected and therefore removed the exception handling.
This means ALL sensors are declared a measurement, but is that correct? Some entities represent totals too right? I believe they are all measurements. I dunno, for example, the distance sensor is not measurement IMHO, they are total increasing. Hmm, I can t see a distance sensor in my version of the integration. That is possible, what is shown exposed depends on what you are actually using. Ref: L190 Sorry, but not sure of the relevance of that code. In the HA integration, the measurement types seems to be from L18, which does not include distance. The entities created appear to have to be on on the types in WITHINGS ATTRIBUTES also defiend in L123, which also does not have distance - and all seem to be measurements.
I'm assuming we don't want this depending directly on application credentials, hence why this works this way. Please let me know if there is a better approach for structuring the dependencies, as this was just my best guess to get discussion started. I don't think the config entries should know about application credentials. We may need an abstract interface to accomplish the remove context details. I don't have a specific idea just yet. I've proposed a hook that integrations can register to add additional data on removal. This can run any time during remove (not just post remove) so if there is a simpler semantic we can use that is useful in more context we can do that too (e.g. a variation on async remove entry that includes a remove value) Can we register this callback per config entry or per config entry domain that sets up the application credential platform so we don't need to call the callback for all config entries that are removed in all of Home Assistant? I've added a callback per application credentials domain, good idea. I initially tried to do this per config entry, but did not see an easy way for application credentials to be informed. If there were a "new config entry" listener then application credentials could instead listen to that to subscribe on removals however that would invoke a callback for all config entries created (very common) in order to avoid invoking a callback when a config entry is removed (very rare) Happy to adjust if we have better ideas, but I think your per domain suggestion is a good balance. balloob what you think about this PR? I'd use the domain as prefix. The item id has a domain as the prefix fwiw. Are you suggesting something like this? {config entry.domain: { "application credentials id": item id}} ? No, I just meant application credentials vs application credential. Not such a fan of this name as it doesn't explain it's meant to add extra info to the result. I wonder if we can do this simpler by adding a WS API to check if a config entry uses application credentials, and call that from the frontend before processing the remove call. That way we don't need any of this callback registrations. Sure, happy to explore that. So the idea is that frontend would do a specific check for an application credentials specific WS API before deleting? Sure, sounds good. I don't yet quite have the intuition about when frontend should depend on specific arbitrary core integrations and where it shouldn't, so this is fine to me. I've removed and replaced with a websocket. Let me know if this is what you had in mind, then i'll take another pass on the frontend PR. I'm going to pro-actively start working on the FE side of this, assuming it's going in the right direction in order, to make sure we have progress on this by next release, given the severity of the usability issues for this. (soft ping)

Seems like this can just use iter chunks to not impose an arbitrary limit Given resp.headers.get("Content-Length") is repeated 3 times, i suggest extracting a local variable: I believe that headers is CIMultiDict[str] so can we avoid the extra str() ? Given images is turned into an empty list below, I think it makes sense to just assign images as an empty list at the top of this function to avoid having to worry about interactions between these multiple cases appending to it. I think we prefer pathlib when possible. Also ntpath is for windows so i'm having trouble reasoning about using that here... Style suggestion: Consider just having this accept a headers dict or None empty dict as default and pushing the header dict building into the test that needs it.
When the name is not set (and thus defaults to None ), the name of the DeviceInfo is used. Isn't that the same? The Scene still needs its own name for identification I think, which is reflected in the tests which does not need changing Why is this "" ? Because its given self. attr name device.name in the parent class Right, but shouldn't it be set to None in that case? Aah yes perhaps :) Changed
as I look at this again... zha gateway.application controller.state.node info.ieee is a lot. Should we make this a property on the gateway that just exposes this? something like coordinator ieee ? I'm good either way but this is in several spots.
Hmmm should we adjust MjpegCamera for this? (Accepting optional name or None )? This is something akin to 4 year old code so it warrants a general revisit (Axis code), but yeah it might also be a good idea to reevaluate mjpegcamera Fixed, thanks!
We want to test both exceptions. Use pytest parametrization. Can we move charset, folder and search to an options flow, or could the connection fail if they are incorrectly set? We only want the required items for the connection in the main flow. - For 'charset' this doesn't change for a configured mailbox and choosing the wrong charset will return a bad result response when doing the initial update. I recommend to keep it as part of the main flow. - As for the folder and search fields, we can move them to options flow. My concern is that there is a chance a user configures multiple instances with the same mailbox (username) and selects the same folder and search values (ending up with duplicate sensors). If that is acceptable I can surely move them to options. Yeah, I guess it's more convenient to keep all items in the main flow. Otherwise the user will need to set up multiple config entries for the same user with different searches or inboxes in a specific order, ie the non default ones first. Can these client calls raise exceptions? We should normally never use the builtin entity poll when we have a coordinator. I don't think we need to add the username if we're using the config entry id as unique id. Further testing showed that invalid authentication or wrong folder selection doesn't raise an exception by the library but rather update the state of the client object. So I added the code to raise some exceptions based on the detected state. If the initially selected folder is renamed or removed from the mailbox the integration will fail to start. If the user wants to select a different folder he needs to delete this entry and configure a new one. We should exit the loop after this so the task finishes. We're inside the task so we shouldn't cancel ourselves. Just let the loop exit by breaking and scheduling the refresh request instead of awaiting it. So it should be like this?
Untested, but I think this should make this a bit simpler Do we need update before add True ? Good question. The rest of the integration used update before add and has been that way since day 1. What does the flag do? I have limited understanding of what the update flag does, but it appear to be when the name of the entity changes, which does not seem applicable. Feels like I can remove it, but you know best here. Its going to call async device update before adding the entity to Home Assistant L443 which calls async update on the entity L695 Which I'm pretty sure isn't implemented because everything comes in via callbacks So I think we can take all of them out I did a quick test to verify. Taking them seems just fine and should make startup a wee bit faster
Shouldn't this be a total increasing state class? No. This sensor shows a number of torrents currently in "completed" (i.e., seeding) state. If user deletes one, count goes down as well. So measurement is the correct state class here. Same for other sensors. So its a total and not a measurement? Maybe I don't fully understand the purpose of total ... Entities tracking a total amount have a value that may optionally reset periodically, like this month's energy consumption, today's energy production or the yearly growth of a stock portfolio. The sensor's value when the first statistics is compiled is used as the initial zero-point. This doesn't apply to this sensor because it only shows the current value of a certain attribute and doesn't get reset periodically (or ever really). and doesn't get reset periodically (or ever really). What does that mean? It keeps counting up? Or does it go down too? Please note that the total class optionally resets. total keeps track of differences between the sums, while measurement only tracks a state of point in time (and e.g., tracks the average completed torrents in this case which seems odd). Okay, I probably didn't explain it well enough. Transmission is a torrent client and it exposes the number of torrent files currently tracked by application. You can add torrents (increasing "Total Torrents" sensor) and you can delete them (reducing it). Torrents can have different states - i.e., started or completed, active or paused. Sensors track number of torrents currently having a certain state, they don't count any totals. It's essentially the same as a sensor tracking a number of people currently inside a house - you would probably not use a total state class for that. tracks the average completed torrents in this case which seems odd Actually that would track the average number of torrents that are completed and currently seeding which makes a certain sense. Again, it's not some sort of lifetime total or even daily total, it's just the number of objects in a certain state at this particular moment. :) Maybe it would be less confusing is "Completed Torrents" was called "Seeding Torrents" instead Shouldn't this be a total increasing state class? I noticed name is used in the unique ID, which is not valid to use in a unique ID I know, it has to be migrated. This is not the focus of this PR though. Shouldn't this be a total increasing state class? Why not use just the already existing name instead? Maybe use the new style entity naming directly? entity-naming unresolved this comment, as it has not been addressed. Not sure what you mean by this. I'm using new style entity naming and got rid of name suffix in favor of name . What else do you expect here? With the new entity naming style, entities are no longer prefixed. entity-naming We don't need to have a method for this. Since this method will just directly return the string, just use that string in the places needed directly (aka this is an unneeded "proxy" method, 
Should this be part of each individual service call? Feels more like a general configuration option to me? It should be part of each service call. Cookies are typically exported per-domain (e.g. twitch.tv). I wouldn't expect users to have cookies for all of the sites they stream from in one file.
Could you update this to be in alphabetical order? done Since you are using self. attr device class instance attribute I think you can drop the property. Prop removed. I think it is confusing to have a mix of Cover Switch Sensor Button device classes. I think this constant should exist instead within each platform (cover plaform contains only CoverDeviceClass, etc.) I've divided this dictionary and placed it's elements to contextually proper modules. I think BLEBOX TO HASS COVER STATES should also be moved to cover.py It is only relevant here. Maybe also move BLEBOX TO UNIT MAP to sensor.py if it is not used by other platforms Please use the full import path here from homeassistant.const import TEMP CELSIUS Relative paths should only be used within the integration component. If these new dict have only one value, are they actually needed? Are there plans to add more items to them? or do they just bloat the code base? Yes, I've just followed data structure. In switch and button platforms, I'll remove. In sensor platform there are plan for new sensor and AirQuality will be migrated there. cover platform finds this structure useful. Does the button entity perform a firmware update when pressed? Oh, now i see. It doesn't, it's just to run command(eg. go up, stop) behind endpoint. So this attribute should be omitted I believe? I'll update this in following PR. Yes. : 1: Thanks!
Not needed This is only ever used during init? No need to store it in self It is used in the base class though. E.g. L68 No special use for device name so you can skip it It is used in the base class though. E.g. L96 self. id is used in the base class. This is only ever used during init? No need to store it in self This is used in the base class. You can probably consolidate all these constants in an Enum Good idea for a future PR. I think you can do this to not need to do cast on line 166 I don't think this will work. But instead of using NLFN I rather should be using s.th. like NaModules.Dimmer (which I forgot to expose) An upstream PR is already submitted. Is this a stylistic thing or would hasattr solve this as well? Wouldn't it be better to be consistent in naming the device between the different platforms? Yeah, there is certainly a lot of potential to clean up between platforms and gain more consistency. Current naming scheme originates from this PR so it starts here? Change this to hasattr? Yeah, for that line alone, yes. But I use state two lines later. Doh!
I can't find any need for the self. device name that can't be replaced by self. attr name It is used in the base class though. E.g. L96 Did pass concepts flow over to the library? :) Your doing multiple assignments from the same source, is it necessary to keep multiple different IDs that only seem to be used once It is used in the base class via that attribute.
This should work as well I'm afraid it doesn't work : It likely has to be done before it's wrapped in vol.schema for it to work. I'll take a look later today and see if I can come up with a better suggestion. This should work Added in 4557c161d9d95708984eac242e0025a8fa009676 Just realized this OUI is Murata Manufacturing Ltd which means it could match non-airzone devices. Is there a hostname you can use as well? bdraco unfortunately airzone doesn't set any hostname by default... bdraco unfortunately airzone doesn't set any hostname by default... bdraco However, I can ask Airzone if they can narrow down the mac address prefixes... We should abort here if its not actually an airzone device
The great thing about the Rest implementation is that you can now have multiple sensors on a single resource. So if you want to scrape five sensors from the same page, then you don't need to load the page five times... Could we do that here? Note: maybe you want to keep this PR as a "everything we want to implement, but too big to review", and we can add some of the new features gradually. For example, we can keep unique id, device class, state class, etc. for a separate PR Could we do that here? Good idea. Let's do that. Note: maybe you want to keep this PR as a "everything we want to implement, but too big to review", and we can add some of the new features gradually. For example, we can keep unique id, device class, state class, etc. for a separate PR Sure. Sounds reasonable to split it out a bit. Wasn't able to clean it out completely yesterday so will continue with that. I believe this one is sort of ready to go once the PR's you made are merged. Can you please move "cleanup config-flow" to a separate PR? Either it has been decided to never implement it, in which case the cleanup should be done in dedicated PR. Or it has been decided to implement it "later", in which case the strings shouldn't be removed. Took me a while to understand what you meant. The strings was never removed when the implementation of the config flow was reverted. I will reintroduce them as they are not part of this PR e.g. no change for now. Will try to have it done by tomorrow and then we can add back the config flow as a new PR next after this. You should import RESOURCE SCHEMA from homeassistant.components.rest.schema and use it here. Then you have automatic access to: CONF RESOURCE , CONF AUTHENTICATION , CONF HEADERS , CONF USERNAME , CONF PASSWORD , CONF VERIFY SSL And it adds CONF RESOURCE TEMPLATE , CONF PARAMS , CONF METHOD , CONF PAYLOAD , CONF TIMEOUT I think these three should be moved to a separate schema that is based on TEMPLATE SENSOR BASE SCHEMA from homeassistant.helpers.template entity : If you create SENSOR SCHEMA as described above, and import RESOURCE SCHEMA , you should be able to use this combine schema, which allows multiple sensor for a single resource. The integration schema is already validated, so we should only need to re-validate it during the legacy migration ( if discovery info is None ) Maybe it makes sense to rename sensor config to template config , and rename conf to parser config We don't need to re-validate it here. The validation is only required on the legacy platform YAML. Should we guard here against an empty list of sensors? Or do we need to make it required and not empty in the schema? I set a guard You could use a walrus here You could use a walrus here: I think name and unique id come from template config. I don't think it's a good idea to add config flow to the coverage exclusion. It might be forgotten when we implement config-flow again. Didn't see much off an option than this Just leave the .coveragerc file as it was. I
lets call this something else (is bidirectional?), I think there will be more chargers that support this in the future. Would be a shame if we would need to change the code then. Also, lets create a list of prefixes ['QSX','...'] and match the first 3 characters of the part number to these. This will allow more bidirectional chargers in the future. see above, change the name of the property. I would just add the sensor without the delete part, I have a lot of sensors in hass that I don't use, one more won't make a difference ;-) I'm not sure we need the loop here. Does this not work? yes it does.. sorry not my native language and got a little carried away. Have pushed the change you suggested.
This is a specific fan mode not provided as a standard, see: fan-modes Let move this inside the esphome integration. frenck can you expand a bit on how that would work? Are you talking about having "quiet" in ESPHome but not in HomeAssistant? It seems that OttoWinter was already happy with that idea: Add the constant to the ESPHome integration, and not to the climate platform integration. (You are adding the constant to components climate const.py , instead, add it to components esphome climate.py ). I'm actually doing both at the moment. Are you saying that the esphome component should know about "quiet" but not climate ? would that work? It seems that integration [need to use to constant from climate]( diff-d335f2f1f824951421ef024c3be5ef2aee032239bc4bbb723b8a5b54814ae889R113). I suppose I could just write "quiet" there instead, but is that what you want? Otherwise I can update the doc as well and make it official. Otherwise I can update the doc as well and make it official. An change to the main climate integration requires architectural discussions and approval. Just move the QUIET constant from the components climate const.py to components esphome climate.py , that is all that is needed. It looks like the constant was changed to a bare string instead of relocating it. Please move the constant per the review comment above. bdraco hmm, it's not clear to me what place and formatting you expect. Could you be more specific? Keep FAN QUIET "quiet" but put it in esphome instead of climate and than use the constant bdraco hopefully I got it the way you expect this time It looks like the esphome PR is waiting for this to be resolved fan-modes There are a couple of built-in fan modes, but you're also allowed to use custom fan modes. We wouldn't expect to add this to the climate platform
We shouldn't update the unique id them change accounts in reauth as the unique id will be wrong and the integration doesn't handle all the devices potentially changing. If it is a new entry they should setup a new one. self. reauth entry will never be None here. You can add a positive assert to satisfy mypy here Ok I understand, only password change should be possible. I changed that accordingly. Usually we patch the library where it is being tested instead of globally in tests to keep the patch as targeted as possible Unfortunately I have no idea what you mean with your comment. Can you describe your idea with some more details? Basically this mocks the entry point of the library which I thought is the correct way. But I'm a beginner in writing python mock tests so I'm happy to learn more. Ok understood, this makes sense. I changed it.
How did you test the LIP buttons? If you made them the same as the LEAP buttons you could use to connect to the telnet port and hit each button to find the LIP button number I didn't test the LIP buttons, I just assumed the integration will require them for compatibility. As far as I know, RA3 isn't exposed via LIP, LEAP only, so they will never exist really. There is no telnet for RA3. Only LEAP There is no telnet for RA3. Only LEAP Hmm.. Need to think about how we should handle this case. Unfortunately, Lutron deprecated the Telnet interface for the RA3 line of products. So I'm pretty sure that means the LIP button id's will never be exposed. I figured this would be the easiest way to maintain compatibility with the existing code. I've just set the LIP id's to the same as the LEAP id's for all RA3 Keypads. Please let me know if I can provide any more information to assist. SunnataKeypad2Button or SunnataKeypad 2Button Which one is correct? SunnataKeypad 2Button I pushed a fix since there were both in the PR All 3 in the DEVICE TYPE SCHEMA MAP should have the underscore
Please match the namespace of the integration Please match the namespace of the integration
How should these be formatted? quiet Quiet QUIET The named speeds shouldn't be exposed to the user so it should be what the library needs If you are interacting wiht the services can't you call a preset however? These look like named speeds and not presets preset-modes I mean they are called named speeds :) I'm fine with lowercase :) typo same change as climate Could be attr... The type is likely redundant here Please combine these message us similar formatting to other debug messages in Home Assistant Same for the rest of the logger messages Could you sort in alphabetical order? Could you add a type hint here? I'm surprised mypy didn't catch it... will do. mypy only checks existing type hints - not missing type hints unless you add intellifire to strict typing file Ah! ... time to add myself to strict typing i guess :) Thanks Can you avoid the setattr here and have a method on read api that sets the value instead? It doesn't look like this device actually has named speeds since you are setting int values. set-speed-percentage Please see If the device has a numeric range of speeds: The fan only has 4 possible speeds: What I've done is taken the 1,2,3,4 and turned them into quiet, low, medium, high ... it can't actually accept a percentage. .... Is this an incorrect approach that I've taken? img width "1084" alt "image" src "" You could convert 1 - 25 , 2- 50 , 3- 75 , 4- 100 with the percentage to ranged value helper The percentage isn't being used here? I think you could drop this as well Maybe make this speed range (1, 4) ? Reverse the conversion with range value to percentage here Looks unused?
Omit this and only catch specific known exceptions What if there is an exception that we can't predict right now? I believe this is a good protection against unknown errors. It's against the design standards for the code base to catch raw Exception, isn't it? The problem is that it mixes programming errors with other types of errors. IMO sometimes we should skip standards when the situation requires it. Exactly 130 other integrations catches broad exception in config flow. Mayby we need second opinion here I think for a config flow it makes sense to catch broad exception to provide feedback to the user and not simply break the flow. I'm not seeing anything here that requires this (it seems arbitrary for this call.. any other line of could could also have a bug and throw an unexpected exception too) so happy to have someone else review and approve. Looks great otherwise. I wasn't aware this is part of the scaffold script template, which is helpful context. L92 Do you need to handle the case where there are no existing profiles to choose from? I'm assuming you have to ask the user to set one up. Or is there always a profile? Each time a new NextDNS account is created, there is one default profile available, we don't need to ask the user to create a profile. Since this is a of queries, i'm wondering if this is really TOTAL or TOTAL INCREASING since it's the total count of queries, rather than a measurement of something like "queries per second" Caveat: I am not a sensor expert. TOTAL INCREASING does't fit here as the statistics can be reset and the value will drop to zero. According to the documentation TOTAL state class "should not be used for sensors where the absolute value is interesting instead of the accumulated growth or decline". I think the absolute value is interesting here. Ah, OK, I had in mind that only the rate (QPS) is interesting, but i'm used to measuring queries in another context. Thanks for confirming. I couldn't find where name is defined to understand why the cast is needed. Can you point me to where the name is defined in the entity description? name is defined here L225 and the type of it is str None . mypy complains that Item "None" of "Optional[str]" has no attribute "format" . hass.data.setdefault(DOMAIN, {})[entry.entry id] I think I don't understand. Dou tou mean hass.data.setdefault(DOMAIN, {})[entry.entry id] {} ? Yes. I just meant you can combine them into one line Yup, good idea. hass.data[DOMAIN][entry.entry id][coordinator name].async config entry first refresh() Yes, async config entry first refresh() should be used here. Good point. Could use a lambda in description instead I think I need help here, what exactly do you mean? I mean something like this L241 Smart, I will address all your comments in the new PR. Are all of these really for diag? In my opinion, yes, this is information about the number of queries with different criteria. Do you think another entity category should be used? I don't know. Just asking 
unload is not only called when it's removed. You need to implement async remove entry instead.
This shouldn't be changed at the moment. Rather add an empty method in the subclass. Can we expand with more temperature attributes in aiounifi? We can. I wanted to avoid having dependent PRs as I wasn't sure if you would want these changes or not. I have some other changes to make it aiounifi and was going to do this then. Or if you prefer I can do the aiounifi changes first and make this PR depend on those. I'm starting my vacation time now so I think I will have some time to continue my refactoring of aiounifi as well, but lets make small PRs to aiounifi that we can release with only changes relevant to this PR. Multi-line lambdas aren't allowed What do you mean by not allowed? It was black that made this lambda multi-line... Code structure wise its not allowed. See comments here Can we expand with explicit system stat attributes in aiounifi? As above, yes I want to do this. Can we expand with explicit system stat attributes in aiounifi? Can we add a general temperature attribute in aiounifi? Make type more explicit Right now I could make it float int datetime , but is that any better than Any ? L345 Oh right, I didn't know about StateType Its a big project and typing is relatively new addition to the code base Inexplicit type, this needs to be changed to explicit else I will need to rework stuff over time. I can replace Any with a union of all of the return types of the lambda s, but that means whenever a new sensor is added the type may need to be updated if the new lambda returns some other type. I might be missing something or misunderstanding you Yes, I think that could do it, there are only like 7 types supported in sensor platform. None, datetime.date, datetime.datetime, decimal.Decimal, float, int, string
Let's use the function to get a typed name. You're correct MartinHjelmare, but it needs some minor refactoring to avoid circular imports. Let's get this done in a separate PR
It is better to have CONF HVAC MODE as optional, and the below it the different modes. This was my initial thought also, but I tried to follow the convention used in MQTT configuration, where both the name of the register (topic in MQTT) and the set of possible values are defined at the same level. If you insist, I can change it but I think it might confuse users. This is also the reason I needed extra constant for each possible mode. Yes I insist, because that is what Modbus does with other parameters of similar type (e.g. 'verify'). We should max. define HVAC MODE, and use the consts already defined in components climate for each entry. Done. Though this part remains the same, there is a question. line 89 and line 90 have the same lvalue. Maybe line 89 should be self. attr target temperature config[CONF TARGET TEMP]?
Leftover debug? stale debug logging? stale debug logging? Maybe add a helper to create the signal here? ufp signal(DISPATCH CHANNELS) ? We need to disconnect the dispatcher signal when unloading the config entry. Please use entry.async on unload . Thanks MartinHjelmare
You could make self.coordinator.data[self.entity description.uid] a property if you don't want to write it out every time.
Could you create a dataclass for this, or at least a TypedDict, then set the return type of parse api container vm accordingly ? It will help understand what to expect inside the data. I changed the api data parsing to use a dataclass instead. Please let me know if there is something I did wrong with it though, as I haven't used this before. All of this can most likely be cleaned up a lot more, but I'll save that for after this PR is merged Since you are planning to add more sensors, I would say this is a perfect fit for using EntityDescription I think you are right, but incorporating EntityDescription right now would require some re-working of binary sensor, which is a bit out of the scope of this story. Do you think it would be acceptable to pospone this suggestion for a future PR (which I would focus on right after this one is complete) that would involve cleaning a lot of this up? I wrote most of this integration a few years ago and I'm really wanting to fix a lot of it now because it wasn't done the best lol You can add EntityDescription to the sensor platform without the need to implement it on the BinarySensor platform. Since you are adding a new platform, I think it makes sense to implement it on this new platform. yeah good point. Made the changes It is not compulsory, but it helps with readability: could you please try to add type hints on all new methods function? done This is a constant. Please use capital letters. done done Can you move the lambda inside the EntityDescription? You will probably need to: - Create a ProxmoxVERequiredKeyMixin class with the definition of the native lambda - Create a ProxmoxVESensorEntityDescription which inherits ProxmoxVERequiredKeyMixin and SensorEntityDescription - Use a class attribute on ProxmoxSensor to indicate the use of the ProxmoxVESensorEntityDescription Good idea. Thanks for all these suggestions btw. Most of this stuff isn't very clear right away. I made the changes in the latest commit. Let me know if there's something wrong with the way I did it. I think it would be better to leave the icon as None ( default value) Can be omitted since it's the default. If I am reading this right, a couple of these attributes appear unused in the parent entity, so i'd say remove them rather than passing them in. Entities should not include the domain name: unique-id Also, hostname is not an acceptable source for a unique id as described there in the docs VM ID is not an acceptable source for a unique id either as they come and go as well. I realize these are copied from the existing pattern, but i think those aren't quite right, and need to be migrated. I'm not sure what should be used then if VM ID can't be used. VM IDs are unique to proxmox hosts, although different hosts can have the same id and node name unfortunately. What would you suggest be used for unique ids for proxmox hosts, which there can be multiple of in one configuration? This page has all the guidance: unique-id Unique IDs awesome, but i
not sure whether it is more correct to use Name(s) of the camera(s) In any case, looks very straightforward
We should clean this up in the future per the comment here discussion r902363239 But for a future PR as we want to get this one merged ASAP to avoid the breaking change Yes. I just wanted to get this one in (as per prior discussions) and then do a bigger clean-up in a new PR as there is more things. This grew a a bit along the way I will hold off new features until clean-up done.
Don t use magic number, but a constant instead. See what I did for AEH. It seems you didn't push this change yet. If you do, I will adapt this PR to use the same style. Sorry, it was for thermostat: L51 Thanks, fixed! Can be move out of the builder. What do you mean? It is not possible to move this out of the init , since two lines further we need to modify it again. . Otherwise I will get. Just to be more clear I tried to adhere to the style we use in the other Overkiz entities as well; I don't think that first saving it in a local variable will make it more clear, imo it only adds another layer of complexity. I would rather implement the select as string eventually and make it more clear, as we discussed a while ago. I think we had a draft for that, perhaps we should try to move that one forward? Yes, there is indeed an open PR open into the upstream API. OK to start that discussing again and keeping this for now?
The property should not be needed. It should be automatically picked up from the entity description by the base class. L301-L302 As above, the property should not be needed. It should be automatically picked up from the entity description by the base class. This cannot be a measurement, "received" is an amount over time. This has now been resolved. You've removed them? Why not set the right state class instead? Same as above This has now been resolved. Same as above This has now been resolved. Same as above This has now been resolved. Is not a measurement. As a matter of fact, this sensor is actually against our guidelines, to begin with. I suggest on removing this state class. This has now been resolved. I plan on deprecating then removing the sensors, but I need to find a proper alternative first.
I was doing some manual testing and observed that google calendars between accounts may share the same calendar id -- e.g. every account may have a calendar with an ID like: addressbook contacts group.v.calendar.google.com The current unique id logic has a problem as it did not account for this, and it uses the following logic: f"{calendar id}-{entity name}" if num entities 1 else calendar id, I think what would make more sense is to include the {config entry.unique id} as a prefix. However, when I tried to change this I now get a bunch of new calendar entities generated. Is a migration path like [sonos]( L358) a reasonable model to follow? I may try this I went ahead and implemented this as I think i answered my own question. Shouldn't we allow a config entry per user that authenticates with an application? Many users can authenticate with the same application, right? Good point. I had in mind the nest integration where you make a device access project tied to a specific account. (Also, we may be able to make nabu casa a partner for this some day, so it could support more than local oauth anyway.) In general, you don't get back unique identifiers from Google's OAuth API. However, we do have a hack that the primary google calendar is your email address and we can use that, which we set as the [title in the config flow]( L152) -- however, it's a little more heavy weight as it requires another API call (e.g. won't work if reauth is needed) Is using the primary calendar id the way to go? Edit: I have a similar change from Nest coming soon, and I don't think it will be able to do that trick, but maybe it can use some other API identifier like a Nest Home id name used for the nest config entry title Primary calendar id sounds good. Implemented. Thanks for flagging that, it works great! I did testing for a few different scenarios and it all looks good and seems to work well. Should we raise ConfigEntryNotReady here? If we don't update the config entry unique id the state of the integration will be inconsistent. Sure, removed gradeful degradation and now there is a how hard fail instead. Added excepiton handling for the two types of failures, including one that requires reauth. Tests have been updated. Maybe abort if this fails? Sure, removed gradeful degradation and now there is a how hard fail instead. Additional error messages have been added for this abort case. Maybe add a comment about when we added this migration? If we ever want to clean up the migration it's nice to know when it was added. Added. I'm not sure we should add the entity name to the unique id. At least not for config entries that don't have any YAML calendar config stored. The entity name is generated from the calendar summary which could change. We don't want the unique id to change. For config entries without YAML calendar config, each calendar can only represent a single entity so using the calendar id for unique id should be enough as suffix. Maybe remove the unique id for lega
This looks like it could be a button entity ? This looks like it could be a button entity ? Remind me to ask you before next time You are of course right Since this is the same in both, you could make this a constant instead of writing it out twice r901160347 I'd try to use a decorator for error handling and implement different methods for the different commands instead. This common api call method is not really helping the developer. Typing is lacking. We normally don't need a custom icon when setting a device class.
But if you are going to add more probably best to keep it as-is Should move pure boost here as well as you wrote in the comment below. If the plan is to also do this for the pure boost it might make sense to define these in the entity description This method shouldn't return anything. I'd invert the check and raise if true. Then we can outdent below.
We shouldn't be creating these entities if its set to hard wired but thats not for this PR Ok - so we will just display battery entities for hardwired at this stage yea ? My hardwired currently are always at 90 anyway so no end user change there The change comes when we remove the entity as we need to remove the old sensor. Right now no changes here besides moving async update which was needed for the other change. In the future we can simplify this by avoiding creating the entities if it is hard wired and advise users to delete them (we could do it for them as well if we want to build that). This is also a breaking change which is another reason it's not in this PR We might be able to lower this but I was worried that we wouldn't be able to update all the shades in time since it took about 5-6s per shade. The current setting can roughly handle 50-60 hard wired shades. I would be surprised if the hub itself can handle that many given how flakey they are I personally was thinking a 15 minute sync - I think 5 will be plenty if not overkill - I would consider making to 10 ? people don t move their shades that often and the hubs really don t enjoy being spammed for an update I know they on occasion return an additional property lf timeout true instead of actually returning new data iif updating is done too often 10 seems safer so lets do that. That means it should still work with 100 shades which seems like its probably beyond what the hub can support anyways people don t move their shades that often I've said that before as well and been told that was not a good assumption. I pointed out that it probably wasn't a good idea to move them too frequently as the motors are not rated for unlimited operations. I expect someone is going to ask for it to be adjusted to a faster interval within days of the this being in a release. The solution for that will be to use the automation in the docs. Do you have a way we could make this user optional - I personally hate the assumed state and want to trust HA (we do all our moving through there) so I want shades to look closed in the UI when they are so You can override this with [customize]( manual-customization) There is an example on how to force assumed state to false . I don't think its supported in the UI (only YAML), but it might be in the future. Edit: It looks like only friendly name , icon , and device class are supported in the UI currently You can override this with [customize]( manual-customization) There is an example on how to force assumed state to false . We should set assume to false by default and tell the complainers to override in the UI Hate appeasing the minority groups Hate appeasing the minority groups It would make it easier, but it really is an assumed state since we don't poll the shade so its hard to justify presenting it any other way. Maybe Hunter Douglas Powerview etc will actually report the state on change someday, but I'm really not holding my breath on that one.
I'm not sure if this is needed. Can I use float for all of the generations? As I said in the description, I don't have a first or second gen heater, so I can't verify. But I belive the API supports float for all generations, but is rouded down for 3. gen. If you set the precision correctly I think you can use the temperature helper L11 If you do like this then I think it's enough to use the old code in set temp but with float instead of int (as float without decimal will be returned as int) Looks good gjohansson-ST ! Will test this out later (been on vacation for a while). If I understands you correctly I can revert all the changes I did in async set temperature ? Local API for Mill requires gen 3 heaters, and PRECISION HALVES is always supported. So there is no need for PRECISION WHOLE here. But tested this for the cloud integration (line 93), but I'm getting this error:
Static, can be defined globally and assign in class instance This will probably not stay static once different devices will be implemented with different feature sets but it can be pulled out again later. This is the basics right? So it should be static regardless, but adding tilt, etc. would be based on device Exactly. Since none of the testers had such a device and the documentation is lacking details I only went with the very basics. Will this be "blocking" while call is active? You mean while the cover is closing? No So it will be in state "closing" for a few seconds? In optimistic mode (which is the only one implemented right now) we can't determine how long the cover is actually in motion. So the state will be in "closing" very briefly or rather show the desired state right away. As soon as Netatmo will provide e.g. webhook events that give feedback about whether the shutter is moving or when it stopped this will change. This is where are local API would really shine. Unfortunately we don't have that. Then I suggest not using closing opening while its not actually supported. Keeps the PR simple. Will this be "blocking" while call is active? You mean while the cover is opening? No Will this really work then? According to the testers this does work, yes. This doesn't promise its at any end, not sure this is logical True, the problem is Netatmo does not provide a useful mechanism to get that information. This is at least working and predictable according to the testers. Its an async library right? Adding async in method names is typically home assistant, no need to reflect this in the library That is true, but right now the library actually provides sync and async methods in many places. This will be the next major iteration of pyatmo. Can closed state not be determined at this point in time? Can't you do self. cover.current position 0 Not without causing IO I'd say. But I'll double check. Sure, should be. Isn't the state available when initializing the library? Something like L90
Stale docstring How does this work exactly, why do we need to pass in the yaml config when configuring a config entry? This has been discussed in other notify integrations. Please refer to pullrequestreview-979335258 Maybe it was actually needed in the tibber integration, whereas it's just ignored here? The same has been discussed in nfandroidtv ( 73227 ) integration and highlighted by MartinHjelmare. Martin can you please confirm if this is required. Yes, discovery.async load platform requires the original config as fifth parameter. That's the signature and interface. Please fix this Sorry about that. I guess I will just remove it unless it is recommended to have a description. We should probably import the config to a config flow here instead. Thanks for the advise. I added the import and the tests for it. Appreciate your review. We don't need this. Can we test the connection and credentials before creating the entry? Unfortunately no. I checked and the api doesn't return any errors if the credentials are wrong. The library seems to raise some errors at least on bad request. L49-L57 Looking at the library an async interface has been added in the last couple of releases, and blocking I O is now done inside the asyncio event loop. As a codeowner I'd be worried about continuing to use this library. I have seen the errors that are raised by the api. The BadRequest error is only raised if the title or message are too long. This will only be raised during a service call. As for the Unknown error raised when the response status is not 'ok' I didn't get such response when using an invalid device key or password. We could probably log an error if the call response status is not ok when the service is called, but this shouldn't fail the integration setup as this could be a simple connection issue at the time. As for the async interface, if I understood you correctly you recommend to use the latest version of the library that supports async. I can surely update the code accordingly. It's ok to fail the config flow if we can't connect. This is standard. We want to validate the config and we expect the service to be up when doing this. But of course we need some indication that the config is invalid from the api to leverage this approach. As for the async interface, if I understood you correctly you recommend to use the latest version of the library that supports async. I can surely update the code accordingly. No, I mean that the asyncio code in the library is incorrectly implemented and would stop Home Assistant from working correctly. The library maintainers don't seem to understand asyncio and as a codeowner I'd be worried to continue using a library like that, unless I have influence and can correct it. Ok, I will add the check for Unknown error during setup. I have checked the api documentation on simplepush.io website and they don't seem to have any response for invalid config. So the library won't be able to implement such check. For the wrong async
This is a static value, could you use a class attribute instead? Great idea! Didn't realize that was possible. I will make the changes now Just a quick follow up to make sure I'm not causing some headaches for people. Would changing the name value break anything in the UI? I know unique id might. Figured I would ask. epenet As long as a unique id is defined, a name change is not considered a breaking change. However, if a unique id isn't defined on an entity, then it becomes a breaking change. Thank you for the clarification
Let's hold this change until a follow-up migrating core integrations to not break CI. In a follow-up, after core integrations are migrated, this should be marked with final : This comment is on the wrong method, it should have been on the temperature unit method. This doesn't do anything, you maybe want to do: And then use the temperature f below in the conversion This is OK, weather entity already converted temperatures, but we should probably return None here if self.native temperature unit is None . What happens if either self.native pressure unit or self.pressure unit is None ? I think we need to handle that during a migration period. This needs to be backwards compatible, there are a lot of custom component integrations overriding temperature unit . I think this would be a breaking change since pressure is not currently converted unless entities opt-in by setting pressure unit ? To make the code clearer, I'd suggest to return None if self.native pressure unit is None Let's keep these sorted for readability, maybe with attr native in it's own section. Maybe just report it directly here, something similar is done here: Also, to facilitate backwards compatibility, I think it should be possible to do: Tried both this and using setattr but both gives TypeError: can't apply this setattr to ABCMeta object Try this: temperature unit ( native temperature unit once this PR is merged) is required according to the docs, maybe unconditionally return self. attr native temperature unit from native temperature unit which will then raise if the instance attribute does not exist. Use walrus operator here, and in the other unit methods I think we will need backwards compatibility for methods temperature , pressure , wind speed , visibility as well as for attr temperature , attr pressure , attr wind speed , attr visibility . Remove this, precipitation only exists on forecasts. We typically use CONF constant naming for user configurable configuration options. Since these are not that, just remove them and use the ATTR UNIT constants instead. Let's extend this docstring a bit to explain the behavior. We should explain in the docstring that all attributes are in native units. Also, since this is just a stupid TypedDict can we add native keys and do forecast.get("native temperature", forecast.get("temperature")) when used? Let's get this line covered in a test. We should make sure this is working, for example by adding a few more MockWeatherXxx classes like is done for number : L32-L183 We should test setting custom precipitation unit in tests. Call this legacy unit behavior or something like that to make the purpose clearer When do we get errors that need to be suppressed? Either by someone setting a uom which is not valid or in this case a temperature comes in which can not converted into a float. I think it would be good if it continues instead of breaking (and thereby skipping this attribute until proper values are coming in). Why do we check self. override her
This really should be stored in a dataclass, but not for this PR
What does the "production" comment mean? Nothing, will remove it Removed We should not use DOMAIN as unique id to prevent multiple config entries, do like this instead: However, why would we only support a single meter? Can't we use the meter's serial number as unique ID? Agreed that multiple should be allowed. This was a "first version" decision. I suggest I put this on a backlog for a future version. I'll fix the usage of DOMAIN though. Thanks! To make it possible to allow multiple config entries in the future, you'll need to set a unique id already now. Did a rewrite to fetch the device number during setup and used this for the unique id. Please remove this, you can contribute it via lokalize once the PR is merged: Understood, I'll remove it. Done Please set the device class for sensors which have a matching device class: available-device-classes Did this, thanks! I had overlooked this. Remove this if it's not used. Moved some stuff and I think it's okay now. This will implicitly add whatever the ultraheat api package provides. Instead of that, be explicit about which sensors will be created, for example by a map or list of SensorEntityDescription where the key is field.name Very good suggestion. Did cost me a bit of time, but the result is much nicer (I think). We want to make sure we're using Home Assistant's units when possible, not whatever ultraheat api is using Changed this along with the change above. I expect this measurement does not periodically reset? If that's the case, set state class to total instead; how-to-choose-state class-and-last reset Same comment for the other measurements. Interesting,.. the part that you link to, states about total : "The sensor's value never resets, e.g. a lifetime total energy consumption or production: state class total" But a few paragraphs above, total increasing is explained as: "Similar to total, with the restriction that the state represents a monotonically increasing positive total, e.g. a daily amount of consumed gas, weekly water consumption or lifetime energy consumption ." So I'm guessing this has changed and documentation is not yet up to par? Set the state class too if this is numeric, same comment for other sensors: Add a simple test for this to improve test coverage. The test just needs to setup a config entry and then remove it, like this cast test: L105-L126 Move this to a function to avoid duplicating code here and in async step setup serial manual path Don't call a dict a list , just call it ports or port selections or something. Use a select selector instead, maybe something like: Why is this needed? Can't the state update wait until we're connected to the meter? I'm not sure what you mean here. I'm trying to restore entities after a reboot. Because the updating is very intensive for the battery it should not be done every restart, but only when necessary (once per day for example). Oh, that's fine then You should cover it with a test though, it's very simple if you use the mock re
You don't need to give the full device info each time. You could just have identifiers {(DOMAIN, info.serialNumber)} and it would connect it to the hub. Thanks for the hint, I was not aware of that possibility. I changed the code accordingly. As now the device info of the hub is only needed once I create it now on the fly. This does not seem correct. The via device should have the same identifier as the hub, which above is set to {(DOMAIN, info.serialNumber)} Thanks for the hint, it was the same identifier but I changed the code to be more clear. why slugify? this becomes a breaking change now as unique IDs no longer match? I removed slugify from the member because I need it for the hub device info. So slugify is just moved from another place to here so no change of the unique id. .list() doesn't return a list? Correct, list returns something like an iterator which can only be consumed once. And with the new code I need to iterate several times over the list and therefore this change is needed. Why is this called here and not when the device info is requested ? The device itself does not contain enough information to create device info, therefore I create it upfront in the controller where all information is available. So if we like to change that I think we need to first do an intensive refactoring of the FibaroController and device classes. So if you think the refactoring should be done first just mention it here, then I will try to refactor those classes upfront in a separate PR and decline this one.
Calling this from async setup entry means we'll try to re-setup zha if the user removes it. Maybe that's not wanted? I'd think we'd handle this like a discovery flow that the user can ignore? The flow now has a confirmation step if onboarding has already been done It would be nice if the user can ignore the config flow if they don't want it. Maybe it's a bit over engineered to have dicts for this? If it's only one instance right now, I'd just use a couple of constants directly. Maybe this error handling can be removed? This step will be initiated by the home assistant yellow hardware integration, should we name the step "hardware" instead? Renamed to "hardware" Maybe this is too detailed, should we just check that a zha config entry is created: Simplified Can we set unique ID here too, maybe the config entry of the hardware source? Instead of this, we should use the unique ID check. zha only supports a single config entry from what I understand. Teaching zha about multiple config entries could be done in a separate PR.
why store this in msg too ? so we can unsubscribe when an exception is raised in the exception handler decorator but why reuse the msg variable? That's the passed in message. Why not use a normal variable? the decorator wouldn't have access to a normal variable? unless I am missing something obvious
Can we gather here? So, the await on most of these is misleading here. It can be an async function if build children True is passed into all of the children methods and it actually fetches the events ( build events is the one that is truly async). Otherwise, it only builds one level down synchronously with no awaiting. So gather would not offer any performance benefits here. I could still switch it to gather though for convention sake, but does gather maintain output order? The order of result values corresponds to the order of awaitables in aws. Could save some indent by reversing the condition and outdenting here Could save some indent by reversing the condition and outdenting here Could save some indent by reversing the condition and outdenting here Could save some indent by reversing the condition and outdenting here Could save some indent by reversing the condition and outdenting here I think you can use dt util.now() here from homeassistant.util import dt as dt util Sweet, that looks like it does the same thing. I did not realize that used the timezone from the config correctly. I think dt util.as local might work here instead Since I know this will come up. This is essentially a greedy algorithm. Since we cannot know which camera channels the user has enabled, we cannot just generate a valid unique ID. That being said, this for loop can run async get entity id 1 to 6 times, but should run only 1 most of the time if the user has the default camera entity enabled (High RTSPS). Worse case is if the user only has Low RTSP only enabled for a camera, it will call async get entity id 6 times for the camera. Can you make this a dict lookup instead? Would a named tuple or something more flexible make sense here to avoid the magic numbers below? I am not sure I follow. The identifier has to be a string. I was hoping the data could be a bit more normalized and the string could be unpacked into something more structured like I refactored it a bit to cut down on that, but having a single class it not really possible as it branches too much. Thats a lot cleaner. Please use er.async get instead. The other is legacy. 76870 We don't need to check length explicitly on containers if we just want to know that they are not empty. Containers will be truthy when they are not empty. 76870 Why do we need to ignore type here? Its a issue on the core end: 76869 Leftover debug print. 76865 (merged already)
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: I'm sorry but I cannot currently invest the effort in refactoring this platform YAML configuration into an integration. If you have developers who are looking for a sponsor to do this work, and make it so their work includes this effort, then I might be able to fund them.
Side note: It's possible to separate the parameters with space after the comma, which makes it easier to read in my opinion. When do we want to implement this property and return None explicitly? Let's add that explanation to the docstring. I don't see how a full name is a backend thing? It's up to the frontend to decide how to display an entity (eg prefixes or having additional information, depending on the context a UX has to provide in that specific situation). This should not be decided or provided by a backend program We need it in backend too to get sane initial entity ids Agreed, but right now, it is directly used by the name property. IMHO, if we need to generate entity IDs, we need to teach the entity ID generation to incorporate take the device name into account (and not silently add it back into the name property). The entity id generation has indeed been modified in this PR By having the name property return device name entity name we can ease in this new feature without breaking things everywhere when integrations are updated to implement entity name . We should also expose the entity name via the entity registry and allow it to be overridden by user, that can be done either in this PR or in a follow-up. By having the name property return device name entity name we can ease in this new feature without breaking things everywhere when integrations are updated to implement entity name. ? I don't follow that one. The name property never had a full name, now it has in this PR; I don't see this adding to backward compatibility? Did we add prefix name with device in the core? Let's be careful calling anything "full" and instead be explicit what is included: device entity name. "full" might indicate the area name is in there too. I think that for this PR, we don't need this method at all. The entity platform should keep using the name property for entity ID generation, since name will return the "device entity name" if available, or fall back to the existing name. since name will return the "device entity name" if available That is my whole point. It should not return that The entity should not care about its device name, with the single exception of the entity ID generation. All other cases are UX problems. Let's be careful calling anything "full" OK, how about render composite name then? The entity platform should keep using the name property for entity ID generation No, that's not possible because we need the name to influence the entity id generation whereas the name property need the entity to registered in the entity registry. I don't see this adding to backward compatibility In which way does it not do that? Consider the examples in the PR description, the entity's name property will get a reasonable and descriptive default by combining the device name and entity name. Well, we don't do that now either, so it's not "backwards compatibility". If anything, it's breaking. The whole point of the naming changes is not to interfere with nam
to have it perfectly non-breaking we could use 50 as default and run it through percentage to ranged value() . The default constant could be sourced from xknx.devices.fan import DEFAULT TURN ON SPEED if you like. The problem is (actually also with my current PR coding) that we once again have defaults in HA, which means xknx does not know for a switch GA fan, if that speed should be set in addition to switching on the fan or whether that was just the default (which should have no impact on switch GA fans). To really fix that xknx itself would need to contain a copy of percentage to ranged value() so that we can also determine what the default speed step for stepped fans should be. Sending that in from HA means we would again incorrectly use that value for switch GA fans. Or alternatively, we add a new parameter to self. device.turn on( ) in xknx so that we can pass both, a speed and a default speed and then xknx can decide what is correct to use. oh dear I'd not add a default parameter to turn on - spreading this logic over 2 repositories. Either add percentage to ranged value() to xknx (would require a new release) or check for self. device.switch.initialized here too to decide if the default should be applied.
You'll need to change the line in async step user so it can win over a discovery await self.async set unique id(format mac(mac), raise on progress False) This shouldn't be needed after d9e7d8a86e74ed5203f14a0ba4a92f28714aa6cf You'll still need to do this because without raise on progress False in async step user it will hit the below code will abort in the middle of the user trying to set it up when its also been discovered since the discovered flow is an in-progress flow. L1297 Fixed in b9632f12ffde5c5c6b7ae5321ee872d368bd9c7a Thanks bdraco It doesn't look like you need another function here Modified in d9e7d8a86e74ed5203f14a0ba4a92f28714aa6cf Usually we don't send them right to the user flow if since it will ask them for data we already have (the url) elkm1 has an example If you really want to branch in the user flow, axis config flow.py has an example of that, but I generally prefer to avoid branching inside a step as it creates higher risk of bugs Changed in d9e7d8a86e74ed5203f14a0ba4a92f28714aa6cf None is the default
Sure, should I also add type hints for the rest of the code or keep that for a different PR? Try to add type hints for all "new" code. For "old" code it's better to put in a separate PR to avoid massive PRs. host port cannot be used to define the unique id If there is no unique id available, then the previous method was the correct way to implement it It would be easier here to get and cache the reauth entry: Can be easily reviewed after 72534 I think it can even be reduced so that it is fully independant of that PR. If you remove all unrelated changes from this PR it might be reviewed and merged before the other one OK let me try to rebase it on dev and only add the reauth flow. Can be easily reviewed after 72534 I think it can even be reduced so that it is fully independant of that PR. If you remove all unrelated changes from this PR it might be reviewed and merged before the other one OK let me try to rebase it on dev and only add the reauth flow. I suggest that you amend the signature for async setup in TransmissionClient to return None and remove the return True at the end of that method: Thanks for the advise, code updated.
Maybe call this enabled or enable ? It took me a bit to figure out what it did. img width "1197" alt "Screen Shot 2022-06-18 at 13 31 33" src "" Thinking about this some more, it might make more sense to have one service to enable, and one service to disable. If we go with how Sensibo themselves does it they have Enable Disable as a button and then "Configure Pure Boost" in settings (which also turns enable Pure Boost if currently disabled. That would be in total 3 services but I think that's stretching it so I would also think your suggestion with enable disable service is the better way. enable also means to configure boost settings but disable purely means disable it. I think you could still do it with two services by making the args optional for the enable service. Probably the best so now it's configured as such and works well on my device.
Please patch for only parts that need the patch in place or move the patch to be a decorator. You can await hass.async block till done() inside the with block to make sure its the action is completed before outdenting Please add coverage for missing lines typo? Please so all of the executor work in a single executor job. Each job has to be scheduled, pushed on to a queue, and then returned so its more efficient to do it in a single call Then you can drop the dict being stored in the hass.data Looks like this copied an older version of the boilerplate async add job has to figure out how to run the job. We know want to run it in the executor so we should use hass.async add executor job Also we don't want to create multiple executor jobs since each one has to be pushed in a queue, run and returned. Its better to do all the work in one job I did not fix the broad exception here. That still needs to be addressed Please only trap errors we expect to be raised and don't use a broad exception catch here We should catch the connection errors only here. Its ok to use a broad exception catch as a fallback and set the error to unknown here but only after you have caught error we know are connection problems We should patch the library not the integration here. Please see writing-tests-for-integrations. You can likely patch principal to get the same effect. Sorry but I'm not good at testing For function homeassistant.components.caldav.async caldav connect I created a test setup entry in test init.py and for the function call homeassistant.components.caldav.config flow.async caldav connect I made a patch by a mock fixture I delivered a new version of the code. is this what you expect? because I don't understand the concept of "principal" You need to remove the mock connect fixture before you can patch DAVClient.principal otherwise it will never get to the patch with patch( "homeassistant.components.caldav.caldav.DAVClient.principal", side effect DAVError(), ): r892030842 r892030842 r892030842 r892030842 Please add coverage or add uncovered files to .coveragerc We don't want to raise ConfigEntryNotReady outside of being called from async setup entry Let this raise here and trap the exception from the caller. You can make a constant for the exceptions to trap CALDAV EXCEPTIONS (RequestException, DAVError) ConfigEntryNotReady is only intended to be raised in async setup entry or a function called from there. Please see r892034195 Non-empty lists are truthy in python. black will complain about this suggestion Is CUSTO a typo? Looks like this can never be missing since its a required field We shouldn't use the URL for the unique id. unacceptable-sources-for-a-unique-id Since there is no discovery I don't think you need one here anyways. You can use this instead: self. async abort entries match({CONF USERNAME: user input[CONF USERNAME, CONF URL: user input[CONF URL]}) Do we need to mutate the user input with .pop() here. Can we use .get() ? async create entry isn't 
It would be a lot cleaner if you could do something like self.device date.update from command(result) as it would avoid all these setattr calls I think also it would probably look nicer to have an update function as these setattr calls are a bit everywhere. But I don't see a better way to update the dataclass except using setattr or maybe use of a function was the point? The dataclass isn't frozen so you should be able to change it directly. I'm suggesting binding a method to the dataclass to process and update data from an api response so Home Assistant knows less about the details The response from the api only contains more or less that it was successful and not anything useful to update the data. So either one has to update manually (like your suggestion) or simply stick a coordinator refresh in instead to update all data. Response from api on setting a timer: Could as follow-up PR move the logic of such to the upstream package to return a proper response with the required information and thereby require less knowledge of the data in the HA integration. At the end it didn't matter I noticed since the service is called from climate.py but the entities are in sensor and binary sensor which doesn't update anyway and didn't immediately see a good way to tell them to refresh so I set to ask the coordinator to update instead which should be pretty near to immediate. Would be interesting to know if there is a good way to ask all entities to update from one. Looks like some of these should be ValueError? silver- The problem with ValueError is that it's not giving a response in the UI while HomeAssistantError does. Probably only the case for these custom services but it's the reason why I used HomeAssistantError instead. But I will change it as it should be ValueError and test it again and probably raise an issue for the non UI message on ValueError if it's still not showing.
These are all very similar models. We should use ButtonEntityDescription for these Example here L28 done Please type the Callable typing.Callable Done too Not related to this PR but for the future, pv data should get converted to a dataclass instead of a dict . This integration is quite old so dataclasses were not a thing when it was created so there is a lot of legacy here. This seems like it duplicates the functionality of service-homeassistantupdate entity If you rename this to async update and remove self.async write ha state() and put in the base shade entity this should make all entities be able to do force update with the built-in call i've just pushed a change to do that - and made the change to reflect in cover.py aswell Could you please test the button for me, it is functioining the same with this code as it was before but still makes me question - the force update button definitely updates the shade position (verified by looking at the shade position in a browser window and seeing the position update) but the actual slider in HA doesnt update immediately - takes around 30 seconds for it to change i put some dummy logging events in for testing and can definitely see it being put into the coordinator so wasnt sure why the UI would be lagging behind Unless you call it through the service it won't write the state. The service calls: L35 which in turn calls L497 Which calls the async update function and then proceeds to call L520 I thought you said to remove a self. async write ha state() call. In particlular since this replaces the force refresh in the cover.py what code do i need to add to make sure it writes the state back to HA too ? Are you saying i need to add that back to the end of the async update call defined here ? Are you saying i need to add that back to the end of the async update call defined here ? [1ad555b]( If you call it from the service homeassistant.update entity service, it will do it for you. If you call it from the button you would still need it since it doesn't do that for you, but since we are removing the button it should not be needed We should drop the button as well as using the built-in service is the preferred way having a moment here so please confirm. What I have just submitted might need to be rolled back The point of the button is to allow a user to force the refresh of the shade position because battery shades cant be spammed. So we cant be overwriting the built in update task as this would result in all battery shades being spammed for a state refresh right ? Its won't poll automatically since it uses CoordinatorEntity as a base class. They will have to call the service to the individual shade to poll L317 sure thats fine then, ill remove the button - but having now updated the asyc update for this item wouldnt that mean battery shades would be getting spammed with a force refresh every 60 seconds ? Or is async update only called through service and not related to the 60 second refresh ? EDIT: I re-read
These probably shouldn't be attributes? Why not make these actual sensors? Additionally, things like "remaining" is the number of seconds remaining? If that is the case, this will cause a lot of state updates. For those things, it is better to use provide a datetime of when it's expected to finish.
I am not an expert on this, but i read hostname as not a source for unique id unacceptable-sources-for-a-unique-id ? Just flagging, bug will defer to others This is not a unique id (which by the way actually uses some problematic sources in this integration). This is a device identifier - basically, a lookup key for entities that should belong to device. I m not sure this is as strict as unique id but open to suggestions for better sources. Looks good to me What would the context of .host be? It's the host of the Glances server that you enter when setting up the integration. Essentially, an IP. I'm not sure if Glances provides a mac address we could use and I think host is good enough to uniquely identify a Glances server. Essentially, an IP. In that case, Allen was correct. IP is not allowed, as a matter of fact, looking at the existing code, this integration already violates that rule for its entities big time. It uses the "name" in its unique ID for its entities (which is an absolute no-no!). Well, I know that name is a big no-no and consider fixing it somehow even though it's probably very tricky without big breaking changes... Do I understand correctly that we should use entry id here? I don't see any unique identifier for the machine hosting glances that could be used here. Unless you can find something avee87 I recommend to use the config entry id. Well, I know that name is a big no-no and consider fixing it somehow even though it's probably very tricky without big breaking changes... We have migrations helpers in place to migrate entries on all places. It happens from time to time and can all be done without causing breaking changes This wouldn't work properly. In this context name is the name of the entity, not the name of the entire Glances server. Basically, device would get named after one (random) of the entities in it - i.e., instead of being called something like "Glances Server" it would be called "Glances Server RAM used" name comes from the entity adding and just looking up into your code name entry.data[CONF NAME]. self.name however would be what you describe which is a completely different thing (you can see that you build self.name from name and a few different bits). Lol, you are right! I remembered having this exact issue with this.name earlier when implementing device info via property rather than setting an attribute. Not needed as you can just use name in DeviceInfo as both of them goes back to entry.data[CONF NAME] See my reply to another comment
This is not a measurement?
Media player has built-in support for join and unjoin. we should use that. I just ported this over from the previous implementation because I didn't want to get this PR even more complicated. Join and Unjoin services are on my to-do list for a follow-up PR. So for any of the services that are going to be target media players, register it on the entity platform [like this]( L57-L63) Do we really need a play everywhere service? Users can just pick the media players they want to target ? This was already existing and can be deprecated in a future PR, I guess? Why store name? The entry already has a name. Why do we need to ask for the name? Noticed below there is a device.config.name so we can remove asking this completely I added the name because it was a property in the yaml configuration, but as this can be overridden for the media player entity via the GUI later, it should indeed be unnecessary. I will remove it. Everything is deprecated, not just port. I went with what I found in other components: logging the migration notice any deprecating the whole config section in the next version? Should I completely deprecate it now? you already print a deprecation warning inside async setup platform so this single key deprecation is not necessary. We shouldn't let other parts of the integration directly call methods on this media player. Once you switch to registering services via entity platform you don't need to anyway Correct. I planned on removing this once the join unjoin services are in place drop name or . Just stick to device name. Title is automatically set to manifest title if omitted, so not needed here. Description also doesn't add much info. So let's drop it. Drop name. The async setup entry were not patched, so your tests were trying to make requests to soundtouch devices. Fixed in e42bef8140eb83a0863562fc26e2aabc47a89c2a Awesome, thank you! This can just be a generator expression. Is creating a zone similar to grouping sound devices to play the same thing? If so, we have a standard media player interface for that. grouping-player-entities-together This could be a dataclass instead. We should return None as state to represent unknown state. It will be converted by the base entity class. Please add a test for already configured device for user and zeroconf flows. Add a MockConfigEntry and then start the flow.
This really should be a switch entity instead but I didn't want to add a new platform since this PR is already large. I'll do that in another turn ok. Would be great if we can do it before the next release so it's not a breaking change. Marking this as a draft so it doesn't get merged prematurely. Once I have the switch platform ready, I'll merge this and open the other PR. I've got the new PR prepared so I'm going to merge now and fix the conflict We should move this into init in the future Why override CONF HOLD TEMP ? Good catch. That's a refactoring error. 54e57689c0a9db2d486a05a2b5bd86f64f8ec4f8 We normally raise ValueError on invalid user input and HomeAssistantError on all other errors in service handlers. Will adjust tomorrow after sleep Fixed in We should probably run the options flow inside the patch context manager as the flow will trigger a reload of the integration. Options flow removed here
Is it possible to specify return type hint? (str?) Added I can see why valid device needed a checking function, but couldn't valid power command be done with a normal voluptuous "in list" type pattern? I assume that would be better for any GUI that might use it too. Could you use 'in list'? lists
Should replace this with a "System Bridge" title and list each available entry as children. Currently, this will only show a media source for the first available loaded entry device, where we want all available systems to be listed Done you're not returning anything you're not returning anything you're not returning anything Why do it like this? Can't you just return data? Otherwise use an event to notify when data is available ? The WebSocket asynchronously receives the event which is passed to the coordinator. This waits until this attribute is set by the coordinator event handler. I'm not sure how I would return a BrowseMediaSource without pausing the function here. Any examples of how I would use an event? All messages send over a websocket connection are asynchronous. That means you need to implement an RPC mechanism where you match requests with responses. Add an identifier to outgoing messages and create a result future to the server [like this]( L113-L124) When a message comes in and it's a result message, pass it to the result future [like this]( L320-L342) Updated package to do this similar to the above Need to rebase. Some changes here are now in dev Please split long strings around 88 characters per line. A ternary operator expression inside an instantiating multi-line call like this is really hard to read. Please rewrite it. Please don't use ternary operator expressions that span more than one line.
The actual test runner might be a bit too helpful here as it seems like its detecting the invalid data before it gets to where it needs to go
Are you planning to use this outside of entity.py ? If not, then you can simply use {self. hub address} in the URL. Felt like there was a reson i did it this way but tested and its working as suggested. Change pushed We should make device info a dataclass in the future In a future PR we should create a dataclass in a models.py instead of using a dict here
Why do we need exit 0 ? Doesn't that mean we never fail if installation fails ? Its on the wrong line Fixed in 0f0be7ee37297bffb52ea48ca8c35ca8ccf7cc55 Do we need to delete this directory after the build? I think thats a good idea. 0f0be7ee37297bffb52ea48ca8c35ca8ccf7cc55 Rerunning the build now to make sure it works as expected Built successfully with that change So one feedback I got from jesserockz is that since it's different run steps, the cache is still stored in the previous layers. So it means it's still there.
Adding this attribute here to be able to get the entity ID given a device. If you see a better or more pythonic hass way to do it, please tell me The device shouldn't know about the entities. The event should be fired regardless of any entity. The event should be fired regardless of any entity Not following that. Without entity, there should be no event (No existing opener, it should be impossible to have an event without that tho) Right, but the device shouldn't know about that. It would be ok to look up the entity id from the entity registry. It's not ok to add the entity to the device. Then I'll save a dict (nuki id - entity id) in hass.data to be able to link device entity We can also look up the entity id from the entity registry using the unique id (nuki id). Example: L532 Oh, didn't know about it. Yeah, 10x easier that way! We're inside the thread pool, ie not inside the event loop. So we can't use the async interface. Preferably we shouldn't use the async API in sync context, although technically in this case it works. Not sure what's a better alternative at the moment. Didn't see a sync alternative. As the async fire specifically states that it shouldn't be used outside the event loop, I thought this one would work. Anyway, the async fire worked too, so I'm not sure. I found nearly no documentation about it Edit: Maybe I can use asyncio.run coroutine threadsafe . But I'm not sure It depends what the call does. This case is just a dict lookup which is canonical. But it's bad to use the async API in sync context regardless as we may change details about how it works in the future. I'll modify the update devices to be async, and call the device.update() with hass.async add executor job() . I'm not sure how much overhead may run in executor add inside that loop though There's an overhead to switch context. That's why we have this function so we only need to schedule it once on the executor for all devices. Compare with needing to schedule on the executor for each device call. Comparing times, it doesn't seem to be relevant. With the 2 devices I have: 1 run in executor 1 run in executor per device ------------- ------------- ------------- First fetch 0.6s 0.8s Other fetches 0.05s 0.05s (Those are just approximate measures as it's very variable) Other way would be to return from that function a dict[event type, set[unique id]] . Not sure if it's worth it, but I'll see how the code ends up Moved the event firing logic outside that function, I think it's pretty clear now Please move this block down, out of the try... except block. We only want to wrap the line that can raise inside the try... except block. But that code shouldn't execute if the update fails. Maybe extracting it to a function? We raise if update fails, so the code won't execute if we put it below those blocks.
Please use consistent capitalisation for the name field I applied the change but not sure I am getting it to show up here. This is my first time and will need to do some research. I see it now below. Let me know if there is anything else. Thanks! Yes, your change is now in the PR but the capitalisation doesn't match the rest of the file. To match what's existing it should be: Written in sentence case Rather than Written In Title Case If you get what I mean? I get it but went with how other sensors are currently named. Anything that had "Temperature" used Title case. To be certain, should it be "Hot water out temperature"? And is "Boiler Supply Temperature" ok? If it should be one standard for all sensors (existing ones) then I can update them all to match. Just let me know. Thanks again Sorry you are right. It changes half way through the original file which is not consistent. I am not 100 sure what the convention is but I expect title case based on looking around at some other instances briefly. Yes, I have checked a few more. Title case seems the most common. So I Suggest Go With Title Case For Now On The New Code Then if you want to change the rest to match, do that as a follow up PR.
Oups Why is OverkizCommandParam(state) here required? Since it is a string enum in OVERKIZ TO HVAC MODE, I would just pass the string directly instead of making it an enum first. Mypy was complaining. See my closed PR, you would need to type OVERKIZ TO HVAC MODE (like we do in the other climate implementations). Why is this check required? I don't recall that it can happen that OverkizState.IO TARGET HEATING LEVEL is not present? Well I just backported the code from ha-tahoma :S L201-L206 I think you added this in this PR? Since I don't have it in my closed version, and not on ha-tahoma. :) Here why I added this condition: homeassistant components overkiz climate entities atlantic electrical heater with adjustable temperature setpoint.py:105: error: Item "None" of "Optional[State]" has no attribute "value" [union-attr] The state can be None. Same question here, do we really need the check first? Instead of directly returning the state. Same answer :) to respect alphabetical order It may be interesting to add all of them into a constant file into the climate entities package. Some are also use into L24-L26 Do more Overkiz entities use those presets ? This may also be the case for the following consts Bepending on which will be the first to be merged between this PR and 78659: - OVERKIZ TO PRESET MODE - PRESET MODE TO OVERKIZ - OVERKIZ TO HVAC MODE - HVAC MODE TO OVERKIZ May share same constants Quentame The constants are not exactly the same and are device dependant. Every devices supports it's own set of preset mode and or hvac mode. That's why it's set on the device file, used only on the device where it's defined. In some case it could be the same, but there is often slight changes between devices... Quentame We can indeed create constant for string such as auto, prog, or manual. As said nyroDev, for constant like OVERKIZ TO PRESET MODE they are not common to all the devices. Quentame If you agree, I will create this constant file with another PR to not pollute this one. Ok for a future PR. Yes, (some) devices will not use all entries of the Dict, but as you don't iterate on it and only use it as a key to value map: I don't think it will disturb anything. I think you could use value as float instead of the cast Ahah good catch Done. you could use self.device.states[OverkizState.CORE OPERATING MODE] I'm wondering who suggest you this I will. Thx Done. you could use self.device.states[OverkizState.CORE ON OFF] Done. If I understand the code correctly, If the device have the state CORE OPERATING MODE , we'll never reach the elif or the else here. Maybe the first if should check against HVAC MODE TO OVERKIZ ? maybe self.device.states[OverkizState.CORE TARGET TEMPERATURE] ? And then value as float Done.
This looks like a feature change. The default scan interval is 10 seconds for media players. Why do we change it? If we need to change it, please move it to a separate PR. This was the result of trying to follow the rules defined in [Integration Quality Scale]( Set an appropriate SCAN INTERVAL (if a polling integration) I've removed it again, as the default is indeed ok.
Feels like we should be able to do this automatically for all integrations with discovery flows since we set a unique id of the config entry and flow. Yeah that makes more sense. I'll prepare an alternate PR
We don't allow new YAML configuration for integrations connecting to devices or services. Fair enough on the media browser point. What approach do you suggest as a way to easily specify a list of favorite stations? That is why I use the yaml config. I tried to implement it using config flow , but there is no support for lists of strings in that framework. That is why I use the yaml config. ADR-0010 prohibits the use addition change of YAML for integrations that connect to a device or service. In this case, it's a third-party service being integrated. I tried to implement it using config flow , but there is no support for lists of strings in that framework. There is actually, all Blueprint selectors are available. This includes lists with custom entries. - - show-form What approach do you suggest as a way to easily specify a list of favorite stations? I would suggest adding such a feature to the media browser; not this integration (this would require an architectural discussion before implementation). Adding it to the radio browser integration is "fake" as the radio browser service doesn't support favorites (so we actually won't allow this to be added here, as this is a simulated feature not provided natively by the integrated service). (this would require an architectural discussion before implementation). What is the right forum people for this architectural discussion? (sorry if it's a dumb question, I'm new to this) You can make an architectural proposal of your change in the GitHub discussions in "architecture" repository (that is also in the Home Assistant organization).
This might be a bit problematic. The current code seem to handle passing the same update callback many times, then i think you can call remove listener same amount of times to completely remove the the callback. It's now assumed to be unique. I've switched to using the "return cleanup" approach for the coordinator, that resolves this ambiguity and allow multiple calls on same update callback (theoretically we could pass along the context, but that would be a rather large change for many components)
Add state class MEASUREMENT to both Done, thanks! Should we disable these 2 entities by default? They tend to spam a lot and will push new updates every 30 seconds and are hardly used. Add entity registry enabled default False to both. These sensors are already disabled by default, see line 344 368: attr entity registry enabled default False As part of the NetgearRouterSensorEntity class
If we type data as Mapping we can probably avoid copying the config entry data to a new dict before passing it here. that was to easy
I don't follow this condition. Shouldn't we check that there are no identifiers for other domains or identifiers with a device left in data? Maybe I'm reading websocket remove config entry from device wrong, but I think it we only need to care about if its ok to remove it for the config entry passed here. The check comes down to the identifier[0] matching the domain identifier[0] DOMAIN and then identifier[1] aka device does not exist: not data.get device(identifier[1]) So it is find any identifier in the set where the domain matches where the device no longer exists. I'm trying to think of a case where that could fail. If we somehow have multiple identifiers for the device and one of them is the correct one and one of them is stale data, but august hasn't ever changed the device ids so I think it should be ok Maybe invert it like this to guard for identifier of the august domain with remaining devices? That will work Its safer in case something changes in the future. a255aed1414bb87e3aba476e177f1af6797e54d4
Should we reset REPORTED INTEGRATIONS when tearing down tests?
I think you intended vs Let's merge this with the device info method. These are both pretty small methods that I think should just be one. I thought of that but isn't it easier to read if we make them separate? This PR is missing a reference PR against or brands repository adding this brand. Could you open one? Thanks!
hmm, it seems, that this doesn't trigger the reauth flow. How am I supposed to trigger it outside the data fetching? Some getting methods don't require a password but the setting methods do ... Found it. This is the default. Are we missing coverage here? If the device is unabailable, the next coordinator update will fail with the same exception and that case is covered by a test. Shall I test it here again? All cases should preferably be tested. It looked like you tested this case, so I wasn't sure if codecov was correct. This will be called from async context so we need to use an async api. Use hass.async create task . This looks weird. There should only be one active reauth flow for the same config entry. Use this helper instead to deduplicate flows: L690-L697 Do we need to block till done after moving time? Yes indeed. I missed that.
The name LOGGER INTEGRATIONS is a bit misleading now, we could maybe rename it to STAGE 0 or something like that. No longer relevant, frontend now has its own stage This adds an asyncio.Future to hass.data which integrations (frontend) can wait on until recorder has concluded if a non-live migration is needed or not. This now needs to be done earlier because the registries are needed by frontend We increase the priority for dependencies of the stage 1 group here. Don't we need to do this also for the logging and discovery groups? This is about logging, and can be clarified in a separate PR Removed because this is now done by calling helpers.recorder.async initialize recorder It would be good to validate we still get the frontend when the recorder setup fails in this case It would be good to validate we still get the frontend when the recorder setup fails in this case Minor nit: would be nice if recorder platform as a constant minor nit: Would be nice if these were constants or better: a dataclass We should probably merge this will a large number an bump it back down when we implement the migration of data It would be cleaner if this code didn't have to interact with instance , but it might be hard to do since all of this is so tightly coupled
Let's do a correct scaling instead: Let's do a correct scaling instead: Or if 0 turns the light off, do like this: The logic came from the original haiku integration. Your suggestion is much better. 0 does seem to turn it off so lets go with the scale clamp 89513734a76437ce82f8ef9e4e956ac360d43176
It is a timestamp, it has no unit Is this the time until a user is marked as DND? It's not clear what value this adds. No, Slack has DND set to pause notifications but an amount of time must be specified. This sensor indicates when DND expires. Ok, understood. Let's improve the name maybe? Maybe "Until" instead of "Timer" ? Update description copy paste These seem like they can be outside the scope of the try except, so should be moved below to keep the exception scope as small as possible, This appears to be using the slack client to store some integration state -- that is, these are not actually defined properties of the slack client that I can see, but just properties that are being set here to hold data. These seem like they would be a fit for hass.data as data stored outside of the client? Entities will have their own name (without device, area). Or, they may optionally set the name to None (in that case they inherit the device name). Then set entity-naming If the description is static we can define it at the module level as a constant. We normally don't set a custom icon if there's a device class. Is there a difference between this icon and the default icon for this device class?
Do the tests assert that if there already is a google calendars.yaml , that is updated and if there isn't it is not? No, there were no explicit tests -- i was being lazy, but now i've added them. Can we parametrize the call count instead so we don't need conditions in the test? The of calls is like 44 since the mock open gets invoked a bunch of times (e.g. one call for every newline in the file) so instead of parameterizing call count i've parameterized the boolean rather than relying on the other parameter so it's at least a little more explicit. If there is a simple way to parameterize "zero" vs "not zero" let me know.
Can we change this to ZHAAttributeButton Hehe, it was like that at first, but I didn't liked the double capital A. No problem it will be changed Is this intentionally being set? Same for all other entities added in this PR can you add a constant for this so there are no magic 's? you need to extend CustomCluster or you will interfere with Zigpy's cluster registry. See here for an example: L178 This can t be None now right?
This is strange: we're awaiting the same coroutine twice and using its returned data to update properties of the same object that carries the coroutine? oops Why aren't we including Platform.NOTIFY in platform setup? I don't think notify is set up that way Should we call it Status if it's really an away switch ? Or should this better be a select so it's clear what options exist? Active sounds better. There is only 2 options so a switch should be appropriate? The switch is not clear to what each option means, since it switches between "Away" and "Auto". this is weird. A user can set it to auto , which might still be "away" if the user is not at their computer?
I think this should be moved to a local constant above async setup entry There is no need to recreate the dataclass if there are multiple config entries This causes a typing issue with black reformatting it to a tuple. There is no reason for black to reformat it as a tuple. You should be able to do: CONSTANT NumberEntityDescription(...) Looks like my indent caused black to add the parentheses. Removing indent manually seems to make everyone happy. These two should be moved out of try...except Did you miss this comment? There is only one Update docstring. Since the native value is always 60, this seems like it might be better as a service since we never know the value unless you can get it back and update it My original thought was to not have a DND sensor and instead reflect the DND Until timer in the number entity. That would update DND every minute, increasing API calls. Setting this as a service would be less user friendly don't you think? I'd make it a service and then use a TIMESTAMP sensor for the the DND ends. I agree with bdraco. Number entities need to be able to configurable and then represent that value. 60 is hardcoded.
Although I am a fan of Lametric and this is nice, I do have a change pending for a complete rewrite of this integration. Adding this, will cause this to become a breaking change later. For that reason, I'm not sure if we should add this right now.
The lru dict we use for the recorder might be a better fit here. I'm not 100 sure they will stay around long enough with a weakref I checked to make sure it didn't leak I tried the lru as well and it worked fine and was just slightly faster but it would have to be added as a core dep (already in the recorder) The LRU definitely performs way better on heavy load. Its only slightly heavier than the LOGGER.debug is enabled check The LRU was faster but it got evicted too soon. We probably need to cancel the task if the queue reaches the max size 8c0da9de2f31baefcde76d7d12de90455ead990d This needs a filter to reject anything with a UOM or state class 195f5c1a8c8836c624d9353ed6de5f4836cc6462 This should not allow you to subscribe to entities with UOM or state class 195f5c1a8c8836c624d9353ed6de5f4836cc6462 We should filter out entities that have UOM or state class here for the existing API We should reduce the entity list before calling async determine event types 195f5c1a8c8836c624d9353ed6de5f4836cc6462 We should filter out entities that have UOM or state class here for the existing API 195f5c1a8c8836c624d9353ed6de5f4836cc6462 The weakref should probably be on the context instead I think we can delete all of this now as the event listeners are setup before the call now so we will already have the data waiting on the queue I think we can drop this completely since logbook has access to the original context I think we don't actually need this Can probably drop this We need a filter if they have limited to specific device id or entity ids fe6287c9107a0b3897c94ed6fe96350bd23b687b Why even wrap it? We can test it's labeled a callback and be done with it? Let's turn this around for readability. It's not possible to disconnect without unsubscribing because all unsubscriptions are automatically called on disconnect. Could this be so long that it causes the subscriptions to fill up the queue ? We don't call task done for these. I don't think we need to call it for the others either ? It's used when calling queue.join() but I don't think we call that? This seems more efficient than going into try catch inside a loop
This looks out of place If I search for "async def async setup(" all the usages I see are defined in init .py . I was inspired by the integration octoprint . Please let me know how you'd go with placing it correctly. Thanks! This can be rewritten as a generator You can also use BinarySensorEntityDescription I looked into Generators but I couldn't figure out how to use them here. Using BinarySensorEntityDescription turns out that adds way more lines of code compared to how it is right now, unless I've done something wrong. Can you provide a quick example on how you'd go with rewriting this? This project does not use assert in production code Most integrations put this in init .py but this may be fine Please have a look at the codebase for examples on how to use SensorEntityDescription . All the extra sensor classes can then be consolidated into 1. New integrations are now required to use the new entity naming style. Please see: entity-naming This can be put in a separate file: coordinator.py Please make these their own sensors. You can use EntityCategory.DIAGNOSTIC as part of above comment if they don't seem critical like others. Same as above. These all seem to work with the button entity? If so, this can wait for a future PR.
I feel like we can drop prefixes of the obvious. Yeah they really are a bit much. Will pair them all down
Use RestoreSensor instead, this allows correctly restoring the sensor's native value instead of its stringified state. done, thanks! Do we want to make all netgear sensor restore, or only some of them? Why is this needed for the speed sensors, isn't it correct to keep the sensor in an unknown state until the first update? Instead of restoring, you could trigger an initial update of the coordinator instead of having it wait for 30 minutes if at least one speed sensor is enabled. I think it is fine to restore all of them, it does not matter for all other sensors since they get updated while loading the integration anyway. A speed sensor update will test the full bandwidth of your ethernet connection directly from the router. Therefore this will take up all available bandwidth on your ethernet connection for about 15 to 30 seconds. I think it is very inconveniant to do this at HomeAssistant start since all other integrations might need the ethernet connection, so it is not nice to max it out during start for 15 to 30 seconds. That is why I chose to only do the first update after 30 minutes. That is also why the scan interval is 30 minutes, you don't want to max out your ethernet connection all the time. But it is anoying in the graphs if there is a gap of 30 minutes because the sensor is unavailable at start, so I just restore the previous result. This can potentially block the lock for 20 seconds. L931-L952 Generally, we don't want integrations to sleep in our executor thread pool, as it may exhaust the pool. Specifically, this may stagger other api calls that come in during the time period that the lock blocks. The mitigating factor is only the much longer time interval for the speed test calls. That stops this from becoming a problem that breaks the integration. The design is still bad though.
From the Tuya documentation: ![image]( So it says power, but its unit listed in the docs is kWh which is energy. This PR says it's Watt . But Watt is a measurement and cannot be a total? Could you explain what this is? It's in Watt. Know from actual readings from device where I know the approximate consumption (read 900 from a boublebath). It also goes up and down which would be strange if energy. In which doc did you get energy (kWh), I do read kW in the snippet but that must be a typo of (W). Merge conflict resolving gone wrong?
This shares the same key with L45 is it guaranteed that device.device id will be different? else you get the same unique id for both sensors: L105 Yes,Each sensor has its own unique device id . This is the closest one to indicate leak The descriptions shouldn't all have the same value for the key attribute. The key value should be unique among the descriptions in the platform. Since our device api design, most binary sensors key attribute is state , So I give key attribute a default value For special sensors, I will override this key attribute. There's no guard for adding more than one sensor per device and we use the sensor description key in the unique id. So the key must be unique across the descriptions. We can add another description attribute for looking up the api value. yolink binary sensor will not have more than one description for per device, but I think I still need to fix this issue. I will create a new PR to solve this, Thanks
Instead of calling async add entities twice, create a list and pass that into a single async add entities call Okay. Shouldn't this be: ? We should represent values in Home Assistant as-is and not try to make mappings. Please take a look at my changes. Is that okay? I will That is acceptable (you could maybe use a dictionary to look it up instead of an if else tree, but... that is a bit taste personal preference). These states are kinda awesome, as they can be translated. stringssensorjson Consider adding a translations file. This is no longer a percentage. This device class cannot be used in this case, as its not a percentage anymore, see: available-device-classes

Is there a use case for the filter to mutate the context? Can we make this a boolean return? No, there's no case where we want to mutate the Context. Changed to just return a bool instead. These doc strings need to be more documenting.
Should we just call it name instead? We're using it to set the name of the implementation. Yeah agreed, keep it short and simple. Renamed. I realized also that imported credentials should have a name if not specified by the caller, and it makes sense to set that here if unset. As a reminder, this will be used for a couple things: 1) for display in the app credentials panel 2) will show up as the default config entry name if integration is deleted and setup again or was setup for the first time, if the integration hasn't set a better title. I welcome feedback, since naming is hard. I have proposed "Import from Configuration.yaml" in this PR (following the pattern of the existing default "Configuration.yaml") but here are some other names to consider: - "Imported from Configuration.yaml" - "Imported Application Credential" - "Application Credential" Either we set a name that describes where the credentials came from, like "Imported from Configuration.yaml or we set a name that describes something about the credentials, eg the first five characters of the client id. Imported name can be "Imported from configuration.yaml". For creation of names I would suggest we don't ask for a name. Only allow users set a name via edit later. Since creating application credentials is not a process that users are familiar with, I am afraid that people will get confused when they see "name". Edit does not exist today. So what is the default name for manually added creds? Ah that's a bummer. Yeah in that case we can ask for a name. Say we have edit (we can add it, it's just not needed): what's the default we'd want for names even if we had it?
We may find we need to refactor this later to store events by domain when they are registered if we ever get more than 100 of them. This is not allowed. Events are tied to devices. ec4e59723d11c0db08b4afa7e4c2138141ea95a0 I just realized I can move these one level deeper since they only need to be created before they are passed to the closure that creates the lambda stmt moved in d5db31d43f716ea83cb7376674b8e146a6b62248 All of these can actually be constants. But thats for another day and another PR
Use async entries for config entry helper. This is really expensive to calculate for everything before you check the others. Use a walrus operator inside your if-statement instead. You shouldn't forward the setup of this platform unless this check is true. As the devolo devices have different capabilities, this could be done for all the other platforms as well and would need some extra logic to calculate which platform is suitable. Do you mind, if we handle that in a separate MR? Reverse this check. if not coordinator: return {} Cache if it's a station once. This will never change right? Well, a station could do e.g. band steering. So rarely the wifi band could change. This should not be stored inside the attributes. If added to HA at all, it should be a separate sensor and it should be disabled by default. That's a good idea. I removed them and will create a separate MR later. Are these items essential for automations? We normally only add dynamic info or automation essential info to state attributes. Define essential ... I could imagine e.g. notifications, if band steering does not work as expected or if a station shows up in the main network although expected in the guest network. An essential attribute allows an automation that someone is planning to do or have asked for. Are you planning to create those two notifications or have someone asked for that? My wife's mobile is not capable of using the upper 5 GHz channels. If the AP automatically chooses one of those, the station is connected via 2.4 GHz, tries to steer to 5 GHz but can't, is back in 2.4 and so on. I can configure the AP to only choose lower 5 GHz channels, but if I screw up during reconfiguration, my wife is mad at me. So I plan notifications in my setup, if devices I know to support 5 GHz are stuck in 2.4 GHz. The guest wifi case is nothing that happens to me as I'm not using this functionality and nobody asked for it yet. Is it a clearer approach to make sensors out of those information as well? If the measurement is useful on its own it should be a separate sensor. My goto example is a light with a brightness. Brightness should be a state attribute as it's not useful to know the brightness if we don't know the on off state of the light. Compare with the battery level of a device. It's useful to know the battery level of the device regardless of its main state. So battery level should be a separate sensor. Then I guess an attribute is the right way. If the station is not connected at all, the information is useless.
Do we need an extra block till done? Nope ca218c4ebcb917e09f02d1b73ada3928711703da
Do we need a common translation string? L73 Typically on the abort step, we render a core driven string with a "Close" dialog. With missing credentials in the frontend PR this is showing its own dialog with a "Cancel OK" prompt and is using a frontend translation. diff-e67939fd25c650222db710f18764d10ae69454b0e8ad680f5e10177c2db93ceaR2806 img width "597" alt "1 - Missing creds" src "" It looks like the dialog could be updated to use a core driven translation. Would it be preferred to use the core string here? I didn't necessarily do it this way intentionally, I was just copying a different dialog. I'll pass the question to balloob. The reason is not directly used for translation this way, however, we have more of those cases (and still provide translations). Considering all reasons uses in core implementation have a matching generic transition; it makes sense to just add it. It will not harm and adds consistency. I've added a translation in oauth2 missing credentials though it is different from the frontend translation since the context is different. It's just saying that the component requires application credentials, but doesn't include the question. I'm assuming we don't need to add unused translation keys to all the integrations supporting application credentials, so not doing that. Let me know if you had something else in mind. I think that is fine Maybe talk about integration instead? You forced pushed over the fix that was committed.
This is an unrelated style change, that has an effect on this whole PR (making this PR unneeded hard to review as well). We generally import specifics for typing, instead of the module. Please revert these styling changes from this PR.
I think this should be removed, there is no real point in dividing into 2 versions? And when doing that also remove me as code-owner would be good. (moved on from hass) My idea was to maintain both considering the variety of routers in circulation. Can we wait for other opinions? My idea was to maintain both considering the variety of routers in circulation. Can we wait for other opinions? ... Could't "commend out" or "strike-through" this, but i finally got it up and running, everything works as expected(from what i can see) ... i apologize for my inpatient nature, but im to old to deal with that :) ......... If you want "assistant" in troubleshooting your "proposed" actions to verify , you better "shoot when the powder is dry" ... im currently without device-tracking and all, as i installed asuswrt custom, and nothing works, hour ago today i had both ASUSWRT AND AsusRouter integrations working , so i might run out of patience, or time for testing playing around :) .... PS: Im still available (for testing purposes) just to justify my conscience :) ... Could't "commend out" or "strike-through" this, but i finally got it up and running, everything works as expected(from what i can see) ... i apologize for my inpatient nature, but im to old to deal with that :) Never mind, good to know that this work for you. Any suggestion that may come using this implementation are welcome I have just finished "evaluate" Asus Router-Custom integration, and i fall back to ASUSWRT, Would be great if You could bring this Integration upto-date, and maybe as you mentioned in " 72591" ADD a few more sensors. What first come to my mind, was (beside WAN IP-Sensor) also Router-uptime.sensor HA " UPnP IGD " Core-Integration, include these 2 sensors, but from a usage-perspective would it be great if we don't have to use 2 different Core-Integrations, to get info's from the Router Personally im not interested in DL UL-Total or Speed etc., But essential info and "Tracking" initially, And using only 1 integration for this :) As of now i have to use ASUSWRT for it's "Tracker" and "Connected Devices" AND UPnP IGD, for "RouterUptime" and "WAN IP"
Reduce the scope of the try except to the smallest possible, wrapped the line that can throw it only. This is an interesting method -- it both can return False or throw an exception. In what cases does it do what? Oh so I read the code and it seems like it never returns False Also i see init calls the same function w o checking the return value, so maybe just remove that check here? So something like this would be good? i'd say make a now variable given utcnow is called 4 times in this function. What's the motivation for the 5 retries 1 second part? In general i understand why you might retry on failure, but here it is unclear that it is necessary to retry faster than the existing scan interval or the default behavior of the update coordinator. There are random error 500s and 502s that occur when the weather station loses internet and other various reasons. Right, so, standard reasons that any device connected to a network would have. I'm trying to understand what's special about this device and it sounds like there isn't anything. Without this, there would be more errors in the log than desirable, but after another request or two, it goes back to normal for some reason. We want to avoid retry logic in the codebase if at all possible. This should live in the library if you really want to do this. I am not familiar with this pattern of allowing a broad exception in a config flow, and generally prefer not having a broad exception. (This came up in another PR, but it didn't see right to me, though the author pointed out other integrations use this). This is the default template provided by [scaffold]( L92) Thanks, wasn't aware of that. I'd maybe say instead to just have the id here as the key? Rather than encoding information in the key, store the locations and get the name back from the id. There is a design standard that you have to show the form for the step in the step itself. This form should move to step async step location , and instead here invoke return await self.async step location() Best practice is for tests not to assert on hass.data, but instead trigger the particular behavior through the integration tests instead. So maybe here you want to advance time with something like async fire time changed ? It would be a little more straight forward to just pass in the extra variables needed rather that coding information into the string and parsing it out, especially since the key is constructed right before LaCrosseViewSensor is created so the separate fields can be passed in. I didn't realize get locations could also throw LoginError so in that case i think it's right to keep in the same scope of the previous try exception. Apologies for that. This regexp could be worth adding a comment at what it's trying to accomplish. I'm fairly familiar with regexp syntax but unsure what this is doing though I didn't look it up. I'd say just inline rather than having the extra typing line Instead of updating the hass.data, you'll need to advance the clo
We don't need to deprecate it for this integration, as it has never been stable. We can simply remove the whole configuration schema. Great! geocaching folks this will break your dev instances. It won't, as getting a token is nearly impossible (hence this integration supports account linking). Awesome, even better, that is helpful context. This has all been removed. While we're discussing this I have two other considerations so if you have any other thoughts on these let me know: - I was thinking about supporting integration discovery based on application credentials, but have not added it yet I noticed this integration does discovery for itself based on configuration.yaml but that has been removed now. - May be possible to further simplify test setup, but just leaving it as is for now. This is based on what I have proposed for the scaffold script to generate. I was thinking about supporting integration discovery based on application credentials, but have not added it yet I noticed this integration does discovery for itself based on configuration.yaml but that has been removed now. Yes, it did that because it was next logical step. One adds app credentials to the config, restarts HA to make it effective, next adds an integration entry. The "discovery" was mainly helpful to aid shorten the flow to the last step. For this integration, it doesn't matter that much. Removing it, is fine. I guess in the future it would become less of an issue (when the application credentials can be "part of" the original flow). Good point, users won't really start in app creds panel. I will test this in the morning (mine that is); I can't right now
You could save some indent if you make this a guard and return True when the conditional is reversed This integration does not connect to a device or service, therefore, ADR-0010 does not apply here. As this is an integration that defines its own protocol. For that reason I expected it to support both YAML and UI (and no import happens). That's fine. I will change accordingly. Yaml is now returned and also removed the breaking change section in PR description as there is none anymore This is not supported by the config flow Is the SchemaConfigFlowHandler not a good fit? Why do we add this? This needs a "None" option too which should be the default, applies also for sensor. Same comment for the already merged scrape config flow. Inspiration: L32-L42 Why would we need a None? If the user doesn't set it then it will not be added to the config entry. This is not needed, icon can be configured via entity options Does it work to apply a template in the entity options? No, I don't think it does, but we don't need all features supported by yaml to be exposed also via the config flow. I think this should be: Is this filtering really needed? Should this also allow selecting the state class?
If you extend SensorEntityDescription with an lambda (e.g., value fn: Callable[[Device], [int, str]] , you'd be able to remove getattr and retain typing. I did that. Upstream library isn't typed so I ended up with some casts Was this changed on purpose or accidentally added during testing? Oops. Was testing. Got added to this PR reverted
Does it make sense to keep a dict of entity id - entry id, ufp device id in hass.data[DOMAIN] that entities get added removed from in async added to hass and async will remove from hass ? Please use f-strings Please break the migration out into a separate PR Please use f-strings This one is confusing as to which entities go in which field if its called entity id Switched it to device id instead to be consistent with the other devices and not require a breaking change down the road. Not entity IDs. It is a target selector. So, it could entity IDs, device IDs or area IDs. r877674692 This works to limit to matching devices Unnecessary change. It already filters the Area IDs and Device IDs to ones that have matching entities. ![image]( I don't think that we're allowed to modify or set the service call data on the service call that we've received. You should create a complete new ServiceCall if you want to change anything about the call.
We should say that it's the config files that the update applies to and not the driver. When can there be a config update? How does the check work? Why dont we use the existing client fixture? If it's only the patch for check config we can override that fixture after breaking it out. Do we need this signal? Maybe just add the entity when setting up the platform? Break this out to a fixture that we can compose as needed. Should we check once when setting up the integration too?
Meh, I don't like adding a new dependency. It's pulling in more code and only for a template function. The code you're linking is showing timezone parsing, but that's not part of a duration at all ? Thanks for the feedback. I will dive in and pull out the good stuff.
I'm currently using 1 or 0 in the attribute what I want to switch. Will be better to switch to boolean? You've mentioned that content of this method is done in the super class, but it never registers SIGNAL ATTR UPDATED L199 Without this, the value on frontend is only polled at predefined time period. I had to register the whole ManufucturerCluster self. channel for signalling when a changes of its attributes occure. Can I somehow scope it to a single self. zcl attribute ? Is this needed? forgot to remove inverted and category should be defined in inherited class. one moment please Missing type annotation for the state parameter. Please type the whole signature when adding type annotations. Sorry I missed this when I reviewed it. No worries. added the type info to another PR I have open in this commit:
A lot of sensors support "alarm" like functionalities in Tuya, but are they standalone or part of the generic alarm function of Tuya? As in, is this a control panel? Can you actively walk up to the device and arm it? according to the documentation within the category of Tuya Developer portal, yes... In the specific device I have, no Ok, lets remove this part until we can test confirm that. on it done Missing name no need for name as this is door contact, the only one that supports it for that category, same implementation as another category for binary sensor (mcs, mc) This is a multi-sensor, it provides multiple sensors values, mcs and mc are contact sensors, so their primary sensor is expected to be this. If you don't state what it is, the user won't know. This needs a name in this case. done - Please don't f-string DPcodes, instead extend the existing DPCodes. - Is this an event or an actual state? this category is for multi-functional sensor, I cloned the same sensor from a simple sensor into array of sensors (the multi-functional one) I don't have a sensor supporting it but done it based on exisiting sensor supporting it, and compared it to the documentation of Tura Developer portal The reason I ask, in case of an event it should not be a fixed entity. So you need to ensure what it is, or omit it. The same applies to the others. removed it (can't test it), although in: is pretty much the same - Please don't f-string DPcodes, instead extend the existing DPCodes. - Is this an event or an actual state? As in, it can't keep dropping? this category is for multi-functional sensor, I cloned the same sensor from a simple sensor into array of sensors (the multi-functional one) I don't have a sensor supporting it but done it based on exisiting sensor supporting it, and compared it to the documentation of Tura Developer portal removed it Unresolving, as this is still an f-string. this is the key as opposed to DPCode which has no f-string, in addition, the file contain originally the same code (including the f-string), not sure why it should be so different removed the support for SHOCK STATE - cannot test - Please don't f-string DPcodes, instead extend the existing DPCodes. - Is this an event or an actual state? this category is for multi-functional sensor, I cloned the same sensor from a simple sensor into array of sensors (the multi-functional one) I don't have a sensor supporting it but done it based on exisiting sensor supporting it, and compared it to the documentation of Tuya Developer portal removed it Unresolving, as this is still an f-string. removed the support for SHOCK STATE - cannot test Missing name, maybe an icon? no need for name as this is pressure sensor, the only one that supports it for that category, same implementation as another category for binary sensor (ylcg) This needs a name, as this is a multi sensor. done
Normally we require integrations to be set up through the core APIs (instead of testing the class directly). But, I see everything in these tests still does that, so I think it's OK to exempt this one. If you are looking for ways to help improve this integration, this might be a nice next step in improve the quality of this integration. Ok, I will try to improve this integration tests. Moreover, I have some new features I think will be useful. I will check other integration tests before. Thanks you, for letting me contribute!
Why make this configurable? I agree, more of those options should be removed due to general improvements in home assistant I made it configurable because all other entities in this integration are. But I agree it is not needed, I'll remove it. This can be defined in the top of the class using attr device class This can be defined in the top of the class using attr supported features Device class provides both IP and MAC properties Copy paste issue I think this does not need to be a primary entity DIAGNOSTIC is already the default at L215-L224 So I don't think it is needed to set it here also? Perfect! Or should I remove the NotImplementedError at L76-L78 ? I will clean that up later on, this is a good reminder for now.
Is this needed? No, exceptions are listed in the hassfest manifest checks, this integration could be added to that list. Should this be retried until we're sure the os info from the supervisor is valid? why would it not be valid? There's error handling in update info data suggesting it's not always valid. This now retries: 0fdb209 Without this, setup of the integration fails. Is it not possible to have an "empty" integration with only platforms? What will set up this integration? Never mind, I see that the supervisor will do that. Is this needed and correct? raspberry pi doesn't match the raspberrypi domain. We probably need to change either place to match. Shouldn't the manifest provide details on the type of integration? "integration type": "hardware" perhaps, but something would still need to translate the board type to an integration I think that should be the responsibility of the integration (e.g., using a discovery kinda solution). OK, we could let the hardware platforms expose what board types they support, then setup that integration if there's a match. Should this be specific for OS Supervisor based installations only? Hardware can be part of others as well, right? If we only support board detection it will be limited to supervisor based installations. We can start with supervisor in the MVP, and consider extending support later The HardwareProtocol only supports providing basic information about a mainboard. The idea is that this can be extended to provide other information for other hardware types. home-assistant core only have to call this on first incoming WS command to avoid doing I O on startup. That means we won't install integrations associated with the board ( zha , rpi power etc.) until the user visits the hardware screen in frontend? The loading of the hardware platforms is deferred in 205ec1c I think that we can explicit about what the board is. {"board": board info} , there can only be ever one board. This integration needs to be moved into raspberrypi , not live standalone. No external images. Not even of kittens? can we distinguish between 1 2 3 4 400 CM4? Yeah, but how? - An integration for each board type ( components raspberrypi , components raspberrypi2 ..) - The raspberrypi integration checks the board type - The hassio integration kicks off a discovery flow when it reports board type Should we add a new integration type that is "hardware" ? I think so


What about adding this directly within pyoverkiz? Within the client we can try to detect if we the local mode is enabled, and if yes, use it. tetienne I would like that, just not sure yet how we should do this in the best way. Currently we do the following check: L157 This will still throw the following error about "Session is closed". Is the issue that the delete local token is async and the pop() happens too soon? Or am I overlooking something? This integration will actually have to support both local or cloud polling. In some case, Overkiz Somfy integration doesn't work completly on local polling frenck would it be possible and useful to add a new iot class "local or cloud polling" that will be used here? Or local polling implies that there might be some cloud polling too? I think this is not a blocking point for now for this PR. This was indeed an open discussion point still. Should we set the iot class to the best possible option, or to the one that most users will face? And if we talk about most users, I would say that 80 is using Somfy, so that at least 60 (not users of TaHoma v1 or Connectivity Kit) can use the local integration. Curious about this as well: I recently contributed a " local push " connection mechanism to an originally local polling integration (currently still out of tree), and wanted to have this be an array or comma-separated string as well to be able to set multiple classes (rather than coming up with various new io class es that are simply a combination of others?). Since you're setting the whole entry.data, is set, so now both CONF HUB and CONF SERVER is set to the same value Can't cookies be defined per request? Then you could async get clientsession . I've seen something similar being asked with headers, not sure if this also applies for cookies At the moment the underlying library will just use the session, and not keep track of the cookies etc. This is actually already part of the current integration, so for now I won't make any big changes here. However good to keep an eye out here for future improvements. Maybe extract this in a separate function since you're doing this twice in this file? Fixed in 89981d36b78fc1a8049bee7e6eff4a5926a700a7. Fixed in 89981d36b78fc1a8049bee7e6eff4a5926a700a7. What would be the benefit of using add suggested values to schema() ? And of moving the default to another notation? joostlek? Is it just me or did this already start as a dict, being transformed to items and then casted to a dict? Oops . Fixed in 89981d36b78fc1a8049bee7e6eff4a5926a700a7. Ideally we don't do a migration unless there is no other option. A migration means it makes it harder for users to downgrade Are there ways to write a "v2 to v1" migration? Without this migration, the integration will be less clear, but there would be ways technically to work around it. I was just thinking about this, but the thing is, this code is run when you start HA since this is in the new version. If someone then downgrades, the version
balloob is this change ok? what is the use case to allow to sent in group entities for light switch cover etc to a Z-Wave JS service? I wouldn't expect that to work because it's a new entity. If you have a light group of z-wave lights, and you want to set a config parameter or invoke the CC API on all of them in parallel, you would not be able to use the light group entity to do it before this change. kpine do you have any additional use cases you can describe? I think this PR came out of a conversation you and I were having Your recollection is correct. There was simply an observation that for the zwave-js services, helper groups aren't being expanded by the integration, whereas group entities are being expanded (are those "old style" groups?) by the integration. A good example use-case would be to use the multicast service to turn on a light group, instead of having to list each light entity individually. HA Core does not provide a way to do this. Otherwise, it just makes the behavior of the two groups consistent. As a user, not concerned with implementation details, I'd expect it to just work, because why not? That said, it's currently "easy" (if you know how) to workaround by expanding the group manually in a template with expand() , although the Group integration and Templating docs don't state whether this is actually supported for helper groups. It only mentions expand() for group entities (old style groups?). I just happened to notice it worked with light groups by experimentation. It is supported in the expand function, that's where I got the solution for this. We should probably update the docs
Please implement async step import instead I tried to, but the method didn't trigger at any point. I never really figured out why it didn't work, but I presume it has something to do with there being no configuration other mentioning the dmsr reader as a sensor. If you're convinced it should be able to work with async step import as well, I'm willing to give it another shot. You need to start it here. On mobile so I can't put a suggestion but you can 'git grep SOURCE IMPORT' to find an example Ah, the fact that I need to trigger it didn't register with me. I've now got a working version locally that does this properly. It also fixed the situation where the integration was imported AND suggested at the same time, so that's great. I'll first check whether it has had any impact on the tests and will then commit. Just wanted to confirm that the requested changes have been made. I can't remember whether resolving a conversation actually sends out a notification. Missing async unload entry Ah, that explains why HA was saying it needed to be restarted for the changes to take effect. I've taken the time to also simplify the async setup entry as it was just doing the work that async setup platforms() already does for integrations. I think it would be better with aborting the flow on this error That makes more sense, indeed. Adjusted. Is this actually possible since mqtt is in dependencies ? I guess it is if they have no mqtt config and they try to create this manually. Should be in abort and not in error Adjusted. If you set title "DSMR Reader" in the constructor I think you can drop this since the default likely does what you need L112 Inheriting from DiscoveryFlowHandler seems to make things easier, indeed. I somewhat fear for the readability as you won't be able to see where the MQTT step gets triggered, so I'll add that information in a comment. I hadn't encountered that class yet. The only somewhat ugly thing I'm seeing, is that I am then required to provide a discovery function for devices (of which there are none here). I'll probably add a lambda instruction to create a simple Future that always returns false, otherwise I'd need to add a useless function just for that. It would have been nicer if that function was optional. I've had to add a new private function due to this. Adding it as a lambda or Future didn't seem to be possible. It's a bit of a shame, but it's not the end of the world either. I think I've cleaned up the implementation as much as possible after that change. Untested, but I checked sonos which uses the same handler, and I'm pretty sure you don't need this I'm pretty sure I had to add this in the past, as I got an error saying that no handler was configured for the config flow (at L747). I've tested it again without that line, and it seems the initialization now properly takes care of adding the handler. It has been removed now. I don't see anything here to guard against creating a new entry each restart Good catch! That did inde
Should we wrap the current entity.get call in a helper like we do for async get current platform ? I did that. However I made it so it doesn't raise because methods that are using it can be re-used outside of entity service calls; like media browsing can be run from a WS too (when resolving for the browser)
This file seems like it's left over from this being a stand-alone custom component? I think it should be removed. Yup, this file needs to be removed. This file seems like it's left over from this being a stand-alone custom component? I think it should be removed. Please keep all code and comments to English. I suppose maybe an exception could be made for device names. But that's a big maybe IMO. No, there is no exception. Everybody in this project has to be able to read and understand all code comments. The use of the English language is required. Stale commented code? This looks copied from the Tuya integration and seems unlikely that this applies to Aqara? Stale code? Stale code Stale commented debug print Stale debug print Replace foreign language usage with English Stale code Stale code Please use the Platform enum here, e.g., Platform.BINARY SENSOR Device triggers don't have to be part of the initial PR, please remove it for now. ffmpeg doesn't seem to be used in this PR, so it can be removed? Commented out code commented out code This PR still has multiple platforms. Please limit the PR to a single platform. This PR has multiple platforms, please limit it to a single platform. This PR has multiple platforms, please limit it to a single platform This PR currently has no select platform, thus this translation file can be removed from this PR. This file can be removed Commented out code
Please remove commented out code. You should probably set the state class to INCREASING here (this enables it to appear in the energy metering features in HA) Is TOTAL INCREASING something for the daily run time? That is the amount of hours the system was online each day. Summary values are provided by the "running time total" and "yield total". These two summaries would be different if the device is not connected from the beginning if I understand it correctly. I am not 100 sure. I don't think efficiency is the right word here. Why not 'Power Factor'? i tried to align the names with the solarlog component. power factor would be fine with me. You could consider self.port entry.data.get(CONF PORT, 502) will do that Missing return data type Not sure what this is needed for. I think HA objects already have a time stamp in them. ok, than this is unnecessary I am not 100 sure but you should probably not be calling this non-async blocking function from an async context. excuse me for asking, but how would I do that differently? The main thing is you tell python to await the answer of the job rather than tie up the execution thread while network transactions are happening. Does this string missing always mean invalid auth? if no auth is needed I can freely access all values. I picked one at random to determine if access was successful. might be better to use the CannotConnect error and ditch the auth. We do not have credentials anyway. I couldn't see a place where this was raised. Probably this is not necessary, as there are only a few errors you need to catch. You can put this at the end, then you don't need to duplicate it. I.e. did that, thanks I couldn't see what used this. Is this correct? Doesn't seem to fit with the comment or the format of the other keys alternator loss is calculated from the two values mentioned in the comment. This is done when the sensor values are updated. I saw several other sungrow modus TCP clients, that seemed to have been around for a while already. Is there a reason you chose to roll your own in this case? yeah, I did find a script and modified it into a library. If you can point me into the direction of an alternative i will have a look at it. I thought power factors were always between 0 and 1? If so maybe the test should be a decimal number? The power factor value is returned from the device with a factor 1000. The test data is what would be returned from the client library. The sensor value is divided by 10 to get a percent value. ok, makes sense thank you :) If you are testing your form, is it possible to patch the return value of the library rather than patch the form validation functions (might be needed for test coverage anyway)?
These add static attributes that are stored in our state machine (and thus add memory usage and cost storage space in database history recording), while their only use is a custom UI card. I suggest on making this configurable on the card configuration instead in such cases. I suggested to expose theses attributes values like the mired min mired max for light for example (or the min max values for climate entity) to avoid the user to enter the value twice (in the integration and in the card). Also, there is default value and user has no idea about these default value unless he go to the documentation. But I understand your arguments about database performance for static information. I will look how we can deal with it in lovelace card. Adding 8 input number looks a little overloaded I suggested to expose theses attributes values like the mired min mired max for light for example (or the min max values for climate entity) That is not comparable, as those can be provided by an integration (e.g., the device on the Zigbee network or whatever else). This is static manual configuration. Also, I don't know the status of the plant domain in the HA core codebase. It's yaml only, there is few commits on it and it looks like a helper but very specific. Maybe it can be migrated to a sensor helper like the utility meter or it's better to use template sensor for these rules. Also, I don't know the status of this plant entity in the HA core codebase. I don't know either. There is no state at this point. As a helper it might work; however, in the end, I think this platform, in general, isn't providing anything really. For example, its state is "problem" or "OK", ergo: A binary state. It should be a binary sensor entity, not a plant entity. We have a couple of more of these occurrences (e.g., promixity; which should be just a sensor actually). I think in the long-term, the chances are pretty high that we convert these into their proper entity types. As for plant itself, I'm not sure if a dedicated entity would be even warranted. It is merely used as a frontend thing and for automations using all original sensor entities, in general, would be easier to automate with on (including their min max values); it would be more consistent with all other stuff we have as well. Totally agree I think that a binary sensor with a proper device class should be cleaner Note that utility meter sensors expose config values but it's just to tease you e.g. Note that utility meter sensors expose config values but it's just to tease you More stuff like that is still there, however, we do try to minimize it nowadays. Things from the past we did a lot and learned from The custom UI card is not the only use though. I have wanted to have those states available for automation scopes (mainly notifications), so would appreciate to be allowed for! I have wanted to have those states available for automation scopes (mainly notifications), so would appreciate to be allowed for! The point made abo
You can simplify this logic a bit with Agree. Updated. Agree. Updated. Looks like CONF REGION is a required key Agree. Updated. I think my way (actually, consistent with the codebase) is more readable. Move these into binary sensor.py since they are only used there Actually, I did it to be consistent with the codebase. At least accuweather and nut integrations do it in the same way. This starts to get messy when there are multiple platforms. We are moving away from this pattern. We can use next here. Updated. Updated. Please only wrap the line that can raise in the try... except block. We can move this part down. Probably check if errors is falsy instead. Please include the config flow in the coverage. Missing type annotations. Please type the whole signature when adding type annotations. There's no options flow so we don't seem to need an update listener. Let s move BINARY SENSOR TYPES into this file. Done. Please use description placeholders for text that shouldn't be translated, like URLs. Set up the Ukraine... To generate an API key... Just a note that these translations will need to be added to Lokalise, as that s the source of truth. Next translation update will override these files. The config flow needs to be covered by tests. A test file was generated when integration was scaffolded.
The upstream lib needs to be bumped and this needs to come out before merging This needs to be fixed with an upstream lib bump before merging This needs to come out since the upstream lib can provide it (currently had a bug in the upstream lib) bumped lib. This is resolved now We've recently had a few cases where we had to guard this to be IPv4 only. Should we do that here too? Good call A big ass fan without a fan? They have some legacy lighting fixtures. Next PR :) Why not assign this one above like the others? copypasta. Will fix and drop the useless init 65c17988785c6220567f87a668e6fc5b7660b70b Is this doing I O ? Nope. Its call a write on an asyncio.Transport which takes care of when the data gets delivered We need to pass raise on progress False since there's a discovery flow possible. Thanks for the time. Will fix
It would be cleaner to use YARL to remove the creds. I realize its a bit slower, but security is usually worth trading performance I agree it should be a built-in helper Is it possible to have one with a password but no username? Yeah, I wondered that, in fact I tried a case for both first. So that url would look like Seems almost like an invalid url but I've checked them separately anyway now just in case. b23610d I think you can just check if its truthy here Any reason to use url in and url ? Can it just be url ? I found that url.with path() erases the query string for some reason. So without using url in , the function behaves like the query string is always blank. I copied it to the others to look consistent. But it is only needed on L31
If you are iterating through a list of test cases you should consider pytest.mark.parametrize Thanks! I'll take a look at that decorator before submitting these test changes in another PR. I think if you have no units, you should set to None (or maybe just omit it) I see that airvisual has units stated as "AQI". This seems very similar to the [venstar manual I found here]( Although venstar seem very vague about what the units actually are, it could be a good starting point. Using None gave the following pre-commit error: And removing the uom fn argument gave this one: So I think we definitely could omit it from the required properties of the dataclass mixin but I'm not sure if that means it has to be set as an optional parameter. Specifying a blank string seems more correct as we're explicitly saying there is no unit of measure. I'm fine with either approach, however. I did see AQI and it seems to be measured on a similarly unitless scale; for example, compare [the table on airnow.gov]( ![image]( to the one in Venstar's docs: ![image]( Though I'm not sure appending either "AQI" or "IAQ" as the unit of measurement is correct. Seems more correct that they don't have units at all. When I search for unit of measurement None and unit of measurement "" , there are some integrations that use None and some that use "", so I suppose it is not critical, but there are more that use None . e.g. L105 as for replacing with None , the mixin will want to call whatever you assign to uom fn, so you'll need something like uom fn lambda: None You don't need coordinator as a parameter for the lambda function because it's not used. I think that can be deleted from a few other uom fn entries nearby too. Cool -- None it is. The coordinator parameter is being used in the temperature unit function so it appears to be added to the other uom fn function args in order to meet the Callable[[Any], str] interface. I see... it is strange to pass a parameter that is unused. Actually it could be anything. I would be tempted to use uom fn lambda : None which I think should work although I am not able to test it. Agreed. Good point; I didn't stop long enough to think of that :upside down face: I'm not really sure why this mixin wrapper is even here but didn't want to remove it in case it was actually useful. Yeah, it is kind of an odd thing to see used like this. I think it is because the original code wants to use the standard EntityDescription class but wants to pick up the temperature units from the api.
Use the new constant here Maybe dialect name
Use attr icon attribute instead.
Instead of juggling with the class variable, we should pass down the right user into the send message callback . This can now be reverted to the original But isn't it more accurate to name it default user? Because ultimately, that's what this is about. If there is no user specified, then the default user will be used instead. According to the service specifications, the target can be a list. It seems like that case isn't handled? Instead of duplicating the partial, creating a local user variable passing in the partial will work too (making the code a little more slick)
Why stuck this in between your base entity and the timing entity? If you plan to possibly add more maybe you should go for entity descriptions right away? IMO, it would be more beneficial to expose the status as a separate sensor which would also be useful for any of the statuses rather than creating one-off binary sensors for each.

There is no such thing as a media context id . This property isn't used anywhere either. What should this do? And how have you tested this PR?
Jinja2's {{ None }} will render to a "none" value. I think this is because of the string casting at 568. The None value should be checked before that (just like the boolean value is checked sooner). That was it. Thank you.
Alternatives: - is local today - is today local But feels like adding local doesn't really manage to convey its meaning
why use a compound unique id like this? would the device ID on its own not work fine? If we have multiple connectors the device id would not be unique. logging to info reserved for the core, use. log-messages logging to info reserved for the core logging to info reserved for the core
Suggestion: could save some indent if you reverse this condition, return True, and outdent below. May not be worth changing since its going to go away we'd also have to return True twice then so I think it's ok to keep it this way for now, especially since it is going away soon like you said Yeah its kinda meh since its going to go away anyways It would be nice to fix the upstream lib that's in progress: I also plan to move these properties out of a dict and into a dataclass or something else that can be more strongly typed If you reverse the condition and swap these you can raise and then outdent the other block It would be cleaner to do data hass.data[DOMAIN][entry.entry id] and then use it below so you don't have all these hash lookups r887550614 You could rewrite this block as If you made this a dataclass it would be a bit easier to type This isn't great, but I don't have a better suggestion. Sounds like the library could use some fixes. Agreed. I will have to experiment on this one a bit but I don't want to tie that to this PR Thinking about this a bit more, is there more downside to letting this create and having the config entry in a retry state if it fails for a few seconds since the user has to wait anyways? just that we'll be adding some additional errors to the logs and hitting the eight sleep API a bit more, but this will only matter for the first import creation since that's the only time that this happens twice in quick succession. I implemented this proposed change and removed the sleep It would be nice to fill this out a bit more. I think you at least have the name [This]( diff-e9fa84532f08b51681ede6b51a04754c32f89ec8932ef6a568525e48ed7c7e18R141-R146) pre-creates the device with all of the info I have access to, the logic here is just to connect the entity to that device Usually we save a reference to the coordinator in the constructor instead. The reason it is done this way is because there are two coordinators, and we can't guarantee that the coordinator that's stored in the constructor is the one we need to refresh - this allows users to target any of the entities on a given bed side for this service Since you need both, you could pass in your new dataclass to the entity constructor instead. hmm that would require some pretty significant refactoring. Right now the logic expects one coordinator instance and one API instance so the base entity class can pass it to the CoordinatorEntity initialization. I'll have to think on this one but I think that should be a separate change if we do move forward with it You can move this above init as attr device class BinarySensorDeviceClass.OCCUPANCY since its static it's a dupe It looks like there is no way to tell if its invalid auth or a connection problem? that's correct for now. I'm working on improving the lib to get more granular on these types of things There isn't anything wrong with this, but stylewise I'd write it to avoid the multi-line statements Minor nit: Usually we avoid stori
Missing return value typing.
AuthorizedConnection was deleted in the current version of the library. Is this condition correct? Function is too complex (C901) Sorry for that, but I did not want to refactor the existing code. I think it is better to address the change in a specific pull request I don't think this comment is needed any more, let's remove it. These conn - connection renamings in this file do not seem related to the topic of the PR nor necessary otherwise I think, let's drop them unless I'm missing something. For consistency. Could we make it so that if there are no guest networks, we wouldn't continuously make the multi basic settings call, i.e. we'd "unsubscribe" from that info unless a guest network was found on the initial call? I suppose we should make the switch unavailable also in those cases -- currently even if there are no guest networks, the switch is shown e.g. in the device controls, but clicking it does nothing (returns to off state after a second or so) and emits a frontend error when clicked: I don't think I've seen a router myself that would have a way to set up a guest network. Then again if one can appear on the fly, polling for it continuously probably is the way to get it to work without restarts etc in HA when it does. Please use a generator expression instead of filter lambda. This will error if the first dict lookup returns None. The return value typing is missing optional. If the measurement data is relevant without knowing the main state of the switch the state attribute should be a separate sensor entity. Please don't access integration details like hass.data in the tests. Patch the library to be able to assert service calls. writing-tests-for-integrations
Why would those be different? Why can't a user just set up both in one go instead of having to set up the same integration multiple times? Or should these have been different integrations? I could have the user set both up in one go. Would that be better? P.S. Built in PR reviews now?! So cool! No more alt tabbing! ![A screenshot of VS Code showing a popup over the code editor displaying the contents of a review comment]( Would that be better? Yes No reason to log the whole exception . You know where it was raised. I have removed the logging exceptions for all except the HttpError , since HttpError returns the response data on this line: L133 I'm sorry, I seem to have mixed it up. Please disregard There is no reason to use a progress for this, it s checking an API so it s a short task. The API does actually take a few seconds to respond when setting it up. Should I remove it anyway and just let the loading symbol when you press submit suffice? If this indeed needs several seconds, it's fine to use progress here This is not OK, there's either a bug in frontend or in the config flow causing the loading to get stuck. There have been some recent fixes for config flow progress, can you confirm this still happens? I tried without it, still the same issue... OK, please contact me on discord and let's solve it I'm emontnemery there too No longer needed with It looks like you forget to set the unique id here? Why is this check removed? I don't know! It has been re-added Why is this check removed? Please also check that the entry gets the correct unique id, both in this test and in the other tests Please better explain this is optional, and the benefit of adding the phone number
Should this also raise update failed? While I was testing this QNAP servers went down (or the update file fetched by the switch was malformed) and it prevented the whole integration from starting. I changed this so the integration would start even if the firmware update check fails. This way the other platforms will still work even though the firmware update can't be checked. It's better to still raise UpdateFailed here but catch ConfigEntryNotReady when calling coordinator.async config entry first refresh for this coordinator. It's better to still raise UpdateFailed here but catch ConfigEntryNotReady when calling coordinator.async config entry first refresh for this coordinator. I will address this in a new PR. Thanks MartinHjelmare Resolved by
Please also restore these options in the dict schema below as they were before the last PR. Otherwise they won't be allowed during config validation. Done Entry title can be changed by the user. We can't rely on that. We need to use the config entry data. entry is derived from API KEY entry L60-L63 Yes, but the title can be changed later by the user. Using the API key Please move this back below. It's more logical to forward the entry to the platforms after we're done with the setup here, even if we're creating background tasks. Done Please use this api data instance in the sensor platform. Done Is this triple-register correct? No. We should also have two different service schemas. It's only one service that has the speed limit option. Please use a specific schema for the service that can handle the speed limit option. Done We don't need vol.All . Changed to vol.Schema
Can we make Callable more specific? Add in expected arguments and return types. Also, isn't this a required field? (As in cannot be None?) Fixed in d718361c9f03bf423a966a1921e8385e788d3cd8 It would be nice to not have this span 3 lines Fixed in bd435d1a8504e6aa6700fe4746ed897ab0c31878 Please cast or implement Fixed in bd435d1a8504e6aa6700fe4746ed897ab0c31878
This guard was not needed, it's handled by the light base component This guard was not needed, it's handled by the light base component Same comment for the removed guards below. This guard was not needed, it's handled by the light base component This guard was not needed, it's handled by the light base component Is this the correct way to determine the color mode of the light when the entity is initialized? color mode doesn t exist on the channel. L25 It will need to be added. The attribute will also need to be added to the ZCL INIT ATTRS dict with False to make sure it s read during initialization and not read from cache. then the comparisons need to be against the Zigpy enum: L14 This is not 100 correct; we should convert the serialized attribute back to an enum Corrected in 7a05ac8 I'm not sure I understand the ZHA light group, it seems to derive its state not from zigpy but from the HA state machine, while it changes the state of the group by talking to zigpy? Is it OK to set the light group to either HS or CT; and how do we determine which one the group is in; the members could be in states: ONOFF, BRIGHTNESS (dimmers with no adjustable color temperature), COLOR TEMP or HS. We could map ONOFF BRIGHTNESS COLOR TEMP to a COLOR TEMP group and HS to a HS group and make a majority decision? For reference, this is the implementation in the standard light group: L283-L292 I'm not sure I understand the ZHA light group, it seems to derive its state not from zigpy but from the HA state machine, while it changes the state of the group by talking to zigpy? It derives the group state by aggregating the state of each member entity from HA state machine. Is it OK to set the light group to either HS or CT; and how do we determine which one the group is in; the members could be in states: ONOFF, BRIGHTNESS (dimmers with no adjustable color temperature), COLOR TEMP or HS. We could map ONOFF BRIGHTNESS COLOR TEMP to a COLOR TEMP group and HS to a HS group and make a majority decision? IIRC currently as long as one member is ON then the entire group is on. The group state is calculated based on the ON entities. Need to verify. The ZigBee groups could be crazy, as I do mix in one group CT lamps and color lamps. At the ZigBee network level, lamps without color support just ignore the color commands Improved in 214adf8, zha groups is now using same logic as the standard light group
I could not find anything in the pysmartthings which helps determine which mode a light is in. This code may not be wanted, because setting the light to a hs-color with 0 saturation will make the light report itself being in CT mode. andrewsayre could you confirm what value the library reports in the status updates when setting the light to a color or a color temperature?
No need to postfix this, as just the heat area id will already be unique within the climate platform for this integration. The heat area ID consists of the serial number of the base and the number of the heat area. Separated by a colon. e.g. EZR012345:4 So it is unique across multiple devices. I added the suffix because I am planning to add the battery state of the heat area controller later on. But if I understand you correctly, this is not needed because it only has to be unique within the climate platform? The heat area ID consists of the serial number of the base and the number of the heat area. Separated by a colon. e.g. EZR012345:4 So it is unique across multiple devices. Awesome I added the suffix because I am planning to add the battery state of the heat area controller later on. That would be a sensor entity, which is a different platform. Unless you are planning on adding multiple climate entities per heat area id, the postfix isn't needed.
The python-lightify library has DeviceSubType.LIGHT RGBW which supports color color temperature, so we need to determine which mode the light is in. The way it's done here is most likely not correct though. OleksandrBerchenko, tfriedel how can we tell which mode a light which supports both color and tunable white is in? emontnemery I'm afraid I don't know and I don't have the time to dive into this atm.
Since you are refactoring this completely please move it into entity.py For a future PR Entities that generate a significant amount of state changes can quickly increase the size of the database when the extra state attributes also change frequently. Minimize the number of extra state attributes for these entities by removing non-critical attributes or creating additional sensor entities. This looks like a useless property. Why not let it just use inhert? If you create self. handle coordinator update instead you won't have to refactor all this Since you are only using this in one place, its better to raise and catch the exception so you don't need to do the tuple return and can return just the user id We won't be use it once when reauth is added later. You could avoid a bit of refactoring if you made this in the entity base class Better to not return a tuple though if you can avoid it. Please leave the schema as-is since its going away. We don't allow schema changes for the old platforms per ADR0007 I realize this isn't a functional change, but it makes it more difficult to review See comment about self. device Separate words with underscores Existing, but for a future PR: generic-properties Entities that generate a significant amount of state changes can quickly increase the size of the database when the extra state attributes also change frequently. Minimize the number of extra state attributes for these entities by removing non-critical attributes or creating additional sensor entities. useless f-string? Please leave the constants in until the deprecation. Let's not make this PR any bigger. sometimes-acceptable-sources-for-a-unique-id-for-cloud-services Does this need to be normalized? I don't think so. It's 24 hex characters, all lowercase. r872898333 needs to match the supertype This needs to be cast This needs to be run in the executor as it does I O Please avoid creating multiple executor jobs in succession as each one has to be pushed into the queue, picked up, run and returned. If you create a single function to call and only do one call to the executor it is much more efficient. We normally log the error and stack trace on unknown exceptions. We're missing the imported data parameter. Passing hass to the exception doesn't look correct.
Can self. last seen be completely removed from the class? Yes the use of it was removed in a previous PR, the initial one is only used to calculate the current state of the entity as in some cases client.last seen can be None
Can this actually be None ? Not sure where you would want to do that? Please don't put side effects in properties Please revert unrelated changed git checkout upstream dev -- script setup stale docstring I don't think you need to subclass ClimateEntityDescription here You can just use it directly stale docstring Can we get this from the api instead? Good question... Actually we can't because it zero's out when he thermostat is turned off. When its turned on by the external remote it defaults to 21c ... I added it to const... if you don't like it I can look into dropping something into the API to make it a little less complicated looking from the HA side. Can you give it a better key name than climate Is this needed if last temp has never been changed? Unfortunately it is. last temp can be changed via async set temperature and trying to duplicate the functionality of the hardware remote - it will remember what your last thermostat settings was (on the remote not the fireplace) and restore it once you turn the thermostat back on. I could change it to stored temp or something maybe clearer? Its going to have some unexpected behavior though if you restart as it will give the default Is there no way to get the current temp target from the device or is it wrong in this case? If it doesn't have a thermostat we should instead return early in async setup entry and not create the entity Should I nix this block then? yes You could leave this above and only override it if its on You could save some indent here by moving this above, switch it to an if and then return inside the if block. The you could outdent the other block since you know is heat as its the only other valid mode Please sort . The return value typing should be HVACMode . Missing type annotation for kwargs . Please use Any . We have a util to convert between Celsius and Fahrenheit. L31
We should only do that if continue on error is True I think we should call set error on the current trace element (instead of adding a variable). Something like: Pass trace element to handle exception() and let it set the error. This would make the trace similar to how current errors are handled (and adds a uniform way to display it in the frontend as well). This would not be for the frontend but to be able to do some error handling in the next step (template condition choose). This would not be for the frontend but to be able to do some error handling in the next step (template condition choose). If that is the case, I'm working on a general solution for that (which was requested in forums and Twitter threads). Allowing to provide an alternative sequence when an automation, script, or single sequence step encounters an error. Allowing, e.g., to send out a notification when something goes wrong. I think that would provide a much cleaner solution, side-stepping into a different flow, and one that can be UI-ed even) than checking variables in sequential steps.
This subclass doesn't add anything. Just use SwitchEntityDescription . If at some point you need additional attributes, you can always come back to it then. I changed this to just use SwitchEntityDescription Try to use a separate line for each key value. That will make it more readable. If you add a trailing comma, black will auto-format it that way. Already handled by WallboxEntity with the subscript. L210-L211 The coordinator is already assigned to self.coordinator with the super() call. "lock component" Is that correct? No, I will change that to switch component Two comments here 1. Past two items, in comparisons are faster with sets, compared to tuples list. At least as long as the items are hashable. 2. I saw that you reused the "charging" key later. It might be a bit over-engineered, but I would suggest to create a new StrEnum (from homeassistant.backporst.enum ) with all possible CHARGER STATUS DESCRIPTION KEY values. Just how the API library returns them. Then change the check to use the enum values instead. Something like this: Just saw that the name is coming from the CHARGER STATUS mapping in init .py . In theory, you could replace the strings there with the StrEnum value, too. OK, I think I understand what you mean here. I added a new StrEnum class in const and used it in init .py and switch.py Shouldn't this be on if the car is charging? Possibly the missing brackets for the lower call. Yes, it is fixed now, good catch Gets set automatically by SwitchEntity .
Add a new abort reason and put this message in there. That way it's visible to users in the UI . Done. We can remove this warning being logged. It's already shown to the user. Warning removed. We should only abort if this is from discovery. Since this is user configured, we should continue. They might want to update data. All existing data is pointed at new one. Done, and updated tests accordingly. This device does not if there's one entry I'd rename the reason to just no unique id .
Please assert the direction data item too.
This has proven flaky in the real world in my dogfooding on my production HA box. I'm going to move this to the config flow so we pull the required attributes once and store them in the config entry itself negating the need to do this heavier operation on every boot. This will have an additional benefit of telling me in the config flow if the device is a valid and connectable melnor device right up front before passing to back to core to create the config entry. I refactored this code and now use ConfigEntryNotReady if for whatever reason we fail to establish an initial connection to the device. It ends up feeling really clean because a) we guarantee the device is connected and contains the required attributes before we init the entities and b) the backoff-retry that core does is really nice. win win. These devices are really odd in how little is advertised, and Bluez has issues parsing the ADV IND portion of an advertisement packet. This portion of the packet happens to be used by the melnor devices for the rich manufacturer data. This means on Linux filtering on both name and rich advertising data essentially doesn't work at all. It works sometimes , but it's nondeterministic and there's nothing that can be done in any areas that we have any control over. You won't reproduce this in a dev env on Mac or Windows, as those BT stacks are more robust and more forgiving. To work around this we'll cast a wider net here and look for either the local name or the hexidecimal-ish (in bytes as integers) representation of 59 which is the first 2 digits of every model number that we can support. Is mac not already a string? Can you set this as self. attr unique id in init ? Is mac not already a string? Yeah, it is. This is the leftovers from a refactor that happened months ago when I first wrote the integration. Cleaned it up and I've added an assignment to self. attr unique id as well. Can you set this as self. attr device info in init ? Its only checked once Does this ever change? Can you set this as self. attr name in init ? If coordinator is the only thing you are storing in the entry, there is no need to create a dict to store it. You can store it directly Also if you need a dict , please use a dataclass instead I've simplified this (in a commit that I have yet to push) to store the coordinator directly. I think you only need this if you are removing the entry via async remove entry since this can get called on reload as well Hmm that makes sense. The best practices section of the docs mentioned hooking this up. By the time async remove entry is called async unload entry has already completed, so any state that I had is already gone. I could write a bit of code to keep track of the most recently removed address to allow me to implement async remove entry and call bluetooth.async rediscover address there, but given the config entry is already keeping track of the unique config entries I wonder if bluetooth.async rediscover address being called during a r
What about non-HTTPS URLs? Telegram only supports https links Same. Use startswith Shouldn't this test if it starts with https?: ? Frenck is right. You should test data btn.startswith( https: )
Only stop if unload was a success. And we know the key is there so no need to guard. Use asyncio.gather since there is a sleep in here. small detail is that the sleep is only reached when a new player connects (first message is hello, second optional message is its name) Actually we don't have to wait? well in case of a race condition we do (player connects just at the exact same time we're initializing). But create task is fine here. we just want to make sure we have the initial state yeah that's probably better to prevent some race condition Why wait max a second? Shouldn't we wait as long as it's necessary? Having a name also impacts the entity ID. the name is there either within a few milliseconds or never (its an optional data packet) Ah ok. This is fine then. Assigned in constructor makes sense Make sure to prefix the URLs with HA URL if it's relative. remote origin is only if people fire events via the API. This is fired from inside HA because of an external non-HA event, so that's local ah, i wasn't completely sure about the meaning of eventorigin. I guessed wrong :-) We should also include the device ID Why would we include player id? Shouldn't people refer to the device ID in HA instead? Hmm that's a leftover from me testing Not necessary as this is the reason people click that button. I shamelessly copied the config flow from the "radio browser" integration which asks that same question and has no further setup This is only fetched during startup so we don't have to generate it all the time. Let's just set this in the constructor. Yes, also leftover from me experimenting with the name arriving later but finally settled on the initial wait We can already check player ID seen here to avoid ever having 2 async add player for same media player running. Just remember that a new socket connection is created if the player reconnects. EDIT: nvm that doesn't apply here. Handled below. Can we catch a more specific exception? What exception do we expect? Use entry.async on unload to unsubscribe the listener on config entry unload.
Very quick scan, but a couple of things: - I think it should raise an issue to tell the user to remove the manual configuration - config flow PRs are always quite big. I suggest that you remove everything else can can be kept for a follow-up PR (eg. the sensor platform) Thanks. I'll have a look into raising an issue from this step. And, let me have a look how I can simplify this PR to only include configflow for now, and move the other small improvements to a future PR. I followed your advice and reduced this change to the minimum, i.e. config flow only, and this is now available here:
Invert the check and return early. Then we can outdent below. Can we move the try... except block so that it only wraps the line that can raise? Please move time forward instead and assert that the appropriate number of api calls are made for every case. L375-L379 We want to avoid asserting integration details like this. Isn't that what I'm effectively doing with moving times forward? I can get rid of these assertions but I'm using these numbers to validate the number of API calls anyway Time moving forward isn't a detail. Library api calls aren't details.
This is already implemented by CoordinatorEntity Do you need to poll again since you just updated the state above? Ideally calling the on function would have the library update the internal state instead of having to call setattr here Due to the way I wrote the library: - read api - I scraped the read data out of the android app and by watching HTTP Traffic - control api - After I released it somebody sent me the control logic so I wrote a separate control module The data is not actually connected inside the library ... I'll have to think on whether there is a clear way to do this ... but it may require quite a large refactor... I spent some time looking into this and as it stands a lot of refactoring would be needed so I'm hoping we can leave this for now ... its something I do want to eventually tackle - but I may not be able to tackle it until the summertime See comments in async turn on data field doesn't seem used. removed it.
Nothing seems to use this property. Thank you for your review. This is the first time I look at the HA code, som my inexperience is exposed. I thought the properties would automatically be exposed as attributes to the lock entity. Then the "method" attribute could be used in automations. Any pointers on how to expose "change method" as an attributes to the lock entity? Extra state attributes can be set by implementing the property extra state attributes . A codeowner should approve the addition of new state attributes. I think it's ok to add it as a state attribute Thanks both, updated the code with the extra state attribute, please review Can the method item be missing in the dict or is it always present? Good point. I don't have access any other installations than mine, and the API seems undocumented. In my tests in my system "method" have always been present, but of course I cannot know for sure for other installations. If it is not present changed method will return None. If changed method is None, extra state attributes will return {'method': None} I assume HA will handle attributes with NoneType? Or would it be better if extra state attributes returned an empty dict if "method" is not present? The entity can handle a None value for a state attribute. It would be good to know the possible return values here so we can type it as narrow as possible. I would make it narrow and widen if needed (this part is simply not documented, so no way to know). I'm not sure if I fully understand what you mean by narrow? 'method' will be a string if present or None if not present. I listed the possible values of "method" I have found in my installation in the description of the pull request, but I have no way of knowing if it can return other values. "method": "THUMB", "method": "STAR", "method": "CODE", "method": "REMOTE", "method": "AUTO", If we think it will always be present, we can change it like so: And update the return value type to just str . To me that seems a bit risky since the Verisure interface is not documented. If the "method" is not present there will be an exception with your proposed edit. To me it seems better to get None if it is not present in some installations. I only have access to mine which is only one of the 722 active Verisure HA installations, so I have no way of knowing that "method" will always be present in all intergrations. But like I'm said I'm new to HA so I respect the decision of the more experienced than me. To me that seems a bit risky since the Verisure interface is not documented. We'll be able to patch it out quickly enough if this is an issue. It is easier to loosing later than to make it more strict later...
This integration communicates with a device service and should not have YAML configuration. Removed the CONFIG SCHEMA Without YAML, this function should no longer be here. Removed the async setup method ludeeus this is needed to import the existing YAML configuration to a config entry, right? So I think it shouldn't be removed. Or am I missing something? New integration so no. Ah, I see, then also the import flow and the test for the import flow should be removed imo. Or are there any other ways an import flow can be triggered? use dict[key] instead of dict.get(key) for non-optional keys, or when the key has a default (basically when we know the key is there access it directly) Switched to dict[key] Scan interval should no be an option. Set a sane default for the integration, and ifntegration, and if the user want to adjust it they can disable polling and use the homeassistant.update entity service CONF SCAN INTERVAL is still added to entry options The CONF SCAN INTERVAL is now removed. This should not be in the entity attributes Removed the attributes Since the option flow only contains scan interval it can be removed, see previous comment. Option flow is removed Remove blank keys Blank keys are removed To keep the scope of the PR limited, only add 1 platform at the time (sensor or water heater) For this PR the sensor has been removed. This line can be removed as it is will be executed by the code path below. Removed the return statement Made the change to the code Can be removed as you have already set it as an attribute above. Removed the temperature unit Can be removed. Removed the operation list This should not be needed?
Please remove empty fields Please limit text line length Limit text line length async set temperature can be called without a target temperature, you need to protect against it: L186-L187 What other types of exceptions can reach here but do not raise an error? (In case it is not client error or INTRUDER LOCKOUT )
process wrong login is called from any URL that is returning Unauthorized. It feels weird to just print data from random requests. Hey balloob, thanks for taking a look! (Silly me forgot to actually post this comment, so it got stuck in Pending for waaay to o long...) I agree that always printing the username here whenever an auth failure occurs would be weird, as most requests handled will not contain this field. For those requests the field will not be printed at all. Just for the paths in the actual login flow the username field will be present in this log entry. The main reason I kept this here is that ideally all data for a single failed auth event should be contained in a single log entry. For parsing logs for failed authorization attempts using e.g. CrowdSec it would help to distinguish between retried logins on the same account or random attempts at generic default accounts. If you have a suggestion to get this data logged by a better suited place in the code base I'm open for suggestions.
Since this is a new action, should we just use the UUID instead? Yeah, I think that we should use uuids everywhere in device automations. UUID has disadvantages as well IMHO (e.g., when replacing devices). I'm not convinced it is a better alternative at this point. As a matter of fact, at this point I'm likely to close this PR than support the change to use the UUID.
Please add this link back It would be better to keep here only the SCAN INTERVAL SEC do the calculation to timedelta where you use it also make sure to import timedelta Please include this message in the PlatformNotReady instead of logging error. This will make sure it is only logged once. e.g. raise PlatformNotReady("some error") self.hass is already assigned by DataUpdateCoordinator class Try to minimize using info log level debug level TODO Please move this logic into validate input and remove this class. In tests you can patch the .login function are there any clear documentation for writing test? it's not clear to me how it works. What is the use for this property? you don't use it anywhere I do use it to retrieve the API object, see switch.py:70 for instance I understand your statement about the content, this is all of the initial content I want this integration to have, and I do prefer to have it from day one so it get testing coverage as mush as possible (I am already working with this integration) Move inside the first if to avoid running this check on every update I removed this block as basically this code can't be reached, as the first if will always raise exception if the devices are None in the first place You need to add logic in config flow to detect that a device is already configured: unique-ids For your device this can be mac or uid (if UID is fixed by the central unit) Example for aborting: L110-L111 Its a bit tricky. in order to get the MAC of the CU, I must login to it first, if the user provides the same credentials, it'll momentarily break the token of the other session, this will result of error message in the log and a reconnect attempt will happen on the next state refresh (meaning the already configured device). And it doesn't promise a successful login every time because of the already configured device session running and trying to take over repeatedly. If you use the uid as device identifier also set it in config flow and check if it is configured already. This UID is a combination of the CU MAC and the device unique id within the CU (separatesd with a dash) I don't see how you can add the same device twice if you can add the same CU twice. So I don't understand why the device itself needs to be verified in the config-flow, I'll be happy if you can explain These should not be set via config flow, but via config options I highly suggest to focus on making the PR small as possible and try not to add additional functionality during review (unless this is needed to fix something raised in the review). Thanks If the flow title is the name of the integration it should be eliminated This should be the same as in strings.json It is not allowed to let the user set the scan interval, the intergration should provide a sane default and if the user wants to customize this he can disable polling and make an automation that refresh data. See comment in config flow, this should be fixed, set it from the const and not from config fl
Humidity is not included in the weather forecast entity design: forecast Only standard items are allowed in the forecast. Changing the entity model requires prior approval in an architecture discussion: changing-the-entity-model
I don't think we know yet here that this component has a platform of the kind that the integration platform item represents. I was thinking we shouldn't try to process it again later if the import fails which is why I always add it to the processed platforms set() before trying anything (and explicitly testing for not calling it twice) I'm not 100 sure thats what you mean though. I could rename processed platforms to seen components instead? 007010c13c6236a75c2ce12e9e92cb481a5c29d8 Ok, sounds good. The code inside the loop should be its own function and we can use gather on it. We can also use it below to avoid enumerating the other platforms Adjusted. Sorry for not noticing that sooner
200fdffc6ad2abd9609f3e65f8f3ea709d61ba31 What are these attributes? Entities that generate a significant amount of state changes can quickly increase the size of the database when the extra state attributes also change frequently. Minimize the number of extra state attributes for these entities by removing non-critical attributes or creating additional sensor entities. In this case the only extra attribute is the maximum temperature, which is a constant value (85 C for my switch) and never changes. Please see comment below discussion r852209657 Can this happen? The title will end up being "QNAP QSW None" if it gets through here? I don't think this could happen at all, but since I've only tested one switch I prefer to guard against the possibility that the serial number isn't provided or is provided differently. Anway, I will change the title to use the model instead. 200fdffc6ad2abd9609f3e65f8f3ea709d61ba31 Since its not expected to happen, we should abort if we can't get the serial number Since its not expected to happen, we should abort if we can't get the serial number bdraco implemented in f3975085a80611b099edd34c3d672c73b3c2fb6c I also decided to replace the serial number with the MAC address for several reasons: 1. The serial number returned by the API contains some weird characters that need to be filtered in order to have a printable serial number ( L347) 2. The serial number isn't displayed on the Switch website as opposed to the MAC address, which is displayed on several places in the Switch website. This way a user with multiple switches can easily distinguish them. Is it possible there are devices with multiple mac addresses (check synology dsm ) Is it possible there are devices with multiple mac addresses (check synology dsm ) As far as I know the local API just returns one MAC address, which is the one displayed on the website: ![image]( ![image]( This is also in test init . Does it make sense to make this a pytest fixture? This is also in test init . Does it make sense to make this a pytest fixture? Actually that isn't needed in test init.py. It can be replaced with the following: I tested it locally and it works. Do you want me to push the change? Please Done in 3c5a60f74d9026f0fc0d7944ee3ae6a4478f680e Does get product() do I O? No, it doesn't: L340 Let's use the mac address since we have it as its preferred. The entry id is the one of last resort unique-id-of-last-resort Done in 56ecb0e976c92560141f7dfd392a8d0590b15a10 I think we can drop this since it doesn't add much value and puts more work on translators Done in e2d35bf30a4c7067dd36f9520f903b326de660b5 We should also use connections instead of identifiers since we have the mac Changed in ccf3a61013a649c3bb9521ac2d1d1ee67e2ff281 Changed in ccf3a61013a649c3bb9521ac2d1d1ee67e2ff281 Changed in ccf3a61013a649c3bb9521ac2d1d1ee67e2ff281 Should this be called get zone value ? Its a bit confusing that it has the name entity in it
Salvage single key schemas from [this PR]( diff-f9f84381af1676630c88469d5fb4f69f36934019ffbbf187b78f9c976f03cae4R915) and let's use that. I guess that won't work with allowing extra keys There may be more keys, though. For the life of me I'll never understand why github won't show all the comments until I reply to some of them... Stupid misses like this is why I really appreciate code reviews. You've copy pasted the code 3 times. Iterate over the different options instead. Ah, yes of course! For some reason I couldn't get out of my head that this couldn't be solved without eval ... Python is a odd little fellow, isn't it thomasloven
Why are we storing entry data here? It might be better to create initialize the client library at this point and store that instead. It also allows for error handling at this point. If there is an error with e.g., connecting to the device the entry setup can be aborted (and retried later by Home Assistant). Stale debug print Missing return type hint Isn't it easier to validate using YARL? Why is this initialized with a non-host? Missing typing (as you have added to most other places) Please re-use our client session, you can get it via async get clientsession(hass) . I would not recommend constructing URLs via string concatenation, maybe use something like YARL instead This is a duplicate of the one below? There is no aiohttp.ClientError thrown here? Also, this grabs any exception (regardless if it is a connection error) and makes it a connection issue. Sounds a bit odd, it could be something completely else? Logged twice? Does it need to be logged? Partially typed method signature. Same comments as above. Use our sessions. This can be simplified. Additionally, you can update an existing entry with newly discovered data.. (for example to catch IP addresses changes on the local network). In the example below, the DATA TO UPDATE is a dictionary with the configuration data to update. Why are we asking for the internal Home Assistant URL? If we can avoid asking for a name, that would be preferred. If we can get a name from the device (or some other identification), that would be enough. A user can rename it at will after the process is completed. What would this string be? We don't have to log this as an error. A user cannot resolve this error. The abort is enough here. Why use a prefix? We can store the webhook we expect right? Otherwise, when using multiple Home Assistant instances, this might become problematic? This constant already exists in homeassistant.const , use that one instead. Move the client setup part to the integration config entry setup Locks? As in multiple? How would that be handled? This would already be logged? We have helpers to create webhook URLs: See: homeassistant.components.webhook - async generate url() How would this happen?
Is there any reason why we dont default to true ? I think reasonably a new user would expect actions to continue if one were to fail. I know that we had a PR to stop on error and now we want to allow continuing but in all honesty if we had an automation that was turning on lights switches or sending a notification to a few different providers it doesnt make sense to stop at the first failure. Reasonably if a user adds more than 1 step they would expect it all to continue unless they used a condition or something similar. Errors are not something a user should anticipate when creating an automation so to them an error would be an edge case or something that doesn't happen often. Is there any reason why we dont default to true? Yes :) I think reasonably a new user would expect actions to continue if one were to fail. I don't agree. Silencing errors are problematic. It causes searching and frustration on why something doesn't work as expected. Therefore, we have been moving towards raising more often in the past years. For example, try using a non-existing variable in a template. Or calling a non-existing service. And many more of those. If anything, I wish we could make it more clear the last run errored failed (e.g., showing a column on the automations script dashboard that shows that). Errors are not something a user should anticipate when creating an automation so to them an error would be an edge case or something that doesn't happen often. I don't agree. Ignoring something is wrong, should be a choice, not a standard. And very often, they can anticipate. E.g., remove the service, buy a new device, put the plug in the wall, or whatever else. Isn't this case covered by line 453? No? It's the inverse? It's doing an opposite check, but on different exception types. Unless I'm misunderstanding, a StopScript can't also be a HomeAssistantError , no? Would this reduce the number of isinstance checks? There is no need to nest so deep, we generally do handle guards early returns as a general coding style in the project. Maybe also test that this broken service would actually break the script without the continue on error ? Done, I've split out the stop test that was hidden in here :) Why set it to error if we're ignoring the error? Also, this would be overridden when the script finishes ? Right, this does absolutely nothing Removing the line.
we need to check both properties to be available based on [API documention ( page 9 )]( voltage is returned as 0.001 volts, so needs to be divided by 1000 ( same like power property ) since power and voltage are returned as 0.001, we do not need to divide by 1000 ... or at least make sure to follow our [style guidelines]( with this I mean the [sorting of the imports]( ordering-of-imports) and formatting of the code by using Black ( black --fast homeassistant ) Hopefully fixed now every change in the import section -besides these to additions ( ELECTRIC CURRENT AMPERE and ELECTRIC POTENTIAL VOLT )- should not be there - see the CI result of [Check isort]( the docs PR shows me, that "Voltage" is better name for this sensor
Can we make it clear from the comment this is used as input for service calls; if it was a state attribute for example we wouldn't want it to sometimes be a string and sometimes a list of strings. Adjusted locally, marking it as resolved for my own overview. Nice, this will be awesome! Why do we do like this instead of having the device and entity registries subscribe to EVENT LABEL REGISTRY UPDATED ? Compare with what happens when a device is deleted. Edit: OK, so it's modeled on the area registry's behavior. I don't know, I think it's fine this way. It is mainly consistent with how devices areas do it. Instead of attr , should we just use dataclasses in new code? Yeah that makes sense I guess, will do Locally done, marking as resolved to clean up for my own view at this point. This is the same as area registry obviously, but is it really helpful to allow renaming a label which means the label id is no longer in sync with the label's name? Would it be a problem if didn't allow renaming, but just allow adding and deleting? I dunno, I kept it the same as area ID, as this is part of a discussion that felt endless has loose ends on areas too. When I set a different solution here in labels, it would be inconsistent with areas. Or would imply I would have to change labels too (but that discussion never finished either). TL;DR: I didn't want to get myself into that discussion and kept it consistent. (although considering your comment, I failed at keeping out of that discussion ) Stale comment Instead of adding this mock, or perhaps in addition to adding this mock if it's actually useful, update async test home assistant to load the label registry unless the load registries fixture is False , tests can then just call label registry.async get . Adjusted it in my local version. Marking this as resolved for now, to clean up my view on this PR. Best Christmas gift this year! It doesn't mean anything. I've just updated the PR. Don't get me wrong, I would love to get this merged. Just wanted to make sure this didn't cause any false expectations. This would be a game changing feature for me (and others too I m sure). How can we help get this merged? (Sorry for the noise, not sure if there s a forum post for this)
It feels wrong to add markdown as a requirement to this integration to do this conversion. Could you clarify? Most popular chat clients ([Slack]( [Teams]( [Telegram]( etc) provide some sort of markdown support, including the "official" Element.io client (though their documentation doesn't include a section on message formatting, the basic markdown syntax works). Is there a simpler alternative? I felt it was better to leverage a maintained package rather than trying to roll a one off implementation of the markdown standard. Are you suggesting that it would be better to implement only a subset of the markdown standard? Home Assistant exposes features for chat clients as-is. We shouldn't try to add extra features like markdown support for Matrix. If Matrix would support Markdown, it would be ok. Here we fake the feature, that's not ok. Makes sense, I will remove the markdown support. balloob Done.
This error doesn't happen when using Polynomial.fit What happens with this data set? What poly is returned? The coefficients are [1.0, 0.0] for this test and the polynomial always returns 1 . Ok, that works If you are attempting to add name unique id functionality, then you should be using CONF NAME, not CONF FRIENDLY NAME. Fixed CONF NAME Fixed The unique id should be generated from the name if unique id is not supplied. This automatically happens when None is supplied to attr unique id. Because of your removal of name's logic, this will be a breaking change. I suggest keeping the old logic as a fallback if the name is not supplied. I changed this per your wishes. It now requires "name" configuration to have "sane" entity id and name. But that's cost of backward compatibility... Tests show that unique id is not auto-generated when attr unique id is None. I added a test assertion to demonstrate that. move this inside try as it's out used outside the try. Also, assign it None. Cleaned this up Added assertion when "unique id" isn't configured. The entity will not be registered and configurable in the UI. This exception is not possible because voluptuous will prevent it. Ignore empty strings in addition to None
Hmm.... I think this is a masked scan interval... I suppose that's one way of looking at it... given the below suggestion I may try to figure out how to do this automatically
I recommend making a dataclass: Why not set the icon in the entity description? Why not set the state class in the entity description?
Move the if-check of the path starting with a . before building an item response.
let's make sure this is covered by tests.
I don't think this is right, if someone wants to group binary sensors, they can use a binary sensor group instead? I don't get it, could you be more specific? Well, this is basically a group sensor: I'm not sure why such a sensor is provided by the integration. The difference between the new sensor and the binary sensor group is that the new sensor combines the information about all active warnings in its attributes, this information is lost in the binary sensor group. We shouldn't be using attributes. They are expensive (in terms of memory, storage and history) and hard to use. What other way is there to provide additional information about a sensor other than attributes? None really. Entities are not for storing large amounts of data. Would it be acceptable for the integration to allow only the new combined sensor or the old multiple sensors to minimize resource consumption? I'm not following, the combination sensor makes no sense as it combines the other sensors. All data stored in the attributes should, in my opinion, not be there. Thinking about it again, I see that there is meanwhile no good benefit in using this sensor. Thanks for your time. I will close the PR. Use the attribution entity property instead There are non-critical non-primary options and should therefore not be part of the configuration flow. Instead, these should be handled in an options flow. Then I would wait for 65890 and convert this PR to a draft Commented out code?
Is the range 0-99 or 0-100? Do you mean we should rescale out 0..99 to 0..100? If the level range is 0..99, maybe something like this:
Usually we disable these type of sensors by default since they tend to spam the state machine Disabled in c7a7d7456aa8031c0f707354712e8323d31126b2 Is it ever possible that the unique id appears later? If so we need to migrate it (example in flux led) No, it shouldn't appear later since Local API features are checked on the first aioairzone .validate() or .update() and if webserver (which reports mac for unique id) is not supported, then consecutive calls won't try to fetch webserver data. Will it ever appear after restart ? I'm think of the case where it isn't supported and than becomes supported where we need to migrate the unique ids since it could change out from under the entity Will it ever appear after restart ? I'm think of the case where it isn't supported and than becomes supported where we need to migrate the unique ids since it could change out from under the entity Yes, if the Airzone WebServer firmware is upgraded and restarted, and the integration is reloaded or Home Assistant is restarted, then it will appear and HA entities should be migrated from entry id to unique id. This is an existing problem. It can be addressed in another PR. flux led has the exact same issue so you can likely copy most of the migration code from there. I'm a little bit lost here bdraco... Isn't that what you already requested in add7103d554a4f5564b73fc342238465ff86e689 The unique ID migration was implemented in async migrate unique ids. If it's something different I'm not getting what you mean. It is all good. I've seen too many PRs in between that one and this one and missed the fact you already did it. Maybe I'm missing something here, but will this work? Changed in df7ab7a4bfd6cfe77b8906ff4aec92df3cbf797d We have a fixture you can use entity registry enabled by default Fixture used in df7ab7a4bfd6cfe77b8906ff4aec92df3cbf797d and 271eb4d383712290fde96b2f0bc84a0dbec886c0 It would be nice to not have this span 6 lines Refactored in df7ab7a4bfd6cfe77b8906ff4aec92df3cbf797d Since DeviceInfo is a TypedDict you can do Done in d833a6d2d08e1e40a7ab2f7170c435ea2e81497b
You can't add a sensor entity from a switch platform, it has to happen from a sensor.py good to know. So basically there is no relation between the sensor and the switch? they are completely independent entities? also the data fetching instance can't be shared or is there some kind of dependency injection? It seems this integration uses a single call to fetch all data. In those cases, the DataUpdateCoordinator can be used to handle the polling centrally. coordinated-single-api-poll-for-data-for-all-entities The coordinator will get the state on an interval, and notify update all entities (on all platforms) when it got the new state. I ll do the coordinator improvements in a follow up PR. This PR should now be ready. The problem with adding the additional sensors is its now going to poll the device additional times to update each sensor. I'm not sure we allow adding new platforms without refactoring for first It would probably make more sense to do convert to a config flow though Yeah, this conflicts with ADR-0007. It would probably make more sense to do convert to a config flow though Agreed I tried to add a config flow. But I'm not sure what is really necessary to have an integration to actually show up. Setting the config flow flag in the manifest and adding a basic config flow file didn't work. The documentation and example repo is quite lacking. do you have some pointers to understand what is really required to get a basic config flow up and running? I was reading the [Config Flow]( documentation and I don't think that applies to the MyStrom switches. In particular: However, in the first two cases, it doesn t work. Integrations are discovered. Integrations require users logging in on the vendor s website and authorize linking (OAuth2) or users are required to press buttons on the hub to authorize linking (i.e. Hue). MyStrom switches are accessed by IP-Address and REST-API as long as their reachable via network. Its not needed to login somewhere or do something on the device for it to show up somewhere. So, no discovery. The easiest way to configure these would be to add a IP and name for every switch sensor added. Can this be done via [Config Flow]( ? Regarding Refactoring for [YAML Structure]( This would look like this: And that would add entities like the switches and also power sensors eg. sensor.mystrom dev 1 power Correct? Is there a sample which can be roughly followed? python3 -m script.scaffold config flow can help you get started with a config flow I gave it a try and added the config flow in PR 74719.
Please move the entity classes into an entity.py Moved in d8771ce4f2a9eaa4674dc796947a61f61abc2fce Similar to line 50, but not similar enough that its likely worth it to make it more DRY here yet. I think it's ok to leave it like that. Changed in fbf909337eb9c78bc0462fc2e935d903775bd3cb Missing type annotation for the key parameter. Noltari this integration seems close to fully typed here. You could add it to .strict-typing so mypy will alert when something is missing in pre-commit. Thanks, I will try that and see what happens. And sorry for the missing type :( MartinHjelmare bdraco I fixed this typing in my other pending PR since I had to add the WebServer entity class which also defines get airzone value: However, I will try bdraco suggestion and see if anything else is missing when .strict-typing is added.
There's no need to stringify non-string format arguments I wonder if I did this for some linter reason... done Should we take the plunge and only set the default buffer size if CONF MAX AGE is not set, although that would be a breaking change? Would love to but beats the purpose of the deprecation warning. Users with implicit buffer size will be asked to make it explicit today. When I add the 'breaking change PR' later, no users are left to experience the break... win-win Quite the contrary, I think there are many user who have defined a ridiculous buffer size like 99999 in their config, just to work around the current limitations. I would love to inform them that they can remove that silly line at this point... hmmm If CONF MAX AGE is not set, shouldn't we warn too since that's the confusing case: CONF MAX AGE does not work as expected because of the default CONF SAMPLES MAX BUFFER SIZE ? Agreed I think we can add a target version where the behavior changes already now, for example like this for a one-month notice period: Good idea. Done.
If you add energy sensor as FibaroSensor the SensorStateClass.TOTAL INCREASING is missing. As I understand this is important so that the sensor can be used in the energy panel. So either you need to extend FibaroSensor with the correct state class or you need to instantiate a FibaroEnergySensor and make it configurable to either get the value from energy or value attribute. Ok, changed to use FibaroEnergySensor instead Instead of detecting power sensor here again, wouldn't it be better to add sensor platform in the loop below wher this detection is already made? So instead of for device type in ("cover", "light", "switch"): you would use for device type in ("cover", "light", "switch", "sensor"): Didn't want to loop over sensors again but ok, I've change that. Unfortunately this is not enough as stated in my previous comment. The FibaroSensor takes his state from self.fibaro device.properties.value whereas the FibaroEnergySensor takes his state from self.fibaro device.properties.energy . So you can't solve the problem without changing either the FibaroSensor or the FibaroEnergySensor. If I can suggest something, I would add the SensorStateClass to SENSOR TYPES array and then take this value up in FibaroSensor: SENSOR TYPES { "com.fibaro.temperatureSensor": [ "Temperature", None, None, SensorDeviceClass.TEMPERATURE, SensorStateClass.MEASUREMENT, ], "com.fibaro.smokeSensor": [ "Smoke", CONCENTRATION PARTS PER MILLION, "mdi:fire", None, SensorStateClass.MEASUREMENT, ], "CO2": [ "CO2", CONCENTRATION PARTS PER MILLION, None, SensorDeviceClass.CO2, SensorStateClass.MEASUREMENT, ], "com.fibaro.humiditySensor": [ "Humidity", PERCENTAGE, None, SensorDeviceClass.HUMIDITY, SensorStateClass.MEASUREMENT, ], "com.fibaro.lightSensor": [ "Light", LIGHT LUX, None, SensorDeviceClass.ILLUMINANCE, SensorStateClass.MEASUREMENT, ], "com.fibaro.energyMeter": [ "Energy", ENERGY KILO WATT HOUR, None, SensorDeviceClass.ENERGY, SensorStateClass.TOTAL INCREASING, ], } Then in initializing code you can just add the energy as other devices like this: for device in hass.data[DOMAIN][entry.entry id][FIBARO DEVICES][Platform.SENSOR]: entities.append(FibaroSensor(device)) if "power" in device.interfaces: entities.append(FibaroPowerSensor(device)) And in the device you assign the state class from SENSOR TYPES structure: if fibaro device.type in SENSOR TYPES: self. unit SENSOR TYPES[fibaro device.type][1] self. icon SENSOR TYPES[fibaro device.type][2] self. device class SENSOR TYPES[fibaro device.type][3] self. attr state class SENSOR TYPES[fibaro device.type][4]
This is copying the condition from the hs color attribute, which was previously gated by checking if the saturation was 0. smwa can you help confirm that's the correct way to determine the current mode of the light (color or white with adjustable color temperature)? Affirmative, this should be sufficient Several of these will no longer have SUPPORT BRIGHTNESS. Is that assumed from SUPPORT TRANSITION, or does this assume that all bulb types have brightness? The SUPPORT BRIGHTNESS flag is deprecated, brightness support is instead implied the color modes: color-modes. Note: this branch has conflict following the implementation of LightEntityFeature .
Is there a reason that I am not aware of that vacuum platform doesn't implement attr supported features ? None I can think of... We should not implement a one-off shorthand attribute. Instead, we should add proper support for all the standard properties in a separate PR. I have implemented short-hand attributes for: - battery level - battery icon - fan speed - fan speed list - supported features Don't forget to update the dev docs! Done: I am not sure if it is useful to implement attr battery icon since it is overriden in both VacuumEntity and StateVacuumEntity It can be useful, or, if specific needs, implement it in the child entities

Great suggestion! I was already second guessing myself if this was available This is no longer needed, please update existing code referencing self. device id to instead use self.unique id
This does not change the behavior compared to without this PR because it would always report a non- None hs color for lights supporting hue saturation which is interpreted as color mode hs by the base entity. However, for lights which support both hs and white mode it would be better to report according to the light's state. I did not immediately find anything useful in the library though. Any idea, Jc2k , bdraco? HomeKit (at least as defined in the public spec ( doesn't have the concept of an active color mode. You can use h s and you can use color temp. It has the characteristics you can see here, and thats it. There's no way to indicate which color mode is currently in use. Sometimes you can figure out a bit more from the open source example code. There are some notes here: L76 Again, theres no characteristic to indicate a color mode there. (via bdraco) says: The HomeKit R2 spec explicitly states that the Color Temperature char must not be used for lamps which support color. Does that help? OK, I see. I'll add a comment in the code stating that's the case. The situation has changed a bit in iOS 13 The spec says that you're not supposed to have color and color temperature at the same time, but in practice even certified devices implement that now. Apple seems to be certifying them anyway, and the hope is that the spec will get updated in the next version to remove that restriction. iOS seems to handle it now so it seems like the documentation is behind the actual implementation The way iOS seems to handle it is, whichever characteristic was the last to get a notify event for is the color mode you're in For the devices that support both color and color temp you can expect to get a notify for the color which is usually the color temp to color conversion value, and then a notify for the actual color temperature characteristic. Some implementations will not send the notify for the color temperature to color conversion first, and only send the color temperature characteristic notify. In practice that's likely not a problem because in the UI we already compute the approximate color of the color temperature. It's also consistent with what I posted above which ever notify event that you get last is the color mode you are in The only real caveat is because events are sometimes coalesced if you receive a color and color temperature characteristic in the same event, you should prefer the color temp characteristic for the color mode That'll be awkward to implement with the current abstraction. For a start, aiohomekit doesn't do any tracking of when the last change occurred. Even if it did, polling and notifications get funnelled into the same state machine and right now we don't know which is which. And there is always polling as it was largely consequence free and a good way to recover on networks that have flakey wifi. If conversions are lossy we would potentially see a notification for one colour mode. Then after a minute there would be a poll of all co
It would probably be a good idea to use a lambda function or just function refrence for this and move the specific call to the ButtonEntityDescription. That will make it a lot esier to add aditional button entities in the future (withouth having to create seperate classes for all of them). mletenay for example look at the Netgear integration: L35-L43 L75-L78 Good point, done. The unique ID doesn't need the domain, it's already unique for this domain. Done Why are these split? Because without it pylance would complain with "Fields without default values cannot appear after fields with default values". It's the same patter of adding non-default mandatory values as used e.g. in GoodweNumberEntityDescription and I thing also rest of the HA sources. Ok Is this call really non-blocking? if write setting perform any io, it should be executed in an exector. It invokes asyncio method without return value I am not sure i like returning the awaitable that way. But i suppose it might work. I would have just used a standard async function instead of a lambda. Ok. Are the changes in this file related to this pull request? No, not directly. It was not formally filed as bug and reported only in user forum and I did not want to create another PR and wait few more months to get it in. It can be separated if you insist, but I considered it a small bugfix which could be piggybacked int this change. If you put it as a separate bugfix, we can get it in in point realeses. So please separate. I did not meant wait for major release, but wait for review (which takes months ;-) I will separate it, hoping it will get reviewed sooner ... Please raise some error here, so the system knows the entry setup failed. Poossibly the not ready exception to try again later. This is intentional, not all inverter models support this feature, in such case, the button is just not created at all. This is not exceptional state, this is expected state (in some inverters).
This can be put into the entity descriptions directly, as in, on the place used. There is no need to put this to the base entity. Ok, thanks, I will look at this during tomorrow. Time to relax before it's time to sleep ;) Updates as suggested. Make this a lambda that runs the command Sorry, I have no clue what that means. Please teach me... Let's discuss on Discord Updated as suggested. Making this more specific, allowing type checking to check the arguments, also passing in just the API, as that is enough at this point. We generally don't want lambda to cover multiple lines... So this works around that a little isort :)
Commented out stale code? It's not stale code; it's a status parameter exported from device to tuya server, but it seems to be not used It is commented out code, so it should not be added. Does this number entity actually count down during watering? yes That is not allowed in a number field. The number field can be a setting, but it should not be used as countdown. To have a "countdown" a sensor should be used with the timestamp device class indicating the time the countdown would finish. I agree with you. But the way of working of this parameter is: the user sets the initial value of the countdown and the device gradually decreases the value. When it reaches 0 the switch turns off. This number field is used to set the initial value of the countdown This number field is used to set the initial value of the countdown What is unclear to me: Does it actually show its is counting down in the number field? As in, does the number value show the time left? Yes, it shows the time remaining before it turns off automatically. It is updated by the device every 15 seconds (multiples of 14 n15). But the initial value must be sent via set command. I attach communication log with the device ![log]( Sure by that means the number entity changes every 15 seconds. As said in a comment above, that is not allowed, we don't allow for countdowns in our entities. ok, I set the entity as a sensor Is there docs available that can be linked? No, sorry, there isn't docs How often does this update? Does this count down seconds during watering? like 10... 9... 8...? The count down is the number of seconds until it turns off (Closed the watter) This translation format isn't used anymore. Please rebase the PR and consult the current codebase to see how it is handled now (see strings.json ). .. Frenck frenck How is this supposed to be handle now? Actually this value can be from 1 day to maximum 7 days and its always expressed in hours I would also add the fault img width "497" alt "CleanShot 2023-06-11 at 10 57 50" src "" The only other thin I see missing would be to ave the ability to set the Irrigation Duration (
Is YoSmart-Inc your company account and is it active? Otherwise, would it make sense to add matrixd2 to the codeowners list as well? Yes, this account is active and add from homeassistant.const import Platform Why do you need to add an (empty looking) dict to the devices array on init? removed Are there more errors possible? - What if authentication is incorrect, how will that be raised? - Can the client recover from a base exception by retrying? Than you could raise ConfigEntryNotReady . client will recover from retrying, If the authentication fails, the process will not go down Should it only be possible to have a single YoLink account configured? What if they want to add multiple accounts (their account of another location perhaps?) not support currently Could you add the typing to all functions? resolved Please return DeviceInfo from homeassistant.helpers.entity I am not sure why you have some entity related functions like device info and should poll here, while this class does not inherit from Entity. We have several different sensors, YoLinkDeviceEntity is the basic class of our sensor entity YoLinkSensorEntity YoLinkBinarySensorEntity YoLinkBatteryEntity YoLinkDoorEntity those entity inherit from YoLinkDeviceEntity, YoLinkDevice class is used to describe device. and this class maintains a list of entities, device info and should poll methods are the same for different entities of a device removed Can you remove unused types from this PR? And it would be better if you just move the relevant sensor entities to your sensor.py. All types are used Can you not directly add the YoLinkDoorSensor to entities ? There will be many different sensor under the user account. I want to integrate the door sensor first Are all these items used? Please only add keys that are used in this PR. removed Where are you using pydantic and why do you need it? What does it mean if this check is false? How do we handle that case moving forward in the integration? Same question as above. Should we not catch asyncio.TimeoutError too? Normally we want to try again, by raising ConfigEntryNotReady , if the api call failed due to connection or server error. If the api call failed due to authentication error we want to let the user re-authenticate by starting a re-auth config flow, by raising ConfigEntryAuthFailed and adding a corresponding step in the config flow: reauthentication Why do we need a separate child class from AuthenticationManager ?
No need to request a refresh, just update from coordinator. Also this should call self.async write ha state() after it's data is updated. Thanks. This solved the issues with the switch toggling back to old state for a short duration. Tested quite extensively by toggling on off tens of times through HA, restarting HA multiple times. And toggling the Ambi Hue with my remote and see if the state is reflected after the coordinator upgrade. This can be removed. The property is on handled this. You can also remove the handle coordinator update function
The light was previously reporting both a color and a color temperature which is no longer allowed. Is this the correct way to determine if the light is in color mode or in white mode?
DEVICE CLASS are deprecated as of 2021.12, use the BinarySensorDeviceClass enum instead. I suggest that at least for newly used values you use the new enum, existing entries could be changed in a separate PR. Should be fixed in 33a2023cc4e41b575a32b7a2ad9893b93d8b518d
Would this be better, since option is always a string and an empty string should be falsy. Not sure which code style core prefers. I don't have a strong preference, but i like the suggestion better if i had to pick.
Does this options still exist? or should it just set that value or skip this variable entirely and just use the DEFAULT? if adx events: check for empty list doesn't need len. I would use if state is None , bit clearer. you can replace the self. max delay with the DEFAULT value here. this seems a bit strange to first load json, and then dump again? couldn't you just return the json string object directly? No, For some reason this does not work. I tryed multiple ways, and this was the only one that I can get to work ok weird! this is the same line as line 54? maybe change self.client to self.write client to distinguish between this and the query client. you could consider changing this function to accept a list of strings and do parsing of that here, instead of the send piece, makes the sender a bit easier to read. your right, however I wanted this just to have the logic of sending whatever, and having the previous function handle the logic of parsing and stiching. fair enough isn't there some max size for the ingest? I guess there is, but this limit is far outside the reach of what HA ever will be able to produce. The ADX ingester used here can scale far out, and if your using the streaming endpoint, the SDK will automatically change to batch upload if the size is to big for streaming. cool! should probably name this ADXConfigFlow or similar Make sure you set the side effect as the very first thing in the test, unless there is a specific reason not to. same if you just use the parameter (which is fine), then you don't need the self. max delay in the init! We don't allow handling the bare Exception outside the config flow. Please only handle specific exceptions raised by the calling functions. Logging is not needed as the raised exception will be logged
Let's add tests showing an empty options list is allowed: The implementation allows an empty list, let's test it: We need to allow an empty options list for custom options: We should still have this check? If custom value is False , we still would need at least one? maybe I missed this but shouldn't we make this Optional by default, add the length of at least one back (so no need for an empty list, either you provide a list or you don't), and then add a custom validator that makes this required if custom value is False ? This makes it so you can create an options selector with an empty list regardless of whether custom values are supported or not (and it requires you to create at least an empty list always) I see this is similar to the question Frenck asked here: discussion r839336822
Let's make sure we add some icons where appropriate and set the entity categories as well. Please also add entity categories hi frenck Sorry I am not sure about the entity categories. I've added entity categories for Alarm configs but I am not sure if I should add them to Radio and Sleep Aid features as they aren't configs of the device, they are the features that can also be used with google assistant for example.
This could be a function since its duplicated in async set absolute position There are other places as well that could be broken out I made some simplifications to reduce the amount of code. This looks like it could be an Enum I converted it to a IntEnum :) Since there is no call to async request position till stop , do you need to call self.async write ha state here so its reflected right away? I will add the call, but in principle a multicast callback will come in when the blind stops moving that will update the new position and does the self.async write ha state. But doing it twice to be sure in case the multicast message does not come in can not hurt I think done r841228316 done r841228316 done We don't allow device and service interfacing integrations to calculate state. None of the added states here seem to be gotten from api information. I suggest we revert this PR. We don't allow device and service interfacing integrations to calculate state. None of the added states here seem to be gotten from api information. I agree. Sorry I missed that, I was a bit too focused on the code review vs the standards on this one. I suggest we revert this PR. starkillerOG The implementation needs to get the opening and closing states from the api. Do you want to do the revert? Well the command that issues the move does give a acknowledgement message that the device actually started moving, if this ACK message is not received or contains inproper values a exception will be raised and the state would not be set to moving. So in a sence the API does provide conformation that the blind actually started moving. Regarding when it finishes moving, the position of the blind is retrieved from the blind itself here: L276 The not moving state is gotton from the API by seeing that the retrieved position does not change anymore (definition of not moving). So I would argue that the moving states are therefore not assumed but retrieved from the device. Also this was a feature request from a user: However if you want me to revert this PR, I will, just wanted to put in my opinion :) Please confirm how to proceed. The library doesn't raise if the there's a missing ack: L947-L954 Am I looking at the wrong place? The response parsing also doesn't seem to consistently raise exceptions if the response parsing encounters missing or incorrect data. There's a variation of logging and raising a ParseException . So currently we can't trust these things to mean accurate state information. If the api has a contract from its request responses to describe the device movement state we can use that as state information, yes. But currently the library doesn't seem to forward this information consistently to the library user. It would be better if the library kept track of the movement state information so that each library user doesn't need to do this. the raise is on line 481 inside the send function: L438-L481 So for instance the blind.Open function calls blind. write which calls blind. g
zwave-js uses Multilevel Switch as the command class name. MartinHjelmare thoughts on whether the extra space should be included or not? I'd vote for Multilevel Switch , although this appears to be done the same way as Power Level , which is really the Powerlevel command class. Too late to change the latter (double anyone's using it...)? Would it be better if command class names were set in a const somewhere in the python lib? Or add the CC name as part of the notification instance? We made an explicit decision to split power level into two words, I'll have to find the discussion later. Anyway, that's the only case where we've broken convention from Z-Wave JS. Does the zwave spec consider it to be one word? If so maybe we should change it I agree it should be Multilevel Switch, I think I was trying to keep it consistent with Power Level, elsewhere Powerlevel is shown as a single word. We changed the name of power level in our client api methods. issuecomment-985657452 It was not the intention to change the name of the Command Class. The command class has a name and we can't change that. OK I can revert the command class name here, I doubt anyone's using this notification type but we can list it as a breaking change. I still don't see where the line is drawn between the models in the lib and the command class since the commands are all related to this particular command class I believe the key here should be event type not type based on the key this should be a list actually instead of parameters this should just be direction for the key as in ATTR DIRECTION?
We should probably set title placeholders here as well. And a flow title in strings.json If you don't have a name you can do something like AABBCC (192.168.1.11) Where AABBCC is the last 6 of the Mac Done Done and tested. Don't forget to regenerate en.json done and tested Usually we just use the last 6
Why do we need to do this manually, it should be done automatically by RestoreEntity when the entity is removed? During my testing I found out that upon reload the latest state did not always exist upon reload. Adding this fixed that. Thinking maybe that upon removing an entity the saving of the state is just "scheduled" or put on the loop but not completed when the entity is then reloaded. If there's a problem in RestoreEntity we should fix RestoreEntity , not add workarounds in the integrations. So been spending time to see how both RestoreEntity and reloading of platform works and agree it should just work without that statement. I've commented out in my test code and retrying to exhibit same behavior again I saw. I did also write a test for template entity to test reload and with that state was restored as expected. Have not seen behavior anymore but will keep on testing. Instead of this, modify RestoreStateData to use ExtendedJSONEncoder which already supports date , datetime and timedelta in a separate PR Also, is it possible to get date , datetime and timedelta objects as output from templates? Will look into this I am using ExtendedJSOnEncoder now but had to further extend it as it did not put in type for everything but instead just the date format. Can CONF RESTORE be a parameter to SensorTemplate instead, or is there some benefit of splitting in two classes? I split it into 2 classes so that if it is not to be restored then we're not saving the state at all. Otherwise all template sensors will get their state saved irrespective if it needs to be or not. Did not want to adjust existing behavior. Understood, but it makes the code much more complicated. Instead of implementing additional classes, overload async internal will remove from hass and only call RestoreEntity().async internal will remove from hass if the restore flag is set. Also, what happens if the user first has restore enabled, disables it, and then enables it again; will an old saved state now be restored? OK, so have if inherit from RestoreEntity and then implement async internal added to hass and async internal will remove from hass so that the methods in RestoreEntity are only called when the entity is to be restored correct? Also, what happens if the user first has restore enabled, disables it, and then enables it again; will an old saved state now be restored? Yes, at that time the old state will be restored unless that state was expired (fixed at 7 days I believe). Other option would be to always have it save the state irrespective if restore is set to True or False but only restore when restore is set to True. So I Mae it part of TemplateEntity and TriggerEntity now, overloading async internal added to hass so if state is not to be saved I then remove it accordingly. This also fixes the issue if the user has restore enabled, disabled, and then enables it again. When entity loads on disabling the state is removed from last states and thus will not be saved anymore. So 
Thanks. I forgot to save it :) SVC? or SRV? adjusted No need to reload anymore since we will auto reload when it changes from the listener after 5s I didn't add support for the new service as I didn't want to make this any larger MOCK WS ENTRY MOCK ENTRYDATA WS And can we move all three to const.py? Feel free to push to this. Family is here so I won't be able to look until right before bed
We don't need to look up the config entry again. We can use the same reference created above, config entry , to check the updated state. Thanks!
from homeassistant.const import Platform I've moved the device id and device info to the constructor. For the name - I think it can change over time, so I'd prefer to use the name received from the device when it's available. Nice, I wasn't aware of the : operator [ Status ]( L52-L78) contains all information about the state of the purifier, not only information about availability. The set status method is passed as a callback to the PersistentClient, so it can push status updates to the Fan. I've updated the docstring to make this more clear. I already had property available() implemented and it indeed seems to stop Home Assistant from calling the other methods, so I could remove the if s there (see below). My preference would be this probably. Or just import enum instead of importing it in two different ways :). There is quite some code here that could be moved to the pypi library perhaps? Any reason why you added this to HA core code? You're right, I moved the whole client to the library. I only discovered quite late that I'd have to publish the library on PyPI myself and didn't rethink this. Instead of twice having the async show form . You could also just check for if user input and wrap the other part in that. also nice to use const for host model here Why not just pass the config entry to your entity? I think this will clean up your code. Just set this via attr icon Make this a constant in the top of your file. Can this be moved to constructor? Same as name? Just set the attr name and unique id there directly. What does this Status contain? Why just not set attr available (or property available() ) when the device cannot be accessed? This should also block the other ones from being retrieved. I've removed the if checks. If I don't do any checks, mypy complains about status being optional, so I've added assertions to make mypy happy. I'm not sure this is the best solution, though. Just set self. attr device info in your constructor. And use the DeviceInfo tuple from homeassistant.helpers.entity import DeviceInfo . Would be nice to try to type your integration fully :). If you want, you can even mark it as strict and fix all mypy errors. I am not a huge fan of this self. status check everywhere. Can you see if this is required when you use available (see comment above)?
I didn't look at your PR yet, however you will need to add a test for your Config Flow with 100 coverage. thank you. I'll do this soon
define all args that have a default value set in the schema. Those will always be present. For a follow-up, it would be good to add type hints, based on the service schema. eg.
We should be able to get the port from async step ssdp I think we also need to shutdown the self. upnp device in async will remove from hass I think this check need to come before the non-encrypted check and see if this url works L102 instead of trying to connect and do a pin since it breaks legacy tvs otherwise async try connect on the encrypted broke the legacy tv discovery so I added async can connect but it needs to be moved into the upstream lib I still don't like this since it only gives you one chance to hit the button on the websocket tv Should we drop the default value, and instead make SUPPORT VOLUME SET dependant on the presence of CONF SSDP RENDERING CONTROL LOCATION? done I don't think this is in line with our design requirements. Protocol details should stay in a 3rd party library. The library should handle the UPnP setup and command details. I figured this was ok since we have the similar pattern in the upnp and dlna integrations Not sure it's possible, and I'm out of time to dig in more for today, but maybe we create a new profile for Samsung Tv async upnp client.profiles.samsungtv? I would consider them exceptions as they are general integrations similar to mqtt. The Samsung TV integration is not that. epenet async upnp client.profiles.samsungtv or a new library? It doesn't seem to fit in any of the existing ones. Not sure what is better I haven't looked into the details, and I won't be back home for a while so but I wonder if we could actually get subscriptions working as well so we could get push updates.
The idea is to accommodate both Celsius and Fahrenheit here as the interpretation of the value will be determined by how the CoolMasterNet device is configured. This is copied from the climate.set temperature service.
You might be able to auto update this via dhcp discovery as well bdraco I did not implement DHCP discovery of the Motion Blinds devices since I don't really know how to add DHCP discovery. How can I figure out the required parameters like the OUI of these gateways? Is there some python code I can run that prints all discovered devices? Turn on debug logs for homeassistant.components.dhcp and power cycle the gateway. You should get the mac and hostname in the log. The OUI is just the first 6 of the mac bdraco I just figured out that the OUI of Motion blinds comes from "Espressif Inc.", I know of 4 gateways all with OUIs from "Espressif Inc.". Unfortunatley all 4 gateways use a diffrent OUI owned by "Espressif Inc." and they own 92 diffrent OUIs, so that is not of much help, that would become a long list.... What does the hostname show up as ? bdraco I just figured out that the OUI of Motion blinds comes from "Espressif Inc.", I know of 4 gateways all with OUIs from "Espressif Inc.". Unfortunatley all 4 gateways use a diffrent OUI owned by "Espressif Inc." and they own 92 diffrent OUIs, so that is not of much help, that would become a long list.... That's what registered devices is for. Since you have the mac address in the device entry it will still trigger dhcp flows based on matching that For a Brel blind it shows as "Iwip". For a Motion gateway is shows as "MOTION 6564" For a separate PR, but something like this should do it The above assumes async handle discovery validates the device is a motion blinds device or aborts bdraco thanks for the example, I will work on this in a seperate PR. Can you merge this PR? We don't need to setup here. The assert are testing the mock and not the integration so we should drop them. When you add dhcp discovery, you'll need to do this as well Please don't mix string references with regular text in the string values.
Is there no sensor for carbon monoxide? We have device classes for both carbon monoxide and carbon dioxide. The description key looks like it means carbon monoxide. Thanks, that was a typo. We will improve it in this PR We use percent as unit for power factor. Why do you remove these three sensors? We don't have such a sensor on our side. Our developer accidentally copied it from HA types. See above the luminance What about the other two sensors that are removed? We don't have them either - the HA integration developer is not skilled in Z-Way, so he focused on temperature and a few others he had in devices on the table. The rest was copy paste. We are not fixing it after additional testing. We may need a conversion function set as an attribute in the description that is applied before returning the state. What is the native value returned by the api for this measurement? The end result state should be a percentage. Here's an example how to apply a conversion function from a description attribute: L59-L63 L115 L166-L170 Looks ok now
Please use asyncio.create task instead. I don't think we need this method. We can pass async scheduled update request to track point in time .
this gets the config flow working. this breaks the config flow on my tubeszb devices as they are now. Working on some new firmware that would work going forward (with another PR from me). but not sure how to make it work for both ways Which port is being returned with the current firmware? We should be able to get this from discovery info I think. I don t remember why we hard coded this. it's not in there as currently piggy back off the esphome discovery info. I'll go hook one up and test to see if I can come up with a suggestion Thanks for the help! Should work now, but still needs some tests thanks, we should be able to get rid of the hard coding in the future. tube0013 Can you test this to make sure it didn't break any of the efr32 ones. I don't have one of these to validate with tube0013 Can you test this to make sure it didn't break any of the efr32 ones. I don't have one of these to validate with Looks like we are stuck with the hard coding
This and above suggestion fails this PR's current tests Is this putting every movie in the attributes? Yes. I believe this was the previous behavior but likely to be a problem as you can imagine. What about a limit to say 1000? Should this be user configurable? That data does not belong in the state machine. I would add spport for the entity description to specify a get native value , it could work like get native value lambda coordinator: coordinator.moves Then this method would just do return self.entity description.get native value(self.coordinator) I assume this would be done like venstar ? It seems to mess with the way I have my dataclasses in aiopyarr where there it is dataclass(init False) Like Shelly L125 EntityDescriptions should live in Home Assistant as it's a way to describe the data for Home Assistant entities. Shouldn't tie to aiopyarr ? Why would this be in the state attributes? Instead it seems like every root folder could be a sensor. We try to push things out of attributes. The old integration behavior. I suppose making conforming changes now would be appropriate since the integration has been broken already? yeah What are commands ? The recently run commands in the application: download client status update, RSS sync, etc. those should not be in attributes. They should be separate sensors then and different PR in that case? Definitely not in the attributes. But why would we have that in HA at all ? I see your point so they will be removed. If someone in the community requests these, I can add them later as sensors. This is the default for a lot of sensors and it should be the attributes for none. This should be moved to to be calendar platform. This reflects the old behavior. Since we are not merging into dev directly, I can remove this for now and have a new PR just for the calendar. This default URL makes no sense. It's a local IP. Forgot that most people don't run supervised using that gateway address to access the docker default subnet. if we want to offer auto-setup of supervisor installed Radarr, for a new PR: In config flow detect if user is running Supervisor, probe that URL, if it works, offer user to set-up the add-on without prompting a URL. Since it's 1 config entry - 1 service, you could keep it in sync with the config entry title. Shouldn't this be len(coordinator.movies) ? you can't make it sync. You're calling an async task. It's better to have 3 coordinators. One for each data source. That way it will automatically enable disable polling based on if entities are loaded. Do it like this: L85-L104 This wouldn't work, users can change entity ID. If we want explicit support for the add-on, we can detect if we're in supervisor and have the add-on, and just offer an option to set that up without asking for a URL. Why is this not returning the data?
Should this be part of the basic group options schema ? no it should not How is this different than states ? Ah it's the state string. Can we just base this on states and not filter it again ? Done all feels like a weird option for a switch. Should we mark this only visible for advanced users? I also noted that we show it as part of the creation of a group. It seems like something that slim of a use case that we don't have to show it during creation, but allow users in advanced mode to enable it in the options later. Done! We may be able to use a generator expression. ah right, leftover from the state magic, will open a PR to adjust
The station is already available in the (custom) coordinator. Instead of storing it in hass data, entities can just access it via the coordinator. Same for the battery limit, if that is moved into the coordinator as a property, then the coordinator is the only thing that needs to be stored. Done. Can be accessed via the coordinator Already handled by the CoordinatorEntity It less code to just handle that using a shorthand attribute in the child classes How much data is stored in there? Seems like this would put some serious strain on the state engine and state history database storage? See also: ![image]( Hmmm, it would be a couple dozen of bikes every time... Now that I think about it, there's probably little use in seeing that information anyways, particularly if the bikes were already filtered based on the battery level - I removed all the bikes and only left the total count. Station name is already the entity name, we don't need to duplicate that? What would be the use case of this attribute? Good point - removed. What would one use the station ID for? Same as above, not much use for that - removed. We now have a location selector, which isn't used yet documented, but a reference PR can be found here: Isn't this an option? As in, is this really required to enter? What is a user enters both station ID and lat long? Let's be explicit in the arguments and loose args kwargs. It is quite inefficient to do this each time this method is called. Instead, we can pre-calculate these values once each time the coordinator updates. Reducing the run execution of this calculation to once per coordinator update. This is a brand name, it should not be translated.
I don't think we should match if the matcher attribute is None. Then we'll match if all matcher attributes are None too. That's weird. I suggest we only match with the attributes that are not None in the matcher. good call hmm I think the same problem exists... Edit: nvm got it OK I handled this in the ZwaveValueID class because the scenario you mentioned should not be valid
I wonder if this list of names might be better to include in the library so if there are updates, it could be handled all there. I was thinking that too, wish I would've done that in my last update to the library. Maybe leave it as is for this PR, but make the change in the library and open another PR to bump the version and make the change? It would be good to type the mock as well .keys() can be removed. It's the default. I am moving the preset name - int mapping to the asyncsleepiq library ( Once that is merged and a new version is published, I'll open a PR to bump that dependency and update how the select entity gets the list of options (and won't use .keys() to do so)
This should really be a selector which allows the user to add a list of strings. When set to required, frontend adds an asterisk to hours, minutes and seconds, and doesn't allow setting the duration to 0. If that's the wanted behavior by frontend, we should make this optional instead. If that's not the wanted frontend behavior by fronted, frontend needs to be updated to allow configuring a 0-duration. Offset is by all means optional The UI input looks like this: ![image]( I expect that to generate a 0-duration when left at 0, but maybe I'm wrong? offset can be several days... (most common offset) yes, we need the UI input to support days. Instead of this, we could create a task which first does setup of the select platform, and only when that's done, of the sensor platform. we should check that all tariffs are unique maybe we could define METER TYPE NONE ? I wonder if we could reuse this assignment from config flow.py This needs to actually contain a description of what a utility meter is? Yeah, and I think we should have that in all the helper flows. In this case, something like this maybe: The utility meter sensor provides functionality to track consumptions of various utilities (e.g., energy, gas, water, heating) over a configured period of time, typically monthly. The utility meter sensor also supports splitting the consumption by tariffs. (requires running hassfest to re-generate config flows) Config flows need to be fully covered, so lets add a test for this case Config flows need to be fully covered, so lets add a test for this case
attr is on is already typed upstream I figured, but I couldn't find the declaration for it myself. The Binary Sensor Group uses attr is on None to represent a group entity with an unknown state, as I've also done here. Without declaring it as an optional bool, [a mypy error is produced]( stating that attr is on must be a bool, which None bool . Is there a different way I should be going about this? attr is on is defined in ToggleEntity , that has: attr is on: bool None None If mypy is complaining it means that it has been overridden somewhere (which it should not have). According to mypy, [this line]( L142) was declaring attr is on as a bool (before I explicitly set it as Optional[bool] ). mypy seems to choke on the default (which makes no sense, pyright does infer it correctly). Looking at the code, IMHO it can be completely removed, as None is a valid default state to start with (the group state is updated when added to hass anyways). I merged that change, tests seem to pass here locally on my system
Maybe move the two new methods below async set charging current to keep it together with set charging current ? Yes, I was actually thinking about that before (keeping async with async, or async with the corresponding sync function, I changed it to the latter now) For EntityDescriptions it's usually best to put each key on a new line. Black will do that automatically if you add a trailing comma. If you don't need additional keys, just use LockEntityDescription directly. OK, I changed that No need to do this. The assignment is already handled by super(). init (coordinator) . Why change it to string? Form what I can tell, it should still work, however since precision 0 is set, a debug log entry should be emitted. Yes, I did this on purpose to trigger a formatting error in the sensor component (which is being caught by a try ... except in the code Is that a valid response from the API though? well, no, so I expect the API to provide a number there, and I expect that I can round the number. However, I don't want the integration to crash so I do a try ... catch on the rounding of the values. (And I want to test the try..catch, so I provide a value that will surely fail - a string instead of a float) Just my opinion, I think it's safe to assume an API will return the datatypes it says it will. Testing it every time will just add unnecessary overhead. The exception to this would of course be security reasons. I.e. don't pass an unescaped API response to a database. If you really want to go that route, wouldn't you also need to check that the structure of getChargerStatus ? The API response is just silently assigned to data . In the end, I don't believe those checks add much value. It's more important to guard against the expected errors, e.g. Connection and Authentication. You can add annotations to tests, too. Although they aren't checked with mypy, they can still help with autocompletions. Would you mind adding the annotations for hass: HomeAssistant in this file? OK, shall I create a seperate PR to also do it in the other test files? Only wrap the call that should actually raise the ConnectionError . I first try a lock and an unlock afterwards, I expect that both return a connection error. I first try a lock and an unlock afterwards, I expect that both return a connection error. That's fine. The problem however is that the second service call will never be executed as the first already raises an exception. Just wrap each call in a pytest.raises block. ahhh, ok, will do This is already set by LockEntity . I removed this ok I update how the coordinator is typed recently. Rebase the PR, that line shouldn't be necessary anymore. The WallboxCoordinator typing is handled by WallboxEntity . This is good but it only tests the state after setup integration . It would be interesting to test it after each service call, too. Furthermore, state can be None . Just to be safe, please add an additional assert state . I don't see how that would work, in real life I s
This can't be deterministic and needs to be set only when requested instead since we need to be backwards compat
Maybe make it a set? This is a tuple. Whoops it was late
Should this be a list to select from? Feel a bit weird to add a number field for this (e.g., I could enter 38235 ) If we add a list, we could end up in the same situation that we are trying to solve. There are some modems that do not provide automatic speed control and use very specific baud speeds. We should not list them all. If you enter a value not supported by the modem the configuration will fail and you can retry again with the value that comes from the specific model. Those baud speeds may not be automatic, but still, conform to a standard set? For example: - 50 - 75 - 110 - 134 - 150 - 200 - 300 - 600 - 1200 - 1800 - 2400 - 4800 - 9600 - 19200 - 28800 - 38400 - 57600 - 76800 - 115200 I don't think we need to go any higher, but some platforms also support: - 230400 - 460800 - 576000 - 921600 - etc Other values may cause issues, and, I didn't see any case that required anything else? I assume this list will work. Can you show me how to specify a list of values in the data schema? import: from homeassistant.helpers import selector and (unformatted): The whole dict is properly easier to create using comprehension, but this above makes the example use clear. Awesome, will do I am seeing an error: expected str for dictionary value data['options'][0]['value'] I think is because is expecting str and I am giving it integers. How do I specify the type of the selector? I am seeing an error: expected str for dictionary value data['options'][0]['value'] I think is because is expecting str and I am giving it integers. How do I specify the type of the selector? I work around the issue by using "string" for the speed value. For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. More information about this can be found in Architecture Decision Record: - ADR-0010: decision Since this integration already has configuration flow support, the YAML setup should have been deprecated. How does the yaml setup gets deprecated? I figure it out. yaml config is now deprecated. DEFAULT BAUD SPEED is already a string? It is already a string? Why is this causing an import error that needs to be disabled? It seems pylint does not know about the gammu lib for some reason. This comment is made on de Voluptuous import, not the gammu library Ahh I remember now. Pylint entered an infinite loop complaining about wrong import order. X before Y. When trying to fix it then it complain than Y before X as so on. The only way I was able to fix it was to ignore the import. I should have added a comment. That sounds incorrect or maybe an issue in your environment. We don't use pylint for import ordering, as a matter of fact, the order is disabled: ![CleanShot 2022-04-27 at 19 00 14]( The error you are disabling in the comment is an import-error , which should not occur for voluptuous Perhaps you are correct. My dev environment is based on WSL and by following the handbook I see a failure in scripts setup complaining about a bad par
This is a breaking change. Instead, we could also leave them as is and deprecate them (as the select entity will be a full replacement). After two release cycles, the attributes can be fully removed. Didn't think about it that way, but indeed it would replace them. len(None) would be an error That seems incorrect, the property is implemented below As per your other comment; that is what we realised, but indeed didn't take it out. Can't these change over time? Applied both Do we want some error-handling and logging here? Instead of debugging, we should raise if changing failed. Please remove the debug statements and add actual error raising. Raise which error? HomeAssistantError? Yup. Right now, it silently fails, which isn't helpful :) Applied in 310a4e0 This is already logged, as state changes are logged in debug mode. oops :)
There is a lot of duplication between this and SamsungTVWSBridge . Does it make sense to make this a super class of SamsungTVWSBridge and override methods? I have created a SamsungTVWSBaseBridge class, that is inherited by both encrypted and not-encrypted bridges. That means that close remote , is on and device info methods are shared. try connect send commands get remote is harder to merge because they use different underlying classes. Might work with a couple generics ( TCommand, TRemote). I'll try that as a follow-up Well I've implemented the generics. I'm not sure if it's easier to read but I guess it reduces the number of lines a little bit. I put it in, and then I could the generic back out. I'm happy to put it back in but I think maybe as a follow-up after this one is merged? KEY POWER did work These could be standard constants instead of bound constants Updated in b77b1f76fe9ab37fcf74c4497adf54e1a16898b6
This is no longer required :) Should we reset update events listener to None here too?

The UX is not good, we should conditionally hide the time and duration selectors. Maybe a version of the select selector which has: value: {label: str, sub-selectors: [selector]} items. Yeah... I'm not really sure if this is "presentable" in the current state :s Don't get time wrong, I get this is the best possible option at this point... but... It is highly confusing: img width "599" alt "image" src "" This should move to the integration entry setup, so we can fail the setup state (or make it retry). We should make this key value pairs, so it looks nicer in the UI img width "403" alt "image" src "" Stale documentation, as some things changed.
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries. We generally also don't allow timeout options but want integrations to use a sane default. I was just trying to add the timeout parameter and wasn't thinking of converting the whole integration. :) That'll be a much bigger change and not sure I have time to tackle that right now. So is this completely blocked now unless I can convert the integration away from the yaml? I don't really own this integration as I was just trying to add this option in there since it failed for me completely without it. For the timeout itself, there is no default specified in this integration at all. It happens to be using the python snmp library that has a default on the UdpTransportTarget class of 1 second. 1 second does not work for a lot of slower devices (e.g. with the default, my QNAP NAS never completes the SNMP get within 1 second). Since there is nothing in the integration to specify a timeout (default or not), even if we have to add a "sane default" we will still have to add the code to specify the value. And for something like this SNMP integration, I'm not sure there is a "sane default" that will fit people's needs (unless we make the timeout bigger than most folks need), so it seemed to me a better option to allow users to override it (even if there is a default). My PR kept the default as 1 second so it doesn't change the behaviour on folks that may have been depending on the previous code implicitly doing 1 second timeout. But open to suggestion on how we can fix this a different way if not providing a timeout override option. What would you set the timeout to? I have one that times out at 1s but is ok with 2s but its not critical for me so I never really cared. For integrations with rapid scan intervals 1m, I usually suggest 80 of the scan interval number of questions made in the scan interval. So 8s timeout if it does one query or 4s if it does two queries. If we think 8s is the right default I can update the PR with that as the default, but it is probably still good to provide the override option, or are we saying we don't want a user overridable option and the integration just use the 8s? You would need to do the config flow conversion to unblock adding an option. If you don't want to do that, setting the timeout to 8s seems fine to me. Ok, I have taken out adding the option to override and just setting the default timeout to 8s for now. I can take a look at the conversion of the config flow when I get more time but will open a separate PR for it to keep it clean. We would still be hesitant to add this option in an options flow. We would appreciate if you want to convert the integration to use a config flow but we can't guarantee now that a timeout option will be accepted.
Fix this comment Fix this comment This is doing I O in the event loop but its existing so I opened This didn't belong in the try block so it was moved below. When can json.loads return a falsey value if you already detect empty JSON object and None ? I don't think it can anymore now that the guard above has been added Can we have this covered by a test? Is this being turned on only for tests or for production? If the former, please revert before merge. If the latter, we should remove the comment and the flag. Does it mean after 2023.8 we no longer try to fetch attributes from the State table? If so, please make this clear in the PR description and add a comment to other code which can be simplified with the 2023.8 release. plant and statistics should use the history api. It looks like you already agree with that per issuecomment-1072116361 so I'm going to remove these comment since these will likely go away long before 2023.8 Please add a comment explaining the tuning of the cache size. Should it be tuned according to the number of states? Can should we do that automatically? What's the expected performance impact on this? Is the filtering first on hash, then on the attributes to handle hash collisions? Does this have any performance impact, or is it negligible since the DB can just fetch the attribute with the wanted index? Its negligible since the DB can just fetch the attribute with the index. In fact it can be faster since it doesn't have to reach the attributes in the states table in the same disk block most of the time since its joined after filtering in most cases. Can we cover this in a test?
Any specific reason to not drop the whole entry in here? (with username password, house id redacted) house id seems to be part of the links data anyway as well. Might be sensitive? It is not sensitive. It is a randomly assigned identifier. I didn't add it to the data since the only thing we really ever have problems with is the brand Randomly assigned identifiers might be considered secret (webhooks and stuff). Anyway i think this looks good, even though that HUGE test data is a bit ugly. All of them require authentication to access so I think its OK. We would need to consider the zone ids, thermostat ids, automation ids as sensitive if we went that route so I think that wouldn't be tenable. Maybe put the data in a json file in a fixtures directory and load it as a fixture?
NIT, but a new const with "Twente Milieu" could be added and used for manufacturer and name. nah, but thanks for the suggestion And use that new constant for the tests... Please sort .
I suggest you add a subclass of BinarySensorEntityDescription where you add a list of extra attributes instead of this. I'm currently out of home, but I will do that as soon as possible. Thanks for the suggestion! Changed in 45e69886536a855c7fb37976548fd2911c57cbf8 Nice! This should be a dict comprehension. Sure, excuse me but my python skills are a bit limited . Changed in 7db4c8dabb4c2cfb0002cf4259892e797ed58a86 That is fine. This is a minor suggestion, that somebody else might make later. You probably should do an early return here. OK! Changed in 213edc291a83b227410b10a7aa25c23b3166ccdc What do these attributes represent? "air" represents that the system has enabled the air conditioning system and "floor" represents that the system has enabled the radiators or floor the radiating floor. Usually we would make these separate sensors instead of attributes Ok, I'll split this into 2 sensors then. Done in 0363ba9d70 What do these attributes represent? The array of errors returned by the API for each HVAC Zone. If there's at least one entry in the array, then the binary sensor will be enabled, but this way the user can check what the specific error is. If its a smaller fixed of potentially problems we want a problem binary sensor per error If its a large list or non-binary, it should be its own sensor entity. It's a very large list: ![image]( ![image]( That's a very strange implementation of error reporting. I think its best to leave this as-is.
Commented code. Don't log passwords. Also also let's log it as debug, it's already given back to the user if it fails Why set DOMAIN as unique ID, that means only one can exist ? You have a serial and that should be the ID ? ConnectionError and ClientConnectionError should raise a ConfigEntryNotReady so it is retried later. Only LoginException should trigger re-auth flow. Stale comment Why migrate? You can just raise ConfigEntryAuthFailed if you detect that a username is stored in entry.data Most likely because I don't understand migration! :) I assumed if I was adding new fields I'd have to have a migration path... is that not the case? Ok this was a great idea I've removed migration .. HOWEVER ... I'm running into one small issue still. It appears my "reconfigure" box triggered by throwing the ConfigEntryAuthFailed error isn't able to correctly pull the serial value into img width "303" alt "image" src "" The actual error is: Translation Error: The intl string context variable "serial" was not provided to the string "{serial} ({host})" img width "252" alt "image" src "" img width "253" alt "image" src "" Can you point me to where how to set this data correctly? I'm a little unsure exactly where which function is triggering it or where its trying to pull that data from. I didn't explain that well. I end up with both of those boxes on the UI. One says error one says Reconfigure - but it appears the reconfigure box isn't correctly being populated with the information it needs. Actually its even stranger - at first it "appears" my error comes up correctly then it some how refreshes and clears out the serial info... So mid-load of HA - I get this as my errors: (which is what I want) img width "510" alt "image" src "" Eventually it turns back into this. img width "937" alt "image" src "" Triggered by this version of core.config entries ... img width "475" alt "image" src "" Even with the translation errors in the UI - The Reauth works correctly and I can correctly update fix the integration after following the flow WooHOO ! I think I fixed it :) Why do you need to nullify the user pass and then ask it again to login to the iftapi website ? Did you manually create this file ? You can run python3 -m script.translations develop to generate this. I think I did manually generate this ... I've committed an auto-generated one. These errors need to have a user facing reason of what went wrong. KeyError feels a bit odd, is that to catch CONF PASSWORD missing ? That shouldn't happen right? Yea it is - because if its an old version of the config CONF PASSWORD isn't there and then you get a key error.. To elaborate - The existing version (of the config data) doesn't have password username ... and since we didn't need to do the migration route but just fire a ReAuth error if they are missing thats what this logic was for... but you guard for that already with checking for CONF USERNAME a few lines above? You are 100 right ... I'll test to make sure Its not some r

We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: Thanks for the feedback! I wasn t aware of that requirement. I ll see what I can do to get this integration switched over.
I kinda agree, but let's only create this once on initial set up onboard (as part of the default configuration). This doing I O and needs to be in executor. Its not just URL config www , but also URL www . I don't think we should add this. It feels wrong. Yeah I agree with Frenck. I don't like this either. Why don't we just always register a local path, regardless if the dir exists? Then if it's created it automatically works. That didn't work in my testing.
This is static. You can make it a class attribute Nice catch. Fixed The below code could be it's own function since it's duplicated code Moved the common code to its own function. Why the noqa? Because of the deprecation warning I added, there is now a linter warning for "function is too complex". I guess that one additional branch pushed it just over the edge. I figured it was fine to suppress the linter warning, since the deprecation warnings will be removed in a couple of releases, at which time I will remove the noqa. I also see this particular linter warning being suppressed in many other places throughout the codebase. If this is not acceptable then please let me know and I can try to refactor the function to avoid the warning. You could move the code in embedded functions out into a new function and call them from the existing function so you still are holding a reference to hass Ok, but is this really needed for this PR? It seems a bit out of scope. Can we leave the noqa there since it will be removed in a couple of releases? The code in async handle service call() will also become simpler at that time, since all services except send poi will be removed. It would be better to refactor it in a fresh PR before merging this one. I prefer not to merge code that turns off the checks unless its for a bug fix since there is no way to ensure that they get turned back on in the future. I was able to remove the noqa by making a small change to the function.
Use from yarl import URL to mutate these urls.
Could you have a look at your failed tests? It seems you are not mocking all requests correctly. And I believe it is better to mock your python client functions, instead of the aio http client directly. However, someone else with more testing experience should confirm this. side effect can be used on the mocked object meichthys
Leftover debug print. Why do we add a state attribute here if we also add individual sensors? One of the use cases for this is to create lights that represent the price, as well as course grain automatons (ie, turn off when price is high, rather than turn off when price is 36c). If it is only an attribute, it would require a template, so I made it a first-class citizen. For more context: "high" isn't the same price threshold for all users, so using this sensor, they can map what is exactly happening in our app. It's added to the attributes for completeness (so it represents the whole object returned from the APi) I suggest we remove the added attributes as we have the sensors. Can we remove this too? No. That is the forecast sensor. There is no equivalent in the price descriptor sensor. Ok.
I was thinking we should add our config entry id to the device so that we have the same device under this config entry. It's a bit weird to only add our entity to the other config entry device entry. Yes, we can do that. Then we should also: a) Remove the switch as x config entry from the device if the other config entry is removed from the device b) Remove the switch as x config entry from the device if the tracked entity is removed from the device a) will result in the tracked entity being removed from the device automatically by the entity registrym i.e. b), so we only need to handle b) Is some other additional cleanup is needed? - If the other config entry is removed, it will be removed from the device, so that's covered by a) - When our config entry is removed, it will be removed from the device automatically by DeviceRegistry.async clear config entry Sounds good. OK, implemented. It added quite a lot of code though. Not so much code after it was clear we don't need to worry about a) Duplicate of the above line? I wonder if we already cover this case with the entity registry event listener below? You're right, that's handled here: L460-L470
You could make a set of valid commands and do something like await getattr(self. device, command)() or raise HomeAssistantError(f"{command} is not a known command") Fixed in If you make this a set, cmd in VALID COMMANDS can avoid a linear search Fixed. Fixed. unused Fixed. Fixed.
Should we do this inside the config flow? That way a user might decide to undo the action. Moved to inside the config flow by f0ecede Why validate ? Doesn't the below check if an entry is returned do the same? The function also resolves uuid to entity id . I think the name async validate entity id is unclear. It used to be async resolve entity id , but we changed it because the function raises if the uuid is missing. Can you pass a string to make sure that works. Also, can you test an invalid value. Fixed in 2d8ab0f
This seems fairly limited? What about all other HTTP clients that are used in Home Assistant? And what would clients from pulled in Python libraries?
This is a bit ambigous as the code above tells exactly this. I think we should handle 'todos' differently, maybe just add it instead of todo-ing it? Are these defaults actual defaults, or only in your installation? These are the actual defaults for GLinet based routers - they were originally marketed a travel routers so used the uncommon .8 subnet as to avoid conflicts when used behind another local network The problem with using the default password is that a user by default cannot see what is entered in the field, so it's not that useful. Make sure to remove this file. It is automatically generated by Localize based on strings.json . removed I think you can only add requirements for your own component accidental leftovers from a rebase - removed Isn't it better to move some api related stuff to your Glinet library? I feel the code and communication is a bit all over the place? I see what you mean. I was trying to keep the python library as lean as possible, it is just a wrapper for async requests really, I could move some of the functions and properties over but my worry is that the codebase would become rather 'split' and would move so code out of the reach of the home assistant maintainers and admins. As you may have picked up, much of the code is borrowed from the ASUS router integration and so I have tried to replicate that as much as I can - I am happy to try and improve the 'smell' of the code with the reviewers' guidance No YAML support for new integrations. We only support import for integrations that migrate to config flow. For new ones drop async setup . Handle if authentication or connection fails. ? Why use DATA GLINET and not just store entry id router ? There are no other fields. What about a timeout ? You need to communicate this back to the user instead of printing it to the logs. This method and TestingHub class have a lot of overlap. I suggest to merge them Why set user input ? Why store the password, you have the token? I tried without, but unfortunately there was no way to handle token renewal without storing the password. Don't return device info. This is already the default of ScannerEntity L297 This means that device states are constantly updated. We shouldn't include this in the device tracker entity. It can be a sensor, but added in a future PR and disabled by default. Why even store the device as an instance variable instead of just always reading it from self. router ? that way it's never out of sync. Why not use a DataUpdateCoordinator ?
Can the value be missing? You're right, it shouldn't be missing :P bdraco removed get and cast in 5dabd97b36141ea79c08583466200ce19eebcb32 There are a few HVAC MODE LIB TO HASS.get s as well. Can those be adjusted as well? There are a few HVAC MODE LIB TO HASS.get s as well. Can those be adjusted as well? Removed in a49e4385c6 I guess I should rebase due to 1072aff0172ae7d4127181af3ac2097c2e5c3398 and remove this, but I don't want to disturb any pending review. bdraco since you have self-requested a review of this, should I proceed or should I wait? I haven't had time to look at this, so go right ahead and re-base I haven't had time to look at this, so go right ahead and re-base Don't worry, there's no need to hurry. I just didn't want to disturb any on-going review :). Thanks :)! Done in b52034defc495c737e7333f9470f7a516639a06c We want the user to get feedback if it fails in the UI If these are only going to used in the climate platform, it is better to leave them there. Moved in 81cad1b547
calling handle get states will send data in a "result" response when setting up a subscription. That's not something that we don't handle currently. I guess we can add it. I know that Android will be interested in specifying the entities that are subscribed to. Default all, optional entity IDs: list[str] to limit what entities are included. How would the frontend websocket consume this? 961941697d368b0d69f62d2a19e2e62da449c244 If we want we can compress this further by allowing "c": "some-id" and interpreting "some-id" as {"id": "some-id", "parent id": None, "user id": None} implemented I'm not sure I like this design. We have known like for like data. This is treating it as unknown data. I think this can be a lot more efficient if we make it a bit less generic Yeah, that's what I did on the JS side. We could change the payload type from 'add' 'a', 'remove' 'r', 'changed' 'c' ? I'm leaning towards yes but thats only if we expect home-assistant-js-websocket is our only customer of this API Since its a new api I went with it Isn't state changed always in SUBSCRIBE ALLOWLIST ?
Is this meant to be like the name of the product for example? Copy paste problem, will change it! A comment like this that is self explanatory can be removed as it is not adding value. Shouldn't these be exclusive? Indeed, will change it! Accounting to the service.yaml file, this is required with a default of 1, however, according to the schema its completely optional? It shouldn't be required, I'll change the service.yaml definition. Smart! But not a construct we want to use. Right now, we don't have any constructs for command with results in Home Assistant. So, unfortunately, at this point in time, you can't build this. Ok I suspected this wouldn't be something we'd want to support with out a proper construction. Btw I am exploring this and had a proof of concept working, but have a lot to do to make a proposal. Ok, I'll remove it! Why is this needed? Because it runs once per config entry? I'm curious if this works to run from async setup in init .py instead so it runs once on component init. I just looked at a few other components on how they implemented it and found this construct. (e.g. in the hue component) Is there a better way? It's indeed to prevent registering services more than once. Thanks, hadn't seen it before. Could be a one-liner How do any of these happen? I would say guard with explicit checks rather than letting these things throw (and only do so if they are reasonable things that can happen). AttributeError can't really happen indeed. StopIteration is for when there are no config entries and KeyError when the data for the config entry is not set correctly. It's just a pythonic way of writing it and it's shorter than adding guards, but I can change it if you like. Yeah, separate these out so the exceptions are tightly scoped, and only catch exceptions that are meaningful (e.g. don't catch things that won't actually happen, or replace with a check instead if its something you want to be defensive of). I think it's fine to assume the config entry id for a device exists in the hass.data for example and let the key error throw rather than re-packaging as another exception in that "shouldn't happen" scenario. I've only left the StopIteration exception... I'm not sure if this is a pattern there is prior art for or not -- is this common to pick an arbitrary device in a service? Most people will have only one time the integration added as it's address based. So picking the first configured integration will work for 99 of the cases and it saves the user from configuring the device id for each service call. Oh let me clarify -- I wasn't asking why , as it's clear the motivation -- My question is if this is the correct design standard (e.g. potential for confusion bugs etc) and if this should be handled at a higher level similar to how entity matches are handled: L64 (I lean towards not doing this and would want a second opinion to allow it) I can't find any references to handling this on a higher level. So the solution would be to make t
This is not needed, as that is considered the default. Without device class the switch currently uses mdiFlash though, which is rather confusing. But, given the fact Paulus also commented on the Pr I suggested to change that also, I am confused what to do...
You can simplify this method by just adding IntrusionSystemAlarmControlPanel directly in async add entities() method. Alarm Control Panel entities will have an icon by default. Any specific reason why you want to override this? Any reason why you don't base this one on the SHCEntity ? This would remove a lot of duplicate code. I know. Reason is the intrusion system is not treated as a device on the SHC, but as a domain function. This is why some methods are not available for the intrusion system (e.g. unique id ). Makes sense. It would be great to see how SHCEntity can be modified to support both cases, or two smaller classes to inherit from. However, don't think this should be a blocker for this PR, but core maintainers would need to agree on that :-). Added the two classes for device and for domain services, which both inherit from SHCEntity in So when the that PR is merged, this PR will become much simpler. It would be good if you could type all functions, should be a small effort here. Already set by the base entity It would be better to have a dict with {SHCstate : HA state} and then use a dict lookup instead of all these if-statements This should implement has entity name but it seems nowhere to be found. I think we should have a preliminary PR fixing that first and then we can finalize this one.
This would be moved to a switch subclass or similar in a real implementation.
No need to cast to string, it's already a string. Thanks! That's what I get for blindly copy-pasting "code that worked" ;-)
Type hints are missing Type hints are missing Type hints are missing Type hints are missing Type hints are missing Type hints are missing Type hints are missing You know the rest Mmm...yes, probably I could imagine! You might want to condense this into CONF URL If not a problem I would separate both parameters in order to follow the mobile app (iAlarmXR) schema view and show the same default value. Please only include en.json . The rest is handled by a translation community. Please remove this translation, you can generate the English translation for testing purposes, but all other translations will be done via Lokalise platform. Uh ok ...I'm italian native so it's a "trusted" translation but it's ok, I'll remove it And your translation is appreciated! However, Home Assistant manages these translations through Lokalise. See (I think you should make these changes yourselves, since it was hard for me to get the indent right via GitHub...) Will there be another exception when the username or password is incorrect? (but a connection is possible). ConnectionError will be thrown if host and or port will be unreachable but if login and or password will be incorrect then a generic error will be thrown. Could you rebase on dev and implement this? Is this a mac address? If so, you should add this: Looks good to me, just had some minor remarks. You could also try to add your integration to .strict-typing to see how far you are with the typing. Perhaps you just need a few small fixes to have it fully strictly typed. (which would be awesome). Thanks a lot iMicknl for your review and suggestions I changed as you suggested me and I've added this integration to .strict-typing components list...only three function's parameters to be typed (uuuhhh what a relief!) I rebased and tested locally, all appear to me working well, tnx! Awesome! :D
You can use the SleepIQDataUpdateCoordinator for this as they have the same update interval The goal was to avoid making the extra API call to get the values for actuators if those entities are disabled, but I'm not sure if it actually works that way. If not, then definitely no reason for an extra coordinator. The coordinator would still update even if there were no entities. If there are no physical actuators then at least it won't make any API call If the coordinator is updating and there are no entities subscribed that's a bug Usually we try to only call async add entities once mypy reports an error when I try to combine that into a single list of entities to add Argument 1 to "append" of "list" has incompatible type "SleepNumberActuatorEntity"; expected "SleepNumberFirmnessEntity" Should there just be a single entity class with a 'type' variable that defines whether it's an actuator or firmness number? They seemed different enough to have separate classes I found examples of how to use NumberEntityDescription, going to use that. Please make these if blocks when a ternary spans multiple lines. Thanks It looks like we should be using sleeper.id here unique-id-requirements It looks like it shipped with sleeper.name in 2022.3 so we probably need to do a migration in a followup PR Some examples cc kbickar It looks like we should be using sleeper.id here unique-id-requirements It looks like it shipped with sleeper.name in 2022.3 so we probably need to do a migration in a followup PR Some examples Don't we want to be using sleeper.name for the displayed name of the entity? I'd think the only place we want to switch to sleeper.sleeper id is in get sleeper unique id . Yes only for the unique id. Sorry about the misfire on that. Do we need the bed.id here or is sleeper id globally unique? The sleeper id is in the same format as the bed id (19 digits preceded by a hyphen) so I'm pretty sure it's globally unique. The main reason I wanted to remove bed id is so that it's easier to detect when a unique id needs to be migrated
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
Usually we disable these by default since they tend to fill up the database and trigger frequent state updates Is sensor id globally unique? I believe it should be pretty unique. An example: lets hope
Are there only two states? Can this be a switch? No, there is a whole set of options and it can be different depending on model so can't set it fixed. Example for mine: This should probably be a select entity in that case Can you make a dynamic list for such selector? Any example somewhere? Does the list of options ever change or are they always the same for the device? If you have a diagnostics file from one with horizontalSwing it might help give better context I got one from a different PR who has a list which is completely different than mine. Actually it's also different from swing but here in the services it's free text (wonder why it's not populated from the property but maybe this selector is pretty new?) hence why I also made this free text. I will look at this select entity. As I now did a select here for horizontal swing would it make sense to make one for swing as well given it's similar or we keep ourselves to the already existing service call (even though there you can't select, you have to type the state you want)? As I now did a select here for horizontal swing would it make sense to make one for swing as well given it's similar or we keep ourselves to the already existing service call (even though there you can't select, you have to type the state you want)? We should use the built-in climate entity when possible. We should only create an additional select when the climate entity cannot represent the state. It looks like this should be checking light for the light description. You could make this all a bit more readable if you added this to the base class Do we know the current mode? It might be bit ambiguous to the user which mode this is referencing Very good comment. I added the mode to the f-string. Looks like you can drop the if and return X or []
Let's make these values constants.
We have a new enough python requirement that you could use a dataclass here instead Fixed. Please use a name other than DeviceInfo as its already used for the entity registry Fixed. This shouldn't be needed Fixed. Generally we prefer these to be their own sensors on the sensor platform. (for a followup PR) Removed. Please limit pull requests to a single platform. The smallest platform is preferred for new integraitons 5-make-your-pull-request-as-small-as-possible Removed. It doesn't look like this will ever change since there is nothing causing it to update and write state Remove remote platform for now. You can set this as self. attr device info Moved. It looks like this should be moved into a base class for the entity so it can be shared between platforms later on Great tip. Created KaleidescapeEntity file and class. You are passing update before add True but it doesn't look like an update method is implemented. Fixed. Please move code out of the try block that is not expected to raise Fixed. It looks like typing is complete or mostly complete. You should add this integration to .strict-typing in the base of the repo Done. Resulted in catching a handful of typing issues. All fixed. We don't want retries to flood the log. Additional retries will automatically downgrade to debug when the message is passed via the exeception. Fixed. Good to know. Move code that isn't expected to raise outside of the try block. Likely into an else block. Usually we don't trap broad exceptions except for when we are getting user input (we want this in async step user but not async step ssdp ). If the mac address is available, its generally preferred to set connections over identifiers Unfortunately the Kaleidescape API does not expose the mac address. This should stay in the media player.py platform since its using media player states If your library implements typing and PEP561 you can avoid the casts
strings.json 43b7ffcfc9a446cbe7389d12c6af7c84b18970a ifs af69365dbcf55e4a1ee921ba2c284dfd7a20a2a3 Please put this in a list called PLATFORMS 8b31006d58c8579f4f6addec4b4b8f3a5ab28487 This won't be needed when above comment is addressed 8b31006d58c8579f4f6addec4b4b8f3a5ab28487 check above comment 8b31006d58c8579f4f6addec4b4b8f3a5ab28487 You may be able to remove this using hass.config entries.async reload(entry.entry id) instead 1745a78bdf20cef356e2ccc5a7173f950ac75772 The async add entities logic is typically done here, not in setup platform . Please use something like this for the above method: hass.async create task( hass.config entries.flow.async init( DOMAIN, context {"source": SOURCE IMPORT}, data config ) ) I did the change but something is wrong. I have the configuration in YML and removed configuration from UI, after restart binary sensors do not work. config entities page shows the binary sensors, but their status is "restored". I didn't do this change in climate.py and these entities are working fine. Have I missed something? d2b56cd1a04482b4eb3c6b2cb0bd1afda3432288 ok, lots of testing and i'm now sure I got it right - a8d7f62ef0ee0cda611e7642b5e3645bae5ff19e Same as above a8d7f62ef0ee0cda611e7642b5e3645bae5ff19e 100 test coverage is required for config flow . Please see other integrations to see how it is done. done This should be adjusted to use issue registry . CONF GATEWAYS is a compulsory key in the schema - no need to check it here again. This file is no longer necessary. Please remove it from the PR. I think you shouldn't use the same logic in user and import steps. - async step user should show an error on failure, and prompt the user again - async step import should probably abort on failure You should set the schema to be a constant, and then maybe use add suggested values Does this change need to be in the same PR? It would be much easier to review if this was a preliminary or follow-up PR.
Please remove commented out code. Also pick one Platform for initial commit. This makes things easier to review and so increases your chances of getting this in sooner. I have removed the comments. I would prefer to get both of those platforms in at once, as having only one of them doesn't really make a lot of sense from a user perspective. But if you want I can also remove one and create a new PR as soon as this is merged. Best would be to split it in separate PR's. When the sensor PR is merged, you can create a new one for the binary sensor. This will make it easier to review and will speed up the review as well. entry.entry id should go before DATA KEY DEVICES . If only device needs to be stored, then we don't need any key at all. I also need to store data that's shared between all entries (DATA KEY INSTANCE and DATA KEY STORAGE). Those two are directly stored in the DOMAIN dict, so I moved the entries into their own dict (DATA KEY DEVICES). It doesn't seem right to store all devices in the same dict as a single client and storage instance. If these values are not expected to change, you can put this in the constructor. Device id can never change. Device name could change, but isn't really expected to change. I've moved it to the constructor for now and will add a callback called when the name is changed in the future. These look similar. Can they be normalized to a single class? See BinarySensorEntityDescription KdeConnectBatteryChargingSensor and KdeConnectBatteryLowSensor (and future sensors) would be able to share the plugin loading. I would probably still need different subclasses though, because they register different callbacks on those plugins. I don't see a way around this other than registering the callback using getattr with the function name as string, which doesn't seem clean. KdeConnectConnectedSensor also can't be combined with the others, at it doesn't even use a kde connect plugin, but registers callbacks directly with the device. For BinarySensorEntityDescription you may be able use the key attribute to do anything specific to each sensor. I have now combined the KdeConnectBatteryChargingSensor and KdeConnectBatteryLowSensor , while leaving the KdeConnectConnectedSensor separate. The first two use callbacks with the same signature, so I can use one callback for both. KdeConnectConnectedSensor uses different callbacks. I can't use lambdas for the callbacks, as they have to be async. Marking this as resolved, as I've removed the binary sensor platform from this PR and will open a new PR, once the sensor platform is merged. Do you need a separate dict for these? Or could you add them to the BinarySensorEntityDescription ? (you can extend this class, see Tuya integration for an example) Done. This is usually done with .pop Can you be more specific with the typing rather than Any ? This returns the data for the ConfigEntry, which home assistant itself types as Mappinng[str, Any] . This function is also typed as dict[str, Any] in t
The data processing is getting a bit complex here. It would be better to have all of this in the library and present everything as a dataclass to Home Assistant The drawback of that would be that any new addition of data would require both a change in the package and the integration. In terms of processing it would be the same I guess? So essentially move the processing into a data class in the package to have cleaner code here in the coordinator? I'm not against but would prefer to merge the two open PR's first and then stop new ones and do the "move" upstream. So essentially move the processing into a data class in the package to have cleaner code here in the coordinator? Yes, also the review on the Home Assistant side will be smaller each time which means PRs can move faster on this side (this is effectively optimizing for the reviewer resource scarcity on the Home Assistant side) And since its a dataclass, it can be typed and less likely to make mistakes. I'm not against but would prefer to merge the two open PR's first and then stop new ones and do the "move" upstream. WFM
Question for reviewers: How long should I wait before removing the deprecated services? I looked through the developer docs but didn't see any guidelines for how long the deprecation period should be. I'm not a member but I can tell you with certainty that the deprecation period is at least 2 release cycles. This can be rewritten as a generator. async add entities can accept that. I'm not familiar with generators. Can you show me what this would look like? I looked but I couldn't find another integration using generators for async add entities to use as an example. Thanks, added. Type hints? For a future PR, could client be made an attribute of coordinator ? Added type hints for init . For a future PR, could client be made an attribute of coordinator ? I don't see why not. I'll try to add this in a future PR. Generally we don't want to pass around the entity. Please pass the needed objects instead Please limit exceptions to a tuple of expected exceptions instead of a broad exception catch Does the api know the state of the engine hazard lights charging? No to the engine and hazard lights, but yes to the charging (I have a binary sensor for it in my binary sensors PR: Charging should be a switch in that case OK, I removed the start charging and stop charging button entities from this PR, and removed the charging binary sensor from the binary sensor PR. I will open a separate PR to implement the switch platform with a charging switch. Please update the opening text of the PR to reflect the changes. Thanks Updated. This could also be a constant if you need to use it in other places Ok, I'll keep that in mind.
The media is actually played by HA in a separate thread and streamed directly to the UniFi Protect camera using ffmpeg. The cameras cannot actually play media. They just have a UDP server running that you can send audio packets to. So, the URL should be one that HA can resolve internally. It does not look like async process play media url makes it an external URL, but that is something to keep in mind. If it is a local path, that is actually preferred so it does not try to stream it through HA and just reads it from disk. this turns relative URLs into full URLs and adds authentication. If it's not necessary, we can skip it. Yeah, it should not be necessary since ffmpeg is ran directly on HA. The relative URLs are still URLs, they are not local paths. Would that still be ok? Note that media sources can resolve to a relative URL, but also to a full URL. Well, how to do differentate between a relative URL and a file path? If they both start with , you would not be able to tell the difference. I guess you would Path().exists() it. If it is a file on disk pass it into pyunifiprotect directly, if it does not, convert it to a hass URL. that's not how media source works, it always resolves to a URL. But it may not always be a media source. If the user enters the value manually without the media browser it could be a file path. ok I will apply this only when resolving media sources. If it can be a local path, the path needs to be checked that it's allowed to be streamed from using hass.core.is allowed path
Should we add a HA logo as icon ? Or I guess the UI will fallback on the integration brand logo if no icon is set. Yeah, the idea is to have the frontend get from brands repo for the domain when no icon url is defined.
We shouldn't get here if the entry is None . We should assert that self.entry is not None instead Correct but this was purely to make mypy happy. So asserting should be fine. We still need to validate the username is the same Good catch! Completely missed that it could of course be a different account.
Can we remove the data schema as there's no user data input needed? Currently not. It's typed as required. Ok, we should fix the typing and make it optional here: L411
We don't want this support just for databases. If we're making a backup, maybe we also want to prevent other changes being made. I think that this could be it's own helper and we let the recorder subscribe with that helper for when we go into "making backup mode" okey Reopened the PR. If the backup integration would emit an event the recorder integration can subscribe to for locking the DB, the lock would take place too late. We need to ensure that we lock before we start backing up. It doesn't have to be an event, it can just have the recorder place a callback that the helper stores in hass.data["HELPER BACKUP"] OK.
I tend to prefer all values inside the condition rather than presetting. But it's just my personal preference. The condition itself is useless, so it would become an else in that case. Which... should not be needed.
Now there will be multiple places to set the name - edit config entry and edit entity. That might be confusing? It will inherit, but can still be overridden. I think this pattern is very helpful actually (and used in more places nowadays). This mainly works is helpful on config entries that have a single device or service.
What is going to call async modbus setup for a second time? If you want async setup to be called a second time, you need to define async reset platform L77-L82 Corrected, and also did a lot of searching debugging in core. I hope it is to your liking now. We are phasing out the use of bind hass because it breaks typing.
Please revert this line to fix the spelling error. Please add the type hint back here. Not sure why double underscore prefix is needed. I think single underscore is ok here. This seems to have been reverted to a much older version that doesn't include the async add executor job . Please use the current code for scanning com ports. I think this might be causing the circular import. Normal procedure is to create the shared constants in const.py then import those elsewhere. I don't think we should import consts from other files back into const.py Please reinstate the type hints Is there a reason for moving these here rather than leaving them defined in init ? Connection class is defined in the manifest now, so this line can be deleted. Please add the type hints Please add type hints
This annoyed me a bit previously too, good idea to use api as a prefix This is a bit interesting: img width "1427" alt "bild" src "" Why is the device called "Vallox Post Heater"? Hmm. I just re-tried with a completely clean setup, and there everything looks as expected: ![image]( I wonder what is different on your side. Did you try it on top of an existing configuration? Ah wait. The second time I started it, I can see this too now. I'll investigate. I fail to reliably reproduce this. I've seen it once so far, but haven't discovered a pattern yet... Converting to draft again for the time being. Now I got it from a clean setup as well. Something looks racy Okay, now it occured to me. device info should never have used attr name for constructing DeviceInfo.name in the first place, because this attribute obviously changes in the course of entity init. Seems like device info sometimes was called before the topmost child class's init was running, fooling me that my code was correct. Ah, that makes sense (not sure if a linter would like to have this divided on two lines, but I think this would make more sense). What are situations where model is not an instance of string? How and when can this happen? It can t, but mypy seems to not take the 3rd party library type hints into account, so I needed to add this to satisfy it. In that case you should not check for isinstance , but use cast() . Or even better, adhere to PEP0484 in your package. ( I faced the same issue and in my case adding a py.typed file to my package source did the trick. Please use cast() or adhere to if you only use str() for typing purposes. self. device uuid is type UUID , so str() is needed here, right? Please use cast() or adhere to if you only use str() for typing purposes. What would it be other than a string? If its None , its much faster to check if its is None than an isinstance. Set this as self. attr device info instead. You can add the configuration url later instead of setting it to None Could you elaborate please? I think when I wrote this, the thing with config url being None was just to dance around mypy. bdraco was it something like this you had in mind? Seems to work locally for me at least, no complaints from mypy, and tests are passing. You can drop and slovdahl could you send a PR against my branch? slovdahl could you send a PR against my branch? Sure Thanks, merged bdraco is this resolved now? Please use the constant homeassistant const.py:ATTR CONFIGURATION URL: Final "configuration url" Done What would it be other than a string? If its None , its much faster to check if its is None than an isinstance. The third party library which we call into here isn t covered by mypy, so it was needed to check for string to make it happy here. If it always returns a string please use cast since we know it and don't have to check Done
Is this really needed? I mean, you're catching the exception and raising it again without doing anything with the exception... Yes, else it is caught by the one below... Ah yes, I didn't realize that the next block caught all exceptions. Can we clarify in the doc string of this StopScript what is different (intention cause) Fixes in [fa9d55b](
This could be a separate fixture used here and in setup platform in conftest.py Was it possible for the username to not be lowercased since we get it from the config entry? The user input[CONF USERNAME] allows mixed case (used in the description as well) but the unique id is consistently being set to lower case in the other config flow steps We shouldn't create a new entry in a reauth flow Looking at other integration, I'd say about 90 of them will create a new entry if it doesn't exist. Is there an error that can be thrown instead? You could do something like this for the case where the config entry is deleted in the middle of the reauth flow, and add a new string You could do this instead and avoid all the need to fetch it in the next step Usually we try to keep the patch target as narrow as possible. We need to patch the integration setup function here to avoid setting up the whole integration.
It's ok to log an error or warning here before aborting. Thanks, added an error Can you walrus notation here if error : await try connection(self.hass, user input): Done The "is None" could even be removed too, just swap it to be set errors["base"] error if there's an error else return the entry Done
Seems like both YAML and UI configs are supported. I think the best practice is to migrate to UI if you find a YAML config. Searching the code base for async step import would give you some examples. Is there a way to validate the port? Why is only one instance supported? Can't you have multiple instances on multiple ports?
It would be nice to have a test case that has actual data here.
I do t fully remember how an optional multiselect works. Can we get back to the non set device default mode in any way now? If you deselect all protocols i suspect it will be an empty list rather that none? Yes, it will be an empty list rather than none, but that is handled when passing the modes to the library. An empty list will be swapped out for None so that the library handles it correctly. I actually swapped out the impl now, so it will change [] - None if it comes back from the form, but you can still set an empty array in the yaml config if you really want to use no protocols, just to close down the edge case. user input will always contain the key. No need for get() Thanks. This is my first foray into HA development, learning voluptuous and lovelace has been fun, it's a very slick framework. We generally try to match the test x name with the main file it tests. So i think it make more sense to put this in test init.py Gotta be clean :) Done. We need to set up the config entry before starting the options flow to ensure that the config flow module is loaded. We can use hass.config entries.async setup and patch the integration setup function to avoid setting up the whole integration. This one went over my head a little, I found this snippet that seemed to match what you were saying but I'm not confident its what you meant, and I had no idea what to mock: diff-d9567f97b73c8bfe62c139ec37b850baee0ea9db0b3cd2028559b46a809b74b1R334 I'll let you comment further in the new PR. There are plenty of other places in that file that don't have this snippet, do they all need them? We can move this up out of the patch context manager. diff-8330b0a7abb34e55d74b728522a45c9ba5546111542c82d8b4b4a3b106355dc4L134 diff-8330b0a7abb34e55d74b728522a45c9ba5546111542c82d8b4b4a3b106355dc4L148
I think we should change the name of this function and or docstring to reflect that it requires the Supervisor. I think that we can apply this fix just to async process play media url and don't need to update get url . Are add-ons not capable of resolving the IP address of the host and connect to it? It depends on what the internal URL is. If the url they are given is homeassistant.local or the hostname of HA then yea we shouldn't have to do anything special. This is one of the benefits of my recent change to how MDNS works in plugin-dns . The system resolver gives us back all the answers it knows for a given domain so when asked about homeassistant.local it returns a response like this: ![image]( I changed it so in the response plugin-dns orders the answers like this: 1) Answer in the 172.30.32.0 23 subnet (if there is one) 2) Answer associated with the primary interface of the host 3) Any others in the order received from resolver So basically - yea if the internal url is homeassistant.local it just works. But for any users that changed the internal URL to something else it won't. The only answer we'll have is whatever eth0 (or whatever the primary interface is) sees. Which will resolve to a LAN IP. This change makes it so no matter the internal URL is its possible to get back a URL which stays within the docker network if the integration plans to hand it to something managed by supervisor. If we know we want the internal url, we don't need to pass an "give us docker url" boolean to get url to force it to return us the docker url. So it could be: Is this just for URLs or anything routed via the supervisor ? I'm not aware of a use case for anything other then an addon using this helper but I suppose it could be for anything managed by supervisor. I'm not sure we have a name for "generic thing managed by supervisor" though. supervisor component url ? docker container url ? It might be not just add-ons, anything behind the supervisor could be targeted, including plugins or the supervisor itself. (although unlikely for media player) Same naming problem I mentioned in the other comment. If we settle on a name for "generic thing managed by supervisor" I'll update both to use it. I think that we should make this a helper to create this URL. No need to cast to string inside string interpolation. If I recall correctly, an add-on talking to HA via the supervisor automatically have authentication attached. In that case we don't need to sign the path above. I'm not actually returning the url for supervisor here, I'm returning the hostname of HA. I know that usually addons talk to HA via supervisor but I can't do that in this case. Because for an addon to talk to HA via supervisor it has to include the SUPERVISOR TOKEN we gave it in the header and I can't tell it to do that here, I can only give it a URL. So I have to give it (or whatever the hostname and port is). That's also why this logic is skipped if ssl is turned on since I assume the certificate won'
Supported features are not meant to be dynamic For context, this will break everything that reads it at startup (such as voice assistants)
Could we await the self. try command() with the name directly instead of creating those separate coroutines below? Plenty of other devices will also have buttons in the future, so it would be better to avoid as much boilerplate as possible. Take care and stay safe, Kirmas! Take care and stay safe, Kirmas! rytilahti Thank you. What you do now to help me finishing this devices integration, it s very important for me. Could we await the self. try command() with the name directly instead of creating those separate coroutines below? Plenty of other devices will also have buttons in the future, so it would be better to avoid as much boilerplate as possible. I refactored code, a little bit. As for me I do some "black python magic", but this is worked, I checked. (Reset the filter at home) Thanks for working on this, I'll try to convert the vacuum to use this later, and perform clean-ups as I see necessary. Having a base to work on makes it much easier for me to do that :-) This is not used anywhere in this file, remove? Was old part. I removed. It'd be great to have this to be the method in python-miio as I mentioned in another comment. This will make it much easier to add support for new button actions. I don't think it's worth creating temporary variables for these, but rather use the values directly inside MODEL TO BUTTON MAP . Is this required? If not for now, I'd remove this to keep it simple for now. This isn't used. Please move the definitions that we don't need until later down after the check of MODEL TO BUTTON MAP .
Let's define this as a namedtuple to make it more readable, maybe something like this? I'm unsure about naming of the elements, but you'll get the idea :-) Use named attribute access for the value here. See my comment above for namedtuples. Same as above. The file should end with a newline. Let's avoid importing anything from python-miio here, and simply create some dummy enums that fulfill the same purpose. My personal opinion is that the tests should verify that XiaomiGenericSelector and relevant pieces work in select.py , no matter which device is exposing those. But I'll take another look at the test code soon, I just wanted to give you some quick comments asap. rytilahti I dont really understand how to do this with out import Dummy device. (Maybe only ones?) Because I need coordinator to check handle coordinator update function. And other milo interfaces. Maybe if I remove airhumidifier miot , test airfresh t2017 and use only airhumidifier class it will be enough? rytilahti Tests was updated. Could you look at please. I don't really like having a different name for miot and regular brightness. Can we avoid that and simply use led brightness everywhere? Main reason why we have miot because LedBrightness enum has different ordering for miot airhumidifier miot: airpurifier: if python has some way to construct enum element self. enum class(self. options map[attr value]), by key, say me, and I remove this options map related things. I don t like it :( Hi rytilahti. Was avoided by using enum class. member map instead predefined options map. options map now using if we want to change enum key to something more readable. Is this ok? Set up the integration instead and let it add an entity. Patch the library appropriately to avoid I O. Then assert the state of the entity in the state machine hass.states and call services and assert mock calls to the patched library. writing-tests-for-integrations Hi, MartinHjelmare Thank you for feedback. I m not very familiar with python. And now I know about patching in the tests, because of this PR. :). Could you looking in and told if now this is OK. We shouldn't define any entity descriptions in the test. We have already defined entity descriptions in the select platform. We should just set up the integration while patching the library as needed and let the integration set up the select platform and add an entity. Then assert the entity state in the state machine and call services via the service registry. : 1: We want to have the complete code path from description definitions to initializing the entities to calling the defined setters tested. I think it would be fine to make the tests against a single select on a single model to verify that the code path works throughout the chain. The idea of using a dummy device instead of targeting a specific implementation for testing came from me, as I'm currently working on making the backend library deliver the necessary information about available settings, sensors etc.
We shouldn't create this in init since its not always used I had no idea! I'll move it into a class variable I guess This matcher looks a bit generic This is supposed to be a draft review :) ... but we can talk about it regardless. I don't have specific information from the manufacture on any mac address matching - mostly - the thread listed above some folks in the community posted their host name... and i then searched to make sure there wasnt any other Zentrios mentioned anywhere else in HA. The only other thing I can do is go back and ask people to post their mac addresses - but I wasn't sure if they would be happy to do so. I'd expect they are all starting with Unfortunately a discovery in this case likely means they (the device vendor) just selected zentri as their IoT vendor, and its not likely to be a fireplace since other vendors use their tech. That is probably ok as long as the probing isn't too cpu intensive or expensive. I think you can create it here instead Changes would be made in: - as this supposed to follow :) You could use a dict[str, str] here Or you could make it self. discovered host: tuple[str,str] None None since in this case you only expect one You could also use a namedtuple or a dataclass (preferred) This is going to setup the first discovered one (you can only return once). We should only setup the one that was discovered. Clarify: there is no need for a loop here. We should set title placeholders here and flow title in strings.json I think I follow but you may need to look this one over again. I took a look at what they did in flux led img width "559" alt "image" src "" - nothing broke but I don't see anything different also went with: For the placeholder - from reading the docs its supposed to only render I guess if the host thing is set? (If i did this correctly feel free to resolve it ... i left it open in case there is more discussion) Maybe change this to a question? 'Do you want to set up {host}?' Happy to do so - I was thinking about your earlier "Manual IP address Selection" "IP ADDRESS" because it was easier to translate... I'd much prefer to do something like this ... also I need to do a local test on the last changes to verify stuff I updated the description with the new image... but it looks like stuff is working on my end - resolving this one. Set this in the dhcp step before moving to the dhcp confirm step so they aren't offered it if its already set up. Please add a test for this case as well Please assert the reason for abort Please use a more descriptive name. Please use a more descriptive name Please call self. set confirm only() I would probably set this instead of appending it to make it clear it's the only one Maybe drop the s and not make this a list since you only store one at a time This string is missing from strings.json
bieniu Now this is ok?
You can drop State , it's an entity in the state machine after all.
Given the description of this PR, this should not be an attribute. This should be a binary sensor. That was my initial thought, actually, then I changed my mind when I saw the existing "latest commit" sensor. I can change it, if that would fit better with what's already there. : 1: OK, so there are no binary sensors in this component yet, so adding one will be a little more involved (I'm very new here!). I'll add it and get back to you though : 1: Yeah, that would be a new platform for this integration, but that is where this type of information belongs, so we should do it right when introducing new data points : 1: the alternative is tacking it on here now, and then have a breaking change later, which is not good. Had some more time to check it out, this can actually have 5 different states, so a sensor is actually correct here. I assumed it only failed success But it should be a dedicated entity, not an attribute The more I look at it, the more I actually think attribute is OK, it is actually describing the main state of this entity. :thinking: What do you think timmo001 ? OK, I'll take it out of draft then! Still trying to find time to tick off the checklists, but if the workflow could be run, that would probably cover at least some of it. I think there are 2 different things. 1) Build status of the main branch 2) Build status of a commit. As the commit sensor is representing the first, I think the build status sensor should do the same and can thus be shown as a separate sensor. ![CleanShot 2022-02-22 at 15 01 47]( It is a very interesting data point to show on a dashboard or automate on, for that reason, if one would automate on it, the general rule of thumb is: do not stash it in an attribute. Also, when exposed as its own sensor, we can provide translations for the statuses as well. So for home-assistant core, this does not have a state, same with home-assistant frontend, as this section does not include actions, of the 10 repos I tested, the only time this have a state is for codecov r812184527 takes care of that, now I'm with frenck again regarding dedicated entity :smile: this also includes actions
We generally don't mix polling and coordinators in the same integration. Please make a second coordinator that updates every 5 minutes for here. Ok...not sure it's better, but I changed it It would be nice if the library was typed and followed It would be cleaner to make a dataclass to store this. Example: L13 Looks like an unrelated change snuck in Whoops If the api won't reject it, you could use asyncio.gather here It's confusing to name this entity class coordinator. Please replace that word with something else or add Entity to the end.
This if-guard is not necessary if stations is an empty list Ah right, the previous library was able to return None, this one handle that. Can be removed. Thanks! don't we already have a user agent in our default websession ? Yes, but as the API requires a custom user agent to be set (usage requirement), I've enforced the library require it on init as well for that reason (in case others start using the library).
Please use constants instead of magic strings Store this as self..... and move to a async step reauth confirm step since if they reenter this the context won't be set. We should abort if they change accounts by entering the wrong api key This is a bit tricky as if the api key becomes invalid because the user removes it and comes here to enter a new api key I would not know if it's for same account or for a different account. I can only assume it's for same account. As you see in the data schema there is only the api key and no username or such. Unrelated to this PR, but I noticed when looking for a better unique id that the api returns the mac address of the unit so it would be nice to add it under connections in a future PR: device-properties fetch("", { "headers": { "accept": " ", "accept-language": "en-US,en;q 0.9", "sec-fetch-dest": "empty", "sec-fetch-mode": "cors", "sec-fetch-site": "same-origin", "sec-gpc": "1" }, "referrer": "", "referrerPolicy": "strict-origin-when-cross-origin", "body": null, "method": "GET", "mode": "cors", "credentials": "include" }); Assuming the username isn't changeable... You could call the api v1 users me endpoint to get the username for the api token. You'd have to add it the config entry data as well if its missing so when we do need to do reauth we have something to compare against. Good call. I will make two PR's for this purpose. One to bump the package to support the new endpoint to get that info and another one to migrate the config entry to use username instead.
This sounds incorrect. This basically squeezes a device into an entity with a bunch of attributes; While Home Assistant has a device construct. Shouldn't this be a device in Home Assistant with multiple entities instead?
This will raise asyncio.TimeoutError which does not have a message, so you need to handle this inside a try except block with a custom message passed to UpdateFailed Even if you have a PAT configured, that does not mean that the PAT (your user) have access to work items for the org project that is configured. I do not see how that is handled here, is that done in the lib and it just returns None when you don't have access to the resource? Should this even be in the same coordinator? It provides separate data from builds, and does not use build information. The great thing about splitting coordinators is that if all entities that use a coordinator is disabled, the coordinator will not call the API to update the data as there is no need for it. Unresolved this conversation Wouldn't this work? We should not define lambdas that span over multiple lines, create a helper function that you pass instead Why does this exist? There is a dedicated sensor class for Build, I would have expected this to just be defined there. Why does this exist? There is a dedicated sensor class for Work items, I would have expected this to just be defined there.
This could be written as a comprehension How would I do that when I have two for where one is in the other one? Can you make a comprehension inside another one? r810533305 If they can t set the value these should be sensors instead. I would probably disable the entities by default as most people probably won t use them It is possible to set the offset via Sensibo API, I suggest we implement the set value. Try to use home.sensibo.com with chrome developer tools and you can see the control message the valid range and the response. If needed I can help adding the offset command to the PyPI package, send me a message on discord It's not documented you can set these values but I'm pretty sure it's there somewhere. These entities are disabled by default. You could make this a constant Good idea. Will do so in this PR Maybe make a function to generate this in a mixin class or additional base class Would probably be a good idea to make a entity base class (as more platforms would come) but I suggest to make that in a follow-up PR. Not mandatory, but I think it is more readable like this Agree, will change Last comment, according to unique-id unique id should be formatted as {unique id}-{sensor type} . bdraco is this correct? should it changed to f"{device id}-{entity description.key}" ? I have seen everything from space, comma, dash etc. Happy to confirm to "-" if that's what the documentation provides as example. Let's see what bdraco has to say, just to be aligned with recommended guidelines as changing this later is complicated - is preferred in new code. There isn't much value in changing existing code though as it carries the risk of migration. This code looks very similar to async set ac state property in climate.py . In a future PR it would be good to make it a bit more DRY (maybe add a base class for them to share) and reuse your new exception constant there. As also more service calls will be added that sounds like a good idea. Probably will make it when I'm going to make a base class for the entities. But then this PR needs to go in first.
Very smart, very unreadable This does something similar, returns a timedelta instead. L424 This has been there since the [very first sonos commit]( diff-e3102b464276703e90884c4b464313af1e28fbd41e4e56d7215714311db969f2R106-R107) Never a bad time to improve readability, done in No need for string interpolation. Isn't this a very generic signal? DOes this mean that all Sonos speakers update whenever this fires? The signal carries a speaker UID as the payload. Each media player checks to see if its own UID or its coordinator's matches. Can't we just subscribe to this coordinator instead of listening to a dispatcher signal?
This would be more readable if it was not a multiline ternary. Right, removed the ternary.
It would be better to use NumberEntityDescription s instead. It would allow you to reduce this to a single class. Like this? Still three classes... ( ToloNumberEntityDescriptionBase , ToloNumberEntityDescription and ToloNumberEntity ). Got some inspiration how to do this from goodwe integration, never worked with EntityDescription before. Will also consider that for other parts of the tolo integration if you approve the way I did it here. To prevent questions: There will come a fourth number entity, which has a different unit of measurement ( hours ) and max value ( 8 ) which I couldn't test yet. Therefore, these values are not set in the ToloNumberEntityDescription class. You are getting here! Nice! Maybe move this tuple into a constant If I make it a top level constant, coordinator is not defined anymore and I would have to introduce lambda expressions, which IMHO is much harder readable as the current version. I could also make it a local constant in async setup entry method, which (again, IMHO) does not really increase readability compared with current version. Which way would you prefer? We currently prefer lambda's (search value fn for examples) Done. async add entities accepts a generator :) Shouldn't it return None when the value is unknown? self.coordinator.data.settings None means disabled, not unknown. After a chat in Discord with some devs, they suggested to use the 0 of the number entity for disabling a timeout instead of having a complete seperate switch entity for that. Therefore: It's correct the way it currently is. The complete situation: The actual TOLO hardware returns its timer configuration in a single unsigned byte per timer, representing the actual value of the timer setting. Each timer can also be disabled, for some timers the special value is 255, for some 61 (don't ask me why please...). The tololib package unifies that by using None for disabling the timeout and the actual integer value (with a range validation) for the value. This also implies: If a timeout is disabled, the numeric timeout value is lost - which looks strange in Home Assistant if you have e.g. a switch for enabling disabling and a number element for the timeout value. Disabling the timeout would set the special value (e.g. 61) on the device, the previous timeout is lost. Re-enabling would then require either to use a default value (which seems strange to the user that disabling enabling changes the timeout value) or to store the timeout value somewhere - where two elements (number and switch) can access it. I discussed that in Discord with other devs and the idea was to just just number, without switch, and treat the 0 as disable value. Then, if the user disables the timeout, he changes the number element by himself and is not changed by strange magic without touching it... For any suggestion how I can solve that even better, I'm open for ideas (here or in Discord). Otherwise, for now, I would just leave it that way. self.coordinator.data.settings None
There is no need to store the entry data, as the platform also gets the entry in its setup. done Use: hass.config entries.async setup platforms(entry, PLATFORMS) instead is Platform.SENSOR (from homeassistant.const import Platform) correct? Unresolved this one, as it has not been resolved. So Platform.SENSOR is wrong? Where do I get the constant PLATFORMS? Instead of asking for a string as a serial port, we should make it a dropdown, so a user can just pick a serial port from a list. The configuration flow of ZHA might be a good example for this one. It is also possible to use a ser2net socket (which you can't pick from a list) instead of a serial port. In that case, I would recommend creating a multi-step configuration flow so both those cases can be handled. I understand. So lets keep this PR small and simple and extend improve this in an other PR? I would opt to add that now, it would add roughly 50-100 lines of code, which is manageable imho. now I added listing of serial ports as radio buttons. done errors removed Missing typing, and doc block Why is this: done Which errors? I don;t see any validation or errors created in the above code? errors removed What does this do? removed - What if this fails? - This is best moved into the init .py file. Please don't add other languages, only English ( strings.json and en.json ) others can later be translated via the Lokalise translation platform. Please create at least one test, that tests the full configuration flow. Additionally, also assert test the flow results (the actual data). checks added Shouldn't we first unload the plaform (and thus their entities) before we disconnect? This cannot work, the second parameter must be an iteratable? - This be validated before we create an entry - Missing doc string
Let's change the flow slightly such that: - If not in safe mode: Not being able to read SSL cert will trigger safe mode - In Safe mode: use a temporary cert if we can't read the SSL cert img width "869" alt "Screen Shot 2022-02-18 at 15 01 26" src "" I had imagined we would rely on triggering a safe mode via the logic in bootstrap: L148-L152 It is automatically activated if frontend fails to load, which as a dependency on http . So if the http integration fails to set up, safe mode is activated. So something like, force failure if ssl can't be created, but once safe mode is passed in to the config, create the self signed and startup ? That gets a bit messy because of the delayed start of http... will take a shot at it I think that we should remove the delayed start of HTTP. Frontend will be loaded almost right away anyway. Or maybe we create the context inside async setup and do the full start when frontend is registered? Hmmm. the webserver is up and running and it started up in safe mode but I can't do anything to recover as this is all I get img width "887" alt "Screen Shot 2022-02-18 at 16 06 12" src "" So if http fails All the deps fail and then we don't try again . Well I got it up and running but all the apis don't work since they aren't being loaded again Preserving DATA LOGGING fixed that img width "924" alt "Screen Shot 2022-02-18 at 16 41 49" src "" (this requires updating the test too) 4b796c9515

We do not allow relative times to be stored in the state machine. Instead, make it a device class TIMESTAMP and store all the time it went online. Internally I modified this to: And it looks like: img width "253" alt "image" src "" Is there a way to get rid of the In ? I'm using: from homeassistant.util.dt import utcnow as my import Switching to: tweaks the output but its still not really what I'm looking for. img width "268" alt "image" src "" Is there a way to say have uptime read: 35 minutes instead of in or for I'll fiddle around and update this comment if I learn anything I think I can work with 8 minutes ago if there isn't a for option. Looking over the other integrations except for UPNP: img width "394" alt "image" src "" which seems to use raw seconds - seems most other integrations are going with: Same. I attempted to put this into a timestamp - but it looks bad and I'll remove it unless ya'll have a fix. Because the sensor value updates every 15 seconds or so the "downtime" seems to "tick" from img width "244" alt "image" src "" to img width "262" alt "image" src "" and then resets back to "now". I also tried dropping a None in when the value was 0 which didn't seem to fix stuff. Connection quality is super spammy, make sure you disable this by default. Remove this one. It is way too long and doesn't add value? Users can see it in their app if they need it. We need multiple lines for lambda, we generally extract it into a separate method (to keep things readable).

Should this be a URL( changelog url )? or MD formatted string( changelog )? or both ( changelog url and changelog )? Maybe both? Being able to provide an excerpt as a string (e.g., containing Markdown) and a link to a full log release details? Can we move this logic into the UpdateData class? And then also do store initialization there. That way there is a single class responsible for the store data. this should just move to the integration init and trigger on stop final write event. I would just do a delay save with 60 seconds. If someone is ignoring things, it's a few in a row. I still prefer if the code for loading keeping it in memory mutating writing data is contained in a single class. Makes it easy to reason about and you don't need to look across different files how data is mutated. okey, I'll move all logic to a manager class like with the backup integration Should we add make backup an option here so we're compatible with todays infra? todays infra? Sorry, today's update button in the frontend. What does it matter, it's completely different? The domain here is update , the action you perform is an update . From your PR description: the hassio integration will migrate to this as well I was under the impression that all updates provided by the supervisor (core, OS, supervisor, add-ons) would be made available by the hassio integration but maybe that's not what you meant. it will. xxxx integrations will have an update platfom and the frontend will call the update integration with an update command to update a single item provided by xxxx If we want the hassio integration to keep having the make backup option for the core update, shouldn't we then allow specifying that backups are supported and the update command should accept a make backup boolean? AH! Now it makes sense! Yes, I need to add something for that. I think we should make a helper similar to the diagnostics integration instead, which doesn't access hass.data directly in the tests: L19-L22 I will exclude this and the scaffold logic from this PR. Let's postpone loading until we need it. Why do we store gathered updates in memory? Shouldn't we just gather those on the fly, and leave it up to the integration to decide how long to cache it ? Let's raise for passing in invalid update. We don't really have to store this, do we ? We could just call a method on the update platform to update? let's put this in a finally to make sure that it's always removed, even if an exception happens. let's raise. Why not store platform ? Also please define a Protocol to type the platform. Example: L49-L60 Does this work? Is self. updating used somewhere to check what's in progress? It was, but most of what I had is gone.

Fixed in new commit What does this do? And is there a reason you need this in YAML, instead of having this configurable via the OptionsFlow. I have "stolen" this code from the developer of the Azure EventHub integration. The current config flow does not support this kind of input, so the filter will still need to be applied via YAML. Don't set this before you verify if the connection is correct. Fixed in new commit Don't you have more specific exceptions to catch? What happens if someone uses the wrong credentials? (in that case we don't want to retry via ConfigEntryNotReady). Added more specific exeptions in new commit Fixed in new commit Why is this required? Fixed in new commit Normally this is handled by HA, where you can set azure to a lower higher value. Without your change, does it flood the log? Yes. the SDK used is VERY chatty, so I needed to shut it a bit down You don't need to pop, you can just assign. Either here you can do a setdefault , or you need to a test for DOMAIN in hass.data in line 78, that might fail otherwise. I would do another empty setdefault (with just the filter at the top of this method, before creating the ADX object, and then you can just assign. the pylint warning shouldn't be necessary anymore No update to the max delay? for Event Hub the whole max delay was decided to just be a default value that makes sense, rather than an option, you could consider the same, the goal is to minimize the work needed to set things up. Not needed The goal of the dropped value is to let the user know that several message have been dropped and that he she should filter more or send more often, not to check if the event is valid! This should probably be if adx event is not None: This moves out of the while loop adx event is already a string, and with a filter or None this str is not needed Might be a bit nicer, if maybe slower to create a list, add all events to the list and then do one transform from list to string below. Why a lambda func here? Not any more specific exceptions that will tell you that something is wrong and has retry logic, now this just results in lost messages? This should be dropped 1, and what does an empty string mean? and what kinds of errors could be possible here, no way to catch those more specifically?
Note to self: check if this is async safe The load auth function just sets variables, it does not contain any blocking code Existing but since it's changed, please move this into an else block since it's not excepted to throw any of the exceptions You could use the walrus operator here and save a line You could save a line using the walrus operator The trends coordinator update method should also needs to be wrapped so it raises ConfigEntryAuthFailed from (SenseAuthenticationException, SenseMFARequiredException) I'm not too familiar with how the coordinator calls the update method - is there something that will handle the ConfigEntryAuthFailed exception? Since Home Assistant has both async and sync code in it we usually prefix async function with async Unrelated to this PR, but we shouldn't ask for a timeout in the config flow. It should be moved to the options flow, or as developers we should choose a sensible option that works. Normally we put the message in the exception argument. It will be logged as a warning by the config entry. We don't need to call super.
errors is always an empty dict , right? Wouldn't it be nice to show an error to the user when the station id is invalid instead of aborting right away? Yes, that's right..how could i forgot.. config is now showing abort reason The coordinator already has an update interval, I don't think it's the idea to update it from here as well as then the interval is not controlled from a single place. thanks for the hint! removed update Here as well, update shouldn't be initiated from the sensor. By the way, if self.coordinator.data is a dict , then the update means something different: dict.update thanks again for the hint! removed update Done. Please add type hints Done Please add type hints Perhaps this should be in a different PR as the title suggests we are just adding a config flow here. I agree, its also redundant information of this station id . the station id is already in the attributes of every sensor This can be put in the constructor. Done This can be put in the constructor. Done You can have entry as an attribute of coordinator . This can eliminate the extra argument. Make a separate class for coordinator in coordinator.py . I am not sure how to implement your suggestion.. maybe you can help out currently it's not nice with the extra argument, but it's working ;-) Please remove commented-out code. This is already handled in the Entity base class. It's everyone's ZAMG, isn't it? These are already handled by the base class attr -attribute.
If these are just for debugging, why not log them at debug level instead? I think our state machine is not the correct place to store debug information in. Additionally, one could implement the diagnostics platform for debugging purposes. Currently it's only for debugging but just as with vicare modes we will need this data to check which presets the device actually supports. A dedicated PR will follow soon but right now I'm still collecting data from users to understand how to deal the mapping from hvac presets to vicare programs. I could still remove it from the attributes if you have hard feelings about that. I think they should be removed, the state machine is not for storing debug data.
All these sensors are using "Power" in their name description, but are actually Energy sensors (and thus not Power). Isn't this sensor a moving window? As in, every day, the last 7 days would shift, right? I cannot answer that since the sensor is not provided by my device. Styx85 or killer0071234 can you answer that? Does this sensor cover the last 7 days or is it more like the current week? oischinger Hi for my Device "Vitovalor PT 2" it is the current week (mo-su). I just did a Screenshot in the app to reassure how it is reported. ![Screenshot 2022-04-26-20-40-40-996 com viessmann vicare]( oischinger As I mentioned here the Viessmann app seems to use three different api calls reportings and does the rest as internal calculation. If it helps to clarify what is reported. Can you show a screenhot of the "days"-section? does it show the last seven days or monday-Today? It shows the last seven days and additionaly the current day. ![Screenshot 2022-04-26-21-14-55-433 com viessmann vicare]( I wonder if this sensor is actually useful in context of home assistant where you would rather use e.g. the consumption year. Either we remove it or we remove the SensorStateClass.TOTAL INCREASING IMHO, you need only 1 total increasing for the energy dashboard. It doesn't matter much which one. I wonder if this sensor is actually useful in context of home assistant where you would rather use e.g. the consumption year. Either we remove it or we remove the SensorStateClass.TOTAL INCREASING I wonder if this sensor is actually useful in context of home assistant where you would rather use e.g. the consumption year. Not for the energy dashboard or long-term statistics, however, some people like to display them on their Dashboards Correct, some like to reproduce the app display in ha as well. Anyhow. With these changes the Vitovalor still is missing the total gas consumption. Or am i missing something? I had a look at the api und the readout I posted in pyvicare repo this morning again. We have 5 different api options for gas consumption values with the Vitovalor PT2: "feature": "heating.gas.consumption.heating": this api call reports the gas consumption for gas burner heating gas consumption separated by day, week, month and year "feature": "heating.gas.consumption.dhw": this api call reports the gas consumption for domestic hot water heating gas consumption separated by day, week, month and year "feature": "heating.gas.consumption.summary.heating": this api call reports the gas consumption summary for gas burner heating gas consumption separated by day, week, month and year and additionally for last month and year as well as floating for last 7 days "feature": "heating.gas.consumption.summary.dhw": this api call reports the gas consumption summary for domestic hot water heating gas consumption separated by day, week, month and year and additionally for last month and year as well as floating for last 7 days "feature": "heating.gas.consumption.total": this api call rep
These will disappear one rebase. Its just out of sync with dev because of the dep chain These will disappear one rebase. Its just out of sync with dev because of the dep chain These will disappear one rebase. Its just out of sync with dev because of the dep chain
There should be self.hass I've dropped configuration of source IDs completely now, so this block of code is gone. We shouldn't use Entity objects for anything but providing states. It doesn't look like it's used for that here. Ah, this is not a Home Assistant entity object. Can you rename the class. I was confused because the called functions have same names as normal entities. I can see how that's confusing. I've renamed it now. For background, this was originally based on the idea of [ MediaSourceEntity ]( which was rejected because media sources haven't got states to report or services to call, unlike other HA entities. Whyn ot call this usn ? Dropped in favour of using the config entry.unique id in DlnaDmsData , which makes much more sense in context. Not all absolute URLs can be resolved. For example, if you're outside the network. Plex has solved this by adding it's own web view to fall back to when the request is not from the internal network: diff-4bc5cfdbcf43f8ad35f24f9c6ae347141b2bd4ee85a26bc372b411422e52337bR79-R86 This could be left for an extra PR. Is it worth doing the browser thumbnails proxying in media player , the same way it proxies the currently playing media's thumbnail? Media player doesn't know if a URL can be locally resolved or not. Ah, that makes sense. I'll work on this in a future PR. StrEnum can be imported from homeassistant.backports.enum . This is not possible. The DLNA DMS media source is only loaded if the setup succeeded. - Don't call this entity ID. - Why do we allow configuring this? Let's just slugify the name and call it a day. You're not asking for confirmation (and I don't think you should) You can pass a dictionary here, and it will use the values as labels. So you could map hostname - UPNP FRIENDLY NAME Thank you for the hint, I didn't know that was a possibility. This feels a bit weird, why not always key it by USN or hostname? I didn't know I could use a mapping in the schema, so I tried to make the displayed keys as human-friendly as possible. Also, UPnP devices may not supply a friendly name, so there was a fallback to the hostname. All fixed now. Should you move this after where we know the device can be used ? Probably not; async set info from discovery does some early parsing of the discovery info and does the checks for unique IDs. I've renamed the method to reflect its actual role and added a comment, so it's hopefully less confusing now. For media source the media content type should be the actual mime type. We only need to type attributes here if it differs from the type annotated in the init method for the attributes. We should not inherit from IntegrationError here. That exception is used for a special group of exceptions by our helpers. Please inherit HomeAssistantError instead. ConnectError doesn't seem used. There's no method named async create entry . When setting the unique id in the user flow we need to pass raise on progress False . We always want user flows to take precedence over di
Both TimeoutError and ClientError is taken care off by the DataUpdateCoordinator so entire try-block can be removed with it's exceptions. removed Should be enum from SensorStateClass solved Seems a bit unnecessary as it's not used elsewhere than init. unnecessary to put it in a local variable? isn't it much more readable? I think this would make the native value static as there is nothing here updating the value. So how should it be handled? removing it will crash the integration. As per above make this the native value property instead
do you have an example of how you would end up with metadata object passed? It seems like it's a special type and wouldn't be possible easily by play media service and would never come from media browser. nvm looks like it's part of the integration with dms integration that is to come. Can you use isinstance to detect if you're browsing UPNP media? I could (and did originally), but that then needs an explicit import of the dlna dms component, and therefore a dependency within the dlna dmr manifest. This current approach is also a bit more flexible because it can handle other integrations extending PlayMedia with a didl metadata attribute, and they don't have to depend on dlna dms for it to work. This has also led me to think about how media sources can provide metadata to media players more generally. I'll work up an architecture discussion for that next week. We don't want to access hass.data in tests. Can we avoid this, eg by changing how we patch? Maybe patch media source.async resolve media ? Follow-up PR:
Not lights here. Not lights here Same Same Same We shouldn't set up a timeout unless the siren natively supports that. We can only support device native APIs. We've had this discussion many times. The device have no native indication of off. Their indication of off is absence of command. If you have a good way to support this in the library can you please provide a pull request for that? No. Then I suggest we set assumed state to True and return None from is on to mean unknown state. This will allow Home Assistant to turn the device on off and not show any state that we don't know is true. Then it is not usefull to use in automations. For example can't send notifications that the fire alarm in your house is active. Which I think is quite important (my main use case anyway). The state is known for these devices. Battery might not be know, but we do know if the alarm is active or not. How do we know the state if the device doesn't tell us when it turns the siren off? As mentioned , while siren is on, it sends siren on every X seconds. When it turns off, it stops sending. This is how linked fire alarms work. While they receive a message that another alarm is ringing, they ring themself. Once they stop getting that, they stop ringing. Technically we should cyclically send as well if the turn on was requested by us. That is missing here, but we must also support the externally controlled case when we are just displaying state of the controlled device. No, you didn't mention that the siren keeps sending siren on every x seconds as long as it's on. That's a big clarification. Thanks! In that case this is ok, but then please add a code comment about this. Do we know that all devices use a two second interval for their messages? Actually no. The ones I've tested with sends it that often (or more often). But we already have a config option for this that it seems I've forgotten to hook up.
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries. We also don't allow scan interval as option. Every integration that supports config entries allows the user to turn off automatic polling and then the user can automate the update interval as needed with the entity service homeassistant.update entity .
We have a feature recently added by agners to pause the recorder while performing a backup. We should enable that here too. That is planed, but is currently only triggerable with WS, so need a little refactor of the recorder integration before that can be done, which is why that is not including this PR ok. We should generalize that logic indeed, to require an override from the user before we shut down if a backup is in progress Let's also add [ .DS Store ]( This can starve the thread pool and does a ton of I O in parallel. Instead, run 1 job in the executor that loops over the files. This does I O bu will be resolved if other comment addressed. We shouldn't load backups during startup. We should load it the first time the page is visited the info is needed ![image]( Do we really need to info log this? I think debug is fine. Why write this to the temporary directory ? Because we need it? that is the file the supervisor reads, and we create the backup file based on the content in the temporary directory. oh we can't add in-memory files to tar files. That's unexpected You might want to do this in a finally to ensure it's reset also when an error happens. Let's just add the info of this new backup to the list instead of re-parsing all existing backups. Why filter before knowing if it's a directory or a file ? Can it ever match a directory ? limited to file Alternative: since we filter out symlinks here, it means that any thing that is a symlink is added to the tar file? we do on the supervisor, but I guess it can work and have a use case here, I'll remove it for now and we can add it back later if needed. All websocket commands are called as callback . You need to wrap this one as async and run the remove backup command in the executor. Why would we do that during setup? We wouldn't Should we exclude the media folder? (especially now people can upload media) The point of this is to have a way to migrate everything easily from core container to OS, if your media is missing, it would still require you to; a) re-upload them in the UI on the new installation b) install samba, and move them Both these are not great, so unless we get issues with it, I'd say keep it for mow. You need to put this outside the try, or else you are going to set self.backing up False in the finally while you were not the one that set it. right! If you already test that it's a file here, you might as well add it to tar? It initializes backups with an empty dict, which is also falsey. Instead, initialize it as None in the constructor, so you know it hasn't been loaded. When you create a backup, you don't need to add it either unless backups is not None (because it will be loaded when listed for first time)
Just for curiosity, what does the :s do? formatspec Its string format. In this case it is copied from the other platform and we don't really need it since its the default.
MODEL AIRFRESH A1 is a string and not a container. If we want to match strings we should use or str.startswith or similar.
The MOTD can potentially be bigger than Home Assistant supports? Can it? What's limit on home assistant's state variable? 59char is Minecraft limit (doesn't account for color markup, which wouldn't make it to home assistant (and didn't on my server here) . Aah that will work indeed Do people call the MOTD a world message? I've seen it called a lot of things. Okay, I'm good with it then.

We need to check if the device is an universal remote before creating the code storage. This logic changes the flag when the request doesn't work. We can only change the flag when the request is sent successfully or the device will not respond to the next command when it failed previously. No it doesnt change logic. The code is yielded. It is only toggled if the iteration continues. It doesn't work. The storage doesn't know about the request. If it failed and we ask for another code, it will change the flag. Another problem is that if we only request one code, it will not change the flag It does in a sense know, if the async request fail with an exception, we break out of the loop. This will make the generator function throw a GeneratorExit exception at the yield call, right before the flag was toggled, which mean it wont execute that toggle. For the one code case, it will still execute the flag toggle. The code will continue after the yield to check if there is any more codes to yield, which there isnt at which point the generator function exit normally. There could be a bug obviously, but this should work identical to the old code. It's not the same behavior, we need to rethink this part. The intended behavior is to send the code one time and change the flag if the request worked. We could add a toggle flag() method to the storage controller, and call it later when the operation is successful. Right, we should raise an exception instead of breaking. I dont want to redesign this code too much as part of this pull. I think it's better to toggle the flag explicitly instead of trying to guess inside the generator. since i needed in in two places i opted for abstracting it away. might have been a bad idea :). but should be okey now i think. We can only change the flag when the request is successful. The yield will stop execution untill the next item is requested, at which point the code has been transmitted. This breaks only the inner loop. We could use product(range(repeat), self. store.toggled codes(code list, subdevice)) to make it break both of them. Hmm..that might work yes. Actually we should just repeat before we turn the commands into codes instead. It's a generator, it should produce the desired behavior, it's the same as a nested for loop. Another way to handle this is adding an else clause and handling a break in the inner loop, we could also use a should break flag. product() keeps things simple imo. Before [product()]( itertools.product) runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it is only useful with finite inputs. So it won't work since the codes will end up being toggled directly. Might make sense to just toggle manually. Just realized. It really should raise here. Services that fail should raise now-a-days.
I do not think we need to check for specific error code, since there was already no explicit error code check before - just do the fallback in case of HTTPError If there is a different error, the second request will most likely fail too, so I only did the fallback in case of error 400. in this case, I would suggest to raise a HomeAssistantError from the HTTPError so that a related message is shown in the UI to the user. Further I would suggest something like: with this the fallback code block does not need to be indented If the error code is not 400 the original error gets passed on and handled by HA just like if there would not be any handling here. I think we should keep it that way for now, as we don't do any handling of HTTPErrors on other requests. Swapped the if-clause to have less indentation. If you're not sure if this is supported by all hardware or not and you want to gain some insight, you could consider making this an info or warning requesting users to open an issue specifying the model of the light they're using. Make sure that's only logged once per light though. This is how cast asks users to open an issue about unknown chrome cast models: L59-L96 This can be an improvement for a follow-up PR though. Hm, interesting. I'll have a look at this, thanks.
This should be info or debug? It's a problem condition that wasn't automatically recovered from when connectivity failed, so I'd think either warning or error would be most appropriate. If you say so.
We may not want to include this in all responses, we should maybe do an entry json extended with all flags. Why not always include it? bramkragten suggested it adds unwanted overhead to keep adding flags to the responses, many of which are only used in some special cases by the frontend. In this case, we only need to know this on the device screen. Ok. Should we raise specific errors for each problem? Maybe a HomeAssistantError with a description? Yes, raising errors sounds good. I would raise specific errors for different cases. Maybe MissingEntry for missing device entry or config entry id? Updated in 4baf5ef The idea is that the integration may need to take additional actions, for example update some remote device or service. Should we call this first, and allow the integration to veto the removal? Yes, we should call it first and only remove the entity and device entries if the return value is True. Changed in 4baf5ef This needs to go below the schema to work correctly with typing. Errors are ignored: L25 Fixed in 4baf5ef Fixed in 4baf5ef Fixed in 4baf5ef How about async config entry will remove from device since we don't expect the config entry itself to remove itself from the device? Ok, but I think it's long. Fixed in 4baf5ef Should we have this on the component or a platform ? Component I think. This is not entity platform dependent. So it's OK as is? This sounds like something that we should always do automatically if we remove a config entry from a device ? And now thinking along these lines, maybe we can automatically offer removal of the device in the frontend if all entities are restored. Here's a related PR:
Maybe the serial number is enough as unique id? Do we need to use both mac address and serial number? Probably not, just figured it would be twice as unique. :) I'll go with just the serial. We can use our shorthand attribute. Then we don't need to implement the property. With this shorthand, can I drop the unique id() function entirely? (I'm new here, sorry) :) Yes, that's right. Okay, cool, that makes this change pretty trivially small.
Is this updated when the user changes this entry option? I think you should add async def async entry updated(hass, config entry): to init Thanks for the tip! The changes were applied directly from options flow, but it is better to reload the config entry. In the future, more options will be added for which it will be difficult to apply changes on the fly, without reloading. This prevents data to be added to hass.data ff async config entry first refresh fails. Thanks! Fixed. Is it possible to prevent an assert in production code? Maybe it is better to throw an error? Replaced it with type: ignore annotation, just to avoid using assert . Although, in my opinion, this solution is worse, because it hides possible errors in our code and, therefore, is less safe. As I've understand correctly, this is not required. the zeroconf: line is enough. Not sure about this. The [docs]( mdnszeroconf) say that we should add zeroconf to dependencies if we use async get async instance . Perhaps with the zeroconf section, this dependency is added implicitly, but I have not found this documented in any way. However, I have noticed that most integrations specify it in after dependencies (i.e. as an optional dependency), and this is more appropriate since having mDNS functionality is not an absolute requirement. This file can be removed. Translations are added by the community via Localize (see Thanks! Fixed. The integration is already logged by Home Assistant and we should never log tokens :) Scan interval should not be part of integration configuration. If someone wants a custom polling interval or schema, an automation that calls the homeassistant.entity update service instead. This mean this option flow can be fully removed, as this was the only option. We should change the cooldown and set immediate refresh on the coordinator instead. Once the cooldown immediate update has been adjusted on the coordinator, you can adjust this: When is entry title empty? Additionally, this could be set as an entity attribute ( self. attr name "X" in the constructor). We should not use ternaries when they split across multiple lines, it makes code hard to read. We could make a NamedTuple to hold the coordinator and device. It would be easier to use and easier to maintain typing. Client, Model State are not re-exported from the package root. These imports are not re-exported by the package. Import them from the appropriate modules instead. This import is not re-exported by the package. Import it from the appropriate modules instead. Why are we ignoring type here? Can we avoid doing that? Seems to be unused? power can be None according to typing, why not return that? We can also set this once in the constructor ( self. attr preset modes X ) We can also set this one in the constructor (once on init), self. attr speed count X Small detail, but can we move this up in the file?
Diagnostic category is read only, ie for sensors and binary sensors. We probably need this: L517-L523 are we sure we need this? I don't see anywhere where we actually dispatch this signal nevermind I found it Maybe we should change the signal and only include the node id and a suffix that is unique for the type of callback, ie remove. Ie make it so that we only need one signal for this operation.
isinstance(None, str) is False so we don't have to check for time from status implicitly. Maybe using : operator in the if would be nice here too (can time from status be something else than str?) I want the self. currentsong.get("time") to be the default so returning inside the if not makes sense. anyway i changed the code to simplify the logic Oh right. So why don't return immediately and do the alternative handling only if this currentsong is None? We should avoid using multiline ternary statements, as it makes code hard to read. Fixed. frenck can you re-review?
Why add to coveragerc if there are tests? And on a separate note why is config flow in there? The config flow is ignored by legacy. We should remove it as soon as we have 100 coverage of that module. This line should be in an else statement: try...except...else We don't need to prefix local variables with underscore. Get the gateway device entry from the device registry via the gateway id. L234-L240 When we have the device entry, the software version is one of its attributes. For the future, what could be interesting is to collect and include the raw json data from all the devices. Yeah, thought I'd just add something as a starting point. I very rarely have any issues with my gateway so I'm curious to see what setups the users have that report they are having problems. But I'll make a mental note of your suggestion for the future. It's a good idea.
The idea here is to allow integrations deriving entities from RestoreSensor to add additional keys. Maybe that's unnecessary though, and such an entity should just return an instance of a subclassed SensorExtraStoredData instead. If the platform still needs to return an instance of SensorExtraStoredData as value in the mapping, adding more keys without subclassing SensorExtraStoredData is probably not useful. Or do you have an example already? We should change the typing of RestoreSensor.extra restore state data function to be: It's error prone though because we would rely on all implementations to cooperate and create a union dict. Maybe better to simply retype RestoreEntity.extra restore state data as The latter sounds good. OK, fixed in 97d1156 I think we need some safeguarding when attempting to deserialize to SensorExtraStoredData . Maybe we could include class name version in the saved data and check for that when restoring? Yeah. Maybe just check if the parameter keys are present and if not return None? Alternatively catch AttributeError .
Please split off the different platforms to separate PRs. We don't need to add all platform support in the same PR for these devices. This PR is way too big. Start with a platform that is already existing and add support to that platform for the new device. When that PR is merged, create the next PR etc. We need to do this in small steps. Thanks!
Does it make sense to do coordinator.async set updated data(None) instead? I think you can drop the dispatcher are as well since async set updated data will callback the coordinator
This is not a MAC address. When HomeKit was being reverse engineered it looked like one so thats why it was named .mac but its only a randomly generated pairing id.
Based on the rest of the code, I don't think these should be hard-coded. Use shorthand attributes instead Not needed if shorthand attributes are used This is an integration that connects to a device or service. As per ADR-0010. For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: sibalzer FWIW, I started such an config flow, including auto-discovery (but couldn't find the time to wrap it up, i.e. to migrate old config entries and to configure which sensor types shoudl automatically be generated). Feel free to copy from there:
Can we use entity entry.asdict() here? Does RegistryEntry provide asdict() method? It uses attrs so it should be built in attr.asdict Ok, I used asdict() attr method. Do you think that some values should be filtered? Can we use hass device.asdict() here? Does DeviceEntry provide asdict() method? It uses attrs so it should be built in attr.asdict Ok, I used asdict() attr method. Do you think that some values should be filtered? Why would we not want the entity id ? I could see someone opening an issue and telling us they are having a problem with entity id X Generally with diagnostics, more is better unless its PII Just because is the dictionary key haha. Yeah that makes sense.
This doesn't look right, the config entry's data options should be updated by the config option flows. If you want to update config entry data instead of options in the options flow, follow this pattern in the options flow: I addressed this in the latest commit We need to set up the config entry before starting the options flow to ensure the config flow module is loaded. Please use hass.config entries.async setup . I addressed this in 74262
We should avoid migrations if we can, and it looks like we can migrate this while fetching the data from the options. Config entry migrations will prevent the user from rolling back Home Assistant versions so should be avoided unless really necessary. Sorry for the delay, not had any spare time. Ahh ok, yeah that makes sense, I thought I was doing the right thing with migration flow, but yeah no worries, I'll take it out Don't add this to the config flow. The config flow should only gather info needed to authenticate. This should go only into an options flow. It's weird that a service called set climate timer allows setting a requested overlay which is not compatible with setting a time period. Yeah I get what you mean, but the reality is that set climate timer is actually setting an overlay in tado, all I am adding is the ability to choose which type of overlay. Probably the service should of been called set overlay, but I dont want to change that due to backwards compatibility Can we make these options a bit more descriptive friendly? If we keep these 2 options but they shouldn't be combined, use vol.Exclusive
Do we still need to cast here? I tried removing them before pushing this PR: Doesn't quite make sense though as the property is an int as expected: ![image]( It may be due to the library not specifying typing is supported with py.typed file in the package. packaging-type-information Although, the whole library isn't typed yet so we should probably wait until that's done before adding py.typed . Noted, let's wait. I'd rather migrate existing entities to a new unique id instead of adding a new feature to the description. All sensor entities should preferably have the same unique id pattern. We should use the description key for suffix. Here's a helper: L889-L893 I'm looking into this now and note that the function loops through all entries. I'm thinking something along the line of this: First we define a helper: Then we call it in the loop: I can't really see how else we would access the key as it's not in the registry and thus can be accessed in the callback? Yeah, this helper may not be right for this case. Maybe have a function that takes hass, the old unique id and the new suffix as parameters. It gets the existing entity entry, and updates the unique id if needed. Call the function in the loop before creating the entities. We can get the entity id with this method: L277-L280 And then get the entity entry: L272-L273 I've pushed a few lines following this. I don't think we should use the device class for key. We should define integration specific keys that only we control. I've changed the keys. Why does the hours show as a decimal number in the PR description screen shot? Because I can't read my own docstrings The API returns in minutes. Does it make more sense to just expose that or to expose in hours as suggested here? (I'm using comma as thousands delimiter so it's 105 600 minutes left). I think we should round it to hours. Minutes should never be interesting. Have we checked that the value only changes when the device is in use, and not just because time passes? Are there separate state change events for this feature? Does it update every minute when running the device? No, let me check how it works and revert. wouldn't it be even better to recalculate that to days months, if over 24 hours... just like the app? ![20220206 135117000 iOS]( Mariusthvdb let's leave that to the user for a template sensor. It doesn't seem to update every minute, let me see if I can track how often it updates. Just noted an update and subscription seems to work as only 5910 updated: L41 The fan is currently on. I'll leave this running for a while so we can see what happens. Another update: I'll turn it off and see what state it has in about an hour. It seems to have a cadence of 50 minutes. Invert this check and return if true. Then we can outdent below. Not quite sure I follow you here but we now return if the deprecated unique id is not found. Maybe only log this if we actually completed the migration? Add a code comment saying when we added this so it's easy to
This should be equivalent to self.info.primary value . You've already specified the CC and property as the primary value in the discovery schema, so it's automatically watched and assigned to this class member. It's guaranteed to not be None, otherwise the entity would never have been created to begin with. There shouldn't be any reason to set this. This property must match the endpoint of the primary value. This is also suspicious. Is it really the case that Fan Mode and Fan State CCs can be on different endpoints? Generally we assume all values belong to the same endpoint. The climate platform is a bit exceptional, and I think those were added as workarounds to buggy devices. I'm not sure that behavior should be blindly copied, unless we've got some tests that show this behavior already? You're right this is copied from the climate entity code, I'll remove from here Shouldn't be necessary since self. fan mode is the same as self.info.primary value and is guaranteed to not be None. I don't think you can assume a state if the value is unavailable. I don't think you can assume a state if the value is unavailable. I would invert this and say The unusual case should be under the conditional while the frequent case should follow the optimal code path. At least that's what typically makes sense to me, I don't think there's a specific convention around this Should there be something more than silence if this property does not exist? Does Z-Wave JS even allow this to happen (the property is from the same command class as the primary value)? If there's no ability for control, should a fan entity even exist? The discovery schema does have a required values field to enforce that more than one value ID exists in order to be discovered. The off attribute was added at ccVersion 2, so devices that comply with earlier versions will not have it. I think it's still useful to have a fan entity to control the "fan mode". For example on my HVAC the Auto low mode is the same as "off" in practice (I haven't seen it turn on when it is in that mode). I don't think we can generalize this to all HVACs though which is why nothing happens when the off attribute isn't available. OK, thanks for pointing that out. (I think the "off" value is actually only [available]( L379-L384) if the Mode CC is 3, but that doesn't matter much). So I have a thermostat that implements V1 CC. The toggle switch is always on, and if I toggle it just reverts from off to on. If I don't know the distinction between V1 V3, I would be confused. MartinHjelmare Should there be something that indicates to the user on off is not possible? At least a log warning? Weird I was looking at this line for the version: L333-L334 But all other checks are using 3, one of these is incorrect You can set off mode in V2, but the report does not include the off bit, that was added in V3. So the Value API only supports V3, but you can still use the CC API and set off mode. It's possible you might be able to set off with 
This requires an architecture discussion. changing-the-entity-model For background, here's the discussion that was had before the integration was created: Opened What can I do to get the architecture proposal under more people's eyes? There needs to be an interest from the member community to drive an architecture discussion forward. Not much to do, besides waiting.
ZWave humidifiers expose the current operating state of the humidifier, which is different from the "mode" in which the humidifier is set. For instance, in "auto" mode, the operating state will go back and forth between Humidifying and Idle . I added this new attribute since I think this exposes useful information that had no good way of being exposed before. My intention is to follow up with UX changes to display this attribute in the Humidifier card when available, just like the Thermostat card does. Changes to the humidifier platform need to be a separate PR. You can either mark this one as draft and wait until the platform changes are merged and rebase, or you can remove the support for this feature in this PR and submit it as a second one, your call. Opened: I suggest removing all features from this PR that we won't accept immediately to not block this PR. done The same z-wave node will likely have a humidifier and a thermostat, which is why this discovery entry is placed above the climate ones, and this one has allow multi . Is this the correct way of doing this? allow multi is only needed when the same ZWave Value is used to create multiple entities. In this case I don't think it is needed. Z-Wave devices are capable of being both a humidifier and a de-humidifier at the same time. However the HumidifierEntity device class doesn't have a way to express that. I'm not sure what is the impact of this limitation. Splitting into two entities, one for humidifier and one for de-humidifier is not really an option IMO, since you'd be controlling the same physical appliance from two entities, which would be confusing in "auto" mode for example. maybe submit a PR for the platform to have a new device class that means both? Opened To avoid blocking this PR I'd make the assumption that we can set the device class to humidifier even though the device does both? After reading through I found issuecomment-719752004 which seems to point towards splitting the humidifying and de-humidifying capabilities into two entities. This would mean the z-wave Humidity control mode would need to map to the on off state of each entity in this way: Humidifier entity De-humidifier entity Z-Wave Humidity Control Mode ---- ---- ---- OFF OFF OFF ON OFF Humidify OFF ON De-humidify ON ON Auto Thoughts on this approach? Still seems weird to me because two entities need to know about each other's state to control the underlying z-wave value correctly. I'd suggest to simplify and do last service call wins. Ie, not have any interdependence between entities. I'll move this back to draft and make the changes to split these in two entities I'm thinking about this a bit more, there's no need for two entities to have a dependency on each other. This can be mediated through the underlying zwave value which would be shared between both entities regardless. On the humidifier side we will have: On the de-humidifier side: setpoint type for current mode maps the current mode to which setpoints
No ideal, would be good to make this public in a future PR. Agreed, I created to fix that and will take a look into adding some tests. I think this would be easier to follow if you asserted the contents of the result here as it would make it very clear what is expected. Done. I also added a fixture for hs110 which has different set of variables, and parametrized the test to explicitly check for the expected content.
One day we'll do something with this The source is generally the domain of the integration that found it. SOURCE DISCOVERY was the source for the removed discovery integration. I've used SOURCE DISCOVERY in these cases because otherwise it won't be in DISCOVERY SOURCES L110 If there is a better way, happy to adjust in the next turn So the thing is, it is to know how it was discovered, but this isn't discovered by the discovery integration. My suggestion would be, to add a SOURCE INTEGRATION or SOURCE CUSTOM to indicate a custom discovery method provided by the integration. That way, we can still know who what discovered it. SOURCE INTEGRATION makes sense to me I'll do some refactoring Looks like we already have SOURCE INTEGRATION DISCOVERY "integration discovery" but its missing from DISCOVERY SOURCES Oh, would you look at that! Two whole integration are using it :)
Shouldn't this method be part of the entity description? It isn't decoupled now (as in, using entity descriptions isn't provide much advantages in this platform right now) I decoupled it now, I think this is what you ment. This default doesn't work. I suggest making a mixin dataclass and have the attribute be required instead so we don't need a default value. Please sort . done We can make this more specific frenck apperently this caused mypy errors, I am not that good in typing. Do you know how to fix this?
I suggest we make a router method that wraps the allow block device api call. It can accept a mac address and the allow or block constant. done Let's keep the api private for now. done Where is the allow state updated? Its part of the device info that is collected in the async update device trackers call which is performed by the coordinator. Do all routers provide this state? I don't really know but considering this part of the code: L323-L332 I guess there will be some routers that will not provide this state, for those routers the value will be set to None. Maybe I schould change that to a default of Allow in the upstream lib? or maybe even better, check in this part of the code for a None vallue and set the state to True if it is None (unknown). Can we use the switch and block devices even if the router doesn't provide this state? I think the allow block service will work even if the router doesn't provide this state. The only problem would be how the switch is displayed inside HomeAssistant, If I hardcode the state to True (in case the router does not provide the state) the switch will always be "ON" and you can basically only block devices but not unblock them again. (although the switch.turn on service schould still work). What would be the best approach for this? Either we don't create entities for devices that don't have the state, or we set state to None (unknown) for the switch if the device doesn't report state. I just tested and if the state is None, both buttons are displayed which is perfect: ![afbeelding]( Ok. Let's modify the condition here so we retain a None state as long as the device state is None . Please type the whole signature when adding type annotations. I added the : str types
Is this no longer needed? Ahh DeconzDevice provides it now via DeconzSceneMixin Is would be a bit more efficient if you could avoid creating the entity object until you know the unique id is not in known entities. Is would be a bit more efficient if you could avoid creating the entity object until you know the unique id is not in known entities. Definitely, Im reworking stuff in the library as I want to remove signals to here which are not explicitly new devices to avoid this It looks like this pattern is repeated in other places. Is there an opportunity to make this a bit more DRY? Yeah, first step towards that is breaking out how to generate serial number and unique ID
Instead of guarding this call here, make a separate coordinator for the traffic meter data. Then the coordinator will only fetch data as long as there are listeners (enabled entities). How will we prevent the two coordinators from making a call to the router at the same time? I do not want to overload the SOAP server in the router. I guess I need to add PARALLEL UPDATES 1, but in which file and where do I need to add this to take effect for the two seperate coordinators? request-parallelism Add an asyncio.Lock on the router that guards the api calls. done Let's make a separate sensor for this value instead. done Please set a lambda or function per description instead that accesses the correct coordinator data. Example: L100 done attribute is the same as the entity description key. We can use that instead after we know which description to use. done We can just iterate the descriptions and pass the description directly to the entity. done This could be a tuple instead since we don't need to look up the description. done Consider moving the lock to the router since it's the router that has the api instance and knows about the api. done If this attribute is required create a mixin dataclass for it. Search for mixin in sensor platforms for examples. I set a more proper default now. I hope this is okay. Pass the traffic data to the lambda instead since that's always what's needed. It will make the lambda shorter. We don't want lambdas spanning more then one line. We also don't need to pass the key to the lambda since the description already knows its key. Just hardcode the key in the lambda, or alternatively just pass the traffic data value of the key directly to the lambda. thanks We don't need a separate attribute for this. Just use the entity description. done I'd make this lambda the default lambda in the description. Then we don't need a mixin and we don't need to specify the lambda in all descriptions. hahaha, just done exactly that and now reading this... I'd return the traffic data here. Then we don't need the router attribute. The data will be cached on the coordinator anyway. sure will change it
Should we make this a persistent notification or a log? We general log these Also fine! Just took over the same behaviour from this migration: I think a persistent notification is better, easy to miss a log. What triggers this import step? I'm not seeing it? The custom integration when it is updated, see Please import a name as normal from in this case the persistent notification integration instead of accessing hass.components . The latter is legacy. I don t really get what you mean. Import homewizard energy or the persist notification ? i copied the persist notification implementation from the PR that I ve referenced, so if you want something else please let me know. at the top of the code, from hass.components.persistent notification import async create then async create( here instead of self.hass.components.persistent notification.async create( - I need to fix this in the upstream PR Got it, thanks! I did a search in core and found that from hass.components.persistent notification import async create was not used, but from homeassistant.components import persistent notification was. I think the latter is the best method. Shouldn't this config entry have another domain?
TO REDACT is empty, so there is not point in using async redact data . If you decide to keep it, it should be a set: But I would just remove it completely.
None not required. Done Can use : here. None not required on get . Done I've never written an options flow but curious if title "" is correct. I'm not sure what this does, but it's apparently required? It seems that this branch is used when committing the options, not when showing the options dialog -- there the title is pulled from the strings file (incidentally, I realized I'd forgotten to include the change to translations en.json, which is also apparently required). Maybe is the title for the confirmation dialog? But it already shows something reasonable like "Success!" Can we autodetect the correct TX count?
Please make sure that all the modules that aren't covered by tests are excluded from coverage calculation. We only have tests for the config flow.
Is this an ip address? We don't allow that as identifier. Identifiers need to be both unique and stable. These devices are very basic, they don't provide any information that could be used to uniquely identify the device besides the IP. They are configured with a fixed IP address (can't even access MAC through an API) and they literally don't have Serial Number (not even a number printed in the box) The last resort is the config entry entry id. Thanks! I think this should be using self. attr device info to avoid re computing it every time. opportunistically added other attr yep! :) Makes much more sense, thanks! You don't need to set self. config entry id anymore. You can use the original arguments here. This line is no longer required git push was on the way ;) I wasn't sure you'd seen it!
Now that they are diagnostic, do they still need to be disabled by default? (as in, we should nowadays only have to disable high frequently updating entity by default when entity categories are used). for some modules there can be up to 64 of these entities, so yes i would keep them disabled by default Hehe ok, that makes sense Shouldn't these be config category? Oh right Goodmorning MartinHjelmare! Always good to have you around :D 66156 why config instead of diagnostics? Diagnostic category is only for read only entities like sensors and binary sensors. generic-properties ok clear, thanks for the explanation
For future readers, the value is an IntEnum: L269-L277 should I explicitly use controller.inclusion state.value to make it more clear? I don't think it matters. It will be converted to a number by the json serializer before the websocket consumer gets it. It's the possible values that may be interesting and those aren't shown anyway by the code here.
The CUSTOM CURRENT APP entry in the CUSTOMIZABLE COMMANDS set won't have any impact in this integration. You may want to define a constant that lacks this entry so that users aren't presented with an option that does nothing. It would make sense do this at library side, defining an additional constant like HA CUSTOMIZABLE COMMANDS ? This allow to have potential new command available without the necessity to change the code. Ok, for now I implemented this here, just think about this. How about I add a sorted tuple HA CUSTOMIZABLE COMMANDS ? Yes, it would be fine Incoming: Thanks, I wait for your PR to be merged, than I will rebase and modify this. Should suggested value be current value ? suggested value propose the current configured value in the cell but allow the user to leave it empty. I don't know the keyword current value . OK. I thought you came up with suggested value , I didn't realize that you were adhering to an existing standard.
This PR is now a dependency bump and a new feature, please split that into 2 separate PR's This will fail for anyone that has followed the documentation for this integration. To get your API key, go to [My Settings]( mySettings) on the UptimeRobot website, at the bottom you will find your Read-Only API Key . What approach you suggest then ? For sure update the documentation, but then ? Added breaking change section It looks like the read-only key starts with ur and the main key starts with just u , they do not say that on their documentation, but I tested with multiple accounts and recreated multiple new keys and that looks like a stable thing to check. So we should check that during integration setup and trigger reauth if it starts with ur Check added This need to trigger reauth flow Don't log exec info Switch API? This method is called by the async turn methods, nothing is checking for ConfigEntryAuthFailed in those? Check the async start reauth method of the ConfigEntry class Done, thx for the hint async add entities can take a generator, no need to make this a list. Copied the approach from binary sensor.py ;-) Then it's wrong there as well :smile: This already exist in UptimeRobotDataUpdateCoordinator as coordinator.config entry Indeed, multitasking is not helping :-) Catch and log non-auth related exceptions as well. Done We do never not have the config entry here, this integration can only be setup with config entry so you prefer a assert ? No, just access it. If mypy complains add it to the coordinator If this does not fail it should request an update, the 2 other entities for the monitor will now a wrong state. Fixed. return here and drop else
I think this is incorrect. ENTITY MATCH NONE is not for these purposes and the state should not be able to be None either (as that is handled as unknown). I'll remove the None! Tks I'm open to ideas on new naming! Regarding naming, can you elaborate on the use case for this? I'm not a template expert so apologies if this is a question with an obvious answer. I'm seeing two use cases: 1) undefined value 2) valid sensor value, but it has a potentially expected unavailable or unknown state e.g. due to a device being offline or whatever Is it common to handle these the same way or is 1 a bug and 2 is expected to happen? This seems kind of like states('device tracker.example', 'my default value') so maybe including something about states in the name would make sense.
It would be better if SoCo took care of parsing the XML, but this can be done later. Should we whitelist instead? That might be safer Perhaps. So far I've only seen "sleeping" as a valid reason.
Can you keep registering two services but have just one function for both services?
Seems you didn't apply all feedback from previous PR yet? Removing this broke the integration, this one I'll need to look further into. Maybe you want to use from future import annotations as well. What happens if you remove this? I don't see why you should need this? I am not sure why you need this either? Since you can just import PLATFORMS from const? Your async step user has some code duplication and is not very readable. Have a look at L86 or L62 for example. (click on it for the full file). You could just combine all steps in async step user and you don't need to call show config form and you can just use the const directly in default instead of assigning it to user input first. You don't need to have super() at the bottom, so I think it is preferred to have it on the top. Since this is static, you can move this to init and set the attribute directly. Example: L38 If you want to add NAME to all entities, I think it is better to just do this in your entity itself. Only use this when you set it to False . Default is True. Do you need to set this? This will be set via super() , so you should be able to remove this. Eventually it would be good to add this logic to the entity description as well. You can extend the entity description, so that you don't need all these if statements here. (and they all look the same?) Same for all attrs Doesn't seem that you have 100 code coverage, which is required. See testing-outside-of-tox for a command how to check code coverage locally. CI CD needs to be approved by a maintainer, otherwise you can see it there also.
You could implement SensorEntityDescription s instead. It would produce less code and better readable code :) I think I would still require these if statements to determine which device class should be used though, no? I can see SensorEntityDescription being useful to reduce the number of Sensor classes I create (from 2 to 1) but then I would need to add if statements for figuring out the unit and value. Is using if statements preferable to separate Sensor classes? I was told to use classes in the last PR haha. I'm happy with either way TBH. Entity descriptions remove the need to have 2 sensor classes in the first place. Sounds good. If that's the preferred way I'll make the swap to SensorEntityDescriptuon and a couple if statements. I've switched over to using SensorEntityDescrption instead of separate classes. Good for review again. Thanks again frenck! This could be implemented with a value fn . ( git grep value fn ) See whois sensor.py You could do something similar for native unit of measurement as well This is much cleaner than a bunch of if statements. Thanks for the suggestion! Done and done! Please type all the args Fixed. Stale doc string Fixed. Since this spans multiple lines let's make it a named function Done. This could be a comprehension but personal preference if it's better or not since it's a double There may be additional sensor types to add in the future. I know that Honeywell also sell indoor sensors, but they aren't compatible with my current system. Perhaps we keep this as is for future proofing? EDIT: I assume you're talking about using nested loops. This signature is incorrect. It doesn't take discovery info , and config should be config entry or entry . That's standard. It's normally better to use the key as unique id suffix. We could need to change device class name in the future and would need to migrate the unique id then. The integration doesn't completely control the device class constant. It does control the description key.
I'd define constants for these and reuse them in the different platforms in the dispatcher signal. color above is an optional three item integer tuple. We should keep the type here. Please be consistent with how the parameters are passed in accordance to what the signature of the target requires. All target parameters here accept positional arguments. So either pass positional arguments or use keywords. There's no reason to mix it up. We don't need this since we don't do anything but call super.

Why add this widget, if the associated platform is None? L109 Having None, or a missing key will result in the same case. See conversation below (duplicate). Why add this widget, if the associated platform is None? L109 Having None, or a missing key will result in the same case. The UIClass is Siren, thus it will be mapped to Siren platform otherwise. This None is to override the platform mapping and make sure we don't assign a platform to SirenStatus ui widget. Please break this line. Done in 872a47ce7183689c9e542c5654d18bdcec515c7e Does it make sense to give them control of the tones volume? turn-on It does. However I marked this as a follow up item for now, since I didn't fully figure out the tones volume settings set.. It is hard to figure them out, when I don't own a device like this. If the schema validates you could assert its an int instead of casting Looks like its always an int if its there L42 Maybe this is better? Addressed in 6ed32982a061eb3878acf9efc4580576e85b5d04, thanks!
Should be To make it check first if state is set Same None is the default value returned if the key is missing in the dict.
Please don't edit these by hand, just run python3 -m script.translations develop to generate your en.json. I didn't realize this was an option, thank you. I've fixed this now Why is this an option? Honestly, I'm not too sure why this was written as an option, but I used it from [integration blueprint]( L57-L62) and that's why it's there still. I tried changing this myself, but I couldn't get a working solution. What if you just remove it? If I remove it, all entities show as unavailable Why not use this one? I am not sure what yours does, but I thought it was legacy. Why is this required? Not sure, I thought that made it display the new value when an update was made, but it seems that's not the case. Removed You would need to test, but I think you can simplify this a lot with the new helpers. Do you have any other (more specific) exceptions that you can catch? I don't think you need to catch a broad exception in your async update data , since this the Data Update Coordinator takes care of this already. Why do you create a new session where, while you reuse the Home Assistant session in init ? How can the one in init be used? Doesn't test connection() get called before setting up the entry, then once the entry is setup, then async setup entry() is called where session is created? You use two different functions to get a (new) session. Create vs get session. You could use get in both implementations. Do you mean literally switch session async create clientsession(self.hass) for session async get clientsession(self.hass) ? If so, that creates an error with "Failed to connect" which I believe is a generic exception from aiohttp, likely due to a missing session. Why manually check if the configuration already exists? You can set the unique id and use the helpers. My only concern would be that a host is not a super unique address, is there nothing in the config setup that is more unique? and Where do you use this? Please use DeviceInfo from from homeassistant.helpers.entity import DeviceInfo When can this happen? Does this mean that the entity is not set up? Yes, this used to mean it in an older iteration of the integration I was working on. It no longer seems necessary and I've removed it I am not a huge fan of all the if else statements in this entity. Are you familiar with the Entity Descriptions? See tuya for an example: Why do you need all these extra state attributes? Shouldn't they just be extra entities? At any moment, there could be theoretically unlimited in the history or queue. This allows a quick look at the last 10 items in either the history or the queue. While they could be their own entities and I don't believe this is a great use of extra state attributes, I opted not to do that to not clutter up with 20 additional entities. What do you think is the best way I could represent this?
This should be a user-friendly representation? Why not set it to name of device info sensor name ? Changed this with c7ded58 get() van return None , which can result in None Sensor name ? It should always be set, but I have update the code to prefix the name with "SMA" if attr device info or attr device info["name"] is not set We generally avoid multiline ternary Alternatively: Looks much cleaner! Thanks! Sorry, I had tabs in my suggestion (thanks GitHub :( ) casting to str to prevent homeassistant components sma sensor.py:89: error: Incompatible types in assignment (expression has type "Optional[str]", variable has type "str") [assignment] Is there a better way to do this? Yes, I'll do a suggestion (with spaces this time ) Any advantage of using over Could we also do this than? It catches the case if name would be an empty string... Ah yes :)!
We have this helper: L1156 Maybe make these states part of an enum? Please add full type annotations to the methods. We can't use the dispatcher if we want to allow other integrations to subscribe to the cloud state. The dispatcher is only for internal communication within an integration or within one helper. If we want other integrations to subscribe we need a proper api function. Well, no problem to roll that back. What's the best practice for a proper API function then? Events are not wanted since they are exposed to user and recorded, which is not useful in this case. Duplicating what's nicely implemented by the dispatcher will either lack needed functionality (with the current commit, it's not possible to unsubscribe which is not OK), or require reinventing the dispatcher wheel. It would be ok to wrap the dispatcher but it's not ok to use the signal string the dispatcher connect method as interface. OK, makes sense I'd expect something like this: We currently don't expose the cloud client. I think we need a top level api function in the cloud module that other integrations can import and use, similar to eg async is connected . Let's remove this. It's legacy. We can remove these methods now, right? Yeah, of course. oops, thanks
This is a counter, thus isn't a current measurement. Same as above Same as above Same as above
You probably want to add with pytest.raises( to test for your exception to be raised. So instead of patch , I use pytest.raises ? Well, the test fails if an uncaught exception is raised. pytest.raises makes the test pass only if configured exception was raised. Id not raise from a side effect, but return an invalid value so you can test your code raises the proper exception. I've fixed it so it now uses pytest.raises You don't need to annotate this with int - it is inferred anyway. You could however annotate it typing.Final . DataUpdateCoordinator will be inferred perfectly fine. the annotations of the function attributes are inferred here, no need for duplication. consider using attr variables instead of properties where possible (like self. attr name ). See L291-L308 I did think about that before, but the name has the county in it and isn't known until the object is initialized. Assign it in init () instead of self. name name . Does this file setup an API to communicate with an external service? The first item on the [development checklist]( suggests this is not allowed so you would need to add your API to a separate repo and then publish it on pypi. It seems a bit excessive, but if it's required, I'll do it. Maybe, but its the policy of this project. You could run this as a custom integration published on HACS if you really want everything bundled together. Alright. Just published a library to pypi. Going to implement it into the integration now It's available here: nice! Consider adding support to optionally pass a websession to it. see platinum- last point Can you explain how to implement this? I don't see much documentation on the website. I also am using httpx instead of aiohttp , is there an httpx counterpart for this? I'll just switch to aiohttp . Shouldn't be that hard . you should use from homeassistant.helpers.aiohttp client import async get clientsession or the httpx equivalent L26 for this a gold requirement would be Full test coverage for the config flow Above average test coverage for all integration modules Tests for fetching data from the integration and controlling it (docs) I guess that means removing init .py and sensor.py from here Hi there! I m slowly working on getting code coverage to 100 . Is there any recommendation on how to mock an API? Are you using httpx or aiohttp now? For latter use from tests.test util.aiohttp import AiohttpClientMocker to use a response fixture. I guess there is a httpx equivalent too. I've searched the repository, and it's a little bit confusing. Do I just import it and it automatically has a mock available in each test method? I'm talking about aiohttp btw I did use it for Fronius tests ( but this has multiple devices with multiple endpoints. See the fixtures directory - there are the various responses that are loaded by a helper function in init .py . I guess for a single-endpoint API you will find less complex implementations in other integrations. Just have a search in the codebase. How doe
We should let the log integration register these Our websocket integration allows creating subscriptions. See how ZHA does it for their logging forwarding: L207-L221 we can do something similar but instead just attach temporary listeners to these logging objects. Then the frontend gets all the log lines, can show them as they see fit, and allow user to download it. And by allowing the user to see the debug logs, we don't have to teach users about terminals they know what they are capturing (kinda) I've changed my mind about having a ZHA-like API. Using the normal logging is good, as we can always decide to stream that log to the frontend and so capture all use cases. We should update the CONFIG SCHEMA to specify integrations to log. It would then take all loggers of that integration and apply the level. When we apply an integration level (either via config or via WS) we should store the old levels such that in the frontend we can allow turning off logging for an integration. Instead of this, I think that we could just return the integrations that are currently enabled. Would be slightly easier to read if you did yaml config self. yaml config and used it in the loop below I suggest to add typing for all new and changed core code. OK, the logger is now strictly typed. We could split the typing changes out to a separate PR if needed. I'd make settings a dataclass. Fixed There's no need to enumerate the enum here, just coerce the value to the wanted enum Handle setting module log level.
I don't think this is needed because notify events doesn't have a config flow? Yep, seems so, thanks! This means we can publish any event, which is not wanted. We should ensure the event is prefixed with notify events . To be least confusing to the user, the service handler should probably validate that data[ATTR ACTIONS][ATTR ACTION NAME] in the service call is prefixed with notify events , and we then again validate it here. Not really sure about this one. I guess if I will force users to prefix action names (which after become events) they won't be able to use event names they already have automations for. Am I missing something? To give you more details: "actions" in our plugin are just basically "events" that we allow the user to trigger right from the notifications we sent to him. Scenario: User set's up an automation which sends notification (using our plugin) that there's someone comes to door. Notification contains photo from camera and "open door" action. In the notification that we will send to our user, that action will be shown as a button. And if user pressed the button, our service will make a callback, which will trigger the "open door" event. I'm not familiar with notify events , so it's hard to follow the scenario. Can you try to make the scenario a complete example with all the needed configuration?
You should import and use SensorDeviceClass constant to replace all the DEVICE CLASS constants: from homeassistant.components.sensor import SensorDeviceClass Fixed with a new commit in this PR You should import and use the unit constants when they are available. For example: from homeassistant.const import POWER WATT Fixed with a new commit in this PR Fixed with a new commit in this PR This function is only used in one place. I think we can inline this function and merge it with add new device . There is no end to perfection ;)) Shall we do the same in other places (already merged) like L32 ? Shall we do the same in other places like L51 ? Should the generic sensor description really be a temperature sensor? What class should we use for a generic sensor? Probably no class at all. Setting a device class means we know that it's a certain measurement kind. You may want to set state class for the descriptions. available-state-classes long-term-statistics Do we know that this measurement is measured in Celsius?
Lint: Need to import annotations also I missed some trailing spaces I need to revise my alphabet!
Minor tweak - we try to keep these in alphabetical order:
Please remove code that is commented out. Recommend making the timeout number a constant that is defined in .const please remove commented out code 'auth' should be 'format' and from homeassistant.const import Platform Fixed in 042e2af582b599b54570553a7003091042de86cf Fixed in 042e2af582b599b54570553a7003091042de86cf Should you not check if the access token is valid? Removed the explicit call by using the entry.async on unload(...) listener (042e2af582b599b54570553a7003091042de86cf) Comment should not be required. If you want to clarify this, you could properly type it. See L98-L100 as an example. Fixed in 042e2af582b599b54570553a7003091042de86cf I don't think these comments are required. The DataUpdateCoordinator() is properly typed and has descriptions. I would just add comments for parts that could not be clear for Home Assistant contributors. (so for example, related to a specific device). Not 100 sure if ConfigEntryNotReady will be handled from binary sensor.py as well (instead of init .py ). Someone with more experience should confirm this. same as other comments There is no code that will set this device to available? Perhaps you should just implement the available property, where you check if the index is present. (how can this happen by the way, does the API sometimes not return every device?) Why should users be able to change the polling interval? Is here no polling interval that you can set by default, that will work for every user? Removed in 042e2af582b599b54570553a7003091042de86cf Fixed in 042e2af582b599b54570553a7003091042de86cf Do they have a single model? Or is this the only one that is supported by the API. Why do you need to log this? Can there be different error messages? (if so; why not catch them here and set a different error message in the front-end). Do you mean that they can only set up this integration once, or that they can only set up a unique connection once? I don't think this part is related to what you try to achieve. Single instance allowed is for integrations that can only be setup once (in total). In your case, you should set a unique id and abort new entries if they have the same unique id. There is already a helper for that. Moving this one to init would make sense to me, if you want to use this for sensor platform in the future as well. It looks like there could be interesting sensors to add. I think you can even simplify this more by using this: Than you don't need to save and call it again.
Please remove the empty ones By using short hand attributes you can remove the extra state attributes property See comment about self. attr extra state attributes By using short hand attributes you can remove the extra state attributes property I guess this are leftovers before DataUpdateCoordinator was added? Yes, this is some leftover code. I removed it other code linked to this. Please use from homeassistant.helpers.entity import DeviceInfo here. Perhaps add static attrs here? This comment remined me that CoordinatorEntity defaults should poll to False so no need to set it L306-L308 I added that later in my review as well indeed, however I only realized it after my comments about attrs. :D You can remove this since the CoordinatorEntity already takes care of this. Why is this function required? (especially when it is not used). This function is implemented in the FiveMSensorEntity in binary sensor.py and in FiveMSensorEntity in sensor.py Why do you use the update value everywhere? It should work like this as well, where the data update coordinator will refresh the sensor state after a new update. What do you save here? Shouldn't this be different entities? Am I correct that you pass the coordinator? Since it isn't typed (and probably using a wrong var name) it is hard to understand. Please dont make any edits to translations en.json , just edit the strings.json and generate translations via python3 -m script.translations develop . Same here as my comment for binary sensor. Should it raise a different error (and show a different message) if the gamename is not gta5 ? Why not just wrap the creation in if user input: so you don't need to have the same self.async show form( twice? Would be more DRY. Have you had a look at the EntityDescription as well? See tuya as an example This would make it easier to create those sensors and when you use the entity description, you don't need to set icon, device class and other attrs directly yourselves. You can just pass the description. This will make your code more readable and more aligned to core. Why do you need this? Is the default handle coordinator update from CoordinatorEntity not enough? See my other related comment as well :).
I think this has leaked in from another PR. Apparently yes. No idea why it's doing this but I guess it will continue until I finish that other PR
This logger does not exists This logger does not exists This logger does not exist This logger does not exists This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist This logger does not exist
Would it be cleaner to move this function into the coordinator itself so you could just call self. attr native value coordinator.get aqi value in your init block? Thank you for your review! I ve been working with MartinHjelmare on the implementation of the coordinator for the past few weeks. I feel he s got a clean view on the path forward, so I ll follow his advice on this one. Let's refactor and use entity descriptions instead. We can define a lambda or function and set it as a custom entity description attribute, and use this attribute to get the correct value from the coordinator. Example: L115 Then we can use the same entity class for all sensors. We can create a map between the device control attribute and the description key and look up what entities with what description to create. Oh, so we want a generic sensor instead of two different types? I think I ve seen those descriptions elsewhere, I ll investigate. I just got my intellifire integration approved - we went through a similar process Let's refactor and use entity descriptions instead. We can define a lambda or function and set it as a custom entity description attribute, and use this attribute to get the correct value from the coordinator. Example: L115 Then we can use the same entity class for all sensors. We can create a map between the device control attribute and the description key and look up what entities with what description to create. Not quite sure I followd you on the mapping but I've implemented basic functionality for entity descriptions. How would I type this correctly? If it's optional. If the attribute is not optional we need to define a mixin dataclass with required attributes and inherit from this mixin in our custom entity description class. Search for mixin in other sensor platforms for examples. Setting the value is not optional but the lambda will return either an int or (if the fan is turned off): None , Can we define the descriptions as constants in a container and look up the correct description based on what device control the device has? Ie, define some id for each description that can be resolved using the device control support. I tried to implement this but failed to see how. Let's see if I can figure it out while writing down what I've tried so far. All devices share the same properties but will have one of the has nnn control flags set to true. All devices also have control properties, although only one of them will contain data per device. I played around with an idea of adding some sort of filter while looping through devices and device descriptions, but ended up with a lot of code so that didn't quite feel like a good idea. Maybe we could use this as a key? L114 We would expose ourselves to IKEA changing those values on a whim, but then again it's a quite easy bug fix to implement. For now we could skip the id and just move the descriptions to be constants at the module level. Then just pass the corresponding constant here instead of defining the
This broke, but is covered by test async remove entry now instead. Mock storage instead and assert the contents of that. hass.data is a detail but storage is persistent state that we can assert. L231
We do not allow for sensors to count down, instead, they should return a datetime object when the countdown finishes. s I couldn't find a way to do this, it was removed. s I succeeded by creating a function in the IntegerTypeData class in base.py . But the sensor display is expected to look like this? ![image]( Hehe no it is not, but that means the device class is missing :) SensorDeviceClass.TIMESTAMP Got it, the problem was that even defining the DeviceClass.TIMESTAMP the native unit of measure got in the way. It worked after some changes in sensor.py , please review if it is workable. The sensor when the countdown is off will be unknown: ![image]( But when it's set it will work: ![image]( ![IMG 4551]( Despite not being able to test on a fan, I performed actual tests with a plug. With these tests I think I understood how the countdown works on Tuya devices: it is the time to toggle the device (if it is on it will be off, if it is off it will be on if it is open it will be closed...). This is no longer used now Interestingly, this will result in an "unknown" state. That feels not right either... However, I do not have a straight answer how to solve it otherwise. I will get back to this, after discussing this with some other core devs. I don't think it's ideal either, but it seems better than displaying the current timestamp (now 0). I haven't found if there is a way to set it to empty or idle. Discussion about sensor status being unknown for when not set:
Added fan cool switch to Fan (fs) with name Cool Wind Natural for evaluation after comment in previous PR. discussion r792974132 ![image]( Please rate if it stays that way or take it out. Should this be turned into a switch instead? I only see this possible if I create TuyaSwitchEntityDescription with a key value and change the command submission mode to include that. This would allow sending commands other than True and False . self. send command([{"code": self.entity description.key, "value": self.entity description.key value}]) Do you think it's viable or is there another way? However, I believe that leaving it as select , we reduce the problems in cases where the manufacturers define arbitrary options from the tuya documentation. However, I believe that leaving it as select, we reduce the problems in cases where the manufacturers define arbitrary options from the tuya documentation. That is a good point There is no description on what this does on curtains, I suggest not to add these for now until it is clear what they do. It will be removed. We do not allow for sensors that count down, instead, this needs to be transformed into a timestamp. It will be removed together with the countdown set. That is a bit long It will change to Last Operation Duration . This is more fitting IMHO. Hmm that is the same as above, we should implement support for handling multiple dpcodes on a single description to prevent duplication. Can you show me an example of this implementation for multiple DPCode on a single description? The binary sensor platform has support for this. Although while writing this, my eye spots a bug with that :S Lets not try to solve this right now What does this do? I don't know, the only information available in the documentation is the description. I included so that if there is this control, the user has it. Better take it off? Well if it is not clear what it does, we won't be able to ensure it is represented or described correctly either :) Removed! That is a bit long It will change to Last Operation Duration .
A minor thing, why not? Good point :) This violates [ADR0007]( hmmm didn't consider that, but I understand FYI recently added and face the same issue and are present in the current beta. (they are basically the reason I created this PR - some low hanging fruit that could benefit users) K... looking at 58596 it seems this is allowed... I have opened a PR to amend the ADR.
Please use DeviceInfo() from homeassistant.helpers.entity import DeviceInfo Are there no specific exceptions in the module that you can catch? Broad exceptions like this are not really nice. Are you sure these exceptions can happen? Since you have a broad try catch in validate input that will raise a SlaveException only. Connectivity to these inverters is iffy, and leads to A LOT of support requests. I want to have tailored feedback to the user so that we can document each cause (and possible solutions) This is good, to have different exceptions. But where do you raise them? If you look at your code, you call validate input where you have a broad except. This means that you possibly only return SlaveException to this try catch. Or do you want to catch issues with AsyncHuaweiSolar.create( ? That is not clear, hence my comments. L68-L70 Yes, the AsyncHuaweiSolar.create() throws these different errors. Import from const.py, since it is already there maybe move 0 to a constant a well? Is it possible to have validation of user input for this field? I tried various configurations of voluptuous, but nothing seems to work. What are the possibilities? Would a select work better perhaps, or what would be the validation that you need? It is a comma-separated list of integers. I would like to validate [ d] (, [ d] ) (cfr lines 99-101 where I do the conversion) I fixed it for now by catching the ValueError when the conversion into slave-id's fails. It shows the user an informative error. I think it is fine to have these entity descriptions in sensor.py, but a core maintainer should confirm that. Most of the newer integration I have seen put the entity descriptions in the platform file. Why no device class temperature? I believe these constants have changed recently May be you can reformat a bit,e.g. the suggestion below saves 1 line. You could also consider creating a sub function to reduce the size of the large if statement.

Why not combine this into the existing remove clients?
Would it make sense to add the name as well? (see Somfy zeroconf). This will perhaps be more strict? There is no reload here
No need to check to abort since we cannot get here if there are current entries If there is a device , but the uuid is None, we still would need to call stop() right? Handled in 12ab4c8b4fb84d791b7d9aa07760de75f25cf17e
This will get filled automatically by the DataUpdateCoordinator L77
It is compulsory to have 100 coverage of config flows - no exceptions. Please import and use the Platform enum. Can you create the logger inside const.py as LOGGER logging.getLogger( package ) and import it here instead? You should import and use CONF API KEY constant from homeassistant.const : Friendly name and update interval should be handled automatically by Home Assistant. There is no need to request them from the user. What if I wanted to recommend an update interval? Import constants from homeassistant.const Clear empty keys Use imported CONF constants Make a search for requests mock in the tests components folder, or search for respx if you have gone async. Use class attributes when it is a fixed value. Use class attributes when it is a fixed value. Use class attributes when it is a fixed value. Use attribute shorthand for name and unique id: Use attribute shorthand for name and unique id: Use attribute shorthand for name and unique id: This is the same endpoint that the [OpenWeatherMap]( integration users. L502
Add a TypedDict to hold "value" and "icon" for each dictionary item Use "value" instead of "state" Since these values are static should they have translations? I agree, we should add backend translations here: stringssensorjson This would need the state to become the lower case as well. Better add it now, instead of later (or else it would be a known breaking change down the road). Done and testing Pushed Use int and not str for the status With changing the key in SENSORS INFO to int, this string convert is not neeed Revert the changes here, we do not want a separate function for each platform. You can assert the sensor inside this comment function
I'm assuming the mac is the mac of the outlet device and the index is the outlet number so its stable and won't every change since its physically representing the device. The Mac is definitely stable, and I assume it would be useless design if the index could change
(Optional, feel free to ignore) You can make both of these fixtures instead and then return the config entry. Fixtures can inherit other fixtures as well, so you do not need to call helper methods at the beginning of your tests to set stuff up. Docs: Example: L148 Thanks, your suggestion cleaned things up a bit, especially since I was able to parametrize the mock requests for single vs double bed. This isn't needed It would be cleaner if SleepIQHassData took the coordinators as an argument Make a function to do this that is called in the executor instead of jumping into the executor multiple times for each bed And assert where its used that its not None so you catch errors when its not been set r805184684 These are coordinated, it shouldn't need to call for an update when adding missing typing Missing typing We don't want options to set the interval. As developers we should pick a reasonable option that will not increase the chance the integration will get banned from the service and we should not let users adjust it. If they want additional updates can use the homeassistant.update entity service with an automation to trigger additional updates. Missing typing Set this as self. attr unique id instead Set this as self. attr name instead You can override handle coordinator update to set attr ... from updates r805185163 r805185163 Use self. attr name This is really for strings.json We need a strings.json that is used to generate the translations Run python3 -m script.translations develop to regenerate it. Please use key common as much as possible in strings.json We should mock the pypi package and not requests since at some point the package may no longer use requests We should mock the pypi package and not requests since at some point the package may no longer use requests It would be better to have the fixtures in the pypi package, and instead mock the pypi package. You can write this as a generator expression Same in binary sensor.py
Where will we use this, for what entity type? Is it number entities? Maybe we should add a device class instead and let the frontend take care of the icon? That is probably better, however, number entities don't support device classes at this point. I'd support adding that if we have multiple integrations implementing the same kind of number entities. I updated the PR description to explain better. We have discussed this internally, and are actually in favor of handling these things via the device classes, as this is a frontend concern (not backend). Okay, I'll close this PR. Thanks.
Please remove this, it should not be a part of the PR. Please remove this, it should be a part of the PR, translations are handled separately: Note that HA entity IDs are alphanumeric . . What happens when an entity id is changed in Home Assistant? Thanks emontnemery. When an entity id changed, this integration will not sync its state to Bemfa Service anymore. One need to remove and re-config this integration at this moment. Please add comments to this code to explain what's happening, especially the topic management. What happens if the user wants to add more entities? Thanks! Some comments added. Please update the docstring to explain what the class is or does. Docstring updated. Isn't this a blocking call? Resolved now. Thank you! Is this a blocking call? Resolved. Thank you! We can't make async calls from the MQTT client's thread. Resolved. Thanks!
We no longer allow to provide a configuration option for this. Instead, one can disable the polling updates and use the service homeassistant.entity update using automations instead. Will do, to clarify it is homeassistant.update entity
Should this run in the event loop? I don't think so, it is doing non async IO to the registered devices in order to notify them to disconnect from the server. However since the callback is not async, how can I schedule it in the executer thread? The asyncio transport close call should run in the event loop. The library needs to be refactored so that all library user interfaces for the server are meant to be called from the event loop. If some internal calls in the library should run in another thread, the library needs to handle that. Alright, that seems very reasonable. I will adjust the upstream library to make all push server calls async. MartinHjelmare Alright I converted all the upsteam push server library functions to async. That schould make it a bit more clear. The upstream PR is here: Done Will this run in the event loop or in another thread? It is a async callback from the running event loop, so yes I think this runs inside the event loop. Is that okay? What is the sensor state value for these sensors? It is a string containing the last action event of that device, so: move flip90 flip180 taptap shakeair rotate or l click ch0 click ch0 d click ch0 l click ch1 click ch1 d click ch1 both l click both click both d click (where ch channel, l long, d double, can not be written fully due to char limit in communication to the device). Of course diffrent types of devices will have diffrent sets of possible values. Maybe disable this entity and the one below by default? A device that sends events like that should be exposed through a custom event in Home Assistant. The last event is normally not something we expose as state. I do fire custom events upon receiving the push callback. It is in line 181-202 of the gateway.py file. However I do that using a entity (I setup the entity with the last event sensor and fire the custom events from there. The devices that have last event or last push are buttons that only have the last event entity. The only thing you can do with those devices is push the button and get the event in HomeAssistant. I do not think async added to hass will be called when the entity is disabled right? So how do I register the callback and subscribe to the event withouth setting up a entity? Ok, the entity should not fire the events. That should happen from something that is not an entity platform. I'd suggest removing these entities and just fire custom events, not from any platform. But then a wall swith like this: Will not have any entities and therefore also no device inside HomeAssistant. So a user will have a hard time discovering that such a device is actually supported and used by HomeAssistant. Futhermore when multiple of the same wall switches are used, how do you distinguish between which switch fired the click ch0 event? (Now that is done through the entity id of the entity that fired the event). Is there some documentation on how to properly integrate wireless wall switches buttons that as sole purpose have to fire 
Honestly, I think this needs more thought into the media player integration in general. Source is often misused for this. Therefore I think we should not build on top of it. But we have already built on top of it? the InputSelector trait already does this for Apps(and not just inputs), again, this is adding more natural language support for Google Assistant, not adding something new. I kinda agree, however, I honestly think we should add the notion of app to these entities (or solve that in the future) in some way. And if we do that, there would be a distinction between those. In case the above would be implemented in Google Assistant, it would cause a breaking change (or having to support both for the future as well). Which is not a wish-ed-for situation. If this was opt in(as in you put some more data in configuration.yaml) to enable it for specific inputs(or even just a global opt in), would that be acceptable? No, that would still hit the same concerns. I suppose this derails things a but. But... Many TV sort of see a source (being hdmi1,2,3..) as a channel of it's hardware input application. Soo.. Having a separate application list could make sense. Then we could sort of generalize source to mean channel of active application. If it's the input application, it lists HDMI1,2,3.. If it's the tuner application, it lists channel 1, 2 3.. If it's YouTube, it might list subscribed channels. But, it sort of brings us back to media browser, since you would not easily say switch to HDMI1. Since the list of sources would change based on active application. I was thinking about this more, and for the concept of breaking changes, whatever is done for media player entities is going to be far bigger of an issue than voice commands that sound unnatural(that I would expect almost no one to use) not working in the distant future. Your still gonna deal with the exact same breaking change regardless though, since every source is currently broadcast as an input to Google. Whatever breaking change that applies for InputSelector would inversely apply for AppSelector...
solved with 47bf8ea solved with 47bf8ea Our test helpers are also used by other integrations. When used by other integrations it should only return the value of diagnostics-data solved with b45a26e This key is a bit meh. Can we use diagnostics or data ? solved with a76ce12 I think we need to make use of this more explicitly, as it contains the username, which I think we should not add as the default output (this result is now used directly). I think the goal is to know if it is run as root or not? If so, we should add a flag for that (instead of putting in the name). for now user is just redacted, but if it is just about to know, if it is root or not, than i will change it this way? It only matter if root or not would this be ok? I would: Or (without knowing the impact it has at this point), change async get system info Since it can be used by custom integrations, I don't think we should remove the user key from async get system info , we could make it None during a deprecation period, but changing that should not be done in this PR. discussion r790148992 would work here : 1: I don't think we should remove the user key from async get system info, we could make it None during a deprecation period Oh, sorry, I should have been more clear. I meant adding runs as root or something to the async get system info . Could be me, but my OCD brain is going on this one... hass.data[DATA CUSTOM COMPONENTS] is empty ( {} ) so not really needed to have this logic here as it does not do anything. We should not access hass.data directly but use this: L564 64752 We should use this: L146 64752
We should leverage entity descriptions instead of adding if else constructs here. This should now be addressed. It isn't as your latest commit doesn't do anything with entity descriptions.
I needed to make this change to get the default value of True to apply when no stream is present in the config. Not sure if there is a better way to do this, but then it makes it safe on the next line to always have an ll hls value. This is one approach. Alternative approach is to not set default values in voluptuous schema but apply when you get the value from the schema. Both are fine.
hass system info will be added central with 64670 Thanks! I'll remove it Please redact sensitiv data from the output. There is a helper fort that - [ homeassistant.components.diagnostics.async redact data() ]( L13) Redacted a lot of different stuff available in diagnostics why not using async redact data ? This does the same ;) It does not. It replaces Mac addresses so it's still possible to view the topology ah I see ... the mac addresses are not values, they are keys? On object store level they are keys in order to find the right object, but they are also spread out in many places as values, f.ex what switch a client is connected to or what Mac a switch port has. Since those are used in the integration I want to keep them somewhat intact, that's why I replace them rather than just redacting them. You can see an example in the asserted dictionary in the test
hass system info will be added central with 64670 Thanks! Please redact sensitiv data from the output. There is a helper fort that - [ homeassistant.components.diagnostics.async redact data() ]( L13) Fixed you can just provide the whole config entry, which also adds some additional info like the system settings and if the entry is created by the user, or by discovery... Changed according to your suggestion There is no need to redact the entriy unique I'd, it is nothing sensitive But you should redact the username! Mac addresses are sensitive? ok, that is a point, when the unique id contains the mac Nevertheless, the username must be redacted, too. Done
without the default value (None), I'm afraid the unique id option will become mandatory. I test tonight without the default value (None), I'm afraid the unique id option will become mandatory. That statement is incorrect. it's ok
This should not be added as an attribute but as a separate sensor entity. Would it be consistent then? Now for example valve position also given as attribute. The change just extends it. ![image]( Would it be consistent then? Now for example valve position also given as attribute. The change just extends it. That is how we used to do it. Just because we did it in the past, it doesn't mean we still do. This needs to become a separate sensor entity. I see. So, you propose to create a separate sensor for every Max device in integration. There are could be many of them, for example in large house it could be 20 and more themostats. If we create a separate sensor for every thermostat it mean that we have to match battery to thermostat device anywhere (automation UI etc), right? Would it be still possible to extend an attribute and keep it as I proposed for simplicity? Would it be still possible to extend an attribute No that isn't possible, this new attribute must be a separate entity. Then, it was done alredy in 58699
For Renault I decided to also implement device-level diagnostics. It's probably not very common to have multiple vehicles, but if it does happen it will help to diagnose vehicle-specific issues. Good idea! Added. Can you make the dict more specific?
Can we make dict more specific? The dict here is the DataUpdateCoordinator data. See [here]( L8-L60) for an example of the coordinator data for this integration. This is a complex type which includes dicts from the pymazda external library. pymazda does not export typing info, so I'm not sure how to make dict more specific. Can you provide any advice suggestions? Also, the current approach matches what is used in the sensor platform for this integration. At the very least I think you should make this a dict[str, Any] as you know the keys will be strings. Thanks epenet. Changed them to dict[str, Any] . I'm new to typing in python, so still learning. Same as above, please make dict more specific Changed to dict[str, Any] . This isn't reused? Why not just put that directly into the lambda in the entity description? (Applies to a bunch of more of these). I've converted functions to lambdas in cases where the lambda would be a single line. I was asked in to avoid multi-line lambdas, so I ignored the ones that would be multi-line lambdas. I know the change is very small, but if it is not directly required for the binary sensors I would argue it could (should?) be a separate PR. Sure, I'm fine with making it a separate PR. Reverted this change. I can't quite decide if it is ok to have these as attributes? or if they should they be four separate sensors? Hmm, why wouldn't it be ok to have them as attributes? According to the developer docs, extra state attributes should be "information that further explains the state", which is what I think I've done here. The entity state says that the car has a door open, and the state attributes further explain that by specifying which door is open. I'll let frenck or another review confirm, but we are generally moving away from attributes. If you look at the commit history you will find quite a few commits to "migrate attributes to individual sensors". It's just that in this particular case I can't quite decide... Fair enough. The main reason I made it one sensor is because I thought it would make it easier for users to create automations. If they were four separate sensors then users would have to create an "or" condition or four separate conditions every time. I was also trying not to clutter the UI with too many entities. But if another reviewer confirms that attributes should not be used here, I can change it to individual sensors. Giving my two cents, as i have made a custom integration for Toyota. I use individual sensors for each door. I can see where bdr99 comes from, and I also thought long about what was the best option, as the user probably does not care which door is open, but rather if a door is open. My integration creates a lot of entities for just a single car, 25 . On the other hand, I personally prefer individual sensors over attributes, as attributes are harder to work with in the UI and in automations. (Though it have become easier over the last year). This could be a comprehension Fixed.
We tend to name them xxxRequiredKeysMixin I've updated the names to IntellifireSensorRequiredKeysMixin and IntellifireBinarySensorRequiredKeysMixin There is a missing d in the Sensor class ( IntellifireSensorRequireKeysMixin ) The comment is not necessary. But if you want to put it in please place it above the value fn We don't allow for entities to "count down" time. Instead, the end time should be calculated and returned as a datetime object. I can do that - the actual hardware sensor presents "seconds remaining 100" and counts down as the time changes.... I'll need to update this I guess and maybe go with something like ... timer end time I'm not resolving this yet :) ... I made a change but I think its not correct When the timer is active its returning a time value img width "313" alt "image" src "" When its off its returning: img width "312" alt "image" src "" I'm taking current time - adding the time offset and returning a string with the X formatter. I'm assuming I either am missing a native unit of measurement for times or something so it correctly gets formatted into the locale. Perhaps I should be returning an epoch time or something? The difference here is do I use 24 hr time or am pm 12 hr time X Locale s appropriate time representation. Additionally - because I'm returning two different strings I"m not sure how to format the time correctly ... so the question I guess is there a way to access the "time format" home assistant is configured to use ? Also now that I look at this I think the state class is probably wrong as well since we are dealing in strings... I did a little playing around and got it into a datetime and pull out the current hass.config.time zone which is maybe what you want ... but it looks REALLY bad on the GUI and I'm not sure how helpful it would be. img width "311" alt "image" src "" So I'd much prefer something like: Timer End Time: 7:33 pm or if I was British maybe: Timer End Time: 21:22 Is the 24 12 hr time an option in HA? Searching around it sounds like this is a browser setting? In any case I'm pretty sure you will be able to answer me quickly on this so I'll probably stop trying to figure it out tonight The current checked in code is using US style time ... This entity has a device class, and thus should not have an icon I've been struggling with the fact there are multiple temp sensors with the same icons - I'll prob nix the device class and that way I can use separate icons to differentiate the different temps. Is there a downside to doing this? So, we try to streamline experiences, by displaying, e.g., temperature sensors in the same way. Additionally, end-user can customize if they want. This should be a class attribute (not instance attribute) and use attr attribution : If it should be used on all platforms, maybe also move ATTRIBUTION to constants file. This entity has an device class and should therefore not have an icon I found a bug in the HTML returned by the fireplace in that it doesn't have prope
not sure if this auto-generates from strings.json or if we should fix it
Please redact sensitiv data from the output. There is a helper fort that - [ homeassistant.components.diagnostics.async redact data() ]( L13) Fixed hass system info is added central with 64670, so it can be removed here. Will fix Fixed
It's a bit weird to call this energy when it measures in watts and has device class power. There are a few examples of this in this file and it traces back to a vendor calling it that. Happy to put in a PR to change the default names for them all if you have an alternative in mind. If it's a power measurement I'd call it something with power.
Is it allowed to have multiple classes in a subfolder? Here we just have 3 classes (base, awning, vertical), however later on for climate devices we will have 10 implementations. Could it be that Error: homeassistant components overkiz cover entities vertical cover.py:42: error: Class cannot subclass "OverkizGenericCover" (has type "Any") [misc] is related to this? Try adding an init .py in the subfolder Might be better to cast once as int None or Union[int,None] directly above in executor.select state It will avoid having two casts here and another one below. I didn't know that this was possible! Will have a look and do that for all other cases. epenet Instead of casting, what do you think if we create these kinds of method: get state as int , get state as bool , it will avoid casting and be more accurate (Overkiz returns the type of a state) tetienne I think that would be best yes, even better to do that in the backend library. You'll need to decide what you do with the None values - it might be good to return int None , bool None , etc. in the library, and keep the if None checks inside HA. epenet, the only difficulty is that we don't know this up front. At run-time, we get back a State object with a type (enum) that reflects a type. The reason why we can make the assumptions is because we know that the state we get by key, returns the type we need. (since it is tested and the API doesn't change). In the library, you could add select state as int or select int state which does the cast. And in HA, it simplifies to: Awesome! Shall we do this in a follow up PR? I think casting in this PR is fine, and we could refactor the whole integration dep bump in a new PR. epenet would you have an idea why this mypy error is present? If I cast command to str on line 99, it complains that this is a redundant cast. Argument 1 to "async execute command" of "OverkizExecutor" has incompatible type "Optional[str]"; expected "str" [arg-type] Maybe you need to cast the select command, not the command: cast(str, self.executor.select command(command)) That select command is redundant as well... Thanks! epenet any idea what is wrong here? This is the last remaining error that I cannot seem to fix. The ATTR TILT POSITION parameter is required. The position parameter is required in the service schema. This package seems overkill for the current code. If the state is static why do we need it? If it's a binary state it should probably be a binary sensor instead. The old device class constants are deprecated. We have the enum instead. L50
If we only use the constant in one place the constant isn't needed. IMO, if they are single-use, I don't think creating the constants is very useful. The same would apply to all keys... I'm looking at the code that uses the unit getter . It modifies these entity description constants. That's not good since the constant is expected to not change. I suggest we refactor this in a separate PR before adding more descriptions. If we can't return the correct Home Assistant unit directly from the lambda, we should probably pass the looked up unit (and device class) separately to the entity instead of modifying the constant entity description. The thing here is that the user can change the unit on his heating device and the api will immediately deliver the value according to the new unit. I don't really see how we can fix that. Doing the calculation on our own is not possible unfortunately. You should create a new key default unit of measurement in the entity descriptions to replace native unit of measurement Then you can use update attr native unit of measurement inside the sensors. Ok, understood. Makes sense. I'll create a dedicated PR. please see
This is needed to make the tests pass. It was probably forgotten in the original PR... cc raman325 This has already been addressed in Yes but that isn't merged yet - I can rebase if it gets merged before this one - but I don't think it will cause a conflict. (see 64504) Should the entry diagnostics include the data from all the devices also? I think it's clearer to have only a summary at the top-level, and use device diag for more details.
you can also use entry.as dict() but make sure you redact any potential tokens in entry.data using the redact data helper
hass system info is added central with 64670, so it can be removed here.
Should it be like this instead: Also, why are these needed, isn't it enough to check if the command templates are set? Did some rework This doesn't seem ideal, wouldn't it be better to send the options in the same message, otherwise we turn on the siren first with wrong volume and tone? As an example, sending the options in the same message is expected by zigbee2mqtt: s siren I changed the whole set up. Left one command and state topic with json support. Why is this needed, is it not done by the base entity? The support flags need to be set, else the base entity will filter the service call parameters. For sirens that do not support duration or volume level setting, these flags can be turned off (default ON). This will remove the corresponding state attributes from the entity. The default is now SUPPORT ON SUPPORT OFF. The support for tones will be set to on if a list of available tones is configured. The base entity does not support storing state attributes for tone, volume level and duration at the moment. Is it maybe a bit illogical that we can parse a JSON message without specifying a template, but we can't send one? We could produce JSON by default and remove the payload on or payload off config parameters. command template and command template off could replace payload on and payload off and can be used when the standard JSON output needs to be customized. If have updated the code so that publishing JSON is the default. payload on and payload off are still used to assign the state to publish. We could use super() here since there's no confusion about which parent init method to target. I'll have a look See
Should we ensure a list here instead? That way, we don't have to check for isinstance(pin, list) in the code processing this value Wouldn't that break backwards compatibility with existing users? No? It would just ensure the output if this configuration parameter is a list, one can still use a single value string value. Search our codebase for cv.ensure list for a bunch of example usages. ensure list wraps it in a list if it's not one. It doesn't enforce lists. Ah thanks for explaining, wasn't aware of a cv.ensure list , thought you meant using [str] . Will make those changes. Fixed in Use not in Fixed in Secure devices pin when used with the cloud integration can still be a single value. You need to update homeassistant components cloud google config.py to make sure it returns a list.
I suggest you create a button entity instead and a binary sensor that represents the active state. I force-pushed to start over. Looks like this function isn't needed. it is used. build entity is used in async setup entry Yes, it's used, but it isn't needed since it just instantiates the entity class. We can do that directly in async setup entry . agreed I also removed the await . it's not necessary for the button entity since we don't call the API on creation This function isn't used. Is this really a proper device class for this action? Does the button restart the device? good point. While it does "restart" the domestic hot water heating what's meant with ButtonDeviceClass.RESTART is probably a restart of a device. I'll rather not set it then.
You're mutating the source dictionary. Make a copy instead. oh nevermind, that's the output.
It's already available at self.registry entry would it make sense to fetch this once when self.registry entry is set ? It's set by EntityPlatform before adding the entity and by Entity which listens to updates. We could memoize the value here based on the id of the registry entry maybe? Isn't this double? Fixed in 4a32a28 Shouldn't this be the first check ? Fixed in 4a32a28 Can you also add a test to rename the entity ID and something random like the name in the ER. We discussed this on Discord, it doesn't add much value. Many integrations don't bother calling super().async added to hass() , meaning there's a big risk this won't be called. It's better to do the unit ! check first, it's faster and most of the times it won't be different. Shouldn't you just store the entry here in a var so you don't need to fetch it inside the disabled by if ? This can be an elif ? Why is beard second not an error ? Oh I guess that entity registry doesn't know about valid sensor options. yeah, that's right.
There never was a version 0. This is unrelated to fix a flaky test? Fine to include it I guess. let's move this to a new method, update entity options(domain, options)
This is currently a set. Can we guarantee that the same device can't be in two different config entries of the same domain? Maybe we should always return the same top level data structure for the same type of diagnostic? Should this be an enum? Add a return here instead of an "else" spanning rest of the function Should we allow specifying the config entry device combination instead? I can't think of a use case where a user wants to have debug information about both Unifi and Z-Wave JS. So the url for a device could be diagnostics config entry config entry id device id when you are on the device list coming from an integration card, the URL includes the config entry ID, but when you click into a device, the config entry is no longer in the URL. So I guess it depends on how we want to expose this in the UI? if the action to download the device diagnostic data is on the device page, would we have separate actions for each linked config entry? I am planning on re-doing the UI once we add device support to be a dialog. Users will be able to pick config entry filter by device. So the url for a device could be diagnostics config entry config entry id device id should we make it diagnostics config entry config entry id device device id ? As in would there be any other diagnostic types that lived under a config entry? Sure that's fine. It doesn't really matter, it would need a frontend upgrade anyway 1 400 (bad request) it needs to be optional. We should still be able to et config entry data too. Use extra urls to add extra mappers. I split these into two views, but was not aware of extra urls which allows us to do it in one I know existing code, but let's do 2 You only need to check info[d type.value] if there is no subtype. let's just return the web response for the config entry here. Are we creating a device here? How will that be used? The test needs a config entry and a device to be able to reach the platforms async get device diagnostics method. Else error handling will return a 404 Right, but I think that these helpers are now too broad for their main use case which will be other integrations testing their returned state. Those integrations should test the diagnostics by setting up the integration as normal and using this test helper. I think for testing the core diagnostics integration here we don't need this flexibility but can create the mock device explicitly. even for the first helper, the right way to do this for testing other integrations would be to provide the config entry right? So the domain or config entry logic only helps for the diagnostics tests (domain should only be used in the base integration tests), same with not providing a device ID. I think we may as well update both helpers if we want to address that concern Yes, that's what I'm thinking too. If we want we can add an internal helper just for this integration. I don't think that's needed until we add more features that require different sets of tests. As long as we just add n
This one is a bit different than usual since we need to pass it off to the discovery library since it can efficiently find devices running the protect app on unifi-os. For most other integrations just finding the device is sufficient, but for unifiprotect, we don't want to present discovery for devices where the unifiprotect server isn't actually running on the unifi-os device since we can't assume that even though they have a UDM PRO that they have the protect camera service turned on This could be a callback since we don't await inside. Thanks We don't use hass .
This looks quite hacky. Would it be cleaner to have a separate class for connectivity sensor (extending SIABinarySensor ) that would override this method? I'd recommend not using the common device classes for unique id suffix as the integration is not in control of those. It's better to define our own strings that the integration can control for unique id. good one! For clarity. Looks like we can abstract the unique id for all entities here to use entry id, account, zone and description key. So we can move the definition to a common place. moved all the logic for unique id and name into a function, without making changes to the result, so non-breaking I'd pass the config entry to the entity instead and create the unique id and name here in the base entity init method. We already have all the other parts needed. good call, that allowed a lot of cleanup! It doesn't look like we can get the ping interval like this.
Any reason to not use attr here? Code reworked I think this part should be in the number platform and not here. Removed Fixed Renamed Fixed I don't think we should continue to add platforms without tests. Besides the climate platform which merged without tests all our last added platforms - device trigger , logbook , button added with tests. I don't think this is a issue, we can always add them later. Isn't it ? Simone All the consts defined in const.py should be properties of the entity description, extend the BlockAttributeDescription to something like NumberAttributeDescription to contain the min max step mode Let's see if the approach I used is what you expected NUMBER ENTITIES[self.wrapper.model]["min"] This doesn't look good and will not work when we want to add numbers for other devices, I don't think the entity should have hardcoded properties by device models. How will it work when we want to add another number entity for the same device? Fixed We should find a better way to eliminate this part This is what I asked for in discord ;-) But as nobody answered I though to start the discussion submitting the PR. Simone thecode what about ? Simone New approach fixes this code block Currently with the single number entity defined which code path takes place? L106 path is coming from NumberAttributeDescription , it get's completed with channel number only if blocktype ! device . I think that there is an inheritance issue with the EntityDescriptions. I think that NumberAttributeDescription should inherit from both NumberEntityDescription and BlockAttributeDescription , and then min max step will be handled automatically. I also think it should moved to number.py to make it clear it only applies to the number platform. Maybe this should be passed as a Callable[[RegistryEntry], BlockAttributeDescription] so that the NumberAttributeDescription doesn't have to be inside entity.py Is the unit of measurement still needed? I'd have thought that would be handled by the entity description automatically. I don't find it as part of ShellySleepingBlockAttributeEntity or NumberEntity It's part of the base Entity: L394-L401 It is part of the base entity: L308 Suggest to just remove it:
Note that this is very basic since the tests for this integration currently use requests mocking which should be replace with mocking the library instead. Refactoring that would be quite large and way beyond the scope of this PR. I'm planning on doing some more cleanups to the underlying library before I get there.
I'm not sure why this had to be done, it was working without as well. I've done it only because some tests were failing. Has to be done for zcl compliant devices. Xiaomi sends updates regardless. I have no idea if value 1 is correct. 0 was failing, so I wrote 1 . It's the number of attribute reports the tests expects and entity shouldd receive. 1 is correct for your test
could you please add those sensors to GLOBAL SENSORS? we don't separate the sensors by heating device type but by how they are structured on PyVicare. could you please add GLOBAL SENSORS and then add this sensor to co GLOBAL SENSORS? we don't separate the sensors by heating device type but by how they are structured on PyVicare.
I think commented out code should be removed Comment needs rewording Remove this here and set this after you have done the async config entry first refresh() . You can also import the SCAN INTERVAL in your Data Update Coordinator? Is there a specific reason why you would pass it via the constructor. Not required and perhaps not directly for this PR, but you could implement a NamedTuple to type this data. This will also make it easier to access this data in your other classes. L44-L49 I have been thinking about the data dictionary i use today and this is nicer. Since I'm planning to implement more platforms (camera perhaps some service to pause abort a 3d print) I'll probably refactor this in a later on. There is no need to implement this one if you catch the exceptions like (TimeoutError and ConnectionError) above and just set errors["base"] "cannot connect" in that situation. Would you find it better to skip the try except block completely inside get printer info and catch (TimeoutError, ConnectionError) when calling get printer info ? Does this work? I haven't seen this before, thus not sure if this is an accepted error. Would be good to have someone confirm this. Normally they are like: . We can read in the dev doc: If something is wrong, you can return a dictionary with errors. Each key in the error dictionary refers to a field name that contains the error. Use the key base if you want to show an error unrelated to a specific field. The specified errors need to refer to a key in a translation file. And i thought that if it's not possible to connect to the printer, then the user have entered wrong ip, and thus the error is related to ip-field. already done below. You can access the printer object via the coordinator. No need to store it here. Instead of making classes for each sensor to handle the native value and available methods, use SensorEntityDescription s. You can add a lambda to those that would handle that. It would greatly simplify and reduce the amount of code needed. You could, for example, look at the tailscale integration (which does this). I guess that i was looking in some older integration. Thanks for pointing me in right direction. You could define these as fixtures and add them to conftest.py instead (same to other fixtures below).
Usually ( git grep RequiredKeysMixin ) these are done as more flat structure that keeps all the key values at a single level. Thanks bdraco , I'll change it. Normally we move code out of the try block that isn't expected to generate AttributeError Better like this? Yes. Personal preference would be to refactor to avoid a try except here, but thats not a blocking issue Do you have a suggestion? I removed using has attr to verify the existence of the attribute, should I create a second method to check its existence? Maybe something like Done, I also did the same changes to the sensor platform that got merged earlier tonight
You could add a value fn lambda to the entity description, removing the need to do all that getattr magic stuff. Sweet! You don't happen. To have an example at hand? search for value fn tailscale maybe? Easy enough :) When can the AttributeError happen? MartinHjelmare i changed this afterwards. There is no longer any try except. It was if the attribute wouldn't exist
Why do we need to check this? This is the function block of the data on my device: The colour data hsv block doesn't have seperate values for h , s v , so I was getting a KeyError without this. I tried with the following but since the hue value is 0-360, not 0-255, the colour wheel broke If you've got a better idea I'd be happy to hear it, I just went with something I felt would have the least chance of breaking other devices. The colour data hsv block doesn't have seperate values for h, s v It should have that. Did you report this issue with Tuya? As this sounds like an issue bug upstream.
Why do you inherit from BinarySensor in sensor.py? Are you creating a sensor entity or a binary sensor entity? Looking at the other code, you should have created this in binary sensor.py. Your are right. I've realized I directly implement the binary sensor platform. Haven't noticed that in the docs. Thanks! DONE! Remove str and None. I don't see when this could be returned in this case, thus the type doesn't match. Since I am overriding the parent class definition I am just keeping the super method signature. This seems fair to respect the [LSP principle in OOP]( although the return type hints can be an exception in this case. Thanks, I wasn't aware of that! epenet what do you think, as typing expert? Both work, but the recommendation within HA is to keep the return type as tight as possible. So I'm with iMicknl on this one Alright then, message received. I've tighten the return type hints as you suggested. Remove None. I don't see when this could be returned in this case, thus the type doesn't match. See above. Done! I don't think dynamic icons are still allowed in core, but a core maintainer should confirm. I don't need this any longer as the binary sensor implementation cover this already :) Thanks again! DONE! Maybe you should throw PlatformNotReady here? However it would make more sense to move this to init perhaps and throw ConfigEntryNotReady. In which situation can this be None and how can the integration recover from this? This is None when the Elmax cloud reports the panel as OFFLINE. Having a panel in offline state does not necessarily mean that the integration is not ready. The current implementation of the coordinator holds a NONE value (as data) in case the cloud reports the panel is offline. Notice: the integration is ready (the cloud is responding correctly), but the panel is offline, so we cannot retrieve updated state of the connected entities to that panel. As soon as the panel gets online, the Coordinator will hold a not-none object (panel status), and this if-statement won't be entered. I hope this clarifies things a bit for you. If the panel is offline, shouldn't you mark all relevant entities as unavailable? attr available ? And that's exactly what already happens [here]( L172-L175) :) Please note, once again, that the discover new device() method is called by the coordinator at every update. The method is invoked regardless of the the online status of the panel (as it's issued against the Elmax cloud) but the panel-data is only available when the given panel is online. That is why we need to check for null values here. How unique is your unique id if you need to double check here if there are no duplicates? This has nothing to do with ID uniqueness: in fact this integration does provide unique IDs. The portion of code you referenced lies in the discover new devices() method. This method is registered as a listener for the data ElmaxCoordinator . So, everytime the coordinator updates its data, this method is executed. This 
with from homeassistant.const import Platform d774b4c A good change, for a follow up PR or here, could be to add a class that describes the hass.data[DOMAIN] like tuya does. L44-L49 Than you don't have to type it here and use a string import to define the coordinator key. Good idea. As this is a bit out of scope for this PR and it also has to be implemented in sensor.py , I think it is better to make this a separate PR. I think we can remove this abstraction at full, as there is nothing else added to here (it just adds another unneeded dictionary at this point?) Like this? I think Frenck meant that you create a dictionary with a single key ("coordinator") and thus don't need this. You could just store it in your hass data directly, without first creating a dictionary. hass.data[DOMAIN][entry.entry id] coordinator I see, nice! Completely overlooked this, it was a dict as some other values were stored here before but it should have been removed indeed. Updated it here (994001b). But it also changes sensor.py which is a bit out of scope of this PR. If desirable, I can roll back the change and open a separate PR. Wouldn't this be the same? Not 100 sure. Yeah, it is quite redundant. Thanks! this is duplicate? The entity can already access the coordinator everywhere, so no need to store another reference to the same thing on a global level. This is a proxy method (probably to fix typing), but that is handled by setting the correct coordinator above This can be set directly in the constructor by setting self. attr device info Feels a bit weird, that if the entry title change, the entity name would change as well? How are switches named in general? I've tried "{entry.title} On" or "{entry.title} Switch" but that also feels wrong. usually device name entity name (if provided by the API). Otherwise just an entity name Switch Added Switch name to entity c93f798 Why is this converted to a bool? Isn't it a boolean? self.coordinator.api.state.power on is an optional bool, as state is optional. State is already checked to not be None by the setup. Can we do this better? is an optional bool Right, than it is correct now This entity has a device class, thus should not set an icon Isn't it a boolean already?
We can remove this as this was to get first version of favorites media source working.
I think that just this change would be enough together with pvoutput would just work out of the box then. Alright, lets do that. My other brainfart doesn't work out anyways, so this would be the best option.
Does defaulting this to 0 do the same thing as making keep false? If so, could keep be eliminated and just use days back? Or if you think there's a reason to retain the keep false, would it make sense to make the default at least 1 so that when keep true, it does something? Not quite. Maybe we cover this better in the docs? keep False , daysback 0 will result in your e-mail sensor being set to None one a subsequent IMAP query. keep True , daysback 0 will not set your e-mail sensor to None and instead "keep" the previous e-mail. Yes, it wasn't clear to me initially. Stating in the docs that daysback defaults to 0, and the meaning of that, could help people understand. Thanks.
It probably doesn't matter here but you could make this a constant and then unpack it below with a will address in other PR I think this will work without the () s
Normally we would call this async launch Maybe change this one as well to async search . But thats existing so maybe a followup PR? noted will do in followup Would be better to encode this parameter using urllib.parse.quote as some services like Spotify uses colon on their deeplink ids. For example spotify:playlist:5xddIVAtLrZKtt4YGLM1SQ that would force the HA user to encode manually it before adding to the UI.
CoordinatorEntity sets self.coordinator . We should use that instead This looks like the same as lock.py . We should move it into a base entity class to make it more DRY. Lots of examples: Good suggestion. Coming up shortly and will make another PR to change lock to use same base entity Should this be multiple sensors? There can and most likely will be multiple sensors as it's door contacts and one would have more than one door at home. Does it make sense to have a binary sensor entity per sensor? I'd assume users would want to know which door window is violated. Not sure what you mean here. If I have two door contacts I would like to have two devices binary sensors so I can see which of them is open or closed. Sorry, I'm doing a poor job of explaining what I'm looking for. Doesn't make sense to me either after sleep. I'll start over. Can we make a dict when the coordinator updates with {contact["address"]: contact[" state"]} so we don't have to do a linear search for each sensor (only once to build the dict) and can do something like? return sensor map[self. attr unique id] "open" ? You can drop this and use self.coordinator everywhere since CoordinatorEntity will set it When I do this I can no longer reach yale as in self.coordinator.yale which is defined in coordinator.py But I don't understand why and therefore left this in here to set it explicit. using self. coordinator Ok, got it but can't remove it unless I change the lock and alarm panel at the same time so will submit it for new PR, or we just do all of it in this PR? It's fine to do here You should be able to drop the bool since the comparison already returns a bool Since you are building a dict you could put it inside here
Minor: Got an extra . that isn't needed. One thing that was confusing when I was testing this out is what value to use for the assignee. We might want to call out that this is the full name of the user, e.g. Dave Smith . I was confused as well that the attribute is full name but it seems not be always the full name. How did you create your Todoist account? Cause with our Google SSO accounts it's not the full name but the part infront of the . In my case kai.bepperling whereas Kai Bepperling does not work. So i assume it hardly depends on the way you created your account in the first place So maybe a more generic approach to make the user look up the username in Todoist ? e.g.: A members username of a shared project to assign this task to. I signed up just using an email address, so you are right there is a difference based on which signup method was used. The generic approach seems fine to me, it might be worth going into a little more detail in a docs PR for the component. Have you created one of those too? If not, it would be worthwhile to update the docs there with this new attribute for the service: I have it on my list to update the documentation as well. I think its enough to describe the process how to get the usernames. Will open the PR this weekend. What bothers me with the current implementation is that you can add an Assignee even if the Project you entered is not a shared project. It would be nice to have the project list as a dropdown and optionally give access to a list of members. But I think that's for another PR, as it is quite a refactor. We should lowercase this so that it matches as expected regardless of the case the user entered. I didn't think this was working until I tried my name in all lowercase, then the task was created successfully with my user assigned. Oh yes I missed to add that again. Will do so.
I suggest conf.get(CONF TIMEOUT, TIMEOUT) , unless you make it compulsory. I added this and increased the default to 50. 8 minutes? Isn't that a bit high? It defaults to 10 seconds from the upstream API library for Influx V2. Setting this to 30, maybe at max a minute. Care to define share reasoning? I honestly just added a 0 to make it work and 50 didn't work on my machine or at least errored that time. I might have messed up something else while trying though. If you prefer 30 I can try that again. Also, the golang package (which I used to carry out tests outside of home-assistant) has 60 seconds in the example in the README See below. 30 is still to low This seems wrong, as this now because 10000 seconds for InfluxDB v1 1 second 1000 milliseconds; You've just converted into microseconds, that doesn't sound right? There was a 1000 here before and I was told it was expecting TIMEOUT in milliseconds here while the v1 section expects seconds. I was trying it to make it use seconds everwhere in v1 and here in v2 . If it was 1000 before, that would mean changing it to 1000000 . Sorry if I misunderstood. I think it would make sense to just use one unit for everything? Before this PR kwargs[CONF TIMEOUT] was set to 5000 - apparently, meaning 5000ms or 5s Now you set the same variable to 10000000 - i.e., increase it by a factor of 2000. It doesn't seem right. Even if you changed InfluxDBClientV2 to expect seconds instead of milliseconds (which you didn't), you would need to send 10 there instead of 10000000. :) The 1000 was already converting seconds into milliseconds. That conversion was already done, you don't need to change this code at all. you don't need to change this code at all. Ok, changed it back then. Black and flake8 want two spaces before an inline comment. Make this and it should be good to go.
I don't see any await call in this method. Is this property setting doing I O ? If so, should be sync method turn on . Its async safe as its using an asyncio.Protocol under the hood its passing it to the transport. Its fire and forget since the response will come back as a callback
Use constants for platforms definition: done Are you sure you pushed your changes? Vip0r. I wanted to give it another review, however it seems that not all current comments (that are dismissed) are addressed. Define LOGGER in const.py and import it here and in sensor.py done I suggest renaming the class to something more custom to your entity ( VartaStorageEntity ?) done Limit the try except block to the result fetch done User constants from homeassistant.const : done Your tests use the default test data, I guess you did not edit them. It is required that you at least test 100 of your config flow.py as per [development checklist]( Fully understand this requirement. Unfortunately i do not really understand what it's needed. Could you please point me in the right direction? What can i do to perform the unit tests (after adding the real values for host port in the file?) If you are using the [development environment]( as advised, you can [manually trigger]( testing-outside-of-tox) the tests for your integration with The requirement will be fullfiled when you get as an answer In the test config flow.py , you will find many patch context such as the patch context lets you change the output or behaviour of one function durint the execution of the context. You can use this to force your hub.test connection() to raise CannotConnect and thus confirm that your config flow.py does raise this error in case of connection error. Similarly, the test form method must check that the config flow works correctly if everything goes well during the entry setup. In your case, you can completely drop the test form invalid auth as there is no authentication involved in your entry (and thus you can remove and the InvalidAuth class from config flow.py ) I hope this helps you! Wow, thats awesome and helps a lot! I will do that and get back to you done On connection error, you should [log a warning rather than an error]( silver-). done Move the coordinator into the init .py Hey Frenck, could you give me some background for this change request? As i forwarded the setup from the init .py to the sensor.py i thought it would be the right place to place the coordinator. Of course i will adapt the code according to the needs but i am not very sure how. Do i need to pass the coordinator object as well from the init .py to the sensor.py? When done in the init .py the coordinator can abort the setup of the integration and hint Home Assistant to automatically try again (e.g., when a temporary connection issue occurs). Additionally, if one is adding other entity platforms in the future, that would be easier as well. Fully understood now - thank you. I will implement all recommended changes and commit again if i am done. moved the coordinator into init .py As the brand is "Varta Storage", the domain should be varta storage to match our standards. Please adjust the domain name, and the integration folder names accordingly. adjusted as recommended. Thanks for your feedback! This method i
I could do lambda s here for getting and setting the value, but it will significantly increase the size of this. I'm on the fence if its a good idea on or not. I don't think I've seen lambda used for switch platform yet with entity descriptions atleast, just value fn and some button press action. I'm not a fan of dynamic set getattr as it's less concise. maybe id opt to keep logic in method but check key and specifically get set the attrs. less magic imo but then I guess lambda would be slightly cleaner implementation maybe I adjusted it to use a value fn and a set fn nice guess it's just docs now then? I think so. Waiting for bdraco I normally leave docs to others but it was basic enough I approved and merged for you so you can start on this ones docs Thanks. That one was a pretty simple one :) was just noticing double Description here. Oops! Good catch. FAN SWITCHES We can drop the brackets and make it a generator expression instead of a list comprehension.
You need to add a type hint here to pass mypy. Done I don't think we should default this to 0.0... its means you all of sudden haven't used energy anymore when an issue occurs... which isn't true. Removed default 0 (which means None is used). Just copied this bad code from another place. Shouldn't the energy attributes from the parent class be removed? That is what I thought as well. - Then it is a breaking change - Also I do not know where the current energy in watt should be, in the energy sensor or in the original entity? - Also there are separate entities for current and voltage, should they as well be grouped in another way? The fibaro devices have quite a different structure than we have in HA, so it is quite difficult to change here something. Then it is a breaking change Yes :) Also I do not know where the current energy in watt should be Energy in Watt? You are mixing up power energy now Anyways, so, the current power w and today energy kwh from switch.py are deprecated and both should be extracted into separate new sensors (and removed from switch.py ) Also there are separate entities for current and voltage, should they as well be grouped in another way? Each data point (including current and voltage) should become its own entity. Entities can be grouped into devices, which this integration currently doesn't seem to implement? Ok I removed the attribute current energy kwh from other entities. Also I fixed two other things which have been wrong, namely I set now a correct unique id for the energy entities. Also I changed the callback mechanism as now more than one fibaro entity can have the same id (this id is the id given by fibaro to a fibaro device).
Do we need to cleanup anything in self.data if the entity is renamed disabled ? If so we should probably do something in async will remove from hass Probably a good idea. If the entity no longer exists for some reason, the view will fail. This doesn't look like a valid sensor device class. We should use the SensorDeviceClass Enum for device classes Use the BinarySensorDeviceClass for device class Please import async track time interval as normal instead. Accessing the event helpers on hass.helpers is legacy. Looks like there's a possible NameError here for instance if request[KEY AUTHENTICATED] is truthy and entity id is None. So, you actually stumbled onto an incomplete feature. haha. The original intent for this view was to require entity id access token if not authenticated or NVR ID Camera ID if authenticated. That way unauthed can be used for push notification and the like and authed can be used later for a Media Source that exposes all of the previous events for playback on supported media players. I was never actually able to get the auth part to work though. request[KEY AUTHENTICATED] always seemed to be false. Do you know a similar view that can do authed requires I can look at? To refactor this one to work the way I actually want it to. Sorry, I don't have that current. I'm not super into our web server code. I've asked for some more eyes on this code. You can also ask on discord. I will do some more digging then and take a second crack out figuring it out. Ah! I figured it out. I assume HA does not have cookie-based sessions. So, I cannot just hit an API URL and expect it to work authenticated. Tests using authed client works as expected. Why don't we inherit ProtectDeviceEntity ? It is to prevent a multiple inheritance issue. EventThumbnailMixin and AccessTokenMixin are both inheriting an ABC so none of the ProtectDeviceEntity functionality gets duplicated in them. In ProtectEventSensor I actually explicitly call a method from this class so to override a ProtectDeviceEntity as well. Scratch that, that is in the refactor PR. I can see what I can do to make this class inherit ProtectDeviceEntity as well. Adjusted in the ufp value PR since I already was changing around AccessToken EventThumbnail classes. Will get the other 2 in a separate follow up PR though.
100 test coverage is required on config flow. Please adjust this to the list of files that are not covered. Done, I added an API call in 6d068974 after I opened the PR and did not re-execute my tests. If I had done so, I would have noticed the non-mocked API call which resulted in an error during test execution. This has been fixed in 0f27cf72dfed85a4506f21ee9af7a7d36febf14f. Sorry for that! You ned to adjust coverage.rc to be file specific not the whole folder. I don't get it: .coveragerc serves to omit file from coverage analysis, but i do have a 100 coverage so what sould I exclude? The file you are commenting is not .coveragerc but .strict-typing where I specify to mypy that all files in my integration are strictly typed. What I my missing? Which file should I be adjusting and in which way? Thanks for your help! Doh sorry my bad! This is fine. list[Platform] Fixed in 5467619f0fccbab11588224ced48928e629552f5, thanks! You should move these two lines out of try into else statement. Fixed in 6cd945738e66a249e8691c243d817e869028b682 I am not sure that gpstracker is the best domain to use. Maybe invoxia or invoxia gps is better. I initially planned to name the integration invoxia but this is a registred trademark (hence the I use everywhere) and I do not wan't to let anyone think this integration is official. This is why I came up whis another domain but yeah, I have also troubles with gpstracker , it gives the impression that it will support GPS Trackers from many different providers... Do you happen to know if there has been issue in the past with integrations named after a trademark without the manufacturer approval? Please adjust the domain to invoxia . The current name chosen doesn't match the manufacturer and thus doesn't identify correctly. Also, gptracker is a generic term, that might be misunderstood (as this is not a generic integration). Ok this is done in d6da24e68fa6a8d0a80d96e9d9b2aea61a010d63. I still need to update documentation and branding. If it is compulsory, don't use .get() (same for password) Fixed in 6cd945738e66a249e8691c243d817e869028b682 I think it would be clearer to use the same pattern as async step user. Return early and unindent below Fixed in 24518a7f076a94df654839d18d75a5cf1e65b362 Import folleg from const.py Done in 24824a7206c5ad4c9a01d44d198eac07170d8184 I think you should look at attr shorthand attributes here. Done in 5429434ddec5970aeec5ce97b6e2ba6592e1dc5e This file should be removed small duplication here Please at the quality scale in a follow-up to make this PR as small as possible. Should the username always be lowercase? If yes, you could use vol.Lower in the schema Please use the new [icon translations]( instead

The -SENSOR postfix is to not break existing users is unique id migration not an option? hum guess that would only cover the config entry not specific entity. guess we have entity registry.async migrate entries. not sure if it's worth it here or if itd be easy to detect needing such migration depending on custom component. It's possible but there isn't much value in taking the risk of a migration if there isn't a conflict yet
maybe just verify native unit of measurement here 4b3891a1bc3bef7bb9134bb3fe64be5cb4103a1c
You can save some indent by reversing the condition and return, then outdent below You can save some indent by reversing the condition and return, then outdent below Doesn't work. It doesn't update anymore then (no idea why). But I changed approach and removed this block completely. It works. Just my if above which didn't work... CONF USERNAME doesn't look like its expected here. This should be the unique identifier of the device Sorry. Good you catch it. It's supposed to be the username from the entry data. Whats going on here ? Jammed is a valid state for the lock platform. properties I could not verify the returns from the api to trust it's jammed so I removed it again until I can do. If the coordinator is the only thing ever stored in the hass.data[DOMAIN][entry.entry id] , it can be stored directly instead of making a dict I agree but it would affect also other platforms. Should we then incorporate that here in this PR even if it's not about the lock platform itself? Let's leave it for a fresh pr Should we raise HomeAssistantError here with a message so they know why it won't unlock? Should this raise? It's only there to make mypy happy. If yale could not load in the coordinator then the coordinator would raise errors during loading of the integration and this check is of course then pointless. Got another recommendation from Martin on separate PR so this now checks typing and asserts That's much better. You could drop the if type checking since there is no circular import here and it would be a legitimate implementation error if it was missing at run time that would be good to report. It's only there to make mypy happy (as if yale is not available it will already raise an error from the coordinator) and a recommendation to use this syntax instead from Martin in the 63672 PR My preference is to not use if TYPE CHECKING unless it's strictly needed since I want the code to always tell me when there has been an implementation error even if it's at runtime. It's not something that should block this though Thanks. I intend to clean this up further in upcoming PR.
teh - the You should probably drop this to debug . HA will log any errors that occur. - updating this now. This doesn't look like it meets the [requirements for a unique ID]( unique-id-requirements); in particular the comment on safe intellifire name suggests that it is changeable by the user. Thanks for this catch! I had tried to use the serial number at one point ... working on making that change now. Would be nice to do a poll here and raise ConfigEntryNotReady if it fails (similar to the check you do in the config flow). Nice suggestion. Added! Same comment about unique ID requirements Updated the ID stuff to pull from the serial number. So this should now be OBE. I don't think this is the actual string you want in the UI, is it? I removed it. There's a linter that gets mad when you use a brand name in the title. You should just leave it out and it will use the title of the integration. Can you move this class to a separate coordinator.py module? Don't set device class to None. Just remove the argument. You should drop the if statement and add a lambda property to the EntityDescription instead. Dont use relative import for ConfigEntryNotReady It should be a list of Platform, and should only have a single platform Where is this used? It should return bool, or bool None. Can you also replace Any with the real type of the api? I don't think you need to create a constant just for the key if it is not used elsewhere. Dont ask for the name. Keep the flow to minimum and then users can rename in the UI Move this to const.py and use package instead of name
Has this been run through black for formatting? Yes (Otherwise the tests would have failed) Please break long strings around 88 characters per line . Black doesn't do this automatically. Doing this check outside of the function call would result in easier-to-read code: Is there a way to test this with mean , min , max , etc populated? No. There are only hourly data, so no mean, min or max are available
This does not match our Unique ID requirements, see: unique-id-requirements Name cannot be part of the unique ID, see unique ID requirements here: unique-id-requirements Same as above same as above
Please add a space. We could use the BroadlinkLB1UpdateManager to avoid duplicate code. Done, both lights use the same manager now.
I'm not sure how to deal with translations. Is there anything I should do? You need to change strings.json instead of this file, the translations are automatically generated once merged. For testing purposes you could edit en.json as well. Thanks for the information. Updated accordingly. This should be vol.Required , it will always be in user input (and you assume that also below). Changed as requested. Ah, nice. Thanks. I'd rather use a selection form here for the transport protocol to use. The default should be the standard dsmr protocol and the user can select to change to rfxtrx protocol. That way, if more protocols are added in the future to dsmr we can just extend this list of protocols. Even better would be if we could autodetect the protocol to use. Auto-detect is a bit confusing maybe (in this case)... Currently, this is the first step of DSMR: ![image]( I think adding a third option to that list is the most transparent we can be. Rfxtrx also needs the choice serial or network right? Oh, right. In that case, auto-detecting sounds like a better option. Looking for some guidance here: how would I go about auto-detecting this? Just give it a try with the regular DSMR protocol and it that does not work (times out?) try again with the RFXtrxDSMR protocol? Should the result of the auto-detection still be recorded so that we can make the right choice in one go afterward? That would indeed be the approach Updated the code to use auto-detection instead of a boolean config item. Please only wrap the line that can raise in the try... except block. Move this up out of the try except. Sure, updated. Instead of adding an item just for rfxtrx, I suggest we name all the protocols and store which protocol to use. If another protocol is added we can then use the same data item. Yes, that makes sense. Do you have suggestions for naming? Would just DSMR and RFXtrxDSMR work? Or does DSMRProtocol and RFXtrxDSMRProtocol (just like the names in the dsmr parser library) make more sense? Those names sound ok. Updated code to use CONF PROTOCOL parameter which is either DSMR PROTOCOL or RFXTRXDSMR PROTOCOL . Please move it up out of the try... except block. Changed as requested. (IMHO it looks worse this way, since the cohesion between assigning the protocol variable and invoking the validation function is lost. To me, it was more clear what is going on when those two lines are adjacent. For the try except block it makes no real difference.) Updated as requested. We prefer to avoid ternary operator expression if it spans more than one line. Changed it into a separate if else. Please block till done after all configure calls that lead to a create entry result, to make sure all tasks are finished before we exit the patch context manager. Use hass.async block till done . I'm really sorry, but I do not think I understand what you are asking here.
Stale constant ? Not used yet. From motion sensor. Will remove though. Why is this one disabled? Does it update frequently? This might actually be useful to have enabled by default. Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Why is this one disabled? Missing state class Missing state class Missing state class Why is this one disabled? Isn't this viable information in general? Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class Missing state class

Can we use async call later here instead and cancel and previous timers? Maybe async track point in utc time from the event helper makes more sense here I think async call later would work better. Then I can use the async fire time changed for the tests, right? Both work with fire time changed Be sure to store the callable that it returns and cancel it if another event happens Figured out my issue with async fire time changed , it does not change the system clock if you do that. Haha. If this is going to be needed another models, can you put it in cost? I do not think it is needed elseware, and if I refactor to use async call later , I think I can get rid of that. The newer practice is to import async call later and pass it hass instead of using the bound method since it works better with typing. async call later should always call back with the time. Should we cancel this in async will remove from hass as well? As I said in the earlier review, we don't allow calculating state in device and service interfacing integrations. I'm surprised we merged this PR with this included. Based on conversation in the Discord, I think it does make more sense to turn this in to a timestamp sensor. I am going to do that with a similar one that will be new for the UP Sense devices. I would rather hold off on doing that for the Doorbell one though until 2022.3 if you are okay with that. That way there are not breaking changes from HACS to the HA Core version. To increase adoption. A lot of users rely on this sensor, it is probably the most popular one aside from the motion ones (TBA). No, we shouldn't include features that are not in line with our architecture design standards. This is unfortunately one of the problems with publishing custom integrations and later moving them to core. We got too caught up in the how its implemented rather if it should be in the first place AngellusMortis Please reach out on discord to discuss. There are a few options: - We could change this to a device trigger, unfortunately this is not a good UX yet since we don't have a way to classify them yet so they can't get linked automatically to the camera - Switch to the timestamp - Get the end of ring time from the websocket data so the package code is doing the callback instead of the derived version in hass - probably something else I haven't thought of.
Please add typing, as requested in my last review. Sorry. It's already fixed. Unresolved this comment. Please fully type this method, that includes all parameters of this method. The command isn't any? Neither are the params. Please type them correctly and specifically. Adjusted! The command parameter follows the one defined in Tuya base. params is not used when sending commands to Tuya integration. Please review. I don't think params is a string? The command isn't a list or dictionary either? Where did you base this on? Maybe I am misunderstanding it? The command was based on [Tuya's documentation]( title-3-Request 20example) and on the Explorer API, where a command with multiple codes can be sent to the same device. In the home assistant, the service would look like this: The params has no function for the send command service to vacuum Tuya. It doesn't matter is parameters is used or not, it still needs to be typed correctly. For command, it doesn't matter what the Tuya docs say, this is a home assistant service, and it home assistant will call this method. It must be typed towards internal use, not external Tuya use. Looking at your service example, y9ir are not putting in a dictionary, yet, your have typed it as such.
This is accessing a protected property, which should not be accessed.
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: I am a little confused. Do I need to add a UI configuration flow for this integration? If so I will prepare for another PR. Yes; I actually used the wrong response template above. I've updated the response above. Thanks. I will try to refactor it.
we use event type
This is a bit odd that it takes "None" here? Can we get rid of that? If you make this a dict , it should take care of adding ATTR ENTITY ID L687 Also that gets us area and device mapping support for free L971 We can use this instead of entity id which will get us the nice UI features Add domain: select if it should be restricted to just that domain I am not sure I follow. It is already restricted to the domain select. The service is bound to the select.unifiprotect platform. There would be the same issue if it was bound to the camera platform instead since not all cameras have LCD displays (extra entities in filter that are invalid). If this service schema is only used in the select platform, please move it to that module. Having the schema in another module just makes it harder to read the platform code. This goes for all constants. Message services are usually a notify platform. Our notify platform support is still lacking though so I think it's ok to keep it as a custom service for now. I understand the sentiment to want to get people to use notify , but this is not really a notify platform. Changing the text is more like "delivery instructions" rather than a notification. It is literally basically just digital signage with a message on it. You can make the message expire, but the main use case for this service is to set a "dynamic" status message (like you want to display the current temperate).
For this to be useful in automations and scripts we should allow both negative and positive adjustments. We could call the new service "step" instead, similar to brightness step for lights, or "adjust", and allow both negative and positive values. I just had a thought. What if instead of adding a new service we add an optional argument to increment and decrement services that would override step from configuration? Would it be too confusing? Not added in this PR, but this magic number should have an explanation (2 63-1)
When is this function to be used? It feels like a workaround for a flaw in our design instead of a proper interface. The challenge that we have is that the device tracker integration needs to know about MAC addresses even of disabled entities. async added to hass is not called when entity is disabled. I looked at it again and you're right, we can do this internally. I have two options: 1. Add the mac address to the capabilities attributes of a device tracker so they are stored in the entity registry 2. Override Entity.async add to platform start to also register the mac Going for option 2 now. btw the downside of option 2 is that if update before add is set to True, we don't have the mac address yet. Lets mark that final, so it would be catched by type checking I had that at first. However Unifi also uses the ScannerEntity to integrate Unifi network devices, and for those it wants to include info. In the case of UniFi that wouldn't matter? As in, it could provide the devices in all other entities? The connection would be made in the same way as all other integrations at that point? (I think I miss the key concept now though) Hmmm maybe you're right and it should still work but I'm too aggressive in cleaning up old devices. I only check if they have the config entry of the device tracker, but it could provide other entities. Let me check. Ok, doing it now once when setting up the first device tracker config entry The assert is not needed here. The block device info here as well (in typing that is) I had done that but it's actually bad in the test device tracker integration. I will update it there and see what else breaks. dmulcahey adminiuga Device trackers no longer create devices. This was causing an issue in the ZHA device tracker tests that I solved like this. Is that ok? I also have 2 failing discovery tests. And I have no idea how to fix it. Fixed it by opting ZHA out of this logic. It is only for IP based devices. Kane610 I've removed the logic for maybe deleting devices. The device registry will automatically delete devices if no config entries are linked so this logic shouldn't be needed. balloob I think the same apply now to Fritz: L459-L477 It's probably better and safer to invert the inheritance in this class and put ScannerEntity last. That's our standard.
default should be UINT That's correct, has been adjusted now.
This should not be added to the YAML configuration. We don't allow changes or additions to the YAML configuration for integrations that connect to devices or services. OK. I was basing this on what was there before, but happy to change it. If I need to add a new setting to the set of existing settings, what is the right way to do it? If I need to add a new setting to the set of existing settings, what is the right way to do it? I'm not sure about this question, could you clarify it? Sure, no problem. This component already has 3 settings in the schema - the controller URL, a list of devices to treat as lights, and a list of devices to not import. I added a 4th setting in the schema - a list of scenes to not import. I added that new setting in exactly the same way as the other settings. The change was rejected on the basis that changes or additions to the YAML configuration are now allowed. My question is if it is not allowed to add an additional setting this way, what is the correct way to do it instead? This is my first tweak to an existing component, and would appreciate pointers on how to do it right. You have added both the possibility to set this via YAML and via the UI (as part of an option flow). The option flow is fine The YAML part isn't allowed. For more information see: decision Got it - thanks for explaining! I have removed that line now and re-tested
Raising ConfigEntryNotReady means you expect the connection might succeed after retries (device is temporarily offline etc). I would try to limit catching just Exception type(s) that indicate this might be possible (timeouts, bad response, etc). Non recoverable exceptions should just be allowed to bubble up. pylint will anyway have an issue with such a broad exception. Try to narrow it down. In the case of an inverter, it is usually available 24x7, a failure would likely be the wifi in my house was down for a while. Yep which is exactly what ConfigEntryNotReady is for. Just need to make sure you are only catching exception types that might go away on their own (timeouts etc). You might want to look into using DataUpdateCoordinator for official polling support ( coordinated-single-api-poll-for-data-for-all-entities). I haven't used it myself, but looks like it has rate limiting features as well. I was hoping to leave this to the next version, I have been trying to get this integration over the line now for many months and what is in place currently works. And yes I know the dev team a REALLY busy. Is there a reason for prefixing debug messages with whitespace? Just personal preference, I wanted the block of debug messages to standout while I was debugging Use Platform enum L22 Updated Any reason to have this debug here? Was helpful when debugging, I am new to HA and Python, but have removed Agree more concise, updated Noted, updated Seems missing in many places Am new to python but will see if I can clean up. Handle this is schema instead Agree, was duplicated. But need to initialise from saved options so rewrote. Why is this needed when we have user input already? Not sure what you mean, some default data is extracted from the inverter so need to be able to get them. Should this not move to the option flow instead? Needed to setup the integration? Should already be a dict? Suggest to handle it in the schema instead with user input.get(CONF SUN UP, DEFAULT SUN UP) This seems identical to the one above? Use attr name instead. Goes also for the others below Can be removed. It takes the integration name Isn't unknown missing
LOGGER here is defined but not used. Should we be aiming to standardise LOGGER as coming from const.py , defined against package instead of name and then imported when required? LOGGER logging.getLogger( package ) cc frenck as that is the path he has chosen in the last few refactors I have seen. Yeah thats better. Thanks
Those are not related to this integration and thus cannot be used for a unique ID in this integration. For other options see: unique-id-requirements Ok, I will try to use the serial number which is part of the raw mqtt telegram. Downside is that you need to wait for a message to setup the sensors. You can use the config entry description key as last resort option Ok but than I have to add a config flow right? true
I browsed the repo a bit. There's a 0.9.14 release on github but it's not on PyPI. The setup.py file has a stale version spec. There are some print statements but they won't be run in the normal code flow for us, only on error. Hmm the stale version will actually cause issues for the wheels build. Will open a PR upstream. Instead of a PR, I've opened up an issue upstream explaining the difference (as there are multiple different things going on there). ![image]( As for the wheels, this isn't an issue at this point, as the publish package on PyPi has the correct version for this PR (0.9.13, which is the source of our wheels building). Marked the PR ready for review again, as I think we can move forward without awaiting the upstream change.
I think we want to achieve this, with the device file containing the type ( K ), but the entity id and unique id not containing the type. Agreed What about calling it key "typeX temperature" or key "tc temperature" . This way it would make more sense for someone reading it not knowing the details. It could be something longer to if "tc" is now a well understood abbreviation. I probably like key "typeX temperature" best, because it matches the OWFS documentation. Name could be adjusted also, to TC temperature or Thermocouple temperature , or... Oh, yes. Checking again now This is not needed:
Any specific reason why this should be off by default? edit: Even bolder question, should this even be configurable? The reason I put it like that is twofold: - you need to upload .js files in your google actions configuration before this will work - the currently present code made it look like this is something that should not always be on (why else is it not already turned on), so I went with that approach I am fine with enabling it by default or removing the config entirely, though I guess I would need to test whether that breaks anything for the cloud SYNC. I am not expecting difficulties though. (why else is it not already turned on) Maybe, because the library feature was built later and wasn't built in this part of the code yet? I think if it can be detected or just enabled always without repercussions is always better than introducing more configuration complexity. Now it is not configurable and enabled by default. According to the [Google documentation]( sync-response) the response should always be able to contain otherDeviceIds and customData, which are the two things that are added to the response if local fulfillment is enabled. I tested it both with and without the local fulfillment application loaded to the Google home device, and as far as I can tell everything works as expected in both scenarios. Import async generate id and use it directly instead of going through the hass object. Done. This is not correct. The manual configured Google Assistant supports multiple users. So in that case each user needs to have their own webhook ID. Could you please explain how multiple users are currently supported? I did some digging and found that the user agents are used in two cases: 1. to pass on to service calls that perform the actual actions for each trait. 2. to 'support' local fulfillment. Am I missing anything? I am uncertain whether the first use case is actually implemented, but the use case is still supported as the user id gets passed along nicely as is for cloud calls, and in the local fulfillment scenario it is always the first user agent id, as we do not know which it was. For the second use case it does not make sense to support multiple user agent ids. This is because in that scenario we are providing the value of user agent id to what should be the home assistant device id in the IDENTIFY request and the proxy device id in the SYNC request. ( I do not know how to link to code here but these it can be found in smart home.py line 267, and smart home.py line 89 which goes to helpers.py 530 respectively ). To me it makes no sense to use Home Assistant user ID values for this, as there is only one Home Assistant device. I would propose using one unique id here. I will make these changes and push them to this pull request. Note that this most likely will make the entire storing of the user agent ids obsolete. I will leave it in for now as the cloud integration makes use of it, and I think it is outside the scope of this pull request 

What information does this provide that is not already available in the state and state attributes? The secondary info: position for entities card is not working. ![image]( As an alternative I made the code change in this PR and then changed the type of the entity to type: attribute and then added attribute: position to get the card to show the status instead of up and down arrows. ![image]( If there is a different approach I am happy to take it.. I tried getting the secondary info to work instead but had no success doing that. My goal is to get the status to show in some way - I am happy to go a different route if this is not ideal optimal. Thank you, DeadEnd That is a fontend issue, which should not be solved in the backend. The card has enough information be able to derive the position from the state. I would suggest opening a PR to the card repo to add support for displaying the state Okay, I will close this ticket then and proceed as suggested. I appreciate all of your time looking at this and giving feedback! Cheers! DeadEnd
Would have been nice if entity categories have been specified in the descriptions. Please also test already configured abort reason.
Why can't a hostname be used? Why can't a hostname be used? Because the device tells me only the IP address. See also the [Remootio Websocket API documentation]( e.g. the [newest version (v3)]( of it. A hostname for any IP address can be set on your DNS server router. Advanced users might want to do that to keep control of their systems. user input can't be none here given above lines. Fixed. Don't log with exceptions here. This is a standard type of error. Fixed. This overwrite any required field invalid errors from above. This overwrite any required field invalid errors from above. This is intentional, because the device can also be discovered using zeroconf, but this will be implemented in a later version of the integration. If the device is discovered using zeroconf, only the IP address is known first, the other data (API Secret Key and API Auth Key) must be given by the user. The idea was that in this case only the error message Please complete the setup of your Remootio device. with key user input incomplete would be presented to the user. Seems a bit confusing. You can have different flows. BaseException should never be caught. That could be cancellations and other core python exceptions. Absolute max Exception(). Fixed. Don't abreviate. Write it out in full. Don't abreviate. Write it out in full. The constant CONF API SECRET KEY is used in the voluptuous schema based on which the form for configuring the integration is presented to the user. When I write it out in full, a password field for the API Secret Key is displayed on the form, but a simple text field for the API Auth Key , which I didn't want. you should set up the connection in the init .py file. Otherwise it will end up harder to add other entity types. you should set up the connection in the init .py file. Otherwise it will end up harder to add other entity types. I implemented this because, according to the [documentation]( the device automatically closes an unauthenticated session after 30 seconds. In the method utils.create client an instance of the RemootioClient class is instantiated, whereby a connection to the device is also established and, among other things, the authentication takes place. - The library [ aioremootio ]( which contains the class RemootioClient , was also written by me. Most of these properties have shorthand versions like attr unique id which you should set directly from the init constructor to avoid boilerplate properties. Fixed. This should really be converted to DataUpdateCoordinator. With CoordinatorEntity entities. This will schedule there own update once the coordinator updates. This should really be converted to DataUpdateCoordinator. With CoordinatorEntity entities. This will schedule there own update once the coordinator updates. I don't understand why I should use a DataUpdateCoordinator here? After a time that can be configured via the Remootio app, the device triggers a LEFT OPEN event if the controlled garage door or garden gate has been l
I don't think queries raw should be exclusive here. By defining it this way you make it so users must specify all their queries in raw or none of their queries in raw. Why wouldn't a user be able to mix and match? Specify one complex query as raw but the others as normal using queries or queries flux ? I feel like the schema should only require that CONF QUERIES and CONF QUERIES FLUX are exclusive since an Influx deployment can only accept queries in one language. CONF QUERIES RAW should be be separate and not exclusive with either. I agree that it's better to be able to mix... I'm looking for improving the proposed changes on that point. Is there a proper way to do the the validation of configuration if set to optional (ie QUERIES and QUERIES FLUX cannot be set together)? Yea just don't bundle the new one into the exclusive . vol.Exclusive means that only one of the fields in the named exclusive ( queries in this case) can exist. Since queries raw can co-exist with the others you just make it a normal vol.Optional . So it would be like this: Taken into account in the e7dfb9f commit Why is this INFLUXQL RAW ? Shouldn't you also be able to specify a flux query in the raw as well? It's raw so its just text either way. Changed to LANGUAGE RAW in the e7dfb9f commit. Used to define the "raw" type of configuration that can be used in V1 or V2 mode This code will break all InfluxV2 users right now since you've made this a separate if block with an else. For InfluxV2 users it will fall to the else and try and make an InfluxQLSensorData for each item in queries flux which won't work. Right, basic mistake, thanks ... Think we should use the same default value here. That keeps it consistent. Also making this field optional allows this to be used for V2 Flux queries since specifying a field is something that only makes sense with InfluxQL queries. When talking to V2 systems field and db name would just be ignored. TBH you could probably just omit this from the config entirely. Just instruct users to put as value in their select statement next to whatever they are selecting to give it the expected name. But optional also works, gives more flexibility. I thought it was more flexible and robust to set the name of the result of the query as a paraeter of configuration wether using the default 'value' which has in this case to be taken into account in the query. And it may be simpler to extend to V2 Flux queries as I have in mind that default value for V2 is ' value'? In V2 flux queries it is always value . There's not an option. It's not SQL-like like it is with InfluxQL where you select the columns and can name them. Each attribute of each entity ends up in its own table where every row has a time column specifying the time that row was created and a value column specifying the value at that time. The only other columns are what you designate as keys (tags in the config). To show you what I mean, here's an example entity in my Home Assistant: ![Screen Shot 2022
To keep it clean, I think this should be done in the backend lib by creating a mac property that does precisely the same thing. Considering this is a rather large change, would you mind adding yourself to the codeowners to get notified on potentially upcoming issues after this gets merged? That's fair This looks like a good solution, I'd guess that the reason for bool enumization is just something some fw developers have simply chosen to do so.. I think it's even more strange than that! On the HT-A7000, some of the settings are enumTarget with on off when the bar is turned on and booleanTarget when it's turned off. My best guess is a wrong code-meme in the firmware, but hey, it's easy to workaround. This was already used above, maybe generalize it into a enum is boolean or something like that? Or should this rather be handled in the backend somehow? I'd rather avoid having a separate entity for the update boolean, or if this is really wanted, maybe generalize it enough that it can be used for other booleans? So the update binary sensor is a very common one to have for many devices already, so it's not uncommon. In this case I don't think there's any other device sensor that needs to be added, which is why this is not very generic right now. This is now an Update Entity! Examples? The start up sequence (as well as changing inputs etc.) may emit these notifications before it calms down, so if that's the case here, maybe these intermediary changes should just be ignored? Should this be consolidated in the backend? That's true... The API is not great as it was developed organically by analyzing the network traffic without having a clue about the bigger picture (prior that there was any docs available). Calling this will just set a variable that'll cause the listening loop to quit its processing. There's also stop listen notifications() in Device that's a shortcut for this exact functionality. The backend lib should be improved to cater the needs of the integration if feasible, IMO. I'll try to fix this one on the backend library, it took me a while to figure out what the problem was in the first place. I'm unsure if this gets hit if the device has zones (which could be implemented as separate devices media players in the future?), but it'd probably be safer to simply log this and use the first control to avoid breaking any existing setups. These should perform the action instead of toggling the state, if possible?
We should use connections instead of identifiers here Thanks for flagging. Can you elaborate on the difference? I'm reading the docs but it doesn't explain what it is other than repeating the words of the variable naems. When you use connections and there are multiple integrations that know about the device (ie unifi), they will only create on device entry. connections {(dr.CONNECTION NETWORK MAC, config.mac)} We should use connections instead of identifiers here We can use a walrus operator here to save the mac address in a variable.
multiselect is a bit of a technical term maybe, how about just multiple ? Changed as suggested This selector is changing. Please inline the old config schema. CC emontnemery This selector is changing. Please inline the old config schema. Please remove comments. It's clear what multiple means When multiple is set to true, we should only validate it as multiple entities, and only validate as single if multiple is false. I was keeping with the interface for entity id in a trigger. It accepts a single or a list. Currently in the selector I only return a single entity if one is selected, and a list if enabled and more than 1 is selected. I believe the entity id in the target selector behaves the same way. That is not always the case, selectors can also be used in places that can't handle lists. They selector config must specify multiple and the user must pick more than one to get a list. So we should be OK. The question is should we always return a list (even an empty list) if multiple is specified. Yes we should always return a list if multiple is set to true and a string if not. However, your current code is not checking if multiple is set, but just validates first as a single, then as multiple. We should just check the value of multiple. Use guard clauses to keep the code readable. Why would you not raise if it's not a valid entity ID ? Because it could be a uuid the previous validation was a little obscure ... and I needed to test each result in the list. Let's not update all tests but also leave some where we don't specify multiple , to verify the default is False. That's exactly what happens; "multiple" has False as default value so it's added to the validated blueprint input The changes just adjusts the test because the validated blueprint input has changed. Should we still verify it looks like a uuid ? Oh nm you do that before passing to validate. Looks like you could move cv.entity id or uuid(cv.string(data)) inside validate too ? Is cv.string necessary on top of cv.entity id or uuid ? Fixed If you do vol.Schema([validate]) it will give a nicer error message, something like "value at index X invalid: XX". Not sure if that really matters. Yeah, that's a bit better indeed before: voluptuous.error.MultipleInvalid: Entity light.def456 belongs to domain light, expected sensor for dictionary value data['selection'] after: voluptuous.error.MultipleInvalid: Entity light.def456 belongs to domain light, expected sensor data['selection'][1]
We no longer accept additions or changes to the yaml config of integrations. See: There is the options flow interface to set options for a config entry: Ah fair enough, wasn't sure how the change applied to existing integrations or not. Will RE-raise the PR's if I reimplement it with the config flow
We don't allow device and service interfacing integrations to calculate state. That's only allowed for template integrations and similar integrations that rely on other integrations for state. Device and service interfacing integrations should just set the state that is reported by their interface api. MartinHjelmare so does that mean the call to pyqrcode needs to be in the external library and passed into HA here, eg as an image? Or does the camera feed need to be generated there too? I hope my suggestion has not made this more complicated. My intention was the opposite It's ok to have the library return a camera image when requested. I don't understand completely what you mean with camera feed in this context. I think what MartinHjelmare means is to move generate guest wifi qr() into a separate class which lives in common.py. Did I understand correctly? No, we don't allow the integration to calculate the camera image. The camera image should come from the library api. If this is something that you want to add, the library needs to be updated to provide this image. Ok, now I understand. But if the project (fritzconnection) doesn't accept such a change (e.g. because there is a new requirement added (pyqrcode)) we could not add such a feature to Home Assistant? That's right? Could we go the "service road" (original PR) in such a case or isn't this allowed either? I don't think we should create the QR code image in the integration, either in a camera entity or service call. The idea is that integrations should express the device or service api features and not invent new features that aren't natively supported by the device or service api. Ok. I will close this PR until such a functionality is ready in the underlying library (which I will try to implement). FYI I started a discussion at the fritzconnection project ( MartinHjelmare kbr , the maintainer of fritzconnection , gave me the answer, that he don't itend to add such a functionality into fritzconnection because of the extra requirement of the QR code lib ( This means fritzconnection nor Home Assistant would like to implement such a functionality. Is there any chance to add this to HA except for a custom component? I think there may not be an obvious clean way to do this. Here are some ideas. 1. Feels like a long shot but maybe the [existing QR code HA integration]( could be somehow enhanced to not only read QR codes from video feeds but also generate qr codes from sensors, and expose them as an image somehow. But that is quite a stretch and might be best as a new integration. 2. Maybe a command line component to create the QR. 3. Maybe a separate [docker container to generate QR codes on demand]( Then you could use a jinja template to put a QR code on the HA user interface based on arbitrary text. There might be online services that will do this for free but I couldn't easily find any. 4. If you have a working cgi-bin locally, QR codes can be generated directly via a cgi script. [Here's a dem
Can you use the newer syntax here? Saves only a line, but you could avoid the assigment Can this actually be None? No, it cannot. Will adjust typing. The "S1" refers to the firmware revision which is normally stylized with a capital. Usually we only use lowercase in the function name, but can stylize in the docstring.
Please make a separate sensor entity for the voltage instead. I think I'll just remove it then. I see that this info is present on Nightscout's API docs, but none of my devices report this value. I added it as an attribute just in case. I'll remove it and if someone later needs it, I can make another PR. What kind of value is this? Please give an example. Nightscout's documentation lacks the possible values... but in my case, my MiaoMiao collector is a BRIDGE and my phone running xDrip is a PHONE : You can also check the tests: diff-1772d43a1407a241f0712609dd915a34eea9104d44612d18475797b6457c57fbR84 Do we need to add this info to state attributes? It's not dynamic, right? State attributes is for dynamic info related to the state of the entity. We should probably set the device info property on the battery entities since they represent measurements from different devices. that makes sense! I'll update the PR Please remove the icon property. The icon is handled automatically already by the frontend. We can remove the property and use the attribute. As above. Take the parent property into consideration too. We can only use this method during config entry setup in the init module, not here in the platform. Use this instead or move the coordinator setup to the init module. L163 Collect all entities of the platform first and then make a single call to add entities. Please collect all entities first in a list and then make a single call to async add entities . Fixed! Is the device name both unique and stable? Can the user change the device name? I think if the user changes, for example, the phone name, it will be instantiated as a new sensor. But the Nightscout API doesn't have any other IDs to rely on, just the name. We don't allow non stable ids as unique id. unique-id-requirements It's a bit weird that the uploader attribute would be missing. Attributes should always be present after instantiation. Yeah, so... a nightscout device can include a uploader object or not, depending on which device it is. Their API is a little confusing and not very well documented. You can check out [the documentation here]( Devicestatus get devicestatus ). uploader pump and xdripjs seem to be mutually exclusive and a DeviceStatus could have any of them. Normally a Python instance sets optional attributes to None.
It doesn't look like InvalidAuth is used. Is it needed? Oh good call! Removing Please limit the initial PR to a single platform This isn't used needed as it seems. Let's remove this note from here. is there a better place to put it? I was not sure about the documentation standards; or whether that should be removed entirely? These can't be None ? They are set on init This is a rather long name... It can also be set in init using a shorthand attribute. After that, this property method can be removed. This can be set as a class attribute: Not needed, as there will always be an wecolor ? PS: Can we also know read if this blind is a favorite? Stale todo? good catch, thx Limit the PR to a single platform. You can create a Pull Requests for the other platform when this merges. 5-make-your-pull-request-as-small-as-possible Got it. Removed the button for now. So, each channel has to support tilt or no tilt? Is it possible for channel 1 to support tilt and channel 2 not to support tilt? Good call -- I think that is theoretically possible, if someone had blinds on one channel and shades on the other channel. But I am confused about how to implement that sort of conditional config flow (set of channels, then set tilt no-tilt per channel) -- do you have any examples of similar config flows? Use constants for the keys None is not a valid return value for this property. See: platform-properties-to-be-implemented-by-deriving-platform-classes Missing keys? There doesn't seem to be auth? This seems to be unused? Cleanup, not needed, as set in the constructor. Use a list comprehension
I personally would consider this bad practice. Why not provide a list of integers instead?
Looks like another one snuck in Can we avoid patching the integration here ? Not easily. The patch makes this much easier to maintain so adding another entity in another platform will not affect the expected counts for this platform. I could iterate over all entities added and only pull out the ones for the selected platform, but patching the ones that gets initialized seems a lot cleaner to me. That would probably be a follow up PR though to do that since I am already doing the same pattern in camera and media player. Ok. Let's save that for a follow up and do it in a separate PR. Ideally we don't want to patch any of the integration code if we can avoid it
bdraco I would like to get your opinion on if there is a better way to accomplish this check. Effectively we want to update a member variable that is input into state attributes any time a new provider is registered (see call above) or ideally any time we have a hunch the source may change. (Technically, the source can change on ever call, but i think its OK to not worry about that). Right now this is called on startup only, which may be ok. But the other question is: integrations need to call super() on the parent to invoke this, or also it might send an RPC and fail. Would love to hear your suggestions if you have any improvements. You could implement this in async internal added to hass to ensure it always happens. Since this is base platform, I think this would be ok to do as long as you are careful to call the super() method L799 L830 Thanks, I saw this but was on the fence about using that. I agree it seems fine since this is a base platform. Updated. Isn't this a pointless method? Is there a reason you add it? Thanks for catching. Whoops, when refactoring I dropped an important call to refresh the webrtc providers. This is for the case where the camera is added after the provider is already registered. I attempted to write a test to catch this, but it is difficult given the way the test setup happens registering a camera at the same time as camera is initialized only. I can consider test coverage for this when adding on real usage. Should we do asyncio.gather here? Yes, getting the stream source may send RPCs, so that is a good suggestion. Done. Can we asyncio.gather here? Probably not since you want the first one This could be an any Why doesn't this update state if needed? This is called from two contexts, one when being added to hass and one when adding the registration. The thought here was that when being added to hass it already updates the state in the context this is called with the comment above ( Note: State is always updated by entity on return ). One option is to always update here, though my general impression was that folks want to be self conscious of state updates -- maybe its not as bad as I think. Or another option is to do this another way, if you have a suggestion. I think we should keep the state update control inside the entity as it knows when that's needed. If want to avoid an extra state update we could add a parameter to not do the state update. The double update would only happen when adding the entity so also not crucial to avoid. Thanks, addressing in
Is it also worth confirming that the country code is preserved? There seems to be some decent amount of logic dedicated to preserving it. Also consider if that is interesting to test in the failed case as well. (e.g. fail, then succeed, and it's still preserved) I've changed the flow so the country code is also asked as re-authentication, maybe it can change if someone moves from one country to the other, so it's fine to ask it again. What do you think about sharing async step user across auth and reauth, and then append CONF COUNTRY CODE to the inputs into vol.Schema() depending on whether or not we are in the middle of reauth? I think it might be easier to follow the different states that are possible since it will only be limited to a single function, and no longer have to pass around different step ids, etc. I'll see if that's possible, I though the step id needed to differ for the different flows, but I actually don't know where it's used for. I've merged the steps but called it authenticate to make clear it's a common step. I realize this is an existing issue but -- I think the common way folks do this is to have this check happen in async step user before moving on to the authenticate step. Can you add a check there for an existing config entry there? You mean aborting if the entry already exists before going into the authenticate step? That's not really possible as we only know the unique id after authentication. It is possible to add the same integration multiple times after all. OK I missed that, thanks for the correction. It may be worth adding test coverage for that case too in a follow up PR unless its already tested and I missed it. Given this is reauth, I think it makes sense to preserve the existing values and use them for pre-populating the form. This will only be the country code btw, the username and password are not saved. But I'll have a look! Hmm, not sure how to do this without adding a lot of complexity, because the prefilled values can't be easily passed to the async show form method. So only way to do this is by passing the default values to a voluptuous schema generator. Is there a reason not to preserve the username? Yes, you'd just inline the schema rather than having it outside as a constant, which is how I usually see this. Ok, I'll have a look. Username is sensitive information and is not needed for authentication after the first time. I meant preserve as in show it again. I realize now it is not even stored in the configuration at all, which I did not realize before. I see! Does this mean its possible for re-auth to select a different device? Is that a problem? Good question, I'll add a check on whether it's the same user account that's used for re-auth I've now added another error if re-auth is done with a different account id (which is used as unique id). Is this correct or need to be updated back to "user"? I can't tell where this step id is used. You're right indeed, will update it!
homeassistant components overkiz select.py:117: error: Function does not return a value [func-returns-value] Found 1 error in 1 file (checked 1 source file) I am not sure why mypy bugs me about this. :-). I tried different ways, but any pointer would be appreciated! Maybe the type hint on the lambda is wrong, if it returns something that is awaitable If the lambda is multiple lines, it is usually recommended to move it out of the EntityDescription and to simply reference the function name: I didn't like those multi-lines lambda's as well, however I am not sure if moving them out of the description will improve readability. If the lambda's are referenced and the originals are somewhere else in the file, you don't have the clear overview of what each entity description does? Happy to move them if this is the best solution eventually :-). Done in ea79ed1. If the lambda is multiple lines, it is usually recommended to move it out of the EntityDescription and to simply reference the function name: Thanks, I was totally looking in the wrong direction! Fixed :) Thanks! This pattern exists in a few places. Can this be more DRY? Agree, I don't like that setup code. It is almost the same for sensor , binary sensor and select . Switch (to come) is slightly differrent. Would this be blocking this current PR? I noted it on the list for refactors feedback that we need to address. I would love to have select and (later on) switch in, so that all platforms that share some of the same logic are in. Than we can refactor the async setup entry to be more DRY. It can be done in a follow-up I was a bit surprised that SelectEntityDescription didn't support this natively :(
Can collapse this into the update We know that this will be true since we have the check for the inverse above and a return there. Fixed in followup Why do we not use self. abort if unique id configured ? Can some entries be created without unique id? abort if unique id configured doesn't work here because we need to merge the new address into the CONF INFO dict and it doesn't support deep merges Can't we pass the whole updated data as updates? We have access to the old and the new data. Sorry we don't have access to the old data. What do the values represent for these state attributes? Auto Comfort allows the fan to monitor and adjust to room conditions like temperature, humidity and occupancy. There are four possible states: "Off", "Cooling", "Heating", and "Followtstat". Smartmode indicates the fan's comfort mode. When auto comfort is set to "Followtstat" the actual auto comfort value will change based the connected thermostat otherwise smartmode tracks auto comfort. There are three possible states: "Off", "Cooling" and "Heating". There is currently no support for controlling these. It is likely they could be moved to the select platform in a future PR. Ok, thanks. These attributes seem static. We normally don't want static info in state attributes. I'm not sure how useful room type, and I think room name has been superseded by suggested area anyways so I'm going to drop them Please always assert the result type too.
Is this intended to run in the executor? If not let's rename it async media stop The method from the base class does shrug : Should this be awaited ? Oh shit. I did I miss that and the linter not pick it up? I wrote the stop method. Usually I make a async media stop in this case and call it from the api exposed methods since Home Assistant sometimes renames methods. Please use our common type. See the same comment on the previous platform PR. A coroutine function is never a callback. Nowadays we raise a ValueError if incorrect input is passed in the service call. Please raise HomeAssistantError if a service call api call fails. Stale docstring. We don't offer a way to select source? The speakers on the cameras are pretty limited. It was mostly designed to just let you play TTS messages. They can only play MP3 file URIs that Home Assistant can access. If you have a reference to an integration with similar requiresments that lets you select a MP3 file, I can add the browse for it. If we don't support selecting source we should remove this support. Oh, you mean there. I think that is needed for TTS to appear? At least I think that is why I added it, I would need to verify. We don't add supported features that we don't support, regardless of other things. Removing SELECT SOURCE does not affect TTS. So, I have it removed in my next PR.
Why asking for the length to the end user ? I would say, use your own password or a default (32bytes long) pwd will be used. That's it Why not? Its no big deal. If one wants a shorter or longer password but like to rotate it for security reason he could use the built-in mechanism and don't needs to worry about how to generate the password randomly. I'm not a fan of too many options, honestly. Will ask for a second opinion on that. Simone Separation of concerns. A service that changes a password to x differs from a one that generates a random, time-limited password. For the latter, would it not be necessary to have a way to receive the generated output (which is not possible using service calls)? I have no idea about the internals of this integration, I just stumbled upon it as I got notified by github, so take my advise with a grain of salt. It's my plan to integrate a camera entity for QR code next. So you could run the password change service and the QR code will be updated. This is my personal use-case. mib1185 what you think about that ? I'm fine with this optional parameter, but would remove the default of 32, since the fritzconnection lib does already have an own [default value]( L28) implemented for that. For your sti0 use case, you can for sure set the length to what ever you need. Removed the default value. Now if no value is set the default value of fritzconnection will be used (length 12). I will change that in the docs, too. You already specify the params in the call, no need to load a default you can add a validation schema while registering the service (see [ hass.services.async register ]( homeassistant.core.ServiceRegistry.async register)), so invalid inputs are handled proper by HA itself I've tried this but can't get it to work. Maybe you could guide me. I created this schema in conf.py : But I don't really understand how to use it and at which part. Must the service call be in a own function instead of services fritzbox ? And where to call hass.services.async register than? the schema must contain all parameters and needs to be added during hass.services.async register() - this is done here: L54-L55 So the [ SERVICE LIST ]( L21) needs to be extended, so that a schema can optionally be included. Thanks for the hint. Added a service schema now :) btw. this method seems not to be used any where in the code? My fault, implemented it in the most recent change. But if we could do the schema validation, it's not necessary and can be removed. would add some typing The schema definition should be moved into the services.py since it it is only used there use DEFAULT PASSWORD LENGTH from fritzconnection.lib.fritzwlan as default the length parameter in fritz guest wifi.set password needs to be an int But if None is passed to the set password method, it already has the DEFAULT PASSWORD LENGHT as a default parameter. So this should not be necessary?! L252 You explicit set the length to the result of service call.data.get("length") ... so if 
There is a lot of duplicate code here. You could create these in a loop. This code really needs to be improved. I will make the modification. Please create only one service and let them specify the trigger number as an argument. I'm creating a service with index and updating. Thanks Then outdent below Your suggestion will create a point not covered by the test... I had done it the way you suggested and then I changed it because it was a point not covered by the test. So the question remains: do I put the continue and start to have a point not covered by the test or not? Reverse the condition, continue and outdent below Sorry but I didn't understand. Could you please explain it to me in another way or give an example? Thanks. Done "if ((entity.entity id entity id) isinstance(entity, WiLightValveSwitch)):" Reverse the condition, continue and outdent below Done "if ((entity.entity id entity id) isinstance(entity, WiLightValveSwitch)):" Reverse the condition, continue and outdent below Done "if ((entity.entity id entity id) isinstance(entity, WiLightValvePauseSwitch)):" These if blocks can be combined into a single statement Like: if ((entity.entity id entity id) isinstance(entity, WiLightValveSwitch)): ? Done "if (entity.entity id entity id) isinstance(entity, WiLightValveSwitch):" supported features is not a property of the switch platform. Please use another name for this Correct, I will not need this property and I will delete it... Please use our entity service helper to register the services instead. entity-services This parameter is required. We can remove the check. Done As above. Done Put the required parameters explicitly in the signature instead. Please make the same changes for this entity as above comments. Maybe round instead?
We need to validate the event name against the available events. do we? I get that it improves usability, but it means that this code has to be updated every time a new event is added upstream or the argument signature changes I think so. It won't work unless a correct event name is provided. I think that's the price for this feature. Would be good to be able to validate the event data filter to match the event we're targeting. oof that adds a lot of extra typing requirements to the library (I'm assuming we would want to maintain the event to event data mapping in the lib). Probably a good idea but a decently large addition. see my other comment Please add the error code in words to the ignore comment inside brackets. I changed the approach so this is no longer necessary Should we use the computer readable identifier instead "type": "value error.missing" ? sure we can do that, all of these are static strings (not even constants :( ) in pydantic so I just picked one. nevermind, I see why you would consider this to be machine readable, I just rechecked the logic
I would not recommend using the class name in the unique ID. While a nice shortcut, it makes refactoring this integration to EntityDescriptions in the future way harder. Hi frenck, Thanks for the review. I had trouble working out the EntityDescriptions requirements (seems to be hard to find docs on this - I saw it mentioned in the [State of the Open Home at 57:20]( but not much else). I've taken the naive approach in the interim. Open to better suggestions! :) You don't have to use them at this point, however, unique IDs should be based on data, not code structure. Simply, because changing structure in the future (e.g., when using EntityDescription or something else... doesn't matter), the unique ID changes because code structure changes. UniqueIDs should be stable and future-proof. I've updated the code to explicitly set a unique id for each entity Should we leave this one out? As this is the base entity, if two instances are created of this one, a conflict in unique ID will occur. How would the unique ID change if the AC is on or not? Nissan APIs returns two figures for the range of the car, one for when the AC is on, and one for when the AC is off. We create two sensors to expose the range when AC is on and AC is off, so need a unique ID.
Thanks for spotting that incorrect commented code. I'll remove it. and add from homeassistant.const import Platform Thanks for the tip, I've replaced the string with this enum. You don't need this. And you are setting the default later on anyway. Thanks - I've removed that. You don't need this, this logic is already handled in coordinator.async config entry first refresh() Again - thank you. I've removed the unnecessary code. My preference would be to move this to another file, coordinator.py. This will make it easier to discover and will improve readability. I've made that change - thanks for the suggestion. Why is this required? (and why not reuse the constant from init , or better move it to const.py ) I think that best practice is to call super(). init as the first thing, but someone with more experience should verify this. Do you have specific exceptions in your client class? Or does it always throw a generic exception, where it can recover from if you try again? The client class is not yet very sophisticated. I know it needs more work to get to a state where the home assistant integration can move up the quality scale. Those broad exceptions aren't allowed most of the time, so I would advise to see if you can catch errors like TimeOuts or wrong credentials asap. I don't think this extra username hint is required. I would just remove the flow title to keep it simple. Remove the title, just keep it the default. Remove unused keys Thanks - I've removed those unused keys. Why do you need this? It seems not used. Remove Why do you need this? (seems unused) Since you only have tests for the config flow, you need to exclude the others in .codecoveragerc Use the typed device info from from homeassistant.helpers.entity import DeviceInfo

A dictionary is typically used here but this might be ok. await coordinator.async config entry first refresh() could be used instead and should then be put above L71 Only one platform is allowed to be added when a new integration is added. This makes things easier for the member who will review this PR while still providing some functionality for the user. Please pick one. We also now have an Enum for platforms. Please use it. Thanks
My impression is that there is some special handling for SCAN INTERVAL if set as a default variable: separate-polling-for-each-individual-entity -- so then having it explicitly i the config is not needed. (I may have this wrong.) Would you be up for splitting up this PR to make review easier faster? I would recommend sending one platform at a time to make it easier to have a focused review (and i'd be happy to look) There are also other changes like style improvements or convention updates that can be split out into separate very quick to review PRs, so that would also be nice to do. We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries if the config schema needs changing. good point, that too... but also, SCAN INTERVAL is implicitly defined already right, so this is not event needed anyway, right? To change the scan interval in the coordinator an option would be needed. But we don't allow that anymore since all integrations that support config entries allow turning off automatic updates and then the user can automate updates using the service homeassistant.update entity . To change the scan interval in the coordinator an option would be needed. But we don't allow that anymore since all integrations that support config entries allow turning off automatic updates and then the user can automate updates using the service homeassistant.update entity . Understood - will remove. While I do like to have the uptime sensor, I think it should reflect the datetime when the VM container was started, not the actual uptime updated every polling interval. You can use a sensor with device class TIMESTAMP and let the frontend handle the time difference. Remembering to include the necessary imports: and
I am not sure why mypy fails on this one.. We don't use NumberEntityDescription , we use OverkizNumberDescription in our OverkizDescriptiveEntity class (which should override the description of NumberEntity). You need to override the type hint in the class Try something like this: That's it, thanks! I was looking in the wrong place. I think it would be better to use here the base class: EntityDescription from homeassistant.helpers.entity import EntityDescription Addressed in d8d7d3f I think it would be better to store these inside the number module. Addressed in d8d7d3f Missing return value typing. Why do we default to 0 instead of None?
Should this be an and ? We use this logic to match the widget or ui class of a Overkiz device. Normally we match on the ui class, however in some cases we need to override this and match on the widget. The or here is a conscious choice. How is that going to work if platform is None? If platform is None (because it cannot find a match in OVERKIZ DEVICE TO PLATFORM ), it won't add the specific device to the platform list. If there is a match, it will add the device to the list for the specific platform ( platforms[platform].append(device) ) and thus it will be loaded in in async setup entry for the specific entity. Or didn't I understood your question correctly? Nevermind, I'm reading it wrong since its split between two lines I was reading it as if (platform : OVERKIZ DEVICE TO PLATFORM.get(device.widget)) or OVERKIZ DEVICE TO PLATFORM.get(device.ui class): tbh I wasn't sure if I did prefer the new notation for this long statement Is it correct that strings.json is not being updated? Yes. I didn't realize that this was not part of pre-commit, thus I forgot to build translations in previous PR. This PR now reflects the current strings.json and for follow up PR's, I will include both changes. Missing return value typing. iMicknl and run python3 -m script.hassfest , you will get some additional feedback from mypy
Should we store the isoformated timestamp in last activated since we don't use it for anything else? Done, will open a PR to do the same with the button

If the only thing being stored is the coordinator, you don't need to make a dict We store the devices per platform as well, however I left that out in this initial PR. Do I need to remove it for now? Or can I keep it as we will add this in a follow up PR. It is fine to leave it in since its coming later Usually we just call this PLATFORMS Move this out of this function and have it return the unique id instead so that the entry isn't created in the try block 8819bcf Does this meet the unique id requirements ? example-acceptable-sources-for-a-unique-id Yes, the device URL is the unique id used by Overkiz. The reason why we split it here is since Overkiz uses multiple subsystemids for the same physical device. In Home Assistant this would be seen as 1 device, with multiple entities. Is there a way to avoid this linear search? Currently not, due to how the data is returned from the API. Based on the feedback from your previous PR's, we try to limit the amount of lookups as much as possible. E.g. for sensor we only loop through it at init and after we look up values directly by key. tetienne vlebourl any additional idea's? What about: There is always a states property, so we can remove the 1st condition. Are you sure tetienne? I thought that stateless devices don't have the states attribute? (or am I mistaken) Have a look here: L64 Even if Overkiz API does not return anything, we will have an empty States structure. tetienne L173 I looked here, which says it can be None? nvm: L282-L286 we set it here to an empty array, in case it is empty. Applied your new code statement, however it is still some kind of linear search, just a bit more optimized.. Ideally this gets optimized in the future, but its ok for now Can this linear search be avoided? What about: There is always an attributes property, so we can remove the 1st condition. Applied your new code statement, however it is still some kind of linear search, just a bit more optimized.. Ideally this gets optimized in the future, but its ok for now Implement native value instead properties Implement native value instead properties Can we generate this once and set it as self. attr device info in init ? Done in 9fa8250. In the future, a dataclass would be preferred since our minimum python version is 3.9 now L12 In the future, update the config entry with the new ip address if its changed using async update entry In a future pr raise ConfigEntryAuthFailed to start a reauth flow
It would be nice to use the same schema as the other attributes: SERVICE KNX ATTR RESPONSE: Final "response" I'd use [pytest's paramterize]( for the whole test in this case. Also I think the tests will fail because the response attribute is not used in the hass.services.async call() calls.
fyi, I would have needed to adapt those and I just didn't see the need. emontnemery the commented out variant didn't work. Any pointers as to why? I'm not sure, but we want the integration filter in the selector. There are other services which limit to sensors from a certain integration, for example homeassistant components advantage air services.yaml, so it should be possible to make it work. Edit: In which way does it not work, is it frontend which is not letting you pick the right sensor, or is a statistics sensor rejected by the service? Yes, I also found other integrations (like Sonos) which use this method. In my case the Home Assistant Service UI does not offer any entities to select from. This is due to a frontend bug limitation where filtering by integration does not work for entities not tied to a config entry (basically all yaml-configured entities). The groundwork for supporting filtering by integration for all entities was done here: but that needs to be extended to the target selector too. Long story short, we need to remove the integration: statistics filter for now. I was not sure whether this service has another purpose or whether it is effectively replaced by the new one and should be deleted. This is to give a helpful description for the reload service which is registered by calling async setup reload service Think you misunderstood me. I question whether this "reload" service is actually needed. I don't have to touch it. Just wondering whether to deprecate it!? You mean deprecate reload in favor of the reset buffer added by this PR? Yes. It gives more control and I don't think reload has a sharp use case. The purpose of the reload service is to allow adding or modify statistics sensors and make the new configuration take effect without restarting Home Assistant. Let's change this to a string so renaming the method does not have unwanted consequences Instead of default values in the implementation, add default values to the schema. Edit: Also, what's up with the default keep age of -1? I suggest to remove the default values here, it makes the code easier to follow IMHO Use a duration selector instead
emontnemery I wasn't sure how to handle non-changing values, which can happen for attributes. The commented out code would ignore those, analogue to the behavior with entity state. However, in turn this does not take into account force update sensors. Any steer would be great.
allenporter This will currently attempt to create a new stream if one is not present, but will return None afterwards. Two questions: 1) Should we try and make it return an image by waiting for an image to be created before returning? I'm thinking it's not worth the hassle. 2) Do we need to put a lock in Camera.create stream()? It doesn't look like there is anything there to prevent multiple streams from being created concurrently. Agreed that if we're starting a stream, it may take a bit long to get an image from it. Though that is effectively what the ffmpeg call does now. Would another option be to only use if an existing stream is already present? (E.g. it was preloaded already) Using a lock in the existing call makes sense to me. I think the alternative is to re-use an existing awaitable if one already exists -- and a lock sounds simpler. Have you thought about how timeouts are handled? Yes, we could use it only if an existing stream is present. But that brings up your earlier question in the other PR - which component is responsible for managing the stream? I'm thinking it should be the specific camera which is in this case generic. If someone was to use generic without preload stream , doing it the current way would still allow them to get an image on the second request to the image (assuming the stream starts up in time). Which timeouts are you looking at? Ah timeouts are a non-issue, i was confused, thinking of the case where it was waiting for a response from the worker which does not happen. Can camera manage this for all cameras as a default implementation? For example in nest [this call]( L228) could be replaced with super().async camera image Maybe nest would change to stop using the event, and only use the still image from the stream, given i added better support for getting snapshots from events recently using a different API. Maybe the logic is flipped in nest to work the way generic camera works: if the parent has an implementation from stream, use it, otherwise use the still image url as a fallback? Yes, it's probably better to do this in camera . The individual camera implementations will still have to make changes if they wish to incorporate this functionality. I don't quite follow nest vs generic. I assume generic should try still image url first (that's what's done in this PR). Oops, i missed the still image check at the top. Had a look at moving this into into camera . The problem there is that cameras have that dual sync async setup where Camera.camera image is not implemented and Camera.async camera image schedules a thread to call it via async add executor job . Then in generic itself, Generic.async camera image is implemented while the sync Generic.camera image is a wrapper that calls it from the main loop with run coroutine threadsafe . There is a thread- asyncio- thread usage that is warned against here: calling-async-functions-from-threads which we have to guard against regardless, but this gets more complicated if 
this is a good catch If you are only interested in the device , then I don't think you need to create 6 temporary variables. Is it compulsory to use all 6 keys for the unique id? Is the serial number not unique enough? I'm a bit confused about this unique id, we don't set one in the user flow? So, how does this work help? [CONFIG FLOW] Config flows that are discoverable need to set a unique ID so i need a unique id for the discovery This is actually not working correctly not and this PR has been merged without this being addressed ( bdraco). So, the unique ID is not just for ignoring (which yes, is required), but also for detecting if something is already set up. For example; setting up an integration that has been previously ignored. The unique ID should be consistently used in the integration; Not at will. Please adjust fix this behavior in a follow-up PR. Sorry I missed that. I figured this check would prevent duplicates Looking again it is not good enough though since the same port could be setup with a different path since linux allows multiple device entries for the same device. Looks like these are limited to just the one vendor so this should be descriptive enough No, the same vendor has other usb ids, so we need the vid and pid I think we are in violent agreement My comment was referencing usb noting that description probably isn't needed here. Usually we use this unique id format for usb devices L106 It looks like we can set confirm only here Unrelated to this PR, but prt in configuration exists could be simplified to be return prt in velbus entries(self.hass)
This doesn't look correctly rebased on latest dev branch.
Seems to be unused? I think this is less readable, but do not have strong opinion This seems incorrect, if one set up 2 config entries instances of the integration, it would kill both. This is already logged in the UI? This file doesn't match strings.json ? Please update the translations using the translation tools. This seems unneeded to log on accessing a name? region and brand missing? I don't see "cannot connect" in the config flow, is this stale? - Don't we have a unique entry of the car? - What if we have multiple entities of the same platform, how does this make the entity unique per entity? you are right about unique ID, fixed. regarding multiple entities, not in scope of initial integration. Missing return type Typing missing. Please note, you can also use shorthand attributes as described here: entity-class-or-instance-attributes The coordinator already has the config entry property, you might be able to leverage that one instead. This is the unique ID of the entity, not the device. Please don't mix those up :) I would just drop these, and use them directly below. We don't have to use get() here, as we know it will be there. hey frenck , it is giving me this error: homeassistant components hyundai kia connect coordinator.py:38: error: "set" is not subscriptable, use "typing.Set" instead [misc] Add from future import annotations to the top of your file This is already handled by the coordinator Move the default into the schema instead. Why limit it by domain? as a starting point, I prefer to set one instance of integration and add multi car support as later on. but it is definitely on roadmap It is more difficult to change that later, as you would have to migrate all existing entities. I would not recommend on doing this, unless absolutely not possible otherwise (which, is not the case as far as I can see)
Please use a DeviceInfo TypedDict and not a standard dictionary. Also, please use self. attr device info rather than a property. As above, please use dataclass and attr format: self. attr device info DeviceInfo(...) As above, please use dataclass and attr format: self. attr device info DeviceInfo(...) As above, please use dataclass and attr format: self. attr device info DeviceInfo(...)
English variable names please. returnValue instead of valRetour Actually, this style of variable naming is not the praxis in home assistant. Either make it return value or just result. Also, we prefer early return value and we can't be logging warnings for normal behaviour. change returnValue by return value You are still logging as a warning here. Also you ignored my comment on early return like the original code did. return change, and warning delete
Well not all support RGBW, we should handle it dynamic and only show the support if they are present over an property Yep, you're right. It got burried a bit over the numerous comments. It's on my list to adjust. Just set L692 , not need to have an property above Side note: I noticed that we don't forward the entry unload to the platforms when unloading the config entry below. Would be good to fix that in a follow up. Our standard is to use the config entry entry id as key under the domain key in hass.data. Would be good to rename CONF ENTRY ID to something that is less mistakable for config entry entry id. We should just remove the extra state attributes here. Brightness is set by the parent light class in the state attributes, and we don't want static info like host in the state attributes. We should rename this test module to test light.py .
you need to import here from future import annotations to fix pylint issue This is handled automatically by the entity description - the device class property can be removed. This is a good start - but I think you can move is on turn on turn off toggle to the base class by adding two properties ( on key and on value ) to the EntityDescription : You can take a look at Renault binary sensor as an EntityDescription example: L24-L29 After you have added on key and on value , you can add has consumption to enable today energy kwh and current power w Move the device class to an entity description Move is on this to the base class SHCSwitch Move is on this to the base class SHCSwitch , and you can delete the LightSwitch class Can you create a should poll property on the entity description? I think you can drop this class completely, and make should poll update part of the base class: This can be part of the standard class, and will just never get called when should poll is False
This also drops the requirement of these two to be reported always in pairs. Should we adjust the current change to keep that requirement? So, if a gps is provided, a gps accuracy is also required? Makes sense. I'll add this.
Should this use HVAC MODES from homeassistant.components.climate.const instead of reading an attribute? This indeed feels like a better way to go, but there is a downside - more labels are going to be created in Prometheus, even for modes, that are not supported by integration. When we create labels from an attribute, we are making sure that we don't create time series which will always be "0". A bit weird that we are usint state.state here instead of a named attribute. Does this actually work? Yes, I totally agree with you here. I tried reading the ATTR HVAC MODE attribute, but somehow I failed - it is not implemented properly in all integrations, for example, I use climate integrations from Fritzox, and it was not there. So I decided to fallback to state property, since it is implemented in the parent class and defaults to hvac mode: L208 If we decided to stick to ATTR HVAC MODE attribute, we will have to fix some integrations, at least the Fritzbox one.
Something sneaked into here... That's indeed for another PR We already have POWER VOLT AMPERE below. We don't need to add new ones here I think. We shouldn't, I added it because of the pattern in device condition and tests The new constants are removed in a20726d Should we use the enum here instead? Yeah, we should. Maybe better to refactor first, then rebase this PR? epenet is there a PR doing that already? Until now I have stayed away from the core entity platforms, and I think the other user who has kind of taken over has avoided it also. OK, I'll do that then Refactoring done this PR rebased.
It's weird we don't have coverage here, is codecov in the wrong or is something missing from the tests? Hmm good question, will take a look. Fine, but how is it used then? An automation would trigger on a state change of the button, which is updated when it's pressed? If that's how it should be used, will automations fire when the button's state is restored? An automation would trigger on a state change of the button, which is updated when it's pressed? Yep. the-state-of-a-button If that's how it should be used, will automations fire when the button's state is restored? That is not a concern, integrations are set up first (unless they timeout, which can't happen for input button), before the automations are started. OK, makes sense. And reloading an automation will also not fire, because the trigger would be setup to trigger on a state CHANGE? Added a test for that specific case in 1bddddc
Seems like you could use pytest.mark.parametrize for the different properties to avoid having duplicate tests? I didn't do that because it would have to have 6 params which got a bit messy so I figured it was better to write it out since it no longer was easy to determine to intent of the test I guess it's a bit tricky, but if most non-relevant values (like service names and platform) are hardcoded to the same things in the test, then you would only need zeroconf properties and matchers like this: It would not deal with "not present" cases, so that would have to be a separate test case (probably also parameterized). The downside for me is we loose the context that am is really about raop. tcp.local. , and what an raop host is supposed to look like. That could make it harder for someone trying to maintain this in the future if they make changes since the code is no longer showing the original intent. I'm not sure if I'd remember why it works this way or why we care about matching on am 2 years from now without the additional context I agree with that, sure, but my counter question is: why not support matching arbitrary Zeroconf fields instead of picking a few ones that "happens to be of interest"? There's no intent shown in code (only in tests) nor any restrictions as you can match this property with any service. This would have been better IMHO: Or similar. You get the idea. That would be much better. I'd have to break the existing matching or add support for yet another way to do it though since we have I'll mark this as a draft while I think about what refactoring all the zeroconf matching looks like since it will impact all the integrations using zeroconf We probably want to allow a properties dict A simple but backwards compatible solution would be to extract all "other" keys in the dict and treat those as matchers. So in this case: {"type":" airplay. tcp.local.", "model":"appletv ", "macaddr": "aa:bb:cc:dd:ee:ff", "foo": "bar"} We would "pop" type and use the rest as matchers. Obviously, this would impose restrictions since you can't match on reserved names ( type being one, not sure if there are others?). But it's very clean and backwards compatible as mentioned. Its more about rewriting the dev docs and updating all the manifests to the new method I've had 35 hours of flying and 50 hours of travel this week so I'm too wiped out to get it done this week.
CO2 dropped - so closing this conversation. Maybe consider changing the wording: If we change here, we should probably adjust the device automation wording too.

Have details of the crash? I assume its in turbojpeg, but i was curious about this step. I was thinking maybe this step is the problem since its produced by the worker thread but run in the main loop. However reading threading it didn't necessarily give me the impression this decode step could be decoupled, or that its cheap enough we can do it all the time. That is, it seems both heavyweight and tied to worker state. How often are there keyframes? (I was thinking through an alternative where the Stream asks the worker for a frame and it produces it on demand as it iterates, which is a little more complex from an orchestration perspective, but maybe less complex from a thread safety perspective if its just passing off the final bytes between threads) No, there wasn't much in my docker logs - I think the process exited with a 256 error. After looking at a discussion about threading in libjpeg-turbo, I don't think it's from that side. It might be from the python wrapper, but there's a good chance it's from the pyav side. I haven't been able to repro. It happened when I had 10 cameras on the same page pulling images every 10 seconds. I don't have a separate dev instance so I took off those settings and only have it pulling on one camera right now, and I haven't seen any problems. Keyframes depend on the input stream. Generally they're every 1 second or every few seconds, but for some of the modified codecs like H264 H265 they use really long intervals like 20 seconds to save on bandwidth. I use those myself, and I don't mind the lag. With the regular keyframe intervals this is not a concern, but for long keyframe intervals an alternative implementation is to wait for the next keyframe instead of the last one, resulting in a longer time to the first request but a shorter "lag" between the displayed picture and real time. We could try to move it to the worker, and that might solve a threading issue if we have one, but we'd have to add the overhead of the worker to core events signaling. Currently the only inter thread interaction is when the packet is set, but I think that is atomic. One more feature we can add is options for quality scaling which can help to speed up the encode implement the width height parameters used in Camera.async camera image How about returning None as i think this gives a clearer signal to the caller? For some reason I thought that returning None in HA was to be avoided, but that might have been for states or maybe it was even in another codebase. I can't find any reference now so I was probably mistaken. I'll change this. I appreciate the efficiency of this, however since this is called on demand interactively, i feel like an if statement in a generate image function would improve readability (e.g. The worker thread does X, the caller from the main loop does Y, etc) Sure, it is more clear that way. I recommend explaining the threading model of this class in an extended description, and what the responsibilities are, so sligh
Should this be a sensor with device class timestamp? Maybe? peak hour is the highest consumption hourly consumption. peak hour time is the time of the highest consumption. (I am not sure it is interesting to do any automation based on this) So they are strongly connected. I think it is a bit unclear when a state attributes should be used. If a measurement is significant on its own it should be a separate sensor. I'd say "time of the highest consumption" is significant on its own. Does this return a timezone aware datetime object from the library? Yes, and in local time
If there a reason to that a unique id is not being set and then calling self. abort if unique id configured() ? Such as this code: L73-L76 I didn't consider an ip:port pair a unique id in HA terms. I'll add a commit to change it. Adding a title is required. Adding a description is highly useful. Isn't "title": "Zugangsdaten" what you're referring to? Can skip the title and just use the one of the integration itself This is no longer used This doesn't have to be an instance variable? I don't see it being used across methods in this class. Doesn't seem necessary as you set and abort for unique id in async step user With that it seems as only return await self.async step user(user input) needs to remain in async step import These don't look optional if I look in the switch. Should they not be required? return True should not be inside the try. Move outside Doesn't seem needed. See comment a bit below on unique id dependency is not checked in the PR what if status comes back as neither on or off? Also needed in requirements test all.txt Seems not to be used?
Perhaps better to use an executor job for this instead of randomly creating a new thread.
Please move code that isn't expected to raise out of the try block Fixed Can we avoid a broad except handler here, and only trap the expected exceptions? Fixed Copying a dict to a list copies the keys by default. We can remove .keys() .
We need to check if the operation was successful and update the state attributes if so. See light.py and switch.py. I'am not 100 sure that I know what you mean. This? I can't see a clear pattern in switch and light. felipediel can you please elaborate? If the request worked, we want to update the state instantly, in the end of the operation, writing the state to the state machine, instead of waiting for updates from the data update coordinator. Example: L148-L152 We need to write all the state attributes we are changing, not only attr is on. Here's a list of attributes that we can use: L178-L205 felipediel I finally found the time to pick up work. I added the update calls and used attr almost everywhere. Please have a look :) I tested everything and it works flawless. felipediel can you please have a look again :) Awesome, thank you majuss! I will do it. felipediel can you please read the code? Here too. Add BroadlinkEntity as parent class. Add here self. attr unique id device.unique id
Maybe move do it chronologically, with the biggest version last? Yes, it doesn't matter for this change, but it may matter for the next one.
I expect you can't generate a value error any more, so probably could remove this. But without the int(), aren't you allowing in anything, including bad data? Looking at the the pydaikin API, it seems that whatever you pass in here will end up in the URL of the API call. So perhaps convert to float and maybe round to precision 0.1 before passing it? Any invalid data would then be trapped here. Yes you are right. I pushed a new commit with the suggested change.
Why should we catch the error and log in this case? If I automate on this, we should throw raise when it fails (or else my automation would be marked as succeeded instead of failed). Yes! This is my exact use case too - rebooting in a daily automation. Forgive my ignorance: Are there specific exceptions that should be re-raised ( raise SomeHomeAssistantException from err ), or is it safe to just raise (just not catch it) the RequestError here directly? You can let the existing error raise, or - in case that isn't a nice message -, raise an HomeAssistantError instead. I think the httpx message will be sufficient. I've removed the try except here. I appreciate the feedback frenck. I always learn from your reviews.
We don't need to add the integration domain to the unique id. The entity registry is aware of both the integration domain and the platform domain of the entity. I think you should be using homeassistant.helpers.device registry.format mac to create the unique id form the bluetooth MAC address. unique-id-requirements Thanks for the pointers, done. Please only patch the library, not our code. Done. I've refactored binary sensor.py to import the pyflic module rather than symbols in it to make it clearer from the test what is being patched (enables mock.patch('pyflic.Foo', ..) instead of mock.patch('homeassistant.components.flic.binary sensor.Foo', ..) ). We want to get the entity entry from the entity registry and assert that it has the correct unique id. Example: L27-L29 Thanks for the pointer, done. Please put the comment above the dict instead so we don't exceed 88 characters per line. Done. We normally concatenate, with comma separation, multiple patches with a single with statement. An exit stack isn't needed. I had this originally but black was formatting it really weirdly (even with () or ), patch.multiple seems appropriate and formats nicely. We don't use the assert setup component anymore. It's legacy. It's enough to assert that an expected binary sensor is present in the state machine, hass.states . Done.
This does not fulfill the unique ID requirements: unique-id-requirements :open mouth: indeed... So, I don't think there is a way to generate an unique id for this entity, according to this list :( Can we allow the user to define one from yaml (like mqtt) ? I remove this code
This elif is not like the others, is this correct? Remove empty line Indent
Maybe mdi:bowl is a better fit? Hi, you're quick :) I was thinking about it, app shows it as numbers, so went that way. I will change it for bowl then. Maybe call this last amount fed? Changed. Isn't this one more fit as a binary sensor? As in, feeding yes no? I was 99 sure you will point this out ;)
This can be part of DeviceListener ? We don't need separate handling for this? Hi, Unfortunatelly it requires another listener - to handle scene switches we don't want to have state of device - we need individual events. Device state won't handle situation when button is pressed multiple times - from DeviceListener point of view (and later HA's) state does not change - because button state is "pressed" the whole time.
This should use ClimateEntityFeature.TARGET TEMPERATURE Aah... Thanks : 1: I missed that development and was confused. :smile:
You should verify the connection can be established before setting up the platforms. That way the platforms don't need to do this check. This is a ZWaveMeEntity We have an existing attribute property to handle this: This is the default. But why is polling necessary? Doesn't the web socket connection send updates when available ? Don't implement empty update methods. Assign unique ID in the constructor using self. attr unique id self.device.id . Uniqueness is checked within the scope of your integration platform so don't include DOMAIN . name is a user generated value and is not allowed as part of the name. If a device provides 2 sensors, using just the device ID will create non-unique IDs. Just set self. attr available inside get new data Make this async so it doesn't run in the executor. This is super inefficient as it iterates over all available devices. Use a dict to lookup in O(1) time. I also don't see this method being used? Is it necessary since the device is already available as self.device ? Not used. Use f-strings. Unsubscribe this dispatcher when the entity is removed. (and add closing ) after this call) According to the parameter type this cannot be None. Where is this list being mutated? This has moved to the manifest. startswith takes a tuple Use f-strings. URL is not unique, as IPs can change. Is it possible to get a serial mac address of the stick? Why limit to a single instance? You didn't validate that the passed URL is correct. You are not using this Discovered instances need to set the unique ID and abort if configured or else the user will get spammed every discovery. It also should ask the user to confirm the discovery, not ask them again for the URL. Remove this and all constants that it relies on. Make this a callback Track the unsub of this function in the config entry and use f-strings. Not necessary Implemented in parent class. No token handling currently done.
May want to convert to absolute import Fixed Is there a reason why you didn't implement the Config Flow? I am not familiar with Micropel PLC's, however it seems to mimick a device? Before I start a review, it would be good to understand if this is allowed due to ADR-0010. decision Micropel integration is similar to integration like Modbus or KNX. There aren't specific devices, just memory addresses in PLC memory. The developer of the PLC program creates variables in PLC memory and the program works with them. This is the reason why I can't implement "Config Flow" and users have to configure HASS integration by YAML file. I expect that this kind of integration (include KNX and Modbus) will be able to do only experienced users with some technical background. iMicknl Any news about this PR? Hi guys, alexyao2015 iMicknl. This PR has been open since 6 December. I would like to ask you if we can move forward or if there is anything missing from my side. I feel like we're stuck in a deadlock and we're not going anywhere. Thank you in advance for your help. There are currently merge conflicts that need to be resolved. spacegaier Merge conflicts are fixed, now. Bu there are CI failures spacegaier Fixed, I can see all green OKs. just drop this property and use self. attr name in init See use attr for the next properties sure its a uuid :) ? it's configurable in yaml.... better use XKNX ? where is this used ?
We shouldn't add anything new to util init .py . Should be own file.
We don't allow scan interval as option. Every integration that supports config entries allows the user to turn off automatic polling and then the user can automate the update interval as needed with the entity service homeassistant.update entity .
Do we really want to make this change just for alarm control panel? This does not benefit only alarm control panel, it's needed to ensure a device automation can have either an entity id (legacy) or entity uuid (newly created). This param name should change since it can be two things now. Good point, fixed
We don't need action , use key . I understand it will work the same way, but what I wanted to demonstrate is that it might be a good idea to use specific properties for the button entity. Sure, but implement it locally in an child class of ButtonEntityDescription. action value it not a member of ButtonEntityDescription I know, but I wanted to raise the possibility of using specific properties for the button entity. So this isn't a PR Contribution? Sorry if I demonstrated in the wrong place. The PR will be closed. Thanks. Why do we append the name here? Feels a bit weird to make the name part of a unique key. Maybe it wasn't a good idea to use the name key, but I did it to make it possible to create more than one button with the same key, for example to make a select that might not have good usability for the user in buttons. This is a base entity-component and should not be modified. I know, I wanted to demonstrate that it might be a good idea to use specific properties for the button entity, for that you need to change the base-component. I know, I wanted to demonstrate Please clarify if this is demo or a actually PR. In case your intention is the first, please close the PR. Thanks Sorry if I demonstrated in the wrong place. The PR will be closed. Thanks.
Variable vs human text This is return to dock or something? Yes, it's the return to dock function, it includes why Tuya's documentation does ( In practice, it happens that some devices have a switch charge switch and others use mode chargego . Right should be call is Go Charge in that case? Or Charging ? I changed it to Return to dock, ok?
For future PR, import Platform from homeassistant.const and use Platform.SIREN etc. Will clean these up in the near future PR is here: NOTE: Leaving it in draft until after the beta to avoid conflicts if we have to patch something in ZHA Config entry nowadays also has an on unload callback. config entry.async on unload(unsub) PR is here for the cleanup of the other platforms that ZHA supports: NOTE: Leaving it in draft until after the beta to avoid conflicts if we have to patch something in ZHA You can also move this above init All sirens have the same available tones ? I'll double check the spec... but I didn't see anything that made it seem otherwise. Name it how it will be used. DEFAULT DURATION 5 seconds This should be canceled when turn on is called within this duration We should assert the state at the end of the test again. wow not sure how that got dropped... good catch
You could just use a super class here ( ButtonEntity ). Although if the type signature on async setup entry was right (anywhere in homekit controller) I don't think the annotation would be worth adding. I wouldn't bother adding the skaffolding for generic ecobee buttons for one button type. As we are only expecting one button with this glitch. The declarative style is for when we are expecting lots of very similar characteristics with simple mappings to simple HA entity classes. But this is a workaround for a buggy characteristic, and we've only got one button with this particular bug. So making the declarative version is overkill (so far). It would be better to just do a "standard" entity class. You define things like the device class directly on the class with the attr prefix. Then don't bother paramterizing async press at all. Something like this: You don't need to implement a description, and you don't need to pass it to this class. So you don't need to even subclass init . Then have: We can make it declarative later if we are flooded with devices that recreate this bug. Same as with the button entity. I don't want to parameterize quirks too soon. Ecobee is the only device with these bugs. Make ECOBEE SET HOLD SCHEDULE a normal number entity (as it doesn't seem to need quirks). Turn the remaining class into a class just for the fan speed. I think we can hoist this out of init and put make it a class variable and then completely get rid of the init . That said, i'm not 100 on the need to even use an entity description here. AIUI EntityDescriptions are when classes are data driven, and this one isn't. In this case the common pattern in other integrations is to do something like: (In this case you could just use CharacteristicsTypes.Vendor.ECOBEE CLEAR HOLD or self. char.type instead of self.entity description.key ). If this works, can you make the same change to HomeKitEcobeeFanModeNumber . I made those changes locally and this approach is working fine. get characteristic types drives polling and even subscription, but this type is write only. Can you test returning an empty list here. This is probably the first time we've tried that so i'm not 100 it will work. It might be you need to include it in this list to be able to use it with put char, but i've been trying to avoid that in recent refactorings IIRC). If it doesn't work, ignore this request and i'll come back to it in the future. Obv better to try it while there is someone with a device to test it! I made this change for the ecobee ClearHold and PresetMode entities and it is working fine. But FanMode is not using a custom ecobee class, so it is still subscribing to read this characteristic value. Should we move it to its own class and return empty array in get characeteristic types? This change only makes sense for write only characteristics - for preset and fan mode we want the number to be readable as well as settable. So only do this for ClearHold. It's a bit weird for async setup ent
This sensor is to bring more information to the user, for example, the home assistant status does not differentiate cleaning from moping and this sensor would bring this information to be used by the user in automations notifications. ![image]( It is a duplicate, I'm not a fan of that - Let's add an icon, to make it look nice. - Needs a custom device class to provide translations for the different options Done! Please review. Add custom device class - Let's add an icon, to make it look nice. - Needs a custom device class to provide translations for the different options Done! Please review. Add custom device class Already part of the Vacuum entity Already part of the Vacuum entity Select Mode is not part of the vacuum entity. The device has the ability to choose several modes not foreseen in the vacuum entity, this justifies the inclusion of the select Mode. ![]( I think we can justify it, but we need to make sure we add translations for them (and not show raw values). Can you tell me the correct way to include the translations? More information can be found here: Done! ![image]( Thanks This provides a bitmap, according to the documentation. How is that processed? There is no definition of the bitmap in Tuya's documentation. Soon the sensor will bring the fault code reported by the device. ![image]( If we don't handle bitmap, we should not add it. As this type is unknown, it will always result in None . So this currently creates an permanent "Unknown" sensor (regards if the sensors has a value). Is adding as a vacuum entity attribute acceptable? Removed the fault sensor. Select Mode is not part of the vacuum entity. The device has the ability to choose several modes not foreseen in the vacuum entity, this justifies the inclusion of the select Mode. ![image](
So, this property needs polling (just like the battery), should both of this share the same code path? Is it possible to share some code among these? The codepaths are totally different. The battery info is polled, but from a central polling handler in speaker.py (not the built-in entity polling). The battery polling is also intentionally throttled to avoid hitting the battery-operated devices too frequently. Ok, I have no clue about the internals, I just recalled hearing reading that the battery is a pollable entity and I was thinking this would be alike. So just forget this :-) The battery state, which also requires polling, implements this method to perform the polling. I suppose the reason is to avoid polling as these entities are not enabled per default? There are two types of polling in the integration: 1. Fallback polling when subscription events fail. If subscriptions are working properly, these polling endpoints should never be called. 2. "Regular" polling where the data we need is not available in subscription event callbacks. That's what we need to use for this new sensor. Sorry, to clarify: this async poll method is used for the fallback polling. Since we're already always polling it's not needed. You could probably use attr 's instead. Will need an init . Can do that for all entity types as a followup. Actually, this would clean things up a bit. Will update shortly. Done. async get registry is legacy. Use async get instead. And we try to avoid accessing hass.helpers . Addressed as part of 61198.
For a future PR, this linear isinstance search should probably be a dict lookup Yeah or using a Task wrapper class for Event too, and introduce a base class with a handler funciton or similar. The reason I split it in this PR was a linter error. Agreed, optimizing it should be in a future PR. We could make it wait for an asyncio.Event (set with hass.add job ) and await that instead of typing up an executor thread asyncio.Event is not thread safe, and afaict we are running in two different threads... Rough implementation (untested) that avoids holding executor thread using add job which uses loop.call soon threadsafe L333 Hm, I see that way around. Yeah seems safe, and avoids run in executor . I'll test it and add it to this PR. Let's not have mutable default arguments Ok, I guess then we can leave the name as it was, essentially reverting this line: We can probably do a shorter timeout in tests? My worry is that the test might end up to timeout for other reasons than the database being locked (e.g. not all events got processed within the time). In the end this kind of timeout testing are somewhat racy by nature to some degree. A quick test on my somewhat old laptop showed that it normally takes about 10ms to lock the database. I'll set it to 100ms which should be fairly save. Move magic number to a constant to allow us to patch it in tests. Maybe make MAX QUEUE BACKLOG 0.9 a constant? Since the message just below refers to the 90 I like to have that factor nearby. The typical case is to record events, not handle special tasks. Should we try that first? No we can't as that code does not check the type. It accesses event.event type , which is not a valid property on tasks. Btw, the only reason I separated this in a function was because a linter complained about function lengths (the two lines seemed to pushed it over a limit). Implemented in I know I am a little late to the party, but I thought of some improvements: - Backup logic should live in the hassio integration. Recorder (and potentially in the future others) should indicate they have interest in this. Maybe via a hassio.py platform. - WS API should be in hassio too. And here for a bit more crazier one: - If the supervisor were to disconnect abruptly, it would never call backup end . That will leave the system in a broken state. It would be better if the backup start would store the "end backup" logic in [ connection.subscriptions ]( L114-L118). Subscriptions are automatically finished when the connection is disconnected. That way, if the supervisor's websocket connection breaks, the backup mode is ended. The supervisor can then [end the subscription]( unsubscribing-from-events) when it's done to also end the in-backup mode. Backup logic should live in the hassio integration. Recorder (and potentially in the future others) should indicate they have interest in this. Maybe via a hassio.py platform. WS API should be in hassio too. Agreed, also suggested that in the PR intro (at least the WS pa
Why is this disabled by default? As there is an option in the vacuum UI I preferred to leave it disabled and the user to enable it if you want to use it in automations. Do you think it should be enabled? So if this is already part of the vacuum entity, why add it here again? The Tuya integration has moved to use StrEnums for this. Why is this disabled by default? This is the vacuum state, right? Why introduce that as a separate sensor? This looks like a bug fix, which should be a separate PR. What does this do? Tabs vs spaces Should we add support for the others too? Like total clean area , total clean count , etc? Does this need a state class ? Should this have a nice icon as well? I'm not sure if this should be implemented as a select entity, to be honest. It provides steering controls (left, right, and such) for the vacuum cleaner. I don't think that a select provides the best user experience for such controls? Should we implement others too? Like collection mode and cistern ?
Maybe you could create a constant here DHCP REQUEST DELAY , then you could patch that instead of patching asyncio.sleep Good idea! You should patch either the contant (if you create it) or patch the "local" asyncio.sleep: patch("homeassistant.components.fronius.asyncio.sleep") config flow requires 100 coverage. You will need to add a test for the invalid host Why is HomeAssistant always imported but not DhcpServiceInfo ? I am not sure what is the best code style is, but I think it should be consistent. I figured the integration would not run without HomeAssistant loaded, but doesn't necessary need the dhcp integration (could be disabled etc.) but I'm not even sure if this makes any difference. Have removed TYPE CHECKING now. Usually we try to avoid broad exception handlers. Can this be CannotConnect ? I guess CannotConnect would suffice. I was basically copying this schema from the user step - which was copied from the scaffold script L92 Since this runs without any user interaction I think it makes sense to catch broad here. - aiohttp.ClientError - aiohttp.ContentTypeError - json.decoder.JSONDecodeError - asyncio.TimeoutError - and KeyError at unpacking are handled by pyfronius - not sure if there can raise something else, like OSError . should I except both, CannotConnect and Exception and do different abort reasons log the exception if not CannotConnect? We usually only use the broad except in the user step. Ideally we don't catch exceptions we haven't planned for because it will hide bugs and make them harder to track down. If the library is expected to throw OSError then we should catch that as well. I couldn't find another integration doing a broad except catch for dhcp (is possible I missed it since I'm a bit tired) git grep -A 50 async step dhcp No OSError isn't expected - we are just making http calls with aiohttp. Most integrations using DHCP use the mac address as unique id. This doesn't work with Fronius since the API doesn't respond it. So we need to make an API call in the DHCP step to get the unique id. Let's change it to CannotConnect and see if at one point an issue is raised by a user - I wouldn't expect it. Please patch the integration setup function on all create entry results to avoid setting up the whole integration.
Oopsie Should go ahead and convert to the new device class and state class enums instead of the constants. just saw your comment from earlier about updating all the device and state classes in a future PR
We don't allow calling entity internals from outside the entity. Usually we use async dispatcher connect and async dispatcher send for these type of cases Instead of storing the entity, use the dispatcher. Consider using a dataclass instead of a dict as it makes it easier to type L12 This doesn't need to be a coroutine function since we don't await inside. Make it a callback instead by decorating the function with callback imported from core.py.
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. More information about this can be found in Architecture Decision Record: - ADR-0010: decision I have started to work on such PR ( but got stuck waiting for changes upstream, still waiting for them thecode could you link to the upstream changes that are holding back config flow for the webostv integration? Would love to see the webostv have config flow and had the feeling you were really close. I'm confused now, is merged, but there is a TODO-list in its description? emontnemery it was merged to home-assistant:thecode-add-webostv-config-flow not the dev branch since it was apperently not fully ready yet (I think). I was following that PR, so hopfully it will be revived now. The two items in the todo list awaits changes upstream. 1. This PR: which disable the local storage file used by the library, there are some ways to workaround this, but few months ago I was promised they will happen soon so I decided to wait for this change. 2. To solve the unique id when migrating to Zeroconf SSDP discovery a change upstream needed to read a unique id from the TV, I already made this change locally but did not make a PR for it, since my first PR was waiting. emontnemery the reason there is TODO is that I initially started to work on finishing a PR which was created by someone else and during review and testing I discovered it is far from being ready (the main problem was related to the issues in the TOOD list), the plan was to wait for the changes upstream and finish the PR. since the PR was already big MartinHjelmare suggested to finish the review and merge it to a branch. For now I don't think the with the current progress upstream it will be possible to finish my PR, however just today I had a contact from someone who forked the library and is maintain it, the storage is already fixed there (all storage related functions are moved to a storage class). I am considering changing the library to this and finish this PR. I had a call with the owner of bscpylgtv he will help me with the required changes, as a first step I will verify that this lib doesn't break anything with the integration and plan to resume working on the config flow PR. thecode that is greath news, If you need any help or testing let me know. I have a dev setup and a LG Web OS TV. This is a custom integration based on bscpylgtv fork: I am already using it in my prod environment with no issues. Will highly appreciate testing as it will be the base for the config flow PR. thecode sorry for taking so long, but I finally got some time to test it out. Unfortunatley it did not work, both on my dev and production env the custom component does not work. On the dev env if I start with a clean configuration, it will ask me to couple the TV through a Notification, I press the button on the notification, the TV asks me to accept, I hit YES and then nothing happens, the notification will ask again
We could make it 3 steps... - requirements.txt contains what core minimally needs - Install core - install requirements all.txt The latter changes the most That particular order defeats the purpose of the change: The idea is to avoid installing requirements again when I just made some code changes. We could still split it up, it would speed up build when just requirements all.txt changes, but not sure if that is worth it? - install requirements.txt - install requirements all.txt - Install core The idea is to avoid installing requirements again when I just made some code changes. That is why I respond on this, as requirements all and the codebase change a lot (I'm pretty confident that the amount of builds without a dep bump is nihil). Hence the original suggested change in this PR doesn't change a thing. If anything, installing just requirements.txt first, would help, but should not have a big impact. (I'm pretty confident that the amount of builds without a dep bump is nihil). Hence the original suggested change in this PR doesn't change a thing. It does for me: My iteration time to build a new Core container (to test it with Supervisor and the whole stack) goes down significantly. I guess we are discussing different use cases. My use case is local development, where I mostly change source code and not touch requirements.txt or requirements all.txt that often. It does for me: My iteration time to build a new Core container (to test it with Supervisor and the whole stack) goes down significantly. Ah right, yeah in that case: - install requirements.txt - install requirements all.txt - Install core Is the better order indeed :) We should update the Dockerfile.dev in that case as well. Hm, seems we don't copy source code there, I guess its bind mounted by VS Code to workspaces . Ah, did you meant separating requirements installation? In Dockerfile.dev we don't install requirements all.txt , but we do install requirements test.txt . We could separate those into two RUN commands to increase caching opportunities. Updated.
Please rename this file to homeassistant components yamaha musiccast strings.select.json Then follow the steps here test-translations to make sure homeassistant components yamaha musiccast translations select.en.json is generated correctly Translations should be introduced via lokalise: Please define the valid device classes in a container here in the platform and validate the device class before returning it. The device class is a Home Assistant API so we need to be in control and make sure it is correct before returning it.
I was thinking this through again and for my particular setup, i have http 2 in front of my internal url -- but then I don't have hairpin nat so my external url is not accessible internally. So, i'm just one data point but i am not sure this detection would work for me. I realize my case is not common. I think that is a fair point. My external URL can only access api camera proxy and api webhook . I primarily use my Internal URL for access it has the HTTP 2 proxy, the external one does not since it is only used for notifications and the like. I do not think it is safe to rely on specifically internal or external for this. Maybe either check both and then set them independently or allow the user to configure it? Thanks for the input. Given the wide range of different setups, I think we should just scrap this PR altogether. We can let users set the LL-HLS option themselves and perhaps default it to true at some point in the future.
Could you move all these classes to a separate module (eg. models.py )? It would help clarify the code. Please use the new enumerator: Only the english translation should be present in the PR. Other languages will be generated automatically.
This is a non-documented DPCode. We should at least add a comment about that in here including a small note on what device this was based. Done. Nice catch!
I would move EcowittEntity to a separate module. Should this one really be in a separate file, the base entity in this case is so simple. Is the preferred structure now to have a separate file? It's not compulsory, but it seems to always start off simple - and then somehow just seems to grow as we add platforms or features... (I have to say that attr and EntityDescription have helped quite a bit with that) It's common practice to put base entity definitions in init .py . I think this is okay. I would split this into two lines. do you mean the hass.data.setdefault? that seems to be the convention now. I think in balboa I had it split and then was told to merge it like this. oh ok. For reference: discussion r748936790 I think it was mostly to drop the if statement, but if it's ok for bdraco it's ok for me. While the review is in progress, why not add coverage... I'm working on it little by little, but, these two are hard. I need to rethink how I do the config flow tests here.. this will take a little while.. No need to set the ECOWITT prefix: No need to set the ECOWITT prefix: No need to set the ECOWITT prefix: No need to set the ECOWITT prefix: No need to set the ECOWITT prefix: Following a recent update to the core, DEVICE CLASS TIMESTAMP should now be reported as native datetime not as a ISO strings.
There are multiple platforms in this pull request, please make your PR as small as possible. See: 5-make-your-pull-request-as-small-as-possible frenck The issue is that the integration is used for monitoring 3d printing, as such it's not really possible to deliver only a single platform and the integration be considered useful. The sensors included represent a minimal subset that are common in monitoring setups. I can break it up if there is no other option, but it will be somewhat unfortunate as it will mean many many months before the integration has any practical use for users. You can add other platforms in follow-up pull requests. Please limit this PR. 1 on reducing the size of the PR. The initial PR can take a while, but once it is merged subsequent follow-up PRs are usually much quicker. It's not a matter of opinion or 1's or something. It is part of our contribution guidelines and requirements. I removed button and binary sensor for now. You have to use dataclass properties now (see 60561): Thanks for clarifying.. I'll sort it out on my end. Additionally, if DATA CONNECTOR is the only thing stored for this domain then we don't have to use that additional dictionary. Seems to be unused You might want to consider using a DataUpdateCoordinator here. It can be used without polling and helps with the signalling updating of entities (and the data) and makes the code more common to other integrations. We should not have to pass the loop. That is the default These should all not be needed. The coordinator can handle that. You don't need to send specific signals or make each entity listen for a specific signal.
This looks like we calculate the power from the current and voltage. We don't allow calculating state in integrations that integrate devices or services, besides some exceptions for time. Device and service integrations should just report what their API provides while following the entity design of Home Assistant. Please remove this sensor. That's unfortunate for users as they will have to create their own template sensor that does the calculation in order to see a, user friendly, power value for the Wall Connector. EV chargers are sold by their power rating and the charging power is a universal way to see how much power a charging vehicle is consuming, regardless of grid voltage. Is this "rule" documented somewhere? I'm not sure if it's documented.
Use Platform enum L22 done Can be removed since loading from config entry The whole block or just the return? The whole block can go as we it should only be used from a config entry Since it is a verbose debug log, it should not matter to stay inside to add logging if necessary True but for me a quite pointless debugging in production code Not used anymore use from future import annotations And don't seem to be needed Optional[X] is equivalent to X None typing.Optional I know but it's more clearer to write as such which is asked Remove as we should load the integration from config entry I recall the integration guide recommends adding a configuration setup as well. But I might be wrong here. Don't think it's specifically mentioned in the docs but it's not asked to create yaml setup together with a config flow for new integrations Why is a try needed here If an invalid old config layout is used the integration setup will fail. (Integration was previous available via HACS) Why not check the district then compared to some list and do things depending on outcome. This try block seems overcomplicated for the job. Don't use state, use native value Where can I find details in the docs? L260 Use attr for these and all the properties below L251 done Don't use unit of measure , use native unit of measure I thought the native unit of measurement should only be used if the unit will be modified by the SensorEntity native unit of measurement Attribution should be set with attr attribution and not be in extra state attributes For platforms it is necessary to use the extra state attributes as described here: using-states-in-your-component
If this is a fan, is should be implemented using the fan platform instead? Definitely, yes! Completely overlooked that there is a FanEntity . Sorry.

We should let the exception propagate so feedback is given to the frontend what the error is What is the intent of this guard?
Pass the error string to ConfigEntryNotReady . It will take care of the logging and will not spam the logs over and over again on retry Similar feedback to r780069119 We shouldn't change the global loggers here as it will override what the user has asked for I agree that this solution is not optimal. The reason I did this is because the third party library I'm using to handle Websockets (python-socketio) writes all its debug logging to the INFO log level. If we don't change these global loggers, Home Assistant INFO logs would be spammed with multiple messages every second. I tried to search for a way to redirect all that verbose logging to the DEBUG log level, but I couldn't find a way to do so. You can use a filter instead like the mjpeg integration does. This returns a callable that can be used to cancel this. Is it possible the integration can get unloaded before it runs? Yes it is possible for the integration to be unloaded before the scheduled task is run. I have updated the code to store the callback in hass.data and run it in async unload entry . Reverse the condition, return, and outdent below The amount of key values is getting rather large here. It would be good to use a dataclass at this point. Example L155 L12 Why is this running in the executor? Is the websocket not using asyncio? We need to validate existing entry isn't None and abort in case they enter credentials for another location We should't ask them the HOST and unique id as they should not change in a reauth flow We shouldn't access extra state attributes . We should access the data that is being used to create it instead. We shouldn't access extra state attributes . We should access the data that is being used to create it instead. We shouldn't access extra state attributes . We should access the data that is being used to create it instead.
I think we should not have separate encoding parameters. Will discuss this first with Erik. Made the a generic encoding config parameter now. This will help to implement processing raw or different encoding using templates. I don't think it really matters, but it seems the method name here has been inversed with test value template with entity id I'll have a look See
Isn't it possible to set an icon for the entity in lovelace frontend? It is, but the root [group integration ]( allows for setting an icon in YAML, yet none of the other groups do. Imo it's a bit tidier to allow setting it in YAML than using customize.yaml, as well as adding consistency We don't want frontend options in the backend. The general group has a lot of legacy. The user can set a unique id for the light group and be able to change icon in the frontend or use the lovelace frontend for full customization. This seems inconsistent with many other integrations (Slack notify, webostv, generic group, fibaro, netdata), do they need updating for the icon parameter to be removed then? All of those are legacy features. We don't need to remove them, just don't add any more of them.

Is it possible for the library to keep the connection open? Maybe. The library is written very simply right now (I don't own this library), but some quick testing with curl shows that my newer venstar accepts keepalive, but my older one replies back and says "nope, closing anyway" So I'm not 100 sure what that buys us. The sleeps are for the benefit of the old ones, which wouldn't benefit from keepalives. Though, if the library was rewritten to use them, it could concievably look at the API version and inject the sleeps. Either way, it doesn't support them yet. I can go ping the author and see if this is something he is interested in trying to do, or if this is something I'd have to PR myself. Please remove stype and use the key instead, unless there's a special reason for this separation. We name the sensors to the user "humidity", but the backend api and device itself knows them as "hum". In the case of battery this looks fine, but.. The key is only used for the unique id. That's not user facing. It's ok to use "hum" etc there. Please remove this patch. Why am I removing this patch? get runtimes in the api makes a direct call to requests and triggers the pytest socket error. We're not supposed to patch the onewire integration in the venstar integration. That looks completely wrong. This is a dict, not a list. coordinator.runtimes gets back a list of dictionaries, of which we always want the last one. Iterating a dict iterates over the keys by default. Try it out. The coordinator entity already sets this attribute. If we define lambda functions in the descriptions we don't need these different entity classes. We can use the entity descriptions to differentiate the entities. For the native value, the lambda function can accept the coordinator as a parameter and return whatever data needed. For the entity name, the lambda can accept the client and the sensor name. Example: L121 Either here or in a separate PR: - Please also fix the climate tests on line 23 and 59. - L23 - L59 - It would be good to also change patch to patch the time slept instead of patching asyncio.sleep. Normally we define a constant for the sleep time at the module level which can be easily patched. Oops, yeah.. I'll fix these two instances too. I'm amazed it actually worked as-is. You mean do something like: SLEEP TIME 1 ... asyncio.sleep(SLEEP TIME) and then in the tests: patch("homeassistant.components.const.SLEEP TIME", value 0) (or similar, need to look that last bit up) Since the unit is always a constant we can just use the description attribute native unit of measurement and set it to the constant. We can remove uom fn from the description class. I had to do this, because the temperature one has a complex uom. I'm not sure how to deal with it without a separate class if I don't use the uom fn thing here. Right, I missed that one. We can remove this property if we implement the comment below. Since the lambda spans more than one line it's easier to read if we just define
Stale commented code Shorter: Additionally, any reason why you are using a dictionary here? Could it just this instead? Stale commented code Stale commented code Stale commented code Stale commented code Stale commented code Stale commented code Stale commented code Stale commented code Stale commented code These comment aren't needed I think? Stale commented code Stale commented code Stale commented code Stale commented code Stale commented code stale debug print Stale commented code Stale commented code Stale commented code Stale commented code Stale commented code Stale debug prints Stale debug prints Stale commented code Stale commented code Stale debug print It should always have a coordinator? How would it be possible to not have the coordinator?
Should it throw instead? I don't know. Do we want to raise an exception here? well, as a user I would like to know if my automation failed and why. It will now complete successfully if something goes wrong, and nothing will be visible in the automation script debugger. So maybe the right approach is to not catch any exception here?
Please don't add more platforms with this test pattern. See my comment in the earlier PR.
This is not the correct place to raise, we should raise from the PLATFORM SCHEMA by adding a custom validator which does this check. This is done in many places, for PLATFORM SCHEMA in example homeassistant components mqtt fan.py Thanks for the hint. I was sure this is not the right way but didn't find a good example. Will look into this Done and test-cased. I'm not sure this is a wanted change, it will force all users to update their configurations. Exactly! As I tried to explain in the PR description: Users are already forced to update their configuration due to the previous PRs. Let's get this one in so there won't be another breaking change in 2022.01 Another perspective: Most users of the statistics component use a statistics sensor and an attribute template sensor or an attribute triggered rule to work with the characteristics. After those parts of their configuration will fail quietly , so it might actually be a good step to force this error onto them. Wdyt? Do users who are using the statistics sensor to average a sensor value have to update their configuration? According to the breaking change section in the breaking change before this PR is that there are no longer any statistic measures exposed as attributes. No, the (default) average mean functionality of the statistics sensor is not broken by 59867. Yes, every attribute is removed (hence broken) by 59867. Therefore, every configuration that relates to an attribute will be broken and I suspect many of these configurations will be broken without any or a direct warning (thinking of attribute triggers or indirect "your template config is invalid" warnings). As I mentioned before, I see this as the last bigger breaking change in the evolution of the statistics sensor. I would certainly be able to avoid this change. I see options to keep the old behavior or to deprecate defaults over time. Overall my main argument is that now would be the best time to rip the band-aid off. I understand your hesitance to accept a breaking change. Hope I made my point, maybe you want to discuss internally, please advise. deprecate defaults over time That's better, let's go that route. Done. We typically do this during schema validation instead, add it as the first validator in PLATFORM SCHEMA . You can tweak this in a follow-up PR. This way I might even be able to avoid the placeholder STAT DEFAULT . Will look into it in the next few days.
attr temperature unit can be used instead of the property. Yes, except, this should become dynamic in a followup PR ;) Nevertheless, will adjust it :) Depositing rhyme fog sounds like a good band name, but I'm not sure what it means here. I am not following? The number of states HA has, are limited. So this translates the (extensive) list of WMO weather codes to the best possible ok available in HA. Do you think there is another state that is a better match? I assume it is rime fog? Rhyme fog indicates a poetic fog. ![image]( But yeah a typo in a code comment, sorry about that. Still, my question remains, do you think there is a better match? Or was this all about a typo? Not sure, this sounds like it is more about icing than fog, exceptional could work too. MatthewFlamm What is your suggested state? Could you please provide a GitHub Code suggestion to indicate what you are talking about? I'm completely lost on your comments. My original comment was about the typo, not knowing what it was. Now that I know what it is, I think either fog or exceptional works for the HA state. exceptional is, IMHO, a mistake in Home Assistant. If a weather condition is exceptional or not, it generally depends on the location you are at. For example, sunny it quite exceptional for me This a problem everywhere. I interpret exceptional as "not an HA state" rather than exceptional for your area. If we go towards trying to accurately describe different local "normal" experience, the number of states will explode. Use the helper ![]( Watching this comment... what helper? diff-07e20eb7c6560330f9774eb23343f5dd3002106bb8b6523ccb18d95857990d77R22 Done Actually, should this include the zone name? No need to check this as you get the entity IDs from the state machine. Actually, I do, as the comprehension uses state.name , as the returned state can be None it needs to be checked (typing completeness). Why not use "Home" or the name of the Home zone? (but still put it at the top) Done Not used. Should this be implemented as the available property instead? Yes no, in the end, current weather can return None from the API, thus needs to be checked as typing demands it :) load fixture modern approach is passing in the integration name as 2nd arg: load fixture('forecast.json', DOMAIN) I added support for DOMAIN FIXTURE NAME as a fallback L405-L406
Should we point this to the English version of the website instead? I did wonder, hence the comment. I'll point to the English version of the site instead if you prefer
L55 LGTM
This will not work for add-ons. Check the source of the configuration entry and see if we need to redirect it to the add-on ingress interface. Should be fixed now, thanks frenck!
I think you inverted the warnings. I think you inverted the warnings.
I think this should be added to SENSOR TYPES constant. Pass the description as a parameter Recommended practise is that lambda functions should be one-line only. If it's multiple lines, create a function and reference it here: Makes sense ... In order to avoid the type ignore you might be able to also use a separate function is update available . Interestingly that doesn't help. It just moves the place, where I need the ignore. I assume, I would need to specify the coordinator data more precise, but as that is JSON, that could turn out ugly ... It would be nice to get this typed in the upstream lib and return a dataclass instead of JSON, but thats probably too big of a change here. I like the idea of a dataclass and will look into it. But I agree that this should be a separate step. Not sure what the style recommendations are on this one so this is more of a note for core reviewers. Anyway 1 for using pytest.mark.usefixtures With VSCode showing the arguments as faded to show they are unused, I find this explicit description much clearer. Why drop the ? I access device in is connected to router and with pylint complains about the private access. Since this is all in init , you could simply use device and device name function arguments instead of self.xxx hmm, I'm not seeing it. Could you help me out? The signatures of is connected to router and the lambda (and any possible upcoming sensor) would need to be the same although is connected to router is most likely the only one needing it and having the information available inside the entity, right? Isn't then accessing entity.device (and by that making it public) cleaner? You keep the change at the top (lines 24 25): But in the subsequent lines instead of replacing self. dev... by self.dev... you replace it by dev... (drop the self. ) Got it! I was at a complete different spot in the code ... Instead of patching home assistant, update the entity in the registry to enable it By spying at other integrations, there seem to be two ways to do that. I chose the one that seemed simpler to me. Use dataclass properties now It would be nice to get this typed in the upstream lib. It is typed, but with dict[str, Any] as its the JSON the device returns to me. Usually we patch where the library is imported so we don't accidentally patch places we don't want to change In this case it would probably be better to adjust the mock device instead The mock device is just a collection of patches itself. I'm not seeing, how I could adjust it. Can you adjust mock device instead of patching here? Can you adjust mock device instead of patching here?
Note that this range is intentionally large as to accommodate both Celsius and Fahrenheit units - the actual unit will depend on the CoolMasterNet unit's current config. I am not sure whether this is acceptable as technically this is logic to communicate (well, parse the response of) with an external device that's not in the upstream library. I am planning a big overhaul of the external pycoolmasternet-async library down the line and would like to address this problem then - is this OK? You can open a PR with pycoolmasternet-async (I'm its maintainer :)). However, I'm not sure about trying to deduce hvac action this way when the unit doesn't provide the info. I'll let the HA core team opine. Same as above with regards to communication with the unit not happening within the library. Question: can these strings be translated? I checked the translations subdirectory in another integration ( tado , which I used as an example to write the service) and there was nothing for services. This is already supported by HomeKit: Please open another PR to make changes to homekit. We don't want to combine changes with another integration in the same PR. Also we need a test for all homekit changes as we have 100 coverage on all HomeKit accessory code This is a new "auto" current state for when we can't get a more precise action out of the HVAC device. This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository. changing-the-entity-model
In the future maybe we can use the dependency resolution code to generate these Base platforms are not bound by dependecies. What about "quality scale": "internal" ? I probably needed to give a bit more context here: This list looks quite similar to: L93 Related: L7 What about "quality scale": "internal" ? What about it? I really don't want to trigger a full suite if "season" or "uptime" changes... I probably needed to give a bit more context here: yes, the base platforms are defined in our codebase as well (and are actually incomplete as we have discovered today). I guess having a single source might make sense, right now, I'm kinda happy it is contained in the CI itself actually... (regardless of code). If this all turns out to work as expected, I'll adjust the CI to get the base discovery integrations from Python, opened up a PR to adjust hassfest to have a matching list as well. Nothing depends on homekit itself so I'm not sure we need this It does, discovery Isn't homekit discovery fully contained in zeroconf ? L442 Oh true! LOL I've added it to hassfest in a local branch, but not to this file Thanks!
For areas we set the ID to be based on the name (and then it can never change again). Is that something we want to consider? entities already have an entity id a name. Giving it a unique ID, prevents the "i want to change it, as it isn't fitting anymore" problem question maybe?
This seems incorrect, as it can also return a datetime now? Of course, you're right.
This should not be solved in this helper, instead, contain solve it within the twitch integration itself. Thanks for checking, I'm going to close this pull request.
Please only wrap the line that can raise in the try... except block. Use an else: block if needed.
Please pass an empty dict to have the helper generate a service schema that works with target parameter. Submitted
I don't think we need to have this as a parameter (as this make use as a filter also harder). Instead, we could check if we could parse it, if not, try to see if this is a UNIX timestamp instead.
Since solar net device is a DeviceInfo object, you can use the ATTR MODEL and ATTR SW VERSION constants Thank you very much! Can you put these in alphabetical order? Can you put these in alphabetical order? Can you put these in alphabetical order? Can you put these in alphabetical order? Don't we have a test for this sensor? No I have no real-world data for batteries since I don't have one. On discord someone offered to send me responses of his system when his battery is installed about end of November.
Home Assistant requires 100 coverage on the configuration flows, please add a test for this added case.
These are swapped, please fix that I hope I have fixed this. Why does the lock change states to "unlocked" when the latch opens? Is that a valid assumption? ![image]( The lock can assume 3 states - Riegel bolt is locked Falle latch is locked - Riegel bolt is unlocked Falle latch is locked - Riegel bolt is unlocked Falle latch is unlocked -- Door opens automatically through the seal The state where the bolt is locked, but the latch is unlocked can be done manually, but not automatically. The automatic door opener always has to open the bolt before it can open the latch. This is mechanically locked. With this state, the command "open" always causes the latch and bolt to be opened. Where, on the other hand, the command "unlock" only leads to opening the bolt. The latch is in this case is always locked. That depends on whether you look at it from the perspective of the door or the lock. If we remove the STATE OPEN , then the resulting state of the lock is unlocked (the state of the door id open ).
Usually we give users a chance to try again and present the invalid auth error (aka [ key:common::config flow::error::invalid auth ] ) Can you use a more exact patch target here? Is a more exact patch target possible here as well? Is a more exact patch target possible here as well? Is a more exact patch target possible here as well? Is a more exact patch target possible here as well? Please only wrap the line that can raise in the try... except block. Store the result in a local variable and check it below. Thanks,
No deep linking available
Wait to store data in hass.data until after ConfigEntryNotReady Fixed in 44b806a Move code out of the try block that isn't expected to throw Fixed in 99683d4 Fixed in 1e80528 Please use upper for constants Fixed in 6ce24c5 We usually use value fn (see august ) Fixed in adcd6fc Please limit initial contributions to a single platform. 5-make-your-pull-request-as-small-as-possible Removing the sensor platform from this integration would make it pretty useless since it wouldn't contain the energy sensor, which for me was the reason to integrate the Tesla Wall Connector into Home Assistant in order to have it shown up in the energy dashboard. I could remove the binary sensor integration but that would mean that the users wouldn't be able to create an automation on when the car is plugged in charging. I understand that pull requests should be kept small but I find it a bit pointless to limit it to just one platform, the binary sensor platform doesn't add much code. If I leave it it, would it just be in order to make a new pull request as soon as this one is merged? Once the initial merge is done, open additional PRs to add the other platforms. Usually we want the smallest platform first since it keeps the initial PR small since large platforms in initial PRs can take months to find a reviewer willing to work through it with the OP Make sure to not interact with any integration details in tests of integrations ( hass.data ) writing-tests-for-integrations Improved the tests in ffe5ce7 Optional: There is a lot stored in here, consider making this a dataclass Example: I was actually planning on making this change :) Made the change in 5a02d54 Is there a web ui? If so add configuration url Yes there is, but it's just not useful for anything as configuration is done via built in wifi hotspot: ![image]( Move this out of the try block since it cannot fail Do this after async abort entries match so the host gets updated in the config entry if the ip address changes. Edit: We probably want after since discovery causes the device to be queried and we don't need to do that if the ip hasn't changed. You can drop CannotConnect since the library already throws a specific exception for this case. Use WallConnectorError instead Drop unused fields binary sensor entities should not implement state directly. Instead implement is on as described properties state is automatically derived L184 If you want to type this. Example here:
Is there any reason to not accept both activity and discovery so we can reduce the chance we have to poll? I thought I had seen discovery trigger false positives (i.e., when speaker was not actually available), but that was probably my poor testing methodology. I think this makes sense and will completely avoid the need to poll for well-working setups. Maybe async offline ? Maybe a comment to explain why it works this way? This timeout is probably too low if the system is loaded we have seen the event loop running behind at setup time up to 10s Is a 10s timeout not long enough then? Since we bumped it to 10 in zeroconf nobody has complained so I think its fine L36 In a future PR, it might make sense to rename the decorator Thanks. I couldn't think of a way to make this cleaner without a whole lot more code. Maybe we will come up with something in the future. We prefer importing helper names normally instead of accessing hass.helpers , to aid typing. Done in 60848.
Unnecessary else Normally, just because the device is in cooling mode doesn't mean it's currently cooling (all the time). If the device doesn't tell us what it's doing right now we don't allow calculating or guessing that. Thats why I checked that the state is on in the line above. State is on and it is a colling device it is currently cooling So state on means that the device is active in whatever mode is set, and not just that power is on? Yes that's the case. According to supported-sensor-types-and-states the "dry" mode still needs to be added, but I think this thermostat class does not support it. I will check and add if needed. I will also extend the test file soon, Kane610 mentioned earlier. The parent class defines return type as str None L1671 Looking through the different properties you base the action on most can be None. In the case of a Tuya thermostat I have in my tests in pydeconz both mode and state on are None and preset "auto". I guess it could be a bad example as "lastupdated": "none". What I mean is, could there be a situation here where the proper thing would be to return None rather than a string? Im not sure I follow the reasoning with preset boost would consider the device to be active, what's different from the other presets and why wouldn't state on be true if its active? The preset "boost" is only active if it is currently boosting (heating cooling at 100 ) There is no situation where the preset will be boost but the device is not heating cooling at 100 If the state os is True, the device is currently doing whatever the mode is set to (e.g. heating cooling). Thats how Smanar explained it to me and how I implemented a thermostate device. Works perfectly fine with all existing test cases in test climate.py Wouldn't stat on be true when preset is boost? If it is a relevant check, could you add to the method description about it? and finally a test that covers the boost use case. Then this can be merged. Yes, this would be the ideal case, but I think the device I have not all devices do change the state to "on" if it's boosting. I will add the description and a test case later today. The return value should just be HVACAction . Thanks! Will fix. Resolved with
Could use x axis and y axis ? done
Instead of suppressing the typechecker, can't we use the fact that we're anyway doing isinstance(value, (date, datetime)) above by rearranging the code? I had that, removed it because of review comments. isinstance was expensive to use. This is the result of it. It is still catched by this try-catch though... Resolved with a suggestion you gave on Discord: casting it, added a comment to make clear why we did that. Is the check needed, or is this enough? This is actually not good, as we should (for backward compatibility) accept strings without timezone in the deprecation handling. This suggestion exposes a bug! Thanks Fixed in 014b49c, added tests in there for that case as well. Is the check needed, or is this enough? uh? Oops, I though it was the same as the previous Why return None instead of raising? We risk masking this developer mistake. Because the result is more or less the same. Example stack trace: The ValueError provides the message, so does an error log. That said, this doesn't happen in the path of the developer, as shown in the stack trace, the source of the problem isn't exposed (and thus this doesn't add value over the error log that is more user-friendly in case it does end up with the user). It shouldn't be a user friendly log. It should be clear that there's a bug and unexpected behavior. What would be the value of the stack trace here? Please note, that these logs can originate from templates, MQTT, mobile apps and other external sources too, so this doesn't have to be "developer". Returning None is wrong. The state isn't unknown, we know that there's a bug. We should communicate this and stop any further processing of the state. That is actually a good point. Alright, reverting that part. Done! Should we do this before converting to a date if the device class is date? I'm thinking the timezone could change the calculated date. Nice catch! Adjusted in 8b70af5, added tests for this case as well.
Side note: The timestamp should always be in UTC time. Looks like we're returning local time here.
Could this be moved to a method ( convert to json if xml ) that would also be shared with switch platform?
We don't allow for "virtual" entities in Home Assistant. For such cases, we offer the use of template entities instead. I think you misread the code, behind every virtual sensor is a physical input so templates will not work. The idea is only to do a network read once, all sensors are then received as a bitarray and split out to the virtual sensors. Consequently we reduce the number of reads dramatically, especially when considering that reading a single bit actually returns a byte. but if the word virtual disturbes you I can call them SlaveSensor. Right multiple sensors from a single datapoint, now it makes more sense indeed, thanks! I would avoid the Virtual naming indeed. Changed You're in async context, you can use async function to write to state right away. Actually, you're already doing that in the next line. Why would you want to schedule an update of the HA state? ups, that's a leftover, removed. Called from async context. updated. Prefix with async to indicate it's called from async context. function removed. removed function. If there are slaves, why still add this sensor? Isn't this data already represented in the other entities? Also, if this entity is disabeld, I guess the slaves won't work anymore? It might be better to use a data update coordinator in this case to make sure data is fetched once and given to all entities that are enabled. the sensor itself is bit0, and the slaves are bit1-n, so if we receive 0x05 on sensor "mySensor" defined with slave count 2 "mySensor" is STATE ON "mySensor 1" is STATE OFF "mySensor 2" is STATE ON I followed your suggestion and changed to use the update coordinator and that is a better solution ! You can do this once when the update comes in: Thanks a lot, that was exactly the function I looked for. There is a convention that function names starting with is class module internal only, we should consider renaming it. In Java speak I would say that this method has visibility protected . I would consider those to still be prefixed with . This is part of the coordinator entity. ups Since it's a name, maybe drop the in favor of a space ? I would love to do that, but when I try calling hass.states.get("binary sensor.mySensor 1").state, it breaks down, it seems it does not allow spaces. Entity ID is derived from the name when it's added to the state machine. It will automatically add the in the entity ID, but the UI will show it with a space. Because the coordinator is managed by the ModbusBinarySensor , if this entity is disabled, none of the slaves would work. I thought this entity would also listen to the update coordinator. No this class does the actual reading. This is because the majority of configurations will not use slaves. And it is correct that if an instance of ModbusBinarySensor fails or are disabled so should all slaves belonging to that particular instance. Don't do refresh, you can just set data instead. Cool, I think our dev documentation needs an update on this theme. I just followed t
The test was failing update before add was set to True . It was ineffective before because it was blocked in async update when the bulb is connected. Looks like we forgot to take it out when we switched to push updates. I took care of removing it Thanks!
This file doesn't belong in this PR. Translations can be provided, after this PR is merged, via the Lokalise translation platform. See: Please remove this file. Ok, I'll do it. Done These are bug fixes, it would be nice if we could extract that out of this PR and ship those in a patch release (separate from the new feature). (including the scaling back of the value) Please explain to me how to do it better. First prepare PR with these bug fixes, wait for merge and then continue with this PR? Yes, if we make a small PR for the bug fixes first (and get that merged), this PR can be git rebased on dev branch after that. Ok, have created PR 59903 That PR is now merged. Please git rebase this PR onto the latest dev branch Should we just call it, Switch? As there is no official documentation of this device category, it means we also don't know if this re-used for other devices as well. There are two move modes - click and switch. In click mode, the "finger" goes down then stops for delay time and goes up. The value of this property returns to "true" after a while. In switch mode, the value of the property corresponds to the position of the "finger". If we name it as simply "switch" it will be not clear what it switches. Here is a screenshot of device page in mobile app. ![image]( Here is a screenshot of device page in mobile app. The app is customizable for every single device (and even per distributor) and does not reflect the API at full. The comment stays the same, since we have no specific device information, we might be better off choosing a more generic name in this case. Can we come up with something? Maybe "Position"? It's a bit more describes physical aspects of the device. You can't really turn on off a position :) (as this is represented as a switch in Home Assistant). Ok, let it be "Switch" Just Tap ? I have no idea what this setting does. It doesn't appear in mobile app. Maybe it's better to remove it? In that case, yeah. Maybe it enables disables the control of the "finger" from the device? Done Agree.
Is this right? entities can now be populated with duplicate things if the top-level for loop has more than one monitor configured. Most of the time I think Python's indentation-as-nesting is fine. And then things like this happen. :) Nice catch. Can you add a test that has two monitors configured to catch what I think is the previously mentioned bug as well? Oddly, there is already a multi-monitor test, but it doesn't detect this issue. Looks like because the actual adding is happening in separate task, await ing the component setup doesn't detect it. If I add a test that actually tries to check the sensors, that catches it. This should be adjusted to use: await async forward entry setups() function instead. config flow should not be set to true since it only imports the entry. once you add user flow, it can be set to true. Is the format of options here usable in a future user gui creation. Bad to import a format that later will need to be changed.
resumed :doh: fixed I think they're going to want a separate PR for the dependency upgrade Wasn't sure if I could bundle it with this change as the bump only effects the endpoints this change uses (and one unused endpoint for a future PR). I haven't been able to find any official guidance on this in a brief search of the docs, but, in my opinion, a service call should only fail if it either can't connect to the printer or if the printer can't be put in the requested state. If the printer is already in the requested state (in this case, not printing), that shouldn't be a failure. Otherwise, automations that use the service become more complicated for not much benefit. Same goes for the other two. Stop should succeed if the printer is already stopped. Resume should succeed if it's already printing (though I can see an argument for failing if it is stopped with nothing to resume). Makes sense to me, updated the PR to not raise an exception if the machine is in the requested state(IE stopped, paused) I believe descriptions are meant to be complete sentences, with periods at the end. Also, if you can, try to give more detail than just restating the name. E.g. here perhaps saying that the print can be resumed with resume job would be appropriate.
Do you want to add this attribute for ZigBee attribute reporting in the channel? L65 Thank you for the pointer, I will add it !
I'm not too keen on the platform filter. While it might be helpful, none of the existing methods provide that and I'm not sure if we should add it to all others as well. I was about to PR the platform filter for the other helpers too Continue or remove? Users can also use expand helper for this but this syntax is cleaner and more efficient I would say remove. done. Can be PR'ed later for all helpers like this if there's interest Don't directly access this. Instead use entity sources imported from helpers.entity yeah, tried that but got me into a hell of circular imports, see 1 commit back... then import inside this function. Doing this all in in 1 list comprehension is a bit complicated, let's break it up. Actually, can we just drop config entries and just do domain to start ? feedback I got from users is that only domain is not enough to grab specific entities e.g. for a specific Hue bridge or something similar. ok Then still break up the list comprehension. Detect before you do it if it's a config entry check or domain check. OK, made some adjustments and splitted it up I realized that we should have done this check case-insesitive (so both lowercased) I considered that too, but the other helper device id is also strict matching and maybe others too. So we could leave it as as (case sensitive) or fix them all perhaps ?
We don't add common units unless the unit is used in many integrations. Where is this unit needed? In the ocpp integration (custom). But I can imagine there are many others that use rpm for fan speeds. Please specifically list the integrations in the core that can use this. We won't accept the PR unless there's a need in core. We don't add common units unless the unit is used in many integrations. Where is this unit needed? MartinHjelmare I use it for my already submitted QNAP QSW integration, but there have been no reviews yet :) diff-3064fa0e716a00d1f14cff440147a93a99a5d34bded9420f757b9e5deac485ecR44 I'd like a complete list, thanks. MartinHjelmare there you go: L161 L177 L34 L104 L178 L184 L192 L200 Thanks! With three current integrations that could use the unit I think we can hold off a bit on adding this unit. Thanks! With three current integrations that could use the unit I think we can hold off a bit on adding this unit. I disagree on this since rpm is needed for any integration which exposes fan speeds and it looks like a pretty common case for me (personal opinion). I think we could add this now so that new integration can use it from now on... We have 30 fan integrations already. If only 3 need it so far I don't think the need is enough yet. We can add this unit when there's a greater need.
Please change the domain to simply be luxtronik frenck An Integration with the luxtronik domain already exists in hacs. Is this a problem? That can be problematic, in that case, recommend changing the custom integration. Hi Bouni , I'm trying to push my new integration "luxtronik2" based on your luxtronik hacs integration. Frenk prevers to name the domain "luxtronik". Would you like to rename your hacs integration domain in e.g. luxtronik legacy or something else? BenPru The above is not a discussion that should be held in this PR. Please take that to the custom integration. PS: Please note, it sounds like you are contributing someone else their code to Home Assistant. Have you asked permission and are you entitled to according to the CLA you have signed for this contribution? Renamed Core integrations inherit the version from Home Assistant. Core integrations inherit the issue tracker from Core. I don't think we need to log this? And if it is really needed, we should make it debug level. We should not set up this listener until the integration has been set up (make it one of the last items in this method). Can we type this correctly? How can this be None? This will break if 2 instances of the integration are set up What is 2 instances of the integration are created, how would this differentiate between the different config entries? This is a new integration, we should not have YAML based configuration. The async setup method can be fully removed. Please keep all things put into the hass.data within the hass.data[DOMAIN][...] scope. HACS? Why is the type ignored? What if communication fails here? Should this have error handling? I don't think setting a language is needed here. We generally bring in names in English and allow the user to customize them at will. DHCP already logs this, no need to add this. Same as the above comment, we don't need this in Home Assistant.
I've never seen a device class that looks like this. Can you shed some light on this? stringssensorjson
Maybe put this in consts Why? It is used exactly once... That's why I wrote maybe . Maybe default to empty string to be in line with the validator type. Since the item is required it will require the user to enter something still.
In sensor.py there is the case of the profile sensor which doesn t need a metric key, because we have to query using get profile(). As long as we don t have a similar case for binary sensors, we could remove the None here, which simplifies the is on() a bit. Mypy doesn't accept that: error: Attributes without a default cannot follow attributes with one (this comes from the attributes defined in the superclass EntityDescription) I think this should do the trick: L61-L72 I'm not sure what you mean. The implementation in zwave js seems quite a bit more complex as it allows multiple different values that mean "on" depending on sensor. As far as I can tell the Vallox API always uses 0 for off and 1 for on, so we shouldn't need that kind of flexibility here. Other than that the is on method implementation there is exactly the same as the one we have here. I was referring to the double inheritance using the Mixin , which should allow you to get rid of the default None as originally mentioned. get metric is returning StateType. Will this always work, or additional type checks needed? In my understanding this will always work. There is no problem in comparing None or a random string with 1 (it will just never match). There is also the alternative of doing if 1 return True, if 0 return False, else return None. I tested that as well and could not detect a difference in results (get metric will never return anything other than 0 or 1, as far as I can tell by practical observation). This will always work indeed, as the expression results in a boolean type. Not sure why this is needed? Maybe that is a future preparation, but for this PR it serves no use, so I suggest to remove it for now.
Do we expect to have here more than one block? As far as I understand we only search for the block which contains the targetTemp We should probably just loop until we find the block or return Same here, there is only one block There is a predefined constant for this PRESET NONE ( homeassistant.components.climate.const ) This will return off if target temperature is 0 We should inherit from ShellyBlockEntity which has this implemented ShellyBlockEntity What is AUTO doing? I used AUTO when a schedule (profile) is active When you set it to AUTO, Google etc won't offer any controls to it. If you set it to HEAT instead, you are still allowed to change the setpoint. So you suggest to use HEAT for both scenario ( preset active and no preset active ) ? As per discord chat, removed There is no such thing as hass icons anymore Fixed Unique IDs are already scoped to integration domain platform. So no need to append platform name. You're now changing the original list of Shelly. Don't do that, make a copy instead: Stale comment. Yes, was there to remind me that availability is not yet handled Done Why do we need to call write state, are we not getting a state pushed back that will trigger the state to be updated? Or does sending RPC commands already return and update the state in aioshelly? Leftover, removed Generally we don't expect the external library to use Home Assistant's internal constants. We should import the constants from the library and map the Home Assistant constant to the shelly constant. I realize the library is probably built for Home Assistant only so they may be the same, but there is some chance we change them later in Home Assistant and shelly will get unexpected values. Discussing on discord... Edit: I was reading this wrong. The HVAC MODE HEAT calls are just NOOPs I think you can drop the cast here Seems not, don't know why but without cast is always unavailable Set by the parent class
What about "kHz" (kilohertz)? Only Hz and KHz exists as scales for Frequency in the Z-Wave specifications, see Z-Wave JS - kHz is not (yet?) part of the standard units in const.py: L472-L475 hmm, can "kHz" that be just added as an additional standard unit in this PR or is a new architecture discussion and decision needed? We can list we would allow it in the documentation comments, but we can't add it to the constants, as that would introduce dead code.
We could define two different constants for these texts.
Please use a more descriptive name than x. Please use entry.async on unload instead to handle unsubscribe. Note that the coordinator will only do automatic refreshes as long as there are listeners (enabled entities) registered in the coordinator. Maybe we should register a listener that adds the tool entities instead of using the dispatcher? Otherwise we won't search for new tool entities if the user disables all other entities. Here's an example from Netgear: L251 TIL, thanks for the tip. I think I updated to match the pattern in the netgear integration If the tool names are unique, let's make this a set instead of a list. Please collect the entities first and then make a single call to async add entities for this callback. Swapped out to store into a list then make the call
One other thought here is to do some kind of url validation or health checking of this backend at this point when not using discovery. Any reason this single instance only? What if the user has two NVRs two RTSPtoWebRTC servers ...or more? Happy to support this, but need to think through the details of how it would be used. Right now it's not clear to me how to use multiple. Do you have thoughts about how to decide which instance to send the offer to at runtime? Have a look at the code in init : it passes in an rtsp server url and does not use any of the existing configuration in the RTSPtoWebRTC server itself. I think maybe what you are saying implies this integration could be pulling cameras configured in RTSPtoWebRTC and exposing them as home assistant cameras, which it's not doing now. Right now this only does.the opposite and pushes cameras from home assistant to that server with zero extra configuration. Am I understanding that right? I can see it makes sense to make it possible to support that. I'm probably over thinking this since my use case is probably on the extreme end. Load balancing or high availability concerns don't really need to be considered here since we don't support it for Home Assistant anyways. I do you think you have a point if we added support for virtual cameras from RTSPtoWebRTC so I am open to considering this more. Two thoughts: - We could pick the "first" config entry for the existing live configuration use case - Config entry unique ids: Given the input is a url though that seems not allowed for a unique id: unacceptable-sources-for-a-unique-id -- is there a unique ID I could use now to better support this in the future? Does the server generate some type of UUID that persists across shutdown startup? Nothing I am aware of, but i'll keep considering. Resolving for now. Can we drop this? ConfigEntryNotReady will already take care of the logging. We don't want an additional LOGGER here since it will log every time the retry happens. Great! My impression is this is a new behavior, so that is great. I will remove this logic from nest . Our standard is to separate words with underscore in the domain name. Maybe change to rtsp to webrtc ? Done. Also renamed all the directories to match. We can use entry.async on unload to unsubscribe. Done When can this happen? Should never happen as the error message states its invalid. I'm getting a hint that you'd prefer not to do this check, so removing. Yes. We assume we're in control of the config entry data. no devices found is never used. Removed. There's no confirm step. Removed. Why do we do this? Ah, i think i didn't realize these were not needed. My primary introduction to home assistant has been via nest which is fairly legacy (and as you know i've been wanting to move away from configuration yaml) -- Removed. We normally patch the integration setup function on all create entry results to avoid setting up the whole integration. Fixed.
Side note: I think we should remove info from the description and pass it separately to the entity. We're modifying the item in the constant container here, which isn't really good, although currently not a bug, since we overwrite the attribute every time. I guess it's the same problem as above. It's not really good to do it like this. do you have an alternate suggestion? I don't think we want to create SensorEntityDescription's for every combo of options do we? ignore what I said above, I see your suggestion in the previous comment lmk what you think about the current implementation Maybe we should return a dataclass or named tuple with the items as two attributes to make it more clear what the return values are?
Please update the library instead. We don't accept code that should be part of the library. Hello, This shouldn't be part of the library since the library offers options on the switch directly to turn on and off the led. hat being said, if that is something that could be usable directly in Home Assistant, I would love some pointers. With my investigations, I only found using that wrapper as a solution, here, which wouldn't make sense in the library because the option is provided directly on the switch itself. Would really love some pointers to make this work! Maybe I missed something since I'm young in my home assistant journey :) If the device already has support, why do we need to wrap it? I'd suggest just creating a new entity class that uses the correct device methods. Hey there! You just crossed my wire, as I'm working on updating this at the moment (hence the WIP tag in the title) Thanks for taking a look! If not adding this, the name is skipped since this is overriden by one of the parent classes ( TPLinkDataUpdateCoordinator ). Alternative would be to avoid the coordinator from overriding that, and setting attr name in all the other subclasses. Which is preferable? We don't need to use the legacy compat here since this is new Does it make sense though to have an ID that might be different from the parent's id ? Instead of having switch id led corresponding to the switch id entity, we might end-up with mac switch id led corresponding to the switch id entity. We are going to migrate away from the legacy device ids in the future. It would be nice to not have to migrate this one as well I'll update, then! :) If you set a custom icon, you should set it for off as well Do all devices have leds ? If not we should only create the entity for ones that do All [ is plug ]( L66) and [ is strip ]( L134) do, according to python-kasa , which is tested for a few lines above! Would it make sense to initialize the led configuration also for individual sockets here? I checked python-kasa and there does not seem to be individual socket support for it, if I'm understanding this correctly: L281-L286 This makes sense in a way, since the "LED" element is the status of the plug strip itself, but not of individual sockets (which could be turned off individually, but I don't believe they have a status LED each ?) At least KP303 has individual leds that can be individually controlled (besides the main one, toggling on the main led adjusts all the leds). But you're right, the state information is not being exposed so it makes no sense to expose these controls to homeassistant for the time being. I created an upstream issue for this: And they actuall do have a status LED each my bad hehe I wrote this before seeing your response, I actually went looking at the products to clarify what was what! I believe once the lib is updated to handle things properly for the individual plugs, that'll be a one-liner update to this to handle individual LED control! (I initially was th
Please add a note that documentation is not available What type of unit is this in? What does this data represent? Work state is generally worded as "Mode" in Home Assistant. Is a work state a measurement? no, but I don't find any other acceptable value for state class state class can be None if the available state classes don't fit thanks What does the use time represent? This is the main switch to turn in on off right? Shouldn't that be a primary entity? This should be mapped to a device class so we can provide translations for these states. What does this countdown represent?
It is now both cloud polling and local polling. What should be used here? My impression is that in general the home assistant stance is that local integrations are "better" than cloud ones -- so given that this does support local, that seems reasonable to use. It may just be worth spelling out the details in the documentation if only certain devices are supported, for example -- which I see you did. My impression from quickly reading this is that existing config entries are cloud based, but do not have a CONNECTION TYPE set. Does this check need to handle that case? I also did not see a test for this case, so may be worth adding that also. Good point Will fix that I realize its a shoudn't happen case, but it feels safer to me to make an else clause here given the fall through doesn't return anything. Seems like this could just be omitted According to the best practices, this is not allowed as a form of unique id: unacceptable-sources-for-a-unique-id Also my impression reading that list is that the cloud username is also not acceptable. Hmm, My impression is that is for the unique id used for the devices and not this one? You're right, i'm conflating config entry id with device id. thanks for the correction. The errors variable can either have its scoped reduced or just be inlined: How is this displayed in the UI? I've only ever seen the key used as a field in the form or on base as the key. Does this work for any error key? (This is just an honest question) You are right. Fixed My impression from watching other PRs is that the best practice is not to interact with hass.data form the tests, but use some other details about the integration. I think asserting the mock objects were invoked could be better aligned with that. (However, i think doing an assert on an empty hass data on unload is OK (e.g. like this test does diff-03b89207ac91dcf6ef3d8ff74ea8f8c5a9b18a9dbdc16e5fcbaf65aa789a3cceR11) Style nit: Perhaps combine to a single with like the local test does. here and below. Sorry I missed this earlier: I also realized that this is another example where there is a preferred API to set up the component, rather than accessing the integration methods directly: writing-tests-for-integrations I think the most common way I see this is to just invoke async setup component which should also invoke your async setup entry method with the config entry created a few lines above. (Here and in a few other places) Also update this on integration details: Also there is a call to mill.async setup entry above that needs to be updated.
This should be implemented as a DataType in tuya base.py . I'm not sure about correct approach here. Should I add this fields "voltage" "electricCurrent" "power" as predefined for the DataType class? What is preferred solution for serialization such json strings? Sorry for silly question, I'm still studuing :smile: That is a good question. Haven't really thought about that. I guess there are multiple approaches to this. It could be defined as ElectricityDataType , as we know what we expect at this point and thus can be specific in the fields and its types. Done Something went wrong with the formatting here black --fast tuya changed it to this, should I revert? add a comma after name "Switch", and run black again We need to return None when subkey is None. Or else, we might end up returning a JSON string as a value for a sensor. fixed
Why did you add these? I guess it comes from a bad rebase. Actually I did not add those lines These HTTP codes are unrelated and shouldn't be part of this PR Same here: does it come from a bad rebase? You should try to keep alphabetical order when you see it. isort will help with some of it, others need to be fixed manualy. Adding new device classes will need a corresponding PR in developer docs: This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository. changing-the-entity-model I don't think pf power factor is a valid unit. Power factor is the ratio of working power to apparent power so actually it has no unit of measurement. It can be uppercase if you like it but I believe it makes no difference Remove the invalid unit This needed to be kept (my bad for the bad code suggestion) Remove the invalid unit Remove the invalid unit stale doc string fixed
Only the english file should be added (other langages are generated automatically) Removed It is not compulsory, but since new integrations can take a while to get merged, I suggest that you take the opportunity to move to 100 coverage whilst the reviews are in progress. Use an uppercase constant: This doesn't do anything. If it's for a follow-up PR it should be removed competely until then. Maybe move this to a separate module vconnex wrapper.py Maybe move this to a separate module vconnex wrapper.py Maybe move this to a separate module vconnex wrapper.py Use an uppercase constant LOGGER . Maybe import it from the switch module: from homeassistant.components.switch import DOMAIN as SWITCH DOMAIN Use an uppercase constant LOGGER . Is the information in self.device available during initialisation? If yes, then it could be set in self. attr device info inside init () instead of using a property. setdefault already checks for the key. None is default for dict.get() You are missing from future import annotations in this module. Don't mute pylint for this. Many thanks There is a new Platform constant available It should be: from homeassistant.const import Platform empty lists are falsy, no need for len() prefer comprehentions over lambdas This just reraises the same error. It can be removed. Ah sorry, now I see it would be catched by the broad except Exception then. If it can't raise move it out of the try block. The api.is valid() may raise connection error exception, which I dont know exactly. So I used broad-except to catch it both are required strings. They can't be None return the info or raise, no need to return None move self.async create entry out of the try: block and remove the None check
Could you use EntityDescription ? Or at least use attr for the name and the icon? Try to use type hints all the way. Though it is not compulsory, I suggest that you try to get 100 coverage as you wait for the PR to get fully reviewed. Unfortunately i'm just not up to speed on testing, so I won't be able to do this. This is trying to use a socket, so I don't think aioclient mock is working as you expect it to. The EntityDescription should be a constant tuple outside the UptimeKumaBinarySensor class. It should contain only constant attributes, and should be passed as a parameter to UptimeKumaBinarySensor . In this particular case, it might be easier to use automatic attributes instead attr . Maybe you can also add the unique id: If the above is implemented, icon and name properties are no longer required. I'm confused. If EntityDescription is used, or if attr is used? If you can use EntityDescription : use it. If an item is too dynamic to fit in EntityDescription , use attr form. If an item is too dynamic to fit in EntityDescription or attr , then use standard property. Use constants: Use constants: It might seem silly to make a fixture file just for this, but I think it is still better to have all JSON samples in fixture files. I'm sorry, i don't even know what a fixture is : It is a json file in fixture subfolder of tests. And inside Python you read the file instead of the string. Take a look at the other integrations. It will help you for future tests... Not compulsory, but I like to use the constant: from homeassistant.components.binary sensor import DOMAIN as BINARY SENSOR DOMAIN And then PLATFORMS [BINARY SENSOR DOMAIN] Can you add type hints to async setup entry ? Can you add type hints to init ? Set the icon as a class constant Can you add type hints to is on ? Can you add type hints for errors parameter? Can you add type hints for user input parameter? Create a constant for this: LOGGER logging.getLogger( name ) Consider moving the schema definition to a constant at the top, outside of the UptimeKumaFlowHandler class. STEP USER DATA SCHEMA vol.Schema(... It is not needed to set icon twice. It is already set as class constant. Move the schema higher up, outside the class definition. What if we have multiple config entries?
We don't want the YAML config to overwrite the config entry. these have defaults set. Why do we get these but not ConnectionSchema.CONF KNX MCAST GRP ? Makes sense for those :) should we move that to const.py so everything is in one place? We don't need that anywhere else so I don't believe we need this in const.py maybe move default port to const.py or import from xknx adjusted move to const.py too - at one point these are not needed here anymore when the deprecated schema is removed I'd remove all of this in 3 months when we can remove it
We don't allow blocking calls in entity properties. Thanks for review. I've submit a patch. This is the default. We can remove this property completely.
I don't think this should be number
It is not compulsory, but since new integrations can take a while to get merged, I suggest that you take the opportunity to move to 100 coverage whilst the reviews are in progress. (Also is there a formatting issue?) You were right: line 252 was idented with tab, while the others with 4 spaces. Fixed now! About the 100 coverage: I will try to catch up with that, but I'd like the review to proceed and complete even without it. I think it is clearer if you move this class to a separate file (eg. common.py or elmax entity.py ) Agreed! I think it is clearer if you move this class to a separate file (eg. common.py or elmax coordinator.py ) Agreed! The connection class should be moved to the manifest file nowadays. You're right, that was redundant: the current manifest already included the iot class attribute. I've removed line 55, which was redundant. Please try to add type hints to all methods and method parameters (here it is missing the return type, and the parameter type for async add entities ) Done. I've also run pylint flake to be sure about that. These seem to be used only to create the ElmaxCoordinator so there is no need to create intermediate variables. Not really, I also use them for schema validation in config flow . Now that Elmax coordinator has been moved as per your suggestion in a dedicated class, these are now legit. Well yes, you dont need them Sorry I misunderstood your point (I thought you were asking to remove CONF ELMAX constants, not the variables). That is totally correct! You should patch async setup entry to avoid trigger the platform setup. Not sure I understood. Can you be more specific about that? Platform setup is not triggered here, there is no need to patch this Agreed! epenet already mentioned this, thanks We should not set anything on hass.data before the entry has not been successfully set up There is no cover platform in your integration. Use attr should poll False You can move this to self. attr name and self. attr unique id in init Agreed Agreed.
Move it to the top (alphanumeric order) Can you put ATTR ENTITY CATEGORY before ATTR ENTITY ID (alphabetical order)? Remove the warning: Remove the warning: This is not useful anymore (I have cleaned up the old ones in 59338) This is no longer required, already present on line 81: L81-L83
It is not compulsory, but since new integrations can take a while to get merged, I suggest that you take the opportunity to move to 100 coverage whilst the reviews are in progress. I probably won't get to 100 , but I'll add more as I have time. Since it is a new integration, I don't think import will be accepted. I suggest that you move this class to a separate balboa entity.py . Only en.json should be uploaded (other languages are added automatically by the translator) Only en.json should be uploaded (other languages are added automatically by the translator) This is no longer required. Add type hint: While, yes, that's true, the very next PR will add another platform.. This applies regardless of whether it's one platform or one hundred platforms. async forward entry setup take one platform, but async setup platforms takes an enumerable. ooooh.. ok.. I didn't know that one was available. Yeah, that makes sense, I'll switch over. Thanks! same as above, While right now it's one platform, the point of this is to bring in the other 2-3 as well immediately following. And as above, this applies regardless of whether it's one platform or one hundred platforms. async forward entry unload takes one platform, but async unload platforms takes an enumerable. Add type hints I think you want to use patch here somehow. Don't update and reset it. suggestion spa hass.data[DOMAIN][entry.entry id] outdent below Use async track time interval Don't set self.hass , it will be set when the entity is added via async added to hass pass in client instead Otherwise it will leak Use a dict lookup instead Use a dict lookup instead
typo If I see this correctly this new option is required and has a default, thus it always exists. We should update the existing configuration entries that lack CONF VERIFY SSL (as in a little migration). We should not migrate the entry version for this, as that makes downgrading impossible. This can be migrated by updating the config entry during entry setup.
Do we really want to use the source sensor's entity id as unique id, it means the unique id is not stable if the source entity's entity id is changed. There's nothing guaranteeing the source entity's ID is stable and not changed by the user. Kind of the point. In I would add the selected characteristic to the mix. When the user changes the source entity (or the characteristic) the resulting statistics sensor tracks a new measure and should for example not continue with old measurements in the recorder. So far this made sense to me. Given, the user could rename the entity id of the source sensor. I would be good to use the unique id of the source entity. Sound better? emontnemery I ran into another issue. The unique id is not unique Look at this example: Both sensors will receive the same unique id. Damn! I hoped to be able to avoid user-defined unique ids like you can must do it for the template sensor. Do you see another way? Maybe some experience how other integrations do it... We mostly don't let the user specify a unique id for integrations where users manually configure entities. One exception is template , where the user can specify the unique id manually. What problem do you really intend to solve by adding statistics sensors to the entity registry? Generally I thought it's desired to have a unique id for every entity. Secondly: ![image]( I want to be able to assign to sensor to a room etc. There is always the option to derive the unique id from the sensor entity id instead of the source entity id... At this point I really lack the big picture of where the HA core development is headed wrt unique id and entity registry. Please let me know what I should do. Not adding a unique id feels wrong for the above reason. I have dozens of non-unique id entities and it annoys the crap out of me I'd suggest to mark this as draft and finish off 49960 first.
For consistency, I would change this to be speedtest.net . Also button should be singular since you can only have one of them. Is the attribution needed on the button? It's not actually doing to be displaying any of the data. you are right, this is left of the initial copy from the sensor platform
This seems incorrect? I only see the reset waste drawer button in this PR? This was introduced in I figured since I was marking the other service as deprecated due to a new entity, it should also be done for this one. I can put this in a different PR if needed. The entity state is checked before the button press, we should check the entity state after the button press in that case as well.
Is this a measurement or a setting? Absolutely correct this is a setting. Than it shouldn't be marked as measurement... Instead mark it as an config category entity Look at this again, countdown is actually a function as well, not just a status. Because of that reason, it should be a number entity, not a sensor. This counts down the number of seconds. We don't allow that in sensors, instead calculate the datetime of when the timer finishes and use that (give it the timestamp device class as well). Additionally, this isn't a measurement? Actually it counts down the minutes left. countdown left Remaining time of countdown Integer { unit : min , min :0, max :1440, scale :0, step :1} I am not sure how to add this one correctly. frenck can you give me a hint or support on calculation of the datetime when the timer finishes? Currently I am using it as a sensor and it updates every minute until 0. Indeed it is not bad to see how much minutes are left instead of a timestamp. Calculate a datetime instead and return that :) Missing temperature, humidity, water quantity, rain sensor information, total water consumption? Haven't added this because I cannot test and verify. Mine is just supporting battery and countdown. We can use the docs to add them, and create a virtual device in the cloud platform to test that Are you able to find an Irrigator as virtual device. I cannot find one here: What the heck? Ok, lets implement what you have in this point in that case, but lets add it as a note comment to the entity descriptions that not all from the spec is implemented. I don't see the child lock in the specifications, nor in your provided data dump? Correct, removed. It could be start as well? Yes In that case, we need to support that, as right now, it only handles the switch As mine is also not supporting start I need to add a virtual device as proposed by you and test it.
Shutgun Please add a test for this branch.
Maybe rename this to buttons? Even better, removed it completely Left over from demo code? Likewise?
I don't think it should process any Telegram, it should just fire and forget right? Right now it processes both, incoming and outgoing telegrams Right, I just think the overhead is negligible but it's easier readable and we can use KNXEntity as is. And maybe once have the button entity updated from the bus.
Can we validate the allowed security class values? At least we should know all the possible ones from zwave-js, even if we don't know what the specific device supports, right? We can use cv.has at least one key to require one of these items: L122-L123 how can I achieve this? The websocket api.websocket command expects a dict which it wraps in a schema so I can't use a vol.All to add the validator In lieu of being able to use this in the schema, I am using the validator as a replacement for the existing check for a key We could add another key level above these keys like we have for the update log config command? Paulus does not want to merge the linked PR since we are the only use case for it at the moment. In my mind there are a couple of options to address your concerns: 1. Move it a key level down as you suggested so we can add complex validation. I don't like this approach because we would only have one key under the parent key, so we are kind of hacking around the issue ( update log config has multiple keys underneath the parent so I think it makes more sense) 2. Do the validation in the command logic (as already done in the PR). For the get provisioning info helper, we could raise an AttributeError if there are no matches and catch that in the commands. For commands that require provisioning info, we return an error, for others we assume None 3. This would kind of be in combination with 2 but we could use a decorator to do some of this if we desired Thoughts? I'd keep the extra validation in the function body but break up the provision helper and put it as validation functions for each specific key in the validation dict in the decorator. Do the strategy validation in the body. Are these items validated somehow? No, per the [interface PlannedProvisioningEntry ]( api controller?id provisionsmartstartnode) the only requirement is that the key is a string, but the key names and the value types are not defined. I am not sure how to add the string key check to the validation schema but I could do that check in the API command if you think it would be valuable The keys in JSON must be strings, so maybe we don't need to validate that? This case should not be able to happen if we validate the input first with cv.has at least one key . We can raise RuntimeError here. add node and replace failed node do not require provisioning information ahead of time so this is still valid for those commands. I don't really like calling functions with all optional arguments and returning None if no input is passed. Maybe we can make one or more validator functions instead that are run during input validation and return the correct provisioning or string? Looks possible at least if we break out the inclusion strategy validation. Can we add a feature to the core schema decorator to allow for additional validators? If so then we can do all of this via input validation Maybe in a separate PR, yes. Run it by Paulus. Maybe allow a voluptuous schema besides the dict for 
Let's add the type here Fixed in e1512a2 Let's add a recording property to the Recorder class and use that here Fixed in e1512a2 Fixed in 1bb070f Fixed in 1bb070f
we don't need to check current mode now since now we know that the bulb supports mode change so we can just send the new mode together with other parameters, if the bulb is in the same mode it ignores the change. Also no need for mode result since we now use single API call
Since input numbers can have different units of measurement, we'll need to have it as the metric name suffix: f"input number state {unit}" Can't unit of measurement have some special chars? Like C This should not be a problem, I believe, since special chars get stripped in sanitize metric name . Also, temperature units are handled separately in unit string . done Add from contextlib import suppress to the imports
This if-statement wraps the rest of the method so turn this into a guard clause. No need to wrap in f-string. get thumbnail url is never passed in. Please remove it. Why is payload a dictionary if you only use 2 fields? Let's convert that to params. Why not raise browse error here? media id is never an int there is no boolean return value
TP link tends to share the mac for both KP and KL devices
I would suggest using the constants: L99-L104 Yup, that is the way to go Using constants now. Setting this to total increasing means we'll be collecting a statistics of lifetime rainfall, is that wanted? True, but only if the sensor is manually enabled from the entities screen ([they are disabled by default]( sensor)). For more control the user can set the max age on the statistic. Setting max age on the sensor means it will reset to 0? That is very unlikely to work well with state class set to STATE CLASS TOTAL INCREASING , or have you tested it? I haven't tested it, but that's what the [documentation]( max age) says. I would set it to STATE CLASS MEASUREMENT , same as the precipation sensor. It's the sams type of sensor but instead of future it is historic data. Wouldn't that make the measurements invalid? That's why I made it an increasing measurement, also see state-class-total increasing Hmm...I know what you mean. The value reported is an accumulated value over the last 24 hours. But total increasing would also give invalid measurements, because the total increasing would only work when e.g. at 0:00 a counter starts at zero starting counting up to 23:59 and at 0:00 it would reset again. Buienradar reports an accumulated value over the last 24h. The fact that it goes down doesn't mean a new cycle starts... I don't think there is a state class which would fit to this, because it's (I think) impossible to derive statistics from this value. Although measurement would still be better than total increasing I guess. True, I think both will result in invalid measurements. I removed the state class from both "Rain last hour" and "Rain last 24h" since it won't be accurate anyway.
These should be relative imports If this is a required option, why supply a default value?
I don't see the advantage of using a temporary variable here. I copied all from L65 In that case all are variables, with similar code style. Yet in this case you are mixing code style. right, I see what you mean. thanks for your review Ill let the checks run first, to see if anything else is wrong. Maybe await some extra review suggestions You cannot use super() inheritance here. You need to implement something like value template Where is the icon template used? It wasn't used - now it is...
entry id is already typed to be a string error: Argument 1 to "append" of "list" has incompatible type "VenstarTemperatureSensor"; expected "VenstarHumiditySensor" [arg-type] from mypy... These are coordinator entities, we should not pass True as the 2nd arg or it will cause the coordinator to poll again You could store name in the entity description instead Its already supported L193 I could, but I don't know the names of the sensors yet. I only know them from calling coordinator.client.get sensor list(), which, I'm doing in the loop. I guess I could build the descriptions on the fly there too, but that seems overly complex to me for some reason? Maybe rename the loop variable above from sensor to sensor name as it would make the code easier to follow since the var won't have a name change between calls If name is always a string and cannot be None then drop the quotes here as well Please avoid using Any since we know what kind of entities can be stored here. Without that, mypy complains: error: Argument 1 to "append" of "list" has incompatible type "VenstarTemperatureSensor"; expected "VenstarHumiditySensor" [arg-type] or will I have to list each of those as a possibility? Won't that be obnoxious when I add more sensor types? This might work You could extend this an add the hum and temp values as a mixin so you could loop though the sensors and add them without having to write them out in async setup entry Example: L94 Usually we put the entities themselves after async setup entry I was getting problems with the SENSOR ENTITIES cls members not having a definition for the classes.. Is there a way to forward declare them like in C? Take a look at Renault sensors I think I had a similar issue You could move SENSOR ENTITIES to the end of the file instead so it defined after the classes I think its just SENSOR ENTITIES that needs to go to the bottom Why not use the description key for this instead of adding a new attribute? Why are we patching the onewire integration code?
Use a guard clause. We can't delete self.alert as it's used in is on() Ah, right : 1: Sort these We don't need to update again if the coordinator is updated during integration setup before the platforms are loaded. We can remove the second argument True . Please return a value explicitly in all cases where we can exit the function, if we return a value anywhere.
This should not be added to Home Assistant during the transition period. Instead, this PR should be opened when it becomes available. I fully agree and I really would have done it that way. However, given the low activity on the upstream library (last commit is three years ago, same for last activity from the author on GitHub) I'm afraid this will take a long time - if it ever gets merged at all. I like the feature though (and know other people would appreciate), that's why I still opened the PR and added the code in a way that it can easily be switched to upstream should my fears have been unjustified. In that case I would raise the new PR of course. Do you think this one could be acceptable that way? Do you think this one could be acceptable that way? I cannot accept this PR in its current state, hence my review comment. Ok, removed the "local override" part and replaced the custom method calls with normal, existing library methods. Is it better that way?
nit: number platform If I understand this correctly, this block (and the identical one below) is meant to enable the entity since this PR changes it to disabled by default, with the time change meant to trigger the built-in reload after entity update. It took me about 10 minutes of searching to figure all of that out, so it might be worth factoring these out into a helper method enable entity and putting a comment as to the purpose of the time change. Yeah I dont love this either, but apparently its the right way to deal with disabled entities. If I wasnt going to remove these in the near future a refactor would be good. Why were this assert and the one below removed? Re-enabling this entity made the count inconsistent. Checking the number of API calls didn't really prove or test anything either. Since there's an identical sequence of asserts in the sensor test, consider pulling this out into an assert helper in a common file. (Tests for some other components have a common.py file for such things.) Of course if you're about to just delete the sensor and its tests, I wouldn't bother. Yeah, the sensor will be deleted in a future version, so any improvement here will be wasted. copy paste Good catch. My impression is that this is returning time until a specific state is reached? This means a lot of updates to the state machine, and an absolute time is preferred instead. Am i understanding right? An absolute time would have to be inferred, and may not be accurate, as the appliance only provides the minutes remaining on its API. I expect using an inferred absolute might cause the value to flick back and forward every 30 seconds between two times because no seconds value is understood. You are correct that the state machine would be updated, but only every minute. Yeah I imagine it would also have to include a setting for only updating when it's a significant change (my impression is there is an API for that) I believe there was an arch discussion on this topic that forbid using relative times. Am I remembering that right? I couldn't find it quickly. We really try to avoid something that writes state updates due to a running timer. I'd still convert this to an absolute time unit even if it has to be the ceiling value and displays for a few seconds longer than it actually runs. This integration is polling so its already expected it won't be in sync with the device for a few seconds bdraco is the number platform appropriate for absolute time? I dont actually know which platform has the right interfaces for setting absolute time, and I am going to run into issues because the hardware wont support times over 720 minutes in the future. I'm pretty sure that only sensor has native support for datetime objects Yeah right, so I need to trash this PR and leave the existing implementation which is a sensor and custom service. I think it makes sense to add support for absolute time to the number platform. That will change the entity model though so it needs an arc
These are all entity services, and should therefore be registered as such. See: entity-services Hi! Thank you for your feedback! If I understand correctly, Entity services are for a particular platform. These services are used to manage settings and programs of a device, so they aren't specifically linked to an entity of the device. On which platform should I register these services? Yet, they all target a specific entity. Which entity would that be? I think the services target the device instead of a specific entity... I agree, except all these services accept entity IDs, not device. Hence I expect entity services instead The entity IDs are used to retrieve the device. But I think it is better to get the device by accepting the Home Connect appliance ID. Or is there a better way? The entity IDs are used to retrieve the device. In that case, ask for devices, not entities. If you want to target entities, change the service. Is there some sort of ID for devices or should I just use Home Connects haID? Yes, we have that, device id Thank you! Is that ID visible anywhere in the frontend? Well, not visible. But when using service calls, they show in a selector, same with creating automations in the UI. Thank you! We should not store the entity in a common container on the device. The device should not know about any entities. Please remove this. We prefer raising either ValueError on bad user input or HomeAssistantError if the api call fails in service handlers. Pass the message as an argument to the exception. The message will be shown in the frontend.
We don't need a custom icon when setting the device class. The frontend already sets a custom icon then. You can remove the constants themselves too, since they're no longer used. Also might as well remove the temperature icon while you're at it, since that already has a device class. This one's unused too
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision This should be converted to an integration level configuration first.
Is it possible to test that the automation actually stopped? That's what the existing code already does :) I tried by removing my actual code (so the await self.action script.async stop() ) and the test did fail as expected. How I read the code it starts the automation, which will then block wait in the wait template , at this point the service ( turn off stop reload ) is invoked which should thus stop the automation. Afterwards the state is changed to the waiting condition so the actions, if still running ( turn off with stop actions: false ), will proceed after which the test.automation service is invoked. The test then validates the passed in calls list which should be empty if the automation stopped and contain one item if it didn't stop. Which I presume will be populated by the test.automation call. So for automation.stop it will block in the wait template and because of the automatio.stop it will thus never leave the wait template , thus test.automation is never invoked and the calls list stays empty. Ok, I believe you! But to be honest I don't understand it. I was expecting to see something like - Start an automation that won't finish instantly - Verify that the automation is running - Trigger the new stop action - Verify that the automation is stopped The len(calls) check with the conditional quantity might do the same thing, but it's not obvious (at least to me!) I had to check it multiple times as well :) But it does work fine I guess. As stated, I did remove the implementation of the service and the test failed as expected. And I do believe it works as you describe: Start an automation that won't finish instantly This is what the wait template does Verify that the automation is running Digging into it I believe this is what the running event is used for. After firing the event trigger further execution of the unit test waits for this event, thus making sure the automation started. Trigger the new stop action That's obviously the code I added Verify that the automation is stopped That would be the test.automation service invocation in combination with the len(calls) assertion I guess, as described above.
Since this is mapping to a dictonary in the device I think we should not use ATTR BETA here (all other places are ok) This was reverted again by the force-push Would be better to catch here only the errors we expect. example from set state : L328 ah thanks, was not aware of which errors might be expected I think this would be better logged as a warning sure, you are right - these are warnings, not errors! warning? warning? warning? This needs to be before line 53, so switch is created also for devices without switches ( lights, gas sensor, etc. ) Nice catch, I suggest to put it right after we fetch the wrapper L49 Same should be for rpc device Exactly where I suggested to place it ;-) done with 5e8c2dd Would it be possible to add a test to cover this line? did already think about it, but struggle a bit how to setup a valid "fake" device from any other domain as the shelly domain itself during the test not necessary anymore Why does this call a service? Please note, this makes it lose context as well I guess it is the same as discussion r746432860 Why is this registered as a service? The button entity (used by this PR) was introduced to reduce these type of services ah ok ... I was not aware that the button should avoid registering services, but to be more an extension to them, to make services easier to use for the user. Those I need to rework this PR to implement the whole logic into the button and remove the custom service at all? Those I need to rework this PR to implement the whole logic into the button and remove the custom service at all? I don't see the need for a service at this point? As an example, you haven't implemented a custom service to toggle a switch either, right? makes absolutely sense, you convinced me just for my "defense" when I started this PR, the button entity does not exists, therefore the service has been implemented first Should the button become unavailable if there is no update pending? we already discussed this on discord, but decided to leave it for a future improvement PR I agree, let's cleanup this PR and remove all services related stuff and we can add the unavailable on a follow up PR
Let's keep the schema sorted: done I don't think we need to check if the format is valid, it's an implementation error if the format is missing? done Just declare that this will be a str in a concrete class done generate entity id() is deprecated, we should call async generate entity id() done I think this is duplicated and should be removed?
done If the attr attributes are set, then the properties are no longer required. You can remove name , unique id and device class properties Automatic attribute properties only work on common attributes ( unique id name device class ). It will not work on custom variables ( cubehandler device ) Automatic attribute properties only work on common attributes ( unique id name device class ). It will not work on custom variables ( cubehandler device ) We should add entity category as well, as this is a diagnostic item. Set it to windows shutter entity and battery entity - 34689923b132854b32a6a940942feb4730e4b7ad Maybe I'm not looking correctly, but that commit isn't in this PR? frenck it's in the base class MaxCubeBinarySensorBase . frenck, it's in PR, I did fixup commit, this commit is now squashed. this commit is now squashed. Please, don't squash. Really, it makes review impossible. Anyways, this integration would benefit from using EntityDescriptions, which removes the magic :) Please, don't squash. Really, it makes review impossible OK, will squash when review is done Anyways, this integration would benefit from using EntityDescriptions, which removes the magic :) Explain, what is it, link? Explain, what is it, link? No link, but searching our codebase will give examples enough. Nevertheless, not for this PR. OK, will squash when review is done We squash on merge. Please don't squash yourself. Thanks PS: Please use descriptive commit messages. "fixup!" isn't helpful. We squash on merge. Please don't squash yourself. Thanks Do you squash all commits into one? I would keep 2 commits, one that refactors old code and another that adds new functionality. PS: Please use descriptive commit messages. "fixup!" isn't helpful. fixup! commits are git way to fix previous commits - Documentation git-commit.txt---fixupamendrewordltcommitgt petslane if you want to keep 2 commits, then you need to provide two pull requests. Us contributors cannot influence how maintainers merge them in, and it is the policy of the HA maintainers to always merge them squashed. If your PR is 100 polished on the first attempt, then just one commit is great. If it isn't polished, and recommendations are made, then as frenck requested it is much easier for reviewers to follow-up if the comments are descriptive (eg. fix pylint or fix black or fix test ). epenet thanks for explaining. Looking at dev branch commits then looks like the most important is the PR title. Do you squash all commits into one? Yes, this is how this project works. fixup! commits are git way to fix previous commits We don't follow that concept. Please use commit messages that actually mean something. Thanks already Yes, Github automatically picks up the PR title as the merge message in case of multiple commits. If there's a single commit then Github seems to default back to the commit description which is annoying. If you have the will once this is merged in, then you could register yourself as a codeowner for maxc
I think that would return default precision for the unit, not the equal one You are correct. Fixed and tested Please also add a similar check in test default setup params for a default target temp step value. I added both the check you asked for, and another test in test precision to check that the target temp step defaults to an overridden precision instead of the unit's default precision ( fixed a typo in test precision that caused the test to actually be in Celsius, so to always be set to 0.1 precision even without setting it manually)
This may not be needed assuming we can't get the device from the device registry.
We don't need to remove old non used items in the config entry data. If we can avoid a hard migration of the config entry, ie a migration that makes rollback impossible, we should avoid it. Ok, noted! Why do we need this option? As I wrote in the PR message: I have added a "force re-auth" flag to config flow options to re-trigger set up, which might be needed if a protocol failed to pair the first time (e.g. access control prevented it). I don't think the user should need to do this. The integration should be able to know if something fails and act accordingly. This is not necessarily an error. A user might have decided to disable AirPlay on the device (which is possible) because it's not used, but later enable it again. Or set a password, which isn't supported today but will be some day. Both of these cases would require a user to remove the device and add again, even though limited functionality could be used via other protocols anyway. Ideally re-configuration should be built into core, seems strange to me that it isn't. EDIT: So it is acting accordingly. If the auth fails we start a reauth flow automatically. The user should not need to force a reauth. The auth will never fail as the protocol was never paired, thus it will never be set up. Only protocols paired during config flow will be considered when connecting. I will pull this out for now, people will have to re-add devices jus to keep it simple. To reconfigure existing entries, check if the entry data has the new identifiers item, if not raise ConfigEntryAuthFailed here. Same as above Maybe use ConfigEntry.async start reauth ? Ah, that sounds reasonable. I'll try that If we know the error we normally don't include the stack trace in the log. We know the problem-ish, but lessons from the past show that including the stack trace here makes it a lot easier for me to troubleshoot when people have problems. Why do we need to change this in this PR? We should only include changes that must be included so that the integration still works with the new library version. Other changes should be done in separate PRs. It shouldn't. It is left to trigger a discussion so that I know what to do to make something happen. The discussion I left i the architecture repo hasn't received any attention at all, so I need to try something else and I much rather take a design discussion before trying to implement anything to avoid wasting time. Please remove all changes that aren't strictly necessary for the new library version. Ok. Any pointers towards how I can get any traction on this since my previous attempts have failed? There needs to be some interest from the community for architecture issues to drive them forward. Ok, I will everyone interested to make some noise in the discussion. We shouldn't change config entry version or use the migration api. Just check for missing item in async setup entry and update the config entry data etc as needed. Huh? Is it deprecated? I thought the purpose of it was to ensu
That is what name is for? The name is used to make the original entity name. And is used in scripts, automation .. It has a technical aspect. Here it is the default display name for UI. If we have a lot of mqqt entities to display it is tedious to rename them all. Especially if because of problem we re-initialize the integration of 0. So I think this is the wrong way around. You want to have control over the entity ID, the name is already covered. This is working around it I guess. If anything, we should not add a friendly name field, but an object id, so you request that. That said, it should not be a concern what the entity id is. Even more, the entity ID isn't guaranteed to be granted (as it can already exist for example). Instead, set the unique id that allows the user to customize it to their likings. As that is already possible and with the fact you can't be sure of the entity ID anyways, I would opt not to merge this. The single id has a different purpose. He is there to make sure that if we change the original name it does not impact the values already recorded for the entity. If I put a non-technical name in the name field. For example "Volume of my media player" even with an id "media player 1 volume". The entity will be designated: "sensor.volume of my media player". The idea is really to propose a friendly name which does not impact the original name of the entity for its scripts, automation .... Moreover, once it is defined it will not be it again. So the user can change at will. After a google search it is a rather requested functionality example: The idea is really to propose a friendly name which does not impact the original name of the entity for its scripts, automation .... That is what unique ID is for. But HA does not use unique id in scripts and the name of the sensor. The sensor in my example will be called "sensor.volume of my media player" whereas it would be cleaner if it is called "sensor.media player 1 volume". What if I had put the name media player 1 volume This UI level is not very pretty. And asks to rename the sensor manually while HA precisely offers the friendly name. Or the name of the sensors should be build from the unique id if it is available and not from the name. Please update the description to clearly explain why this is useful and why name and unique id are not enough. You mention that: The idea is really to propose a friendly name which does not impact the original name of the entity for its scripts, automation .... Then please give an example of how this addition improves the user experience Is what you're after a separation of entity id and name ? Or the name of the sensors should be build from the unique id if it is available and not from the name. I think you may be mixing up unique id , name and entity id . My personal example is the following: - I create a Freebox to MQTT platform. (The Freebox device is french media player and internet box). - I go back in mqtt full of sensors of this device for
Could you use attr unique id ? Done
Shouldn't this be set in async setup device registry like the other data? Then it also works if the device has not entities :man facepalming:
This needs to take into account that the config entry can be on discovered data provided by the supervisor. In that case, this URL isn't valid.
An exception should be raised after the 3 failures. Does it make sense to wait 3 full poll cycles to update or declare "connection" lost? Yes, this may sound weird at first look but the behavior is intentional and fine-tuned over last year from experience of many users. The 3 (silent) retries was selected as best approach for most users. (There are users out there with various usage scenarios, some have 30s poll time just to watch it, some use aggressive 1s scan interval to use it for real-time control of devices consuming the produced power. To accommodate these different needs, this a bit unusual approach was selected). When the inverter is not responding at all, the exception is intentionally not thrown, since it is usually a correct state of a solar inverter (non-battery) which went to sleep mode overnight. All it's sensors will report themselves as Unavailable and will come back to life again in the morning when sun will wake up the inverter. How are timeouts handled here? I see in init there's 3 retries before declaring a timeout. The retries during initial connect() are handled internally by the underlying library, I have add explicit retry 5 parameter to that call for the setup to be more robust. I suggest moving to using SensorEntityDescription to describe your sensors along with icons, units, etc. Many examples in existing integrations. An example that I just submitted a PR for (modernizing the integration) is here: Done, SensorEntityDescription is now properly used, simplifying code a lot. If you can simplify the creation of the sensor that would make the code more readable. For example, config entry does not have to be passed in. It is available through the coordinator . Done, proper use of DeviceInfo made it unnecessary. Use the attr form. Look at both the Entity and EntitySensor base classes to see all the attr s that are supported. DeviceInfo should be used as the return type (this is a recent change). Done. I think that this long if statement can go away when you move to SensorEntityDescription . If you do have extra attributes in what you need in SensorEntityDescription then you can derive a new entity description from that base to add in your specific attributes. Accuweather integration is one that does that. Done. I think that this long if statement can go away when you move to SensorEntityDescription . If you do have extra attributes in what you need in SensorEntityDescription then you can derive a new entity description from that base to add in your specific attributes. Accuweather integration is one that does that. we could add: "configuration url": "", we could add: "configuration url": "", All async methods should have async prefix. Any reason this cannot be converted to attr extra state attributes Can the coordinator available method be used? L311-L313; i.e.: can this method be deleted? attr native value won't get used ever. Since the native value method overrides the one in the base class ( L237-L239), attr native value 
Shouldn't this be 2 20 ? Correct, implemented. Shouldn't this be 2 30 ? Implemented. Shouldn't this be 2 40 ? Implemented. Shouldn't this be 2 10 ? Implemented. Why do you add this? See here: Based on what it says there, it's not needed. I'll remove the line. Why not something like: Yes, I tried that first. But that would lead to incorrect overflows. In the end I tried this, combined with line 151: self. overflowed False . And that worked as intended. And I was tired, no more energy left to investigate further :) About adding or not, the derivative function does not handle a byte-counter resetting to zero well. If we intend to extend the functionality of this integration, we should fix this as well. And the proposed solution does not interfere with the existing functionality. So why not add it?
These are scenes, not effects. My review comments from the previous PR stay the same, we should not hardcode these and they make no sense in the Home Assistant world IMHO. i would have to disagree. as mentioned in my previous comment. these scenes effects are hard coded in the Tuya app. i believe the problem here is that Tuya refer to effects as scenes. This would just move us closer to feature parity with the Tuya smart app. Scenes in the home assistant world are a set of devices set to particular setting. for example the setting here called beautiful is a soft transition between 6 colours. this is all handled in the bulb in order to have the same effect running with HA you would need to have a script running at all times to make the transition happen. adding this support would allow it to be extended later on by adding your own effects from the config file. is there a preferred way to add these default effects? I don't want to have to reinvent the wheel here and having some out of the box functionality will help people understand what they are and what they can do. This would just move us closer to feature parity with the Tuya smart app. Home Assistant is not about being feature parity with the individual app, we provide a abstraction that is as much consistent as possible across all our integrations. As these are not effects in Home Assistant terms, and not provided by the device (but by hardcode in Home Assistant), I have to decline this. Home Assistant Scenes already provides the same possibility, which is universal across integrations. this is using functionality that the device has eg work mode scene [work mode]( title-3-work mode) the effects mentioned in the home assistant docs refer to flashing and other transitions handled by the device, how is this not that? home assistant scenes do not provide the same possibility. a home assistant scene can only set the light to 1 colour. these effects have multiple colours and transitions (albeit not all of them). if I take it the only problem you have is that the effects are hard coded? If i make it configurable am i allowed to use any default config or do i have to leave the feature not working? if I take it the only problem you have is that the effects are hard coded? If The problem is that it is hardcoded here and not provided by the device. Thus not a device feature. my tuya light using the "beautiful" effect this is using a list of colours and transition rules specifically the one i've listed in the source. This is a feature of the device and not a quick setting of a specific hsv. Nice, got quite a few lights at my disposal, and thus am aware. You are missing the point. we're both missing each other points. The devices have a feature on this we both agree. you don't want the config hardcoded. i want it to come with some default settings. but ultimately be extendable via the configuration.yaml i suppose. i'm asking is that what i need to do to get this approved? but ultimately be extendable vi
Move this check into the if statemenet when you assign master result

Can you do a normal if elif here instead? One liner was good before, but not if you keep adding conditions. Something like? or something like?
This is effectively an alternate implementation of SensorEntityDescription. We should switch to using that now that the original PR has been merged git grep SensorEntityDescription for some examples Agreed, done. Thanks! :) Should any of these get state classes ? I think you are right, they probably do. But it is working 100 fine without this (including in the energy dashboard). Perhaps the DEVICE CLASS ENERGY has some default behaviour that works. I will change it but would like to try it for 24h on the hardware to make sure it behaves as expected. Done. Subject to hardware testing (I have to wait for daylight to confirm ok!). Is this actually possible? Agreed, this would be a major ( obvious) coding error, and not worth the test. I think it was previously added to get 100 coverage in the original way it was implemented which had a switch case that could easily be incomplete. Deleted. Is this actually possible? Gone now, see above. We shouldn't test the entity class directly. We should setup Home Assistant and test it through the standard interfaces by examining the state machine ( hass.states ) writing-tests-for-integrations I think this might be moot as it might be remove-able anyways per my comments above Agreed, gone now. In a future PR, please separate words with an . Just noticed this was already pointed out in 58504 so I'll mark this as resolved here Yes that is already being covered in 58504
This can't happen. I have removed the check Please don't use a ternary operator expression if it spans more than one line. Use a regular if else block. Changed This is not optional. Changed We don't need to define the init method explicitly in a dataclass. removed init This is not optional in this class. removed check Is there no way to get the position from the device? I have not found a good way yet. In the zwave2mqtt UI, I can press the refresh button and the values appear in the zwave2mqtt UI. I have not figured out how to do that in home assistant yet. Please let me know in case you have any hint on how to solve this. The Value.value attribute will return the current value of the ZWave value. If this is updated by the device we can use it to return the current tilt position state. L197 Thanks for the hint. I have found a way to do it. It looks like the update needs to by triggered by async refresh cc values. Can't this entire function be condensed into a single call? self.tilt value is already a ZWaveValueId . get value from id constructs the value ID for you and looks it up in the nodes collection, returning the ZWaveValue if it exists, or None . The device offers the tilt command depending on it's configuration. You can use the same device for roller shutters or venetian blinds and configure the use case. So we need to check here if the device offers the command which I did with checking node.values.get. What do you think? Sorry, I don't see the difference. Did you look at the implementation of get value from id ? You are duplicating it, in fact you are duplicating it and then calling it again. So we need to check here if the device offers the command If you care about this, why don't you check for the value in the discovery schema, using the required values field? If it's missing then this new cover class won't be instantiated. Many thanks for this hint: required values works fine! This doesn't work. When you modified the platform hint, you never updated the device class attribute for that hint. Fixed I don't think we need a default value if the parameter isn't optional. When I remove it, I get the following error: File " usr local lib python3.9 dataclasses.py", line 504, in init fn raise TypeError(f'non-default argument {f.name!r} ' TypeError: non-default argument 'tilt value' follows default argument How can I get rid of it? We can make a mixin dataclass that defines the required parameter and then inherit both BaseDiscoverySchemaDataTemplate and that mixin class here. I implemented the mixin class. Does the Z-Wave tilt position range also range from 0-100 as it does for Home Assistant? Below we use percent to zwave position so I assume the ranges are different. Thanks for the hint. I have implemented the conversion properly now. kpine what do you think about this? My understanding is that the driver already schedules a refresh of the value: L123 The default delay is 5 seconds. This refresh would cancel the scheduled one and issue it so
Time to remove these (not now... not in this PR) It's only the attributes that are still accepted here, the code behind is already cleaned up;
Shouldn't these modes be config entity type? Still learning the nuance here, but that makes sense to me. I've updated all mode sensors to be config , and also found some other set point type sensors that seem like config too. My thought process building on your comment here is that most of these are things that would be better served by an entity specific card, e.g. a climate card, for example. So uh... Don't kill me please... during this re-review, I realize these are sensors... so read-only... so cannot be used to config a device... Maybe revert that last commit, we'll all do as nothing happened, approve and merge it after that? No problem!
I tried to extend this from a common schema but voluptuous didn't really like it.
So given Halo Home appears to make products other than lights, it would be better for this connection logic to be moved to init instead, and stored in access from hass.data[DOMAIN][entry.entry id] Bre77 Appreciate the review. Updated to create the connection object from init .py . username is not a good source for a unique id . See for ideas on what you might consider using (or not). Thanks for all the feedback. Updated to use the user id from the HALO Home API. Brightness should be initialized from the lib or if not known set to None . Same as previous comment, from lib or None . Is pid the same each time this is run -- pid sounds like a process ID which would change on each run. Yes, it's a strange name but it does appear to be consistent. Perhaps it means "permanent id". I don't understand how user id is that different from username . Is user id really a globally unique user identifier ? If so, that might be a better name. The goal with unique id is that it "never" changes and is unique if this integration was setup with another account. user id is static for a HALO Home account, and remains the same even if the account email is updated, for example. If the integration is setup with a different account, I would think it should be added as a separate integration entry. Looking at [Unique ID Requirements]( sometimes-acceptable-sources-for-a-unique-id-for-cloud-services) (for the config entry, rather than for devices), it lists email address, username, and account id (which is user id in this case) as "sometimes acceptable" for cloud services. Works for me. Thanks! Now that I know None is valid, you can delete these two lines. attr are generally set to None by default when deriving from the base entity. See L650-L652 It is not compulsory, but since new integrations can take a while to get merged, I suggest that you take the opportunity to move to 100 coverage whilst the reviews are in progress. LOGGER seems to be unused? We already provide feedback via the UI, why add additional logging here? Isn't it better to just keep raising in the list location devices and try except it here? The None handling seems a bit artificial, especially considering None means no connection? Use The Platform enum here, e.g., L22 Would the user need to set a different host here? Potentially yes. HALO Home uses avi-on under the hood, but also a separate url that they sometimes use. how would an end-user know what URL to use? That's a good question that I don't really have an answer to. HALO Home is not very transparent so it's not clear in which situations a different URL is needed. I'm fine removing that as an option, since it might never come up. In that case, I would leave it out and see what happens in the future. It can always be added when a clear use-case pops up. There is no update here, should this be marked as assumed state instead? See: generic-properties Raise ConfigEntryNotReady and don't continue set up If you can figure out that the auth was unsuccessful,
This behavior was added to aioasuswrt in PR kennedyshead aioasuswrt 80. In order to fully support it, a new release of aioasuswrt is required. This will raise a ConfigEntryNotReady if fail, and will eventually abort integration setup just due to missing sensors. Doesn't seems a good idea. Would catching it and then skipping all temperature sensors be sufficient? My opinion is that initial check should be done inside router.py in method init sensors coordinator() . If all sensors are not available, coordinator will not be created. If only some sensors are available, you should store the information in the router class and use it here to choose the sensors that must be created. Check should not be done based on exception description. Library should raise a specific Exception if required. Sure. I wrote that line for the current version of the library, that raises an odd exception. Will delete that line and bump requirements once a new version of the library is released. kennedyshead a new release of aioasuswrt will be required for this PR. Noted! Working on release, but want to add as much as possible so lets give it a couple of days more ;) This method should be moved in Router class because is only used there during initialization and have nothing to do with coordinators. Are you sure that this are the only exceptions that can be raised? Because this run during initialization, if there are some others error all integration will be unavailable. May be make sense add also generic exception to avoid this kind of issue? The library is handling exceptions. Line 379 could be cautious and catch any Exception . It might be considered too broad in this repo? (read: I get what you suggest, it doesn't break anything, but is it an acceptable solution here?) Module homeassistant.components.asuswrt.router homeassistant components asuswrt router.py:379:15: W0703: Catching too general exception Exception (broad-except) pylint is warning about it too You should add pylint: disable broad-except . But I just want to be sure that check for a sensor will not cause whole integration to fail. If you are sure that library is properly managing any condition, you can avoid this. I would be more for a debug , probably does not make sense warn users for this. But you can leave as is and wait for member team opinion. I debated about it too. Figured it's an unexpected exception - so I better not hide it in debug log. (btw - thanks a lot for your feedback) now logging to debug This would be if not sensor names: Can you add test for this condition? Removed specific handling of OSError and ValueError since they are handled within the library. Now response is consistent for any exception. Added a raised exception test (for IndexError ). Why are we fetching the sensors inside this loop? We don't seem to vary the input to this method depending on the loop item. Number of temperature sensors on asus routers vary depending on number of radio, and in some routers are not available at a
This doesn't exactly match the docstring here: L41-L47 Do we need to update the docstring in the library? Also we should only use the modes that doesn't correspond to speed settings as presets, ie the preset modes and the speed levels should not overlap. We'll use the percentage parameter to set speed level. It's probably only the "auto" ie 1 mode that will be a preset. preset-modes In the app, it's possible to click the "Auto"-button (ie mode 1). There is also a slider having values 0-5 with a step between each full step. Thus, we'll just use Auto as a preset and implement the slider as a percent-selector? Yes, that sounds good. I count 10 speeds including speed 0 which is off. Mode 1 is an auto mode and not a speed setting. We should check that the preset mode is the acceptable preset mode, 1 . Otherwise raise a ValueError with a message as exception argument. We should handle the percentage and preset mode parameters here too. Maybe let async set preset mode handle this since we have error checking in place there. Alternatively we could check if both percentage and preset mode is set and raise a ValueError since that's not supported. I'm not quite sure what you mean here? MartinHjelmare I'm proposing this new change since yesterday. I think you need to add a calculation so you convert e.g 51 to the closest step that are legal . I think from percentage is not doing that correctly. Could you please add a test that shows that the percentage calculations in both directions works. janiversen are you sure about this? We can't set 51 in the GUI as the slider steps are [0, 10, 20, ..., 100]. I'll add tests. the slider might change in the future, so this is just to secure the software can manage it. Gotcha Let's move this limit to the convert function. Please try with e.g. 51, not numbers that convert directly. We should translate this to our constant ATTR AUTO . If no preset mode is set this property should return None . You mean like this? Yes. Don't forget to exclude the new module from coverage calculation in .coveragerc if we don't have complete coverage for the module yet.
It looks like desc is used in the base entity to generate the unique id. If that's the case, will this be a breaking change for existing sensors? I think you're right! I will come up with another solution, because I don't like this being a breaking change. I'm trying to grasp the breaking change here, it is needed to support the WasherDryer class? Because otherwise there will be a clash between washer and dryer programs. See
Thanks for the fix! Merged into the commit. How do we guard the user from configuring the same stop id and routes for more than one platform? The unique id must be unique and stable. Added the component prefix and sort routes. The user can still add more than one platform for this integration with the same stop id and routes, as far as I see. I don't have an idea how to prevent a user to create duplicate entries. I removed unique id from the sensor again. Routes already defaults to an empty list. Nice catch! Fixed
Why are these attributes and not separate entities? comfort temperature and eco temperature are the actual values for the presets "comfort" and "eco" and as far as i understand those are not part of the current implementation of homeassistant.components.climate.ClimateEntity since they could be beneficial to use within automations, they are exposed as attribute So, if the intention is automating, they definitely should be separate entities instead. to elaborate this a little bit more: the fritzbox thermostats are produced by AVM, a company that also builds home-routers. they integrate into their eco system and you can only set them up using the routers webinterface. you set two temperatures and a schedule, where the thermostat switches between those two temperatures (you can also set the thermostat manually to any value between 8 C and 27 C, but if the schedule triggers again, it will go back to one of the set temperatures) also see page 12, entries for komfort and absenk the fritzbox thermostats are produced by AVM I'm well aware of what it is. This is not about what the fritzbox is or can do. This is about the Home Assistant architecture. Back in the day we mainly used attributes, nowadays, we don't use those anymore (and are trying to get rid of them slowly). Back than, Entities was the only concept we had. Instead, we now have the concept of devices that can provide multiple entities. Which makes attributes largely obsolete. Entities are more feature-rich and easier to use for the end-user (e.g., automations or in the UI). Thus we prefer separate entities instead of entity attributes. So, if the intention is automating, they definitely should be separate entities instead. i dont see why and how this should be a separate entity? it is basically just a (readonly-) property of an already existing entity do we maybe have a misunderstanding here? it is basically just a (readonly-) property Sensor entities are also just readonly properties. do we maybe have a misunderstanding here? Nope, we don't have a misunderstanding. ok now i got it. i was under the impression that it would be "ok" to have the other attributes but not those two. your point is basically to move everything (And the few i added) from attributes to sensors belonging to the said device, correct? if yes i will see how this can be implemented. In general, that is preferred, yes. the newly added readouts have been implemented as sensors. this sensor should not have any state class (see available-state-classes) this sensor should not have any state class (see available-state-classes) this sensor should not have any state class (see available-state-classes) this sensor should not have any state class (see available-state-classes) this sensor should not have any state class (see available-state-classes) this sensor should not have any state class (see available-state-classes) I guess an copy paste issue from "comfort temperature" what will happen, when nextchange temperature is set to som
Why not do the work in async remove config entry device ? We already have the device entry there. Thought the device might have some other way to get removed, so it would be good to act on the event instead. This is how the only other user of this does it (cast). I can move it. There was one more reason. It need access to the devices variable, which is currently local to to that function. So can't easily move it to the other function without larger refactoring. Ok. Please use this pattern instead: done Looks like we can clean up the import of config entries if we revert this change and just use ConfigEntry which is imported. Will fix. I'll merge here now. We can clean this up later. : 1:
This won't work for add-on use (Ingress), maybe check the source of the config entry? It's possible to access phoscon through ingress right? It will just be a different path? Yeah in that case, you should be able to link to: core deconz so that would be something like host address core deconz ? No, just core deconz . There is no external address involved in case of ingress. "configuration url" validates with homeassistant.helpers.config validation.url which require the url to use http: or https: Ok, its a link internal to hass frontend. ludeeus its not possible right now for addons then? Something that should be extended or do you have another suggestion? ludeeus Oh right, that's stupid actually, we should update it to support add-ons. Will try to look into that. Kane610 I would start by implementing to expose the configuration URL only when the source ! hassio. Currently not possible, but I think we should extend it to allow ingress and potentially other navigation paths inside our frontend. Edit: What frenck said :point up: :smile: Will do, non add-on support first We can now use homeassistant: hassio ingress core deconz device-properties Thank you ludeeus, PR is up
Should this be a subclass of HomeAssistantError ? At the moment i don't think it makes any difference if it was. We don't handle those differently. But it would be nice if home assistant errors suppressed backtrack by default for service calls. Then it would be useful. Or we could have a separate ServiceError exception. Our standard is to inherit from HomeAssistantError in all custom exceptions that we define. Please keep it sorted . Number entities. Number entities. This is the default.

Normally we raise a ValueError with a message as argument if a wrong parameter is passed to a service handler. The message will be shown in the frontend.
Battery state is defined as a sensor, not binary sensor. Please update the sensor platform instead. I just replicated it from the tuya beta integration, but sure not a problem will do The beta and core integrations are not much alike. frenck done The smoke state DP is considered legacy. It is fine to add that, but can we also add support for smoke sensor value (as a sensor) and smoke sensor status (as binary sensor) to complete support for this device? sure thing frenck I just gave the constant a bad name, I will rename it but it is using the non deperecated smoke sensor status. I will rename it. I will also add support for the legacy smoke sensor state and smoke sensor value to complete the integarion frenck done Small thing, but could you keep the sensor list sorted by its key? sure frenck done on sensor and binary sensor This feels a bit weird in naming, for when a user sees this sensor in the frontend. How do you feel about: Please note, that sensors are already pre-fixed by their device name (automatically). yeah I wanted to ask you about that, that indeed sounds better frenck done Oh, sorry missed this one in my last round (feel ashamed to keep reviewing this... sorry!) done As this entity has a device class, we don't have to set an icon. The device class takes care of that. done, I also added the measremtn state calss
Looks like we already check that description brightness max is not None above when we set brightness max type. Sure, but it is used below, thus requires to check it if not null for MyPy. This is where typing sometimes sucks just a little bit ![image](
I believe, DEVICE CLASS CONNECTIVITY provides you connected disconnected icons for free. Or do you feel like these custom icons are actually important here? Yeah, I prefer these since the regular ones are more server centric and this shows two devices which makes more sense (at least to me). The device class has been set, in that case, an icon should not be set. Why is this disabled by default? Wouldn't it make more sense to mark it as the diagnostic entity category? Not sure which one you are referring too, I have completely migrated to a entity description setup, so please have a look at that and let me, it includes categories for two sensors as well. A device class is set, the icon should be handled by that. A device class is set, the icon should be handled by that. Please consider implementing EntityDescription s instead of this logic. Done!
This method is not reliable, for this reason was not introduced till now. It works only on some router models, and do not consider the possibility that not both the radio are available. I think is better to avoid to introduce a sensor that could not work. It is indeed unreliable and hard to test - having no access to the variety of Asus hardware and firmware. I have edited that method over at aioasuswrt , making it try multiple commands. It will make adding a new command a bit easier. Added an additional set of temperature commands that work with my router. and do not consider the possibility that not both the radio are available I'll try to look into that too. Might try changing the current all-or-nothing approach of that function, or maybe split it into 3 methods. I think that should exist a method to probe what is available, so that it will be possible to determinate which sensor must be created. Than the get temperature should always return the same structure and only required data will be used. But it will be hard to have this working considering the huge number of model and related firmware available. Yes there are a lot of versions, thats why I suggest we only support our own versions. My goal is to make the component try with the known commands (currently 2 known variations), so our own versions will work. I agree with ollo69 that only sensors which actually get data should be created. There's a bit of work needed on both aioasuswrt and the asuswrt component in order to support that functionality. I also intend to memorize which command is working in order to avoid running all variations in every get temperature call. I'll try investing some time in it today.
Use only one underscope for private methods and add docstring comment. Actually, a single underscore is protected, not private. Double underscore would be considered private. Should check before unpack: Fixed What is this construction? This throws an error. I think the square brackets are not needed here. Why do we force an update here, while not on other changes? Additionally, it seems that the update method is throttled, this would bypass that, isn't that an issue? Additionally, it seems that the update method is throttled, this would bypass that, isn't that an issue? By the way, I don t know why there is throttling in the update function. This breaks the manual update service ( homeassistant.update entity ), without it everything works great and responds faster. I think we can remove it in separate PR. R0nd I think we can suppress self. update volume() in this method now and improve the state updates in the next PR.
Let's match the name to the product page It's better to start with the integration specific entity class, LookinDeviceEntity , in the MRO. We should not need to include Entity at the end specifically. All the other classes inherit Entity already. The first class should pass non used init arguments, ie the coordinator, to super(). init . Thats probably due to some bad advice on my part. I'll clean this up Where is LookinPowerEntity used?
Could have used the connectivity device class here, but if an add-on is running or not did not quite fit into that. We could add a device class for this? : 1: aaaaand added to this PR : 1: Using "Running" is not in line with the API status, but might be better for a user to get? Both are ok, I think. I like running more, because it describes what is happening now (state) versus started, which was an event and could be unclear if this was the last event, or that maybe it already stopped.
Seems a bit wasteful to create the entity before we check if it's needed. Can we check the unique id of the device ie sensor instead? The sensor unique id is not enough here since it will need to add a suffix and multiple number entities will belong to a single sensor. Im doing it in a similar manner for tampering binary sensors as well as batteries. It might be a good idea for me to review the whole unique ID flow for deconz entities going forward, to normalise it, but that shouldn't be a part of this PR. Doesn't the platform add all entities for a device regardless? Do we need to keep track of the entities instead of just what devices have been added? That is true Martin, its not the same case as battery which on restart might take some time to report. I will look into changing this. Thanks! This is hidden by the unique id property in DeconzBase . Thanks! Fixed.
It looks like the docs for this are outdated? events Nevermind, I missed your docs PR It would be a bit more readable if you did something like event simplisafe.initial event to use[system.system id] and then used it below Might be a bit more readable with self. attr extra state attributes.update ? I agree. Anecdotally, though, I got a code review once that said, "Why use an extra dictionary?" Does it make sense to make this tuple a constant? Would it make sense to make a mapping here of EVENT to STATE ? Would a mapping of event type to lock state make sense here?
Should this also turn off away mode? mm. good point. will fix. updated to flip the away mode boolean when turning on hold mode. Should this also turn off hold mode? it does both. sorry misunderstood your question... hold mode is determined by the actual state of the thermostat (since it is a natively supported feature) whereas away mode is a feature "created" in HA to simulate what many other types of thermostats do. so when turning on away mode, we don't need to turn off hold mode. (technically, on the thermostat itself, all away mode does is turn on hold mode and set the temperature.) this new feature allows you to set hold mode without setting the temperature... ie maintain current temp setting. It looks like mode is coming directly from the device and not the library L156 so we can't be sure its a hold mode. Since there are only two modes, L255 Would you please avoid using setattr here instead and throw an exception if the mode returned isn't valid. Actually, we do know it's a hold mode. The Honeywell thermostats have a permanent hold setting and the somecomfort library is able to gather that info from the device. So in this case, the update I'm making is to allow a user to see if their device is in permanent hold or not and to also allow them to turn the hold on or off, which is why I use setattr to turn the hold mode on. What's concerning here is the integration is accepting arbitrary unvalidated data from the Honeywell api and using it to set an attribute. This is one of the ways software vulnerabilities creep in. While I think the risk is low here, we should mitigate it if it's reasonable to do so. If there is validation and I'm missing it, please help me out and point me to it. Ah! Now I understand what you're after... I added a check that confirms the mode returned is within the values that it should be (auto, off, heat, cool). .keys() is the default so this was ok. It just wanted you to drop the .keys()

: 1: Should we mention that this one has been removed in the breaking changes? Done
I copied a lot of this from cover.py . I think it can be made a bit more DRY
Since you are refactoring, it feels like this could be implemented using a generic sensor class configured by a SensorEntityDescription rather than this lookup. Done! As above, this code should not be needed. Done! As above, this could be implemented using SensorEntityDescription Done! You may want to consider DataUpdateCoordinator here, which does a lot of what you have implemented here for you. In general this moves towards a named dict to store the copied data rather than lists accessed by an index. I never heard of this... will need to look into it... Again, would you have a component to point me that uses it? I'm only adding readily available features to an existing component. I don't have the time knowledge to redesign the component. I already fulfilled other requests, but for this one I tried but was unsuccessful. Potentially this could be moved to an async context as the get() here will lock the thread until it completes. Spent a great amount of time trying to make it work as an async without success... Would you happen to know another XML scraping component that uses async that I could refer to? As previously stated, I'm a very beginner in Python coding... I'm only adding readily available features to an existing component. I don't have the time knowledge to redesign the component. I already fulfilled other requests, but for this one I tried but was unsuccessful. I'm not sure what to put here but I don't think the SensorDeviceClass is MONETARY in this case. Yeah, I think you're right, it returns the carbon lbs kW... I don't know in which class to put it, I think it just won't have a class at all? I think this can be SensorDeviceClass.DATE No, it can't be a DATE class as it only returns an integer of the reading day, e.g. "1" for a reading on the first of the month ![image]( In that case the entity name might be better as 'Day of Month' Does this mean that there's an addition to the YAML config? I don't think that is allowed as per ADR010. If possible can you make the enhancements without this new YAML entry? Absolutely, it could be "extended mode" for everyone, just don't use sensors you don't want or disable them individually in HA, will do this shortly... I'm a bit confused by this pattern. Could this functionality just be implemented within the update() function below? That would seem to make the ownership of the data{} a bit clearer. I assume you are choosing to collect all data in all cases, even if the 'utility' data is not configured by the user. I suggest adding a comment saying this is what you are doing. Won't need a comment since I'll remove the "mode" input from user I realise that this PR is adding to existing functionality, and largely accessing the data in the same way as it was previously, however this does seem to be reaching quite far into specifics of the ted5000 API. I would strongly consider moving this into a pypi library that can be imported, as this is what is requested in the 'Development Checklist'. I believe th
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
Why don't you allow a DNS-name? The pyebus library supports hostnames, so I would remove this restriction. PLATFORMS [Platform.SENSOR] Consider moving this logic into the pyebus library. I don't think this PR makes any chance with all this "non-essential" code being here. Ideally, you should be able to replace it with a single callback in your Api-object that is called every time a value changes (cfr. acmeda hub.py for an example) Please explain better what the difference is between an EbusEntity and an EbusFieldEntity. Now the description is the same? Can't you retrieve the proper manufacturer model from pyebus? Change this to your handle Update this map to use SensorDeviceClass.TEMPERATURE and the like This seems like an improbable value? Is this in ms? Add a comment if so Why not just use the available attribute of the sensors to mark any problems with the eBUS? I would just remove this. I suggest removing the service from the PR to increase your chance of getting it reviewed by the core team Use "cannot connect": "[ key:common::config flow::error::cannot connect ]", use load fixture to move this into a separate json Use cannot connect What is the use of saving these in the config entry? Why not discover them upon initialisation? use snake case here use attr should poll As I've fully gone through your code now. I think you should remove this class entirely. It serves no real purpose. Can't this be set in attr name upon initalisation of this class? Use attr device class remove this Shouldn't this be in the sensor-subclass? Also: use native unit of measurement , and use the attr to prevent defining your own property move to constructor and use attr field Remove this service to reduce the size of the PR Do all this work just once in the constructor and set attr device info Why don't you merge this into init ? what happens if the ebus-server is unavailable? You should throw a ConfigEntryNotReady error in that case.
Why are you removing all these constraints? I'm trying to figure this out, it happened automatically by one of the pre-commit hooks. I think it's because I removed the dependencies from the manifest. I tried adding them as after dependencies, but that didn't help. I'll try to figure this all out add some tests today :smile: Converted this PR to draft in the meantime.
This should not be part of an integration, the project already has a license, please remove this file. Please remove the README file, this should be part of our documentation instead. Please add yourself as codeowner Core integrations don't have a version. For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
I think this needs an architecture discussion if you want to fire this event from the platform for a specific entity. If you want to fire an event for a new Fritz device from the integration, that would be ok I think. We shouldn't need this. The device registry already fires an event when a new device is registered, that should be enough? True, but there is no useful info at all: There's a helper for the device id. Anything better than this ? Is it not good enough? I was thinking to improve the " replace() " maybe using domain if possibile, Also would be nice to have some more info in the message, like mac address , ip address , etc. But didn't find a solution for neither of the 2. Simone The action is specific to each use case. Not important for this discussion I think. The trigger and condition is what's important, ie will it allow the user to trigger an automation when needed. Ok, let's speak about condition only: any better way than " startswith() " ? I don't have an improvement for that part, but the event data action matching could move to the trigger under event data since it's full string match. event-trigger
this is not a measurement, as it is per hour. Same this is not a measurement because it's a max.
Here are a couple of more
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision So then this integration needs to be refactored so that it supports configuration under the domain key (command line) while still supporting legacy configuration. Should that be its own PR? Command line also needs to be refactored to use async, but I'm not sure I'm feeling that ambitious. Would the configuration refactor be accepted without also doing the async refactor? Somebody has already started a PR ([ 63840]( to refactor command line to the new config style and async, so converting this to draft for now in hopes that PR is eventually completed.
Why remove coffee maker ? Its a duplicate
This seems to be unused? It's used by the switch, but good point: I can save that reference there.
Let's add test cases for empty list and non-list inputs Yah, I'll have to to increase the cov tests What if one of the items is not a number? Would be nice to log a useful warning It raises an error just like min and max, trying to keep it consistent with those functions filters Worth checking if it's a list before doing anything else? Again, trying to keep it consistent with min and max. It takes a single list or a multiple arguments. A single argument that's not a list returns an error Can't we use statistics.mean instead of implementing our own? Does statistics.mean require dependencies? Or are they already a part of core w o integrations? That's all I was trying to avoid. I can swap over if that's the case. It's part of the Python standard library, so does not require any 3rd party dependencies. statistics.mean emontnemery ended up using statistics.fmean because that was more inline with the original intention of the avg function. Please rephrase can do can do
hass.data[DOMAIN] is already used to track config entries. It will now also track devices? Will it be possible to have entities call the prefixed host method on fritz inside the device info property, maybe by storing it on the coordinator ? ah yeah, that's a good point ... have reworked it to be integrated into the coordinator data If you extend the coordinator instead of passing an update method, you could expose a property on the coordinator that calculates the host once, instead of on every update. However, I'm fine with this too. Your call. will extend the coordinator ... feels and looks more cleaner ... thanks for that hint Don't store it in hass.data before calling async config entry first refresh . If that raises it now leaves the coordinator behind. What if the connection between HA and fritz is down, it ends up raising auth failed ? Can we distinguish a 401 to trigger login? (and yes I know this is existing code but we're changing it up, let's do it good!) we now check if there is an ConnectionError which raises an ConfigEntryNotReady ... otherwise re-auth is tried
For another PR, but should we move this up to TuyaEntity ?
No energy? Not in these device specifications. There is a generic property called add ele which reports the amount of kWh used since the last time it reported. It assumes you keep track of the total. Considering that, I guess we could use a total state class and use each time it reports as the last reset . The state of the sensor itself would be a bit weird and rather useless.
We don't need this. We know any entity under button domain contain a timestamp. This is the default behavior so we don't need a platform for this. ... or should we wait until there are proper device classes available? Right now setting a device class is invalid. There are no device classes. This guard for that. Why do we use double underscore prefix? Because that marks it private by our linters. Thus cannot be overridden by an integration.
is this a real todo or copied from something else? This is from the scaffolding. It can be omitted I am not positive that the implementation of this method is correct. Perhaps you can help me see what i'm missing, or confirm that the behavior. My read of the camera state machine is that the state can either be recording , streaming , or idle and on off is a separate property: L617 This is also described here: properties However, there is a comment that says attr state: None None State is determined by is on but i'm not sure that is actually correct. What do you think? You're right, allenporter, the camera state is recording , streaming or idle .
They are not going to want this exposed. We should set a reasonable interval. If a user wants a different polling interval, they are able to create an automation to force an update. Understood. This comes from Transmission (in case it should be removed as well) and seemed nice, but I will remove it as you suggest. This is not needed. We leave the old yaml config where is was. The old YAML config was duplicated original both in sensor.py and switch.py, Do you want to restore the duplicated code or to move the old PLATFORM SCHEMA to init .py? I'm not sure this change would actually work. You are moving this yaml to its own domain right? This would be incorrect as existing users have their yaml as a platform underneath the sensor and switch domains. The accepted convention is to use EntityDescription, not individual classes. Why are we changing this? Use base class attributes Use base class attributes Use base class attributes
If it's a list, lets use plural This isn't necessary. Numerous integrations use the singular (for instance, look through the codebase for the usage of DATA ). Why not ConfigEntryAuthFailed ? Is this retry-able? Should we raise ConfigEntryNotReady ? Can you make this a bit more DRY? Should we future proof this in case something else gets added? sometimes-acceptable-sources-for-a-unique-id-for-cloud-services Does this need to be normalized? It's an email address; I'll make sure it's lowercase. Should each pickup name be an additional sensor instead? Interesting! Let me chew on this. bdraco Okay played around a bit and I don't think separate sensors is that clean. Ridwell works such that as you update a pickup, the data that comes through changes accordingly. So, if I remove my "Plastic Film" pickup, that data disappears from the payload similarly, if I add something that wasn't there before, the data appears. I would need to manage creation deletion of entities at runtime, which doesn't feel great (compared to just keeping the data, however it arrives, in this single sensor). Thoughts? The multi-level dict doesn't seem to be a common use case. However the typing for attributes is attributes: Mapping[str, Any] so it seems like its ok. It would be good to ask for additional eyes. Another thought could be that is my attribute is a list of single-level dict objects (name, category, quantity). At least then, it's relatively easy to iterate through. How does it render in the UI as-is? ![CleanShot 2021-10-25 at 15 51 01]( It's better to not store things in hass.data until after we know we won't raise ConfigEntryNotReady etc. Collect the errors and write one call to show form if there are any errors instead of writing it twice. Do we need this check? Is it possible to be in a reauth flow without having an existing username set as unique id? The attribution is just returned as that corresponding property nowadays. generic-properties Use ATTR QUANTITY ? If there's no time info just a date we should use device class date. available-device-classes Already configured account? If we extend the pytest parametrization we can merge these two latter tests.
Please use helpers.device registry.async get instead to get the registry. The other is legacy. Also please import the name as normal instead of accessing hass.helpers to help typing. Will fix! Resolved in
I think all humidifiers (MIIO, MIOT, MJJSQ) send use time value. Shall I add the sensor to all classes? Done. This time doesn't update just because time passes, right? That is right. It is an increasing counter for the number of seconds it was switched on. It is useful for statistics to see how much time the device was uses in a certain period, that is why the state class total increasing is used here. So this stays constant when the device is not in use. Please use this common constant. L446 done
Could you please add a unit to the metric name? This should probably be device tracker latitude degrees device tracker gps accuracy meters device tracker longitude degrees
Do we want to do some validation of the URL, e.g. it has to be a valid URL, with scheme set to http or https ? Definitely. We should do that in entity platform . Only allow http and https .
If a ternary spans multiple lines, our standard is to convert it to an if else block. If a ternary spans multiple lines, our standard is to convert it to an if else block. It looks like switch.py was intentionally suppressing the logging call shell with timeout(command, self. timeout, log return code False) 0 It looks like its going to go through the call shell with value path now so it shouldn't be an issue. Please add a test to verify that we don't get any unexpected logging with turning on off the switch with a non-zero return code using the caplog fixture.
Translations are handled by Lokalise. Please don't change any translation files, besides the default English translation that is autogenerated when running the translations develop script. I've just copied the translation files from transmission, since the same strings are used by both integrations. Reading the documentation, I'm not sure if I have to do something more to properly add the translations. The translations are provided by the translation community via Lokalise. We don't add translations here. It's the other way around. Please read the whole translations docs. Understood. Thanks.
Let's also add diagnostic, for RSSI uptime firmware Lets create constants for these as well :) There's already a constant in const.py: I don't think there's a reasonable pattern to avoid repeating the constants though. This is not allowed: We can do it backwards, but it's a bit meh: We could otherwise make an ENTITY CATEGORY enum? I meant creating a constant for the "diagnostic" value I didn't mean it for use in the Literal typehint (sorry I should have been more clear). An enum is nice IMHO, which we did that more throughout Home Assistant. But it would also be weird to have it here? Anyways... if we ever want to do that stuff more regularly, we have to start introducing it somewhere OK! Done in cc8d190
In generally these should be converted to the more modern attr options. And the getters removed. Applies to the number platform too.
Use the constant STATE CLASS MEASUREMENT same I do not think we should access it like this. While this is generally a good way of executing multiple calls, this call is special. It goes to the supervisor which then calls the docker API, we now do this for all installed add-ons at the same time. A better option here might be to implement a "get docker stats for all" API in the supervisor instead or at least do it in sequence (preferably only for entities (add-ons) that the user has enabled). Since this API call works differently from all others here, I think it's good to place it in a dedicated try except as well. pvizeli what do you think? I don't see an issue with calling that. Core and other API callers need not care about docker and our API is object-based. Maybe we can optimize that on the supervisor, but that doesn't change how others call our API. I think in general, it's a core issue that we collect data for disabled entities and that needs to be fixed on the core architecture. Please use our common unit constants as far as possible. L520 This one still needs a constant too. We don't seem to need to nest this function under update info data .
No need to cast to tuple. Nit: If ROOT PATHS is never to be modified, I would prefer an immutable tuple instead.
Not needed when inheriting CoordinatorEntity Try to use the internal datetime functions instead We don't use config entries to store device or service data. Config entries are used to store configuration to be able to connect to the device or service. Integrations that integrate devices or services should not calculate state. We have other integrations for that like the template integration and similar integrations. Device and service integrations should just report what the API reports while following our design standards. Why don't we use the builtin update on interval mechanism of the coordinator? Remove this. We don't normally allow poll interval options. The user can turn off polling and schedule it manually if needed. This is supported by default when using the coordinator with config entries. This kind of data is not suited for the config entry. Connection config should be stored in the config entry data attribute. Remove this. We shouldn't need any other requirements than the device service library. Please remove empty items. Remove this.
Ideally, we migrate this to use SensorEntityDescription s Done That is quite a lot of resources if we need to loop each time over the full set. We should use lru cache on that function or just having a simple dict for mapping I think using a cache would be to much overhead, so i used a secondary dictionary. Lets set the entity description property on the init and remove that property L215 Makes sense. Thanks Let's not make a fallback. At one point we have to fix that to having for all sensors the correct description object. So if somethings pop-up, we can fix it Without the default description it will crash, and then the sensor does not work. Maybe log an error and still do the copy? ![grafik]( I log a warning message, because the sensor is in a working state. Only the correct entity descriptions are missing. This is how it should work as before. I would open another PR to maintain those missing sensor descriptions. Or what do you think? Okay but let's do that on the setup platform and update the base HMDevice init (conf: Dict[str, str], description: EntityDescription None None) So we don't need overload the init on each platform (future) Done. Thanks for review Are you sure STATE CLASS TOTAL is correct for this one and the next two? Shouldn't it be STATE CLASS MEASUREMENT ? Hmm, I think you are right. I read the documentation again and it says: available-state-classes This state class should not be used for sensors where the absolute value is interesting instead of the accumulated growth or decline, for example remaining battery capacity or CPU load; in such cases state class measurement should be used instead. Sometimes it's really hard to tell, which one to use. Thanks for the hint : 1: I will change that. I had to set a type for this, because mypy gave me an error. I think this one should be a dict[str, str] or am I wrong? Use the base class from from homeassistant.helpers.entity import Entity, EntityDescription as type
I'm not certain this is the correct place to try this, or even that HA will "react well" and merge the existing two devices once a common connection is inserted. Thoughts? I plan to add some tests to cover this when I have some free time (free time? what even is that anymore? :D)

Why aren't these separate entities? ATTR OFFSET , ATTR VALVE and ATTR LOCKED were already there as attributes. I didn't want to add more entities since I'm not sure how generic the Climate class should stay. Adding things like valve which is specific to a category of devices or mounting mode, display flipped and external sensor window stuff which are optional features and maybe vendor specific. pydeconz doesn't have most of them as entities either. Also, except ATTR LOCKED and ATTR EXTERNAL WINDOW OPEN which I expose as template sensors in my HA, the rest is really debug so I don't have to open deconz. See changes on the bottom of homeassistant components deconz climate.py Also see code in pydeconz L677 Im ok with external window and sensor but the other ones (flip display, mounting mode and schedule on) are not relevant to expose. frenck only a couple of devices expose the external xx so far so Im not sure they would warrant the extra effort to put as their own entities. only a couple of devices expose the external xx so far so Im not sure they would warrant the extra effort to put as their own entities. its not about warranting effort, its about not using attributes :) I didn't want to add more entities since I'm not sure how generic the Climate class should stay. They should not be added to the climate platform, that is the whole point of making separate entities. pydeconz doesn't have most of them as entities either. We did everything with attributes back in the day. Just because something is because of history, doesn't mean we need to keep introducing patterns we are trying to get rid of. frenck I completely agree with your thinking... However, I am not a skilled Python dev and have no idea how to proceed or how big this change would be. I'm happy to let you take over this PR if you want. atus if you can't make the requested changes, please close the PR. Someone else can take it up if they want and have time. Thanks for your willingness to contribute! So you're rejecting the change? No explanation on how to do it or where to look... We can help you if you want to try. Your previous comment gave me the impression that you didn't want or have time to do that. I'm happy to let you take over this PR if you want. I'm not, I have enough on my list at this moment. So you're rejecting the change? In the current state: Yes. We are happy to help you with guidance and implementing the changes. Some good resources, in general, are of course available on our developers' website: And, of course, you are welcome on our Discord chat server which we have dedicated development channels. OK, so you're gonna gate this change behind refactoring. Great. Let's unpack this. LOCKED tells us whether the thermostat UI is locked. It can be toggled, so this would be a [lock]( This means we need to also implement deconz calls to turn it on or off. EXTERNAL WINDOW OPEN , FLIP DISPLAY , MOUNTING MODE , SCHEDULE ON are probably [switches]( so again we need to implement on o
Please remove the attributes that are only repeating defaults. done, thanks What does this sensor represent? it represents if the device mac is allowed to connect to the router ap network. In the router settings you can block certain devices or you can even block all new devices. I think it is a silly option since you would simply not give the wifi-password to devices that you want to "block" from your network. But apperently someone want to have this option to see it in homeassistant see issue: I am fine with removing this, because I think it is rather silly and I don't think many people are going to use it. What can the state value of the sensor be? "Allow" or "Block" I suggest making it a binary sensor named blocked, eg, instead. I agree, I will remove it from this PR, we can add it later in a seperat PR. What's the state value of this sensor? the mac address of the router AP the device is currently connected to Is this a fix? yes Please move the fixes to another branch and PR so we can release them in a patch release. Alright, will do Is this a fix? yes Please make this a non private attribute. Why did we change this? that was before I filtered the sensors based on update method. It is not needed anymore so I removed it again.
I notice the other lines above don't have this assertion. Any particular reason to have this or could it be omitted for consistency? I am not actually sure. I must have copy-pasted this Removing. Why are we adding extra attributes and not separate sensors? I can do a sensor, I am not yet familiar with what are the best practices. Though a sensor is unnecessary if we use a switch. Added switch, removed service and attribute. Instead of making this a service, we could just make this a switch? Yeah, I tried to follow the pattern I saw in the integration, but a switch is likely better (that's what I ended up doing with my workaround for this issue). Done. Remove this and the PRIV MODE SCHEMA below. Can we just use . attr is on rather than . is on for this? Then we don't need to have this property. good call. Done.
The options flow for existing config entries still work, right? yes I tested this Don't we need to patch something when setting up the integration below? If this is an existing bug in the test we may want to fix it separately. not sure what you mean. There is no bug, the reason I changed this is because we got rid of the config flow module which included this helper function but the unique ID is inconsequential to the test so we can enter anything I'm assuming the integration will make requests to the service provider when the integration is set up. We should patch those calls or the integration setup function to avoid I O in the test, when setting up the integration. The integration is set up on line 27 below. ah good point! It's not an existing bug as I used to have a patch where autouse is True so fixed it here
This will read: In Canceled minutes That doesn't sound ok. And the attribute below will no longer always hold digits. Instead I'd remove those attributes that are no longer true, if the departure has been canceled. What does the integer mean? It is 0 if the train is not canceled, one if is I think . It's not defined by the API... Please test what the api returns when a departure is canceled. We need to know the possible values here. I've done some checking of the API and can confirm a "1" means that the train is canceled. It tends to be quite easy to find canceled trains on this connection: Good! Then we should update the logic to check for "1" . Ah thanks! It's the motivation I needed to finish this (finally!) thanks Glodenox departure minutes won't have minutes if the departure is canceled. We shouldn't set this attribute if the departure is canceled. Wouldn't it be better to always have a "canceled" attribute available that just contains "Yes" or "No", no matter the canceled state? That would probably make it easier to use in automations. That said, I'm seeing it being mentioned by other reviewers that attributes shouldn't be set in that case, so maybe I'm wrong. MartinHjelmare What's your opinion on such boolean-like sensor attributes? Leave them out whenever they're not in an interesting state or is it best to always have them present? And would it be better to have an actual True False boolean value instead of an integer or text? I'd go with a boolean that is always present. We're moving to always keeping the key present in the state attributes. Would it work to extract the feature to a separate binary sensor for each departure that is tracked? Should I keep departure and departure minutes too then? Set them respectively to "Canceled" and the original departure time. This is the actual behaviour, it makes sense IMO to have the original time but a cancelled state. Or infinite for the minutes? I wouldn't recommend a separate binary sensor. I use a modified version of this sensor that tracks the next N trains and not just the next one, which I think should be the next planned feature. When I look at HA I usually look at the next train or the one after to decide if I should go now or should wait. If there are even more sensors it becomes a bit messy... I can agree with that as well. Certainly departure and maybe also departure minutes should still have some value in the case of a cancellation. If infinite time is a valid value, I think it would make sense in this case. An option to ignore canceled trains would indeed make sense from a user perspective. I'd honestly almost even prefer that to be the default behavior. Just set them to None if canceled is True. We're converting to an integer above.
We should assert here if the warning is thrown in the logs Done
Only wrap the code that can raise in a try except
I am wondering if there would be a benefit to using async for a big file read like this. Given that the new code is almost identical to image sending, would it be possible to combine it with the existing command, and choose whether to call send image or send video based on the mime type? Then you wouldn't need an extra command. I ask more of an idea discussion point than anything else. Video files can be big, we should not read the whole video into memory but stream upload it. The underlying library uses requests , so passing the file instead of the file contents also works here. joshgordon See this diff: balloob Would this change make the file upload logic a bit more acceptable so we can get this merged? Hi joshgordan, jurriaan! My PR [here]( is aiming to switch to a new dependency library for matrix that uses aiohttp ; I'm hopeful that if I'm able to get that merged, various features such as video uploading should become a lot more palatable forward-compatible
From looking at the cbb.disconnect method it looks like it will not work if you call it more than once. If the entry is unloaded and HA is stopped this will be called twice, it to prevent it wrap it with entry.async on unload I also suggest to rename the const PLATFORM to PLATFORMS to make it more clear it is a list of platforms Maybe this was missed, please replace the loop with hass.config entries.async setup platforms(entry, PLATFORMS) (it does exactly what is in your loop) ah, sorry, I misread your suggestion! Better to name it PLATFORMS , No need to mark all the consts with Final maybe we shouldn't even put the user agent in the config entry, and hard-code it here: L95 CONF USER AGENT is hardcoded to the DEFAULT USER AGENT I suggest we remove it from the user input and just use the default in places where needed. same as original translation. same as original translation. same as original translation. The defaults should already be in the entry data (added by the config flow). There is no need to resolve them here? Why make this an async method if you are passing it as an executor job anyways? Just keep it a sync method in that case. Same as above These defaults should be the result of the config validation schema, and should not be needed here. We should not offer this selection (especially not in the configuration flow). Instead, add them all and let the user decide. frenck Adding them all used to give a performance impact on the bridge (although I haven't tested this recently), so it's best to only subscribe for the sensors you need. But maybe we should select a set of "minimal defaults"? Adding them all used to give a performance impact on the bridge (although I haven't tested this recently), so it's best to only subscribe for the sensors you need. In that case, it still should not be done this way. Instead, we can disable the less common sensors by default in the entity registry. Considering the defaults done in the validation, I think the data needs to be pre-processed here. Turning on off entities sensors is a Home Assistant default feature, we do not need a new construct option flow for this.

Move the key (OBIS value) of this dictionary to the key field of the entity description (that is the purpose of the key field of the entity description). Why did you revert the use of entity descriptions? That is actually the preferred method to use. I thought it's better to create the entity descriptions only for the sensors that are actually supported by the respective smart meter (see [line 268]( diff-5e4e812555e1b089aa137084f7dac49e1f457f0a8addc1eb46299b01b2c40220R268)). If you think this is premature optimization, I will change it "back" to That is not how SensorEntitiesDescription are meant to be used. Instead, replace your current mapping with a tuple of SensorEntityDescriptions Your previous version was going in the right direction, you only needed to move the mapping key into the key field of the entity description. I can replace the mapping with a tuple, no problem. But, then I would need to search within this tuple for the matching SensorEntityDescriptions instead of taking it directly from the mapping as currently done [here]( L263). Just for my clarification, as far as I understand EDL21 meters and this code ( mtdcr Please correct me if I'm wrong): - EDL21 meters support a set of metrics each identified by an OBIS code (e.g. "1-0:96.1.0 255") - You can not know which metrics are supported by your EDL21 meter until your receive the first SML telegram. Each SML telegram is basically a list of key-value pairs: OBIS code and the respective metric value. (The smart meter I have only supports 7 of the 27 metrics listed in the code.) - So the code receives the first SML telegram and for each OBIS code found in the telegram it looks up the matching SensorEntitiesDescription in the mentioned mapping and creates a SensorEntity using this SensorEntitiesDescription. - For each further SML telegram the code "just" updates the states of the respective SensorEntities via async write ha state . So imho the dictonary is the better approach here (unless of cause we just want to create SensorEntities for all possible OBIS codes, even when they are not supported by the smart meter). If this behaviour contradicts architectural patterns best practices in HomeAssistant, I am happy to refactor it. PS: Sorry for the long text :) We generally handle that as follows: Thanks for the hint (and for taking the time). I changed the code accordingly. When an entity sets a device class, it should not set an icon. However, the EDL21Entity sets an fixed entity. Instead, remove the icon property method from EDL21Entity and set an icon on the EntityDescriptions that do not have a device class. I'm missing an explicit native unit of measurement set for the entity descriptions with a device class. We only allow specific units when using our device classes. We have constants for these units in const.py that should be used. available-device-classes
Is there a real possibility that the unique id is not set? If no, the type hint should be fixed and this should be de-indented. Yes, if discovery failed the unique id would be missing Worth adding an explicit note about that just in case? IMO, this should be parametrized as it's pretty much the same code path for both old new protocols. 9b613f5bd5a88b256c034150797f09203a7bba0e done We will be able to get rid of the positional args once is published. But I don't want to hold up the next PR on top of this that will actually fix the RGBW RGBWW Color temp lights so I'll do another turn of this after we bump the upstream lib.
We already merged this bump, right? We should rebase here on latest dev. : 1: good point, thanks!
Template variables can be any type. I don't see how it is possible to re-instantiate those classes? Right, it's not possible. It doesn't really matter though, a restored trace will only be used by the frontend so as long as we can serialize it again with the same output we're good. The from dict should make this clear though, in comments or docstring. Another way would be to, when restoring a trace, simply store the serialized data instead of pretending to deserialize. I like the latter idea better. Let's just not mess with it. Fixed in c0f06fb Why are we still calling this method and converting it to a class? Can't we just keep it as a dict and when the frontend calls for traces, we include this dict? callback? This is called directly from automation.trace.restore traces script.trace.restore traces Renamed to async restore traces in 8760b1a Isn't it weird that automations still need to call this function if it was loaded in the setup? I suggest we postpone loading them until the traces are fetched for a domain. That way one could even check if we still need to load them, because the max stored trace count has already been reached in the current run. Do less and be lazy That's great! Will refactor accordingly. Why is this a standalone function? changed to a private function What exception can happen? There is no data verification happening. Oh I guess RestoredTrace(json trace) could raise. In that case, let's only wrap that case in the try except. Sounds good, fixed Why not make it part of the constructor super call ? Ah I see now that we can drop it now from script, nice. You can you can define this outside of the constructor and drop this constructor too. Shouldn't you call as dict ? can't we just break, given that all following also won't fit?
I think this is not something we should not solve this way. I do see the use case, but it has problems in my opinion. - So this is basically only useful when using a sensor with a datetime device class or when using an input datetime. - While the trigger supports multiple times to trigger on ( at ) can be a list, offset just applies to all regardless. (Meaning if you add normal manual written timestamps, you have to account for the offset) - The current items of at supports templating and can do this already With the latter two in mind, and the limited use to only referenced entities, I would not opt to add this. Thank you for your feedback. I have to agree with your comments, but I don't think the templating part suffices? at only accepts a time (string) and not a datetime (string). So you can't really calculate based on for example the next alarm sensor, because the alarm might not be set for today but for a later day. So you can't just format the next alarm with HH:MM:SS. But I do believe this would be a workable solution if at also accepts a datetime.datetime (and optionally a datetime string), so this is possible: Do you agree with this and would you accept such a change? The current items of at supports templating and can do this already Are you sure of this? I'm getting an error, even when using a static string as template: leads to: Invalid config for [automation]: Expected HH:MM, HH:MM:SS or Entity ID with domain 'input datetime' or 'sensor' data['at'][0]. Got None. (See workspaces core config configuration.yaml, line 24). Although I guess one could still create a template sensor of the timestamp device class and use a template like in my previous comment. But that might lead to some bloat of having to create (possibly multiple) additional sensors. Another solution might be going for a solution where at could be an object specifying the entity id and offset , something like: which could also be combined with a list: which also makes it clear the offset is only bound to that entry entity. I like this :) I'm getting an error, even when using a static string as template: Hmm that might be my brain that failed on me Thank you for your feedback once more :) I've updated the PR so the syntax is as proposed accepted. Although one thing I'm wondering about is the fact that this accepts offset of an input datetime with just has time while the offset isn't applied . So that might require a notice warning error being logged? IMO it doesn't make sense, especially when it would wrap around, so for example a time of 00:10:00 and applying an offset of -00:30:00 should that result in the automation being triggered at 23:40:00 ? Personally I think that's just confusing as well
These properties are overwritten in SureBattery, so only used by Felaqua. Not sure it makes sense to have a superclass here? Maybe not only for that, yes, but the Feeder FeederBowls PRs will follow directly after this one okay, will fix that tomorrow I see that most of the surepy devices have an icon? So maybe we can move this to SurePetcareEntity ? An icon or even picture in the best case, see here for full spectrum ![image]( so yes, will move it I will fix that in another PR as this involves more than just 1-2 lines... If you want, I can remove the entity picture also for the felaqua for now? Would be great if you also could add a test for the new sensor, Felaqua(SurePetcareSensor). This is not testing any of the new code? didn't know tests are a requirement now, but good to know Not required. I expected tests when you marked Tests have been added to verify that the new code works. :) ah sorry :D
Since we set the default options property with the default voice, the options dict here will always contain the default voice at minimum. So we don't need to use dict.get . We can use dict[key] . Adjusted it in 58277
Usually we use an f-string instead of .format() , but I think in this case it might make it less readable.
Interesting. I was thinking we would just store "stat X, upwards" in the original stat field. Now we can't use net values for Solar or battery without updating their formats too we can use net meters for solar or battery, but we can't use only increase or only decrease for solar or battery
We use None for unknown state L462 I did not know that, thank you. In a future PR you could switch this to contextlib.suppress Good tip, I'd forgotten about contextlib.suppress , and can use it in a few other places too.
This belongs in the network integration
Shouldn't we keep this within the domain of this integration? hass.data[DOMAIN][SERVICES] Do we really need to check again registering this double? Like would it matter? This is done like in the deConz integration. Both are quite similar in regards to supporting multiple instances and having services. Right now the integrations reside directly under hass data unifi. I would need to add another layer for every place retrieving an instance of the integration if we want to move services to hass data unifi services. If there is no control the first integration to be removed would remove the services as well? Maybe I don't understand your second question? The unload of services is not done by UNIFI SERVICES , it uses: The point is, that UNIFI SERVICES and its deduplication isn't needed? Aah ok, I should verify UNIFI DOMAIN being empty during async setup entry and remove anything with UNIFI SERVICES instead right? That would have the same effect. Additionally, I don't think (not 100 sure, MartinHjelmare can probably confirm), registering a service twice isn't a problem doesn't have side effects. So I think we don't need the logic that prevents them from registering twice. It will send out multiple events L1351 and that's about it, I'm just trying to keep stuff tidy :) Hmmm right :) I guess we send out a duplicate event quite a bit in general (in case of multiple config entries). I wonder if that is something we should solve on a different level Anyways, it's fine I think the UNIFI SERVICES can be refactored out while still achieving the same and some docs and it should be good to go. Can we merge this as is and I will do a follow up PR to clean this up tonight? Would be nice to not miss the beta Added documentation PR I think that is a good deal If we want to avoid doing the work of registering the service again we can check if the service is registered already with hass.services.has service . Resolved in 56834 This doesn't need to be a coroutine function since we don't await inside. Thanks Martin fixed in 56834 As above. Thanks Martin fixed in 56834
Battery level should be a separate sensor entity.
We won't be called if there's no vicare in the user config? I saw this in many other integrations and assumed it's important. Why is the same check in other integrations? Sorry, my mistake. This guard is needed until the migration is removed, then we can remove async setup . Add a log here telling the user to remove the config, something like this: Then in a quarter the import can be removed alltogether. Why do we tweak the config schema when moving to a config flow? Well this change is not really needed since we will delete this at a later point when yaml is officially removed from this integration. But I still need the CONFIG SCHEMA in init .py or are you saying I could get rid of the complete section now? The CONFIG SCHEMA is needed until the migration step is removed, I just mean there's no value added by modifying it since it's deprecated. Why do we need to copy data from the config entry data to hass.data ? Maybe add a note in the comment this should be removed when the import is removed No need to have this in hass.data , get it from the config entry instead In async setup entry it's set to the username instead. We should remove all keys from the imported data which are not supported by the config flow. Please rename async add devices to async add entities . all entities We don't allow setting a scan interval. All integrations that support config entries allow the user to disable automatic polling and the user can then automate the polling as needed with the service homeassistant.update entity . Please just set a sane default. Please only wrap the line that can raise in the try... except block. Use and else: block if needed. We normally don't log this. Showing the error is enough. Why are we setting a unique id here if we only allow a single entry? It's not a real unique id anyway. I'd remove this. We can pop with a default if we don't care about the result. Then we don't need to check before popping. We should validate the imported data before creating the entry. Usually we pass the data on to the user step. We don't need to set up persistent notification anymore. Please remove that in all the tests. We normally deprecate the domain key in the config schema with cv.deprecated to warn users that the configuration YAML is deprecated. Do we need to ask for name if the entities have a unique id and can be renamed easily via the GUI?
Looks like this could be a loop
Invert the map programmatically instead, something like: Good idea! I think we can drop this, just the type is enough? Fair. I'll remove it. Make KEY UP , KEY DOWN , KEY HOLD constants: I can do this, but I think it might be overkill if we want KEY VALUE to be the source of truth for the values and IDs. Unless you think I should take the string values out of KEY VALUE and have it use the constants as well. I still feel like that would be messy. Also, backticks should no longer be used with python3. It doesn't really matter, but we should at least not use dict.get() here. The backticks were not intentional, sorry about that. I'll change it to using the string constant "key hold" as "key up" and "key down" are already used as constants elsewhere in the code. Same comment as above Do we ever expect to get an unknown event.value here, and if we do should we fall back to some default? This should never happen. One of the conditions in the loop checks that event.value is in the allowed types. ex: if event.value in self.key values: Then we should not use dict.get(), use [] instead. Ok, updated.
This is format for current summ delivered? Then "demand formatting" -- "summa formatting" ? One digit to the right of the decimal point is probably adequate for metering of aggregate consumption in a house, but is perhaps a bit too coarse a default for plugs metering the energy consumption of individual devices? Could 2 decimal places be a reasonable default? No. Demand formatting depends on demand formatting attribute value and summa formatting depends on summa formatting value. Those could be different, could be same No. Demand formatting depends on demand formatting attribute value and summa formatting depends on summa formatting value. Those could be different, could be same Adminiuga, sorry for not including more lines of context. But you seem to reference "demand formatting" for both demand formatting and for summa formatting, no? Agree those could be different, but the PR currently appears to use "demand formatting" for both? Both are calculated using the same algorithm, but stored in different attributes for later. Check the metering channel source, diff could be hard to see the whole picture. Although, because currently the value is translated into W instead of KW, the formatting may be moot for some devices. I checked the source, and from what I can see the input to get formatting method (for determining the summa format) is currently retrieved from the demand formatting attribute (0x0304); not from the summa formatting attribute (0x0303). Am I looking in the wrong place? Doh, you are right. Copy'n'paste. This was supposed to be summa formatting. Thank you for catching this. IMO should let HA to do KW to W conversion, instead of doing it in the channel Seems correct to me based on the [specification ]( p229. Leak probably only meaningful for gas meters unless somehow they measure earth leakage (RCD). I don't see how unique id suffix would be anything other than None here. So I presume that gets assigned in superclass. But in the ZhaEntity class you seem to do almost the same thing again. It's assigned in subclasses when inherenting he entity class. See sensor.SmartEnergySummation class Possibly you need device class: str None DEVICE CLASS ENERGY maybe also unit ENERGY KILO WATT HOUR here. When I connect to my device, the new metering sensor appears (great!), but it is displayed in W (should be Wh or kWh). It is summation value. It cannot be KWh, can it?. And unit of measurement is W is set by zigbee channel. ZCL Specs are confusing at times. Summation is: ![image]( and unit of measurement attribute both indicates kWh and kW ![image]( I guess my questions then are: 1. is summation supposed to be kW h or just kW? 2. In case this is a non electric meter (water, gas etc) is it still DEVICE CLASS ENERGY ? Summation is surely kWh rather than kW. Summing a series of kW readings together from one sensor would have no meaning. There has to be a time factor in the unit for it to represent energy. So the new value reported as 5000000W on my device

You should use PLATFORMS in place of binary sensor Please import DEVICE CLASS SAFETY from homeassistant.components.binary sensor Why is this hard coded as 100? Can it ever change in the future? Should it be a constant? This class is never used. Perhaps you should call it during exception handling near line 70? It is not compulsory, but since new integrations can take a while to get merged, I suggest that you take the opportunity to move to 100 coverage whilst the reviews are in progress. This is not a valid unique id. example-acceptable-sources-for-a-unique-id Please remove as written below. This is not a valid unique id. example-acceptable-sources-for-a-unique-id You probably don't need a unique id as it makes no sense to have this set up multiple times. You can use something like this instead: As written above I'd do this in the integration. I don't get it. What would you do? Translations are handled automatically once done. Please only include the english version. Where is the strings.json ? stringsjson Move this response to a fixture? Nice to have: It would be great if you can allow passing in a session in the library. Use async get clientsession to obtain a client session from HA. I don't think a binary sensor should have that many extra state attributes. Those might be better off as extra sensors later on? The attributes contain general information about the warning, such as the heading and the warning ID. I think to move this information to other entities would be confusing. Maybe find a better name? SafetySensor or something alike. This should have a maximum, setting it to (example) 125.000 will create 125.000 entities for all selected regions and will break HA. Please remove the pylint ignores and fix the typing issue for async add entites . It should be of type AddEntitiesCallback . Fix the pylint issues instead of ignoring them Please setup the data coordinator here and save this in the dict instead. Only save to hass.data after the general setup is successfully completed. reraise as UpdateFailed It would be better to move this into it's own fixture file and use the load fixture helper instead. There are various examples in the existing code that do that. you should abort here, right? If the API does not return anything it does not make sense to show the form at all. Remove has error completely Maybe implement a custom DataUpdateCoordinator and take care of the data mapping there? Because calling self.parse update() before every operation isn't really nice.
Why don't we look up the correct key in the dict instead of iterating all the items of the dict?
Should convert it to config flow setup with Then async step import will be called Done Done You should also deprecate the PLATFORM SCHEMA, like this L44 I removed the schema entirely Keep this. but you could mark it as deprecated. L44 Done Keep this as: This will migrate the yaml config to a config flow. Done It will default to the name from manifest.json Done Should not have more code than necessary inside the try except block Done Done Sorry, it seems that cv. deprecated is not working for PLATFORM SCHEMA. discussion r719954461 Removed You will need to change this line to use the new solax library version: solax 0.2.9 After that (and the CODEOWNERS change) the diff should be identical. I'll close my duplicate PR Done This seems incorrect? This is trying to import integration level YAML configuration, but it seems like this integration previously used platform level YAML configuration? This PR is my first interaction with HA architecture and if I recall correctly I followed the same approach from some other integration. But it's my understanding that this code is importing the YAML integration from the existing installations. In any case, should I change anything? But it's my understanding that this code is importing the YAML integration from the existing installations. Sure but this imports a type of YAML configuration, that this integration hasn't used previously? So I should use async platform setup instead? PS: Why store entry data here? I also based this code from another integration. Should I change this to something else? See suggestion? I understood your suggestion as an optimization to the current code but your PS seems to be asking why I'm storing the data like this. Is there an alternative way besides hass.data?
Exclude devices that are already setup and abort if no supported devices are discovered Example L166 Thank you! Added code to compare the list with already configured devices and exclude them. Config flow also aborts if no devices match the condition. These can't be missing L371 Make this the first in the dict ahead of CONF NAME so they select the device, and than name it. Done. If you make this a dict and keep the MAC address as the key, you can show the modelName and the MAC address as the value (probably construct with a. F-string). It might make it a bit easier for the user to figure out which device is which if they have multiple. img width "382" alt "Screen Shot 2021-09-27 at 2 38 59 PM" src "" I went ahead and took care of this as it would be nice to have the device selection in beta.
Kind of nit-picky, but... These conditionals read oddly to me. At a glance, I would think they are list-based comparisons instead of string comparisons. Changing from in to would help readability. There are other places where this could be applied, too. I applied your suggestion along with conflicts with current dev version... Thank you :)
Why do we not use the oauth2 code flow instead of the client credentials flow? Is that only for business accounts? Yes, that is only for business accounts. Here is the consumer API: The key is not very user friendly, consider setting name on entity description and using it here. ( attr name wins over EntityDescription) We should inject URL via a placeholder and not have it be part of the translation text. Why not use name attribute? Because I want to include the device name too self. attr name f"{airthings device.name} {entity description.sensor name}" self. attr name has priority so there's no conflict. L264-L271 Ahh, will fix Currently we only allow mikrogram cubic meter. This may change if we see more integrations requiring a different unit but for now we can't use this device class unless we use the unit in the docs. available-device-classes Most other functions are typed.
Should it be elif here? Yes, fixed. Fixed Perhaps you could use self. attr preset modes in init I think fan platform doesn't support attribute shorthand for property implementation. Ok I would not split up here all varieties, better to map the min max en step attributes to a class to keep this scalable. I think now is much better. What do you think? Looks much better indeed. Nice work
maybe add a variable for "disabled"? I though about it, but in the end avoided as you cannot use variable in the services.yaml anyway. makes sense. maybe add a variable for "stale"? see above comment add type hinting Completely reworked the code Completely reworked the code, please recheck new implementation internet access switches may end with 2 or 3 if they have duplicate names or if you prefer find: This removes all empty device, doesn't it? So also empty devices from other integrations? Not sure if that is necessaryly a bad thing but... how about something like: Optimized device removal (device search based on config entry) do we assert in HA? (not sure but the assert could give a non descriptive error) I think we can just check if async entries for device is truthy Cleaned Are these all registered by mac address? Might be cleaner to find them with something like: L87 You could eliminate this loop by pre-building a set of known macs Loop removed This looks it should be passing the entity it removed? entity removed is a bool to know if there is a entity to remove or not Renamed to entity to remove This is getting rather complex. In the future, it would be good to break it up into multiple functions Nothing is being awaited here so this doesn't need to be a coroutine
Set attr unique id in the constructor instead, same for other constant properties Tried to set constant properties in the constructor How is this helpful to the user? Is it better to just mark the switch as unavailable? removed, was copied from an switchbot integration, does not make sense or does deliver valuable information This is really quite difficult to read, and the explanatory comment for SENSOR SETTINGS DATA doesn't seem to match SWITCH SETTINGS DATA and SELECT SETTINGS DATA . Make these named tuples, dataclasses or maybe typed dicts to make them readable, that will also get rid of the tuple unpacking and large number of arguments to the entity constructors. Tried to solve that. Nice! What's the point of this class? PlenticoreSelectUpdateCoordinator was needed to pass the options for the select forward. This is not possible with PlenticoreUpdateCoordinator. Why does this need to be overridden? Sorry, I do not get your point. What exactly do you mean? I mean that the implementation of async read data in SelectDataUpdateCoordinator is (now was) almost exactly the same as in SettingDataUpdateCoordinator . Can you try to make them share one implementation instead, maybe add the read write in a mixin class? added a Mixin class Why does this need to be overridden? Sorry, I do not get your point. What exactly do you mean? I mean that the implementation of async write data in SelectDataUpdateCoordinator is almost exactly the same as in SettingDataUpdateCoordinator . Can you try to make them share one implementation instead, maybe add the read write in a mixin class? added a Mixin class This doesn't seem to be called from anywhere? Checked it, removed. stale Copied from senor.py to keep things consistent. Why was it ok, when maintainer submitted the code for senor.py? It was OK then because it was about sensors, now it's selects or switches. Sorry for not being more clear in the comment. I still do not get the point. Looked at knx switch.py how they did it and rebuild it. If this is still "stale" I'm out of ideas ... if not, I will adopt switch.py in the same way. KNX just forgot to update their docstring, a PR fixing that would be welcome. Anyhow, you fixed it in ca61960 stale Copied from senor.py to keep things consistent. Why was it ok, when maintainer submitted the code for senor.py? fixed in ca61960 It's nice to sort these . As above. We prefer defining named tuples in the modern way as we do below for SelectData including type annotations.
Typo? more like moving too quickly through copy and pastes Do we have other parameters that aren't snake case? Maybe make a code comment why we have that here if we keep it? didn't think about that, maybe we should just use snake case and convert in the command Is this still correct? this particular event is still correct, but reviewing this allowed me to find two places where we included this parameter incorrectly in the tests Looks like lowSecurity is missing in the forwarded node details on "node added" event. The frontend needs this info to be able to tell the user if a device was added non securely after inclusion. It's this part in the docs: getting-started security-s2?id confirming-the-inclusion-process
Does this needs to be defined as constant? No, I don't think so. It's only used once here, and all other metric names are defined inline.
Note that only in rare cases you can have multiple platforms in your initial PR, you can add other platforms features in a later PR. - 5-make-your-pull-request-as-small-as-possible I understand this guideline to keep the PR code size as small as possible to ease the review process, but in this case, adding only 1 platform instead of 2 would not make much of a difference in code size. It is not compulsory, but since new integrations can take a while to get merged, I suggest that you take the opportunity to move to 100 coverage whilst the reviews are in progress.
Use square brackets if you know the key exists. same. Only wrap things that can raise in a try block. Move this below. Also if site is not found, why trigger ConfigEntryNotReady ? that will let HA try again in 30 seconds and the site won't just appear ? user will not be able to recover, so don't say it's not temporarily ready. In a future PR you can do a re-auth step. This way you can only ever support 1 config entry. Preferred: However, I don't understand why you're storing the entry, as all platforms have access to that? How would it be possible to get to this step without coming from user step which populates this ? Also, don't recreate the user step, just return the user step then. We always have a site here right? Else we can't wrap up user step ? map code is hard to read. Prefer this: Why allow setting a name ? Can't we just get the name of the site ? import from const. Have this class extend DataUpdateCoordinator. Instantiate this coordinator in your init .py file and use coordiantor.async config entry first refresh() to automatically trigger ConfigEntryNotReady etc. More readable: However, is it really necessary to fetch the sites and verify it exists on each update? how often do they change ? What's difference between this package and ? amberelectric.py got renamed amberelectric . The latter is the official version. Use string formatting using f-strings. why slugify ? string formatting. Why would you provide two sensors, one compatible ,one not ? Add a state class measurement to store it in statistics. native value of a sensor is not a boolean. You are thinking of a binary sensor. Initial PR should only have 1 platform, so remove this one completely and open a 2nd PR later that adds this as a binary sensor Please replace all filters from your code with list comprehensions. No need to test len(my list) 0 , use if my list: instead. We should never even get here if no site was found. This kind of checks, where you know that you won't do anything the rest of your function, turn them around. async setup entry in init .py should only forward if the site was here, this can't happen. Why are we creating this again? Initialize the update coordinator in init .py and only forward to platforms if update was ok.
When is this called? And why not add it to entry.async on unload ? Fixed Why we're having 2 event types? Why can't we just put it all in the same event ? I have pushed a commit which uses single event. Beside that btn up and btn down less fit for an event named shelly.click it is not that bad. Events are not overlapping so they can still share the same base shelly.click event. Offline discussion: Everyone is ok to go with single shelly.click event Let's include the device type (rpc block) or generation (1 2). That way people will be able to use blueprints that handle both. Added ATTR GENERATION: Final "generation" with values of 1 or 2 to the shelly.click event
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: Hello. Thank you for the feedback. I'm fairly new to HA development, but I will take the time to refactor this integration to a UI flow. Thanks tokenize47 If you need help or questions, feel free to reach out to us on the Home Assistant Discord chat server.
Use EntityDescription Examples: Thank you for all the examples, it helped a lot! Done. Since this happens quite a few places in the integration, it would be good to make a helper to format it instead of repeating the .replace everywhere IDX is equal to self. mac.replace(':', '') I just replaced this with IDX properties Usually we disable these type of sensors (anything that is a radio signal strength) by default and let the user enable the entity if they need it since they tend to generate a large number of state changes as they fluctuate quite a bit and are only useful when debugging a connection issue advanced-properties entity registry enabled default Done. This is intended to be human readable
Use EntityDescription Examples: Done. Reverse the condition and return early and outdent the block below Done. Should this be entry.entry id? Changed to list comprehension as per sensor entity. You should be able to drop any of the keys with a value of none Tested this and it works fine without the none keys. Dropped none keys as suggested.
Then you can drop the above It would be more efficient to filter PLATFORMS when calling hass.config entries.async setup platforms(entry, PLATFORMS) Added if statements to remove platform from list before calling: hass.config entries.async setup platforms(entry, PLATFORMS) Combine the check and outdent below Also I missed the one in switch.py (its should be extra state attributes ) as well. Since {"last run success": self. last run success, "mac address": self. mac} are both shared between this entity and sensor.py , make a base class 'SwitchBotEntity and do something like return { super().extra state attributes, "switch mode": self.coordinator.data[self. idx]["data"]["switchMode"]} in switch.py Examples L36 L25 L25 Thank you for the examples. I have added an entity.py file and removed the duplicate code. same with the others Done. You'll need something similar in async unload entry Done. Also added in async unload entry . Done. You can drop the ,None as that's the default You can drop this function since it's the same as the base class. Max debug here Max debug Debug
Usually we only patch where the library is imported, in this case homeassistant.components.surepetcare.config flow.surepy.client.SureAPIClient.get token I'm not sure thats going to work in this case though. We don't want it to spam the log every time it retries. ConfigEntryNotReady will log once and downgrade to debug. Should it check if the account logged in with during re-auth matches the account that re-auth was requested for?
Is this const correct? Yes. There are only a couple of major endpoints (lights sensor) which all different device types are exposed from. In this case siren is exposed as a lights resource
Consider moving this to its own function Consider renaming lock states to something which indicates that it contains callables. With the current name I expect it to contain scalar values (states). Consider allowing this exception to propagate to the caller instead of swallowing it. With this handler, it's impossible to tell what the error was, and the caller will assume that the operation succeeded. Same as above Shouldn't this test include calling the lock.lock and lock.unlock services on the entity to confirm that it works? You did add some tests already, maybe complete them instead of ignoring the new module? You could save some indent by reversing the condition and continue You might be able to avoid the cast with something like this Ahh, nice These loops can be replaced by a single list comprehension. It's generally common practice to make the call to super() first, before anything else; is there a reason this can't happen here? The super class calls update attr, so lock state must be initisiated first
I think keystroke is always available in entry.data so Same with account and student id . We don't want to use global variables. Use self. attr device info on init () instead of this property. Use self. attr unique id f"vulcan calendar {self.student info['id']}" on init () instead of this property. Use self. attr name on init () instead of this property. Once you use f"{ student.pupil.first name} { student.pupil.last name}" , and once you use students list[student id] as title . I think it should be standardized. I'm not sure about changing this line - {student.pupil.first name} {student.pupil.last name} is already used in creating student list and there is probably no reason to do it again. Do we need this check? I think ConfigEntryAuthFailed should be raised here. Example: L60 I think you should use load fixture here. Don't log the error here. Just pass the message as a argument when raising ConfigEntryAuthFailed . Otherwise we'll spam the log. As above. We don't need this. Log spam is handled when raising ConfigEntryNotReady with a message. Why do we need this check? The entry is setup and unloaded once per lifecycle. Use entry.async on unload to unsubscribe the listener on config entry unload. Please use hass.config entries.async setup platforms instead. Please use hass.config entries.async unload platforms instead. Remove this. We don't allow this option. This should probably influence the available entity property. Why would there be a RuntimeError? The library should raise library specific exceptions. Don't disable this. Please fix the issue instead and define all attributes properly in init method. This is a dictionary not a list. Please rename the variable. Normally we don't need to include the type in the variable name. We don't need a local variable if we only use it once. Looks like we can invert this condition and return early to the auth step if true. Then we can outdent below. As above. We can invert and go to the async step select saved credentials if true. We don't allow an option for scan interval. Every integration supporting config entries supports disabling automatic polling and then the user can automate polling manually with the entity service homeassistant.update entity. service-homeassistantupdate entity Please remove this option. Can we break if we find a match on student id or do we need to look for more matching students?
L126-L127 hass.data[DOMAIN] is not used and async setup is no longer required. Use the constants from homeassistant const.py instead of adding integration constants for ATTR . Switched to constants from homeassistant const.py Can async step import be called without data ? What happens if some bulbs are not available when the config flow is added or imported, will the bulbs be picked up by the FluxLedList class? Instead of duplicating code from the FluxLedList class here, can we use the FluxLedList class here instead of using BulbScanner directly? Or move this to a helper function which can be used both by the config flow and by FluxLedList ? We don't need to store the options in two places, we can instead pass options when creating the config entry in async step user , see Why do we add these in this PR? This PR was part of a larger PR that has been cut up. I tried to cut it down to be just config-related and get it back to the original code as much as possible. Getting it all the way back to the original and just adding the config-related code will take a lot of work. If that's what's needed I can do that but, keep in mind that the current integration in production barely functions. This code keeps it function until it can be completely be updated. Let's keep this PR to just the config flow. It will go much faster if there is less to review. Additional fixes should come in a followup. I think we need to use the on unload helper to make sure the subscription is cancelled if the config entry is un- or reloaded, for example after the user changes options. If not, async new lights will be called multiple times and meaning we will have multiple entities for the same light. A test to verify this is currently broken (you get multiple copies of a light) but is fixed by unsubscribing would be good. What happens if we end up here? Also, we don't want to raise when handling SIGNAL ADD DEVICE ? Ideally we create a separate config entry for each host. This avoids the need to build retry logic to reconnect to a device if it's offline during startup as we can raise ConfigEntryNotReady and auto retry later. Assuming discovery reports a unique id (it appears to report an id based on the pypi package), You can run the scanner in async setup and start a discovery flow when new devices are discovered. Discovery flows for existing devices can update the IP address stored in config entries if there is already config entry for a discovered id. My concern is that the only way to fire the scanner currently is through broadcasting. It doesn't target specific IP's yet (future update). I'll double-check on if it reports the MAC Model directly as those would be ideal to use as the IDs. If you send the packet directly to the ip, does it respond? Looks like they do respond img width "963" alt "Screen Shot 2021-09-28 at 8 50 38 PM" src "" Please check unique-id-requirements I noticed this and I was trying to work through it. It's going to require changes to the Flux LED API to
Looks like this is unrelated Yep, not sure where that came from but can be deleted
I think that this is not a good idea, long series names will now be indistinguishable because the first 100 chars are all the same. I'd argue this is an issue that's better solved in the UI, and or by splitting media descriptions into discrete metadata fields. Updated this so the show name is omitted when browsing into the specific show. However, the show name will be printed in directories with mixed shows media, such as on-deck episodes or recently added items. Also moved the release year of a TV show from the episode to its season, which should conserve a bit more space.
In general, we want to reduce the number of attributes in Home Assistant. In general, these can be separate sensors instead; making it easier to use them in Lovelace dashboards and automations. Thanks frenck! Sorry for the delay, life's very bust lately. I'd be happy to re-organize this. I'm familiar with the concept of related entities within devices. The moon is not a "device". Is there a general concept for relating entities to each other?
How about making these a constant. This code is a bit hard to follow since it is using libtype as a loop variable and expecting it to be set that way. It would be easier to follow if we had another variable for the loop variable and set libtype for the success case Agreed. Updated with a more explicit method. Edit: Had to force push to fix a conflict, change is in
This file should be moved to a Python library hosted on pypi. First bullet point: Or use the already existing library: You should only include one platform in the initial pr 5-make-your-pull-request-as-small-as-possible But the hardware has so many states and settings to offer. I don't want to delete already implemented functionality. Is this really needed? I do not think it is required, but really recommended Pull requests containing large code dumps will not be a priority for review and may be closed I would recommend excluding some of the code from this pull request and then you can open a new pull request when this is merged.
I think you'll want to add this also under the status changed function as well so when the state changes the icon updates as well. A general question (maybe for raman325?) , is there a reason entity attributes are preferred over property functions when the attribute is dynamic? Is it because it's assumed the node state changing is a "rare" event? As an entity attribute, you need to take care to update the attribute when the node status changes. With a property function there's no reason to, it always accesses the current value. With the former you do need to do as firstof9 has suggested and update the attribute when the status changes. Besides that, I would use NodeStatus as the key instead of strings (with typing). This avoids a conversion from the enum to a string and the mutation ( lower() ). I think the goal is to not have to re-invent the wheel since the Entity class already has the property and is looking for self. attr icon ill await Ramans view on the suggestions you both raised, for which I say thanks! Maybe, but I ask because the [documentation]( property-implementation) does not explain why you would choose one technique over the other and says both are valid. The examples both show when the attribute is static, in this case it's dynamic. It would seem less error prone to me (as evidenced by this PR) to use a property function for dynamic values, but there must be good reasons not to. I don't think one or the other is wrong, it's a matter of clarity and simplicity. Generally speaking using the entity attributes is good when the value it has is static or there's a single place where it gets updated, like self. attr native value in the example above. I would probably just use the property function myself and get rid of self. attr icon references since that approach puts it in two places versus the one icon (and many other attributes) are only updated in 1 place (usually in init or update methods), so 1 line vs 4 saves code. In this case, a property would be the best approach Besides that, I would use NodeStatus as the key instead of strings (with typing). This avoids a conversion from the enum to a string and the mutation (lower()). I agree with this thanks, Ill go ahead and revert what I did, and replace it with kpine's suggestion above. Not sure though how this will only pertain to the nodestatus sensor like this? edit: misplaced it, as I figured already....
Usually if one arg is typed, all of them should be typed Since the library already has named exceptions, we can avoid creating new ones and let the validate input function raise Since the library already has named exceptions, we can avoid creating new ones and let the validate input function raise Should this be normalized? sometimes-acceptable-sources-for-a-unique-id-for-cloud-services Probably use already configured account reference.
Done. Removed all references to UNDO UPDATE LISTENER. Done. Removed all references to UNDO UPDATE LISTENER. Done. Removed all references to UNDO UPDATE LISTENER. No need to create CannotConnect since the library already has an exception for this. You can use ConnectionError directly instead I removed the try block inside this method. It looks like my calling method catches the exception. stale docstring Done stale name Done stale name Done stale docstring Done stale docstring Done stale docstring Done Check this in the config flow before creating the entry. Don't create the entry if the input isn't valid I do validate user input in the config flow. I don't recall why I do it here in the async setup entry() method. I'm not sure if I added in response to some testing of mine... Do this in init 's async setup entry so you don't get to platform setup if there is a ConnectionError ws66i.open() creates a connection with the amplifier. I call this here and keep it open until the component is unloaded. However, I also call ws66i.open() in my init 's async setup entry as well to verify that a connection can be made, and then I close it. This needs to be done in init as ConfigEntryNotReady does not work in a platform Do the first run when the device is setup in the config entry so we don't have to do it here and then we don't have to keep track of this It looks like you are creating the object twice. Once here and once below. We should only create it once. validate input is purpose built for the config flow. If you want to reuse it, break it apart into multiple functions so it only does what you need here. Move this to init as well This can be set as self. attr device info DeviceInfo({....} This can be set as self. attr unique id
Change print to logger or delete deleted - thanks I haven't reviewed other implementations of the climate component but does it make sense? It seems confusing to me to have the PRESET HOME and None because I understand that they are the same use case. Completely different. Consider None like manual or hold. None is the only preset you can't set. Use config[value] instead of config.get since you are already validating that the key exists in config
To keep the complexity of the API away from HA, maybe move this into the PyPi package that is responsible for communication. Yes, it sound good. I will do it. Communication with external services has to be done with an (PyPi) package - 4-communication-with-devicesservices OK, I agree. I will move it to PyPi package. We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: This is the complex integration similar to modbus. I don't think that it is possible to configure it through GUI. frenck Where I can ask for an exception as is described in ADR-0010 document? I think that is possible, nevertheless, ADR-0007 still applies Yes, it makes sense. frenck Could you please help me? Do you know which integration use configuration YAML by ADR-0007? Thank you in advance. KNX might be a good example Thank you. I will modify my configuration according to KNX. Could you please reopen my PR and move it to draft state to keep our communication? I'd like to avoid a discussion from the start with someone else. Please open a new PR when ADR requirements are met and the communication logic is extracted to a PyPi package. OK, I will. Communication logic is already extracted to PyPi, only modification of configuration YAML remains. Did I miss something? Aah, that was squashed in a commit. Please don't squash commits! Do you prefer multiple commits in one PR? Every project has different rules and this is my first PR to HASS. Please don't squash commits, it makes it really hard for reviewers to follow the changes that are happening during the review process. This project squashes commits on merge of the PR (we that for you). Thank you for your help
No need to implement this if there's no extra attributes. This allows removing the supported features property getter from below. This could be moved to inside device info() to avoid creating the device info altogether. Done - thanks No need to include translated files here, they will be exported automatically from lokalize. Removed all but strings, en and es - thanks These could be define using attr class attributes to avoid boilerplate property getters. See L181 for list of available attributes. Thanks, this was a great tip! I cleaned up all I could, plus found a few more from the base entity. I think there's need to guard this, as these should not be accessed by homeassitant if the device is not available. Thanks. Removed the guards. Use attr should poll , see also the comment below on attr . Done, thanks very much for the whole review. I believe this is copied from the izone integration: I think the preferred way is to not use any yaml config at all, and just rely on the user interface, so I would remove all of this and just return True from this function. Hi Allen, thanks for taking the time to review this. You are right, the structure was based on the izone integration, and without a good grounding on Home Assistant or python, I've inherited the baggage you mention in your review comments. I will go through these and see what I can clean up based on your tips. Thanks once again, Regards Laz This one is done Recommended style seems to be to sort attr in alphabetical order Done I noticed that pescaea already has a similar same log message when a controller is discovered for what its worth. Done Have you considered not using DiscoveryService at all and directly implementing Listener here? It seems like the code can get simpler by inlining some of these calls and just implementing Listener in each place you want to listen to an event. For example, my impression is that Listener.controller discovered is invoked on the first time you add a Listener , this you don't need to both loop over the existing found controllers. This then becomes something like this: Sorry, I've struggled with this change and the ones below. (For the most part) I understand the structure I've used (which used iZone as the template) and seeing as it has been working well for me the past couple of months, I'd rather not make changes like these (that I'd struggle to debug). Wrap this or it will leak when the integration is unloaded. Also please rename config to entry or config entry as its a config entry My impression from reading the pescea library is that the Controller itself knows about the state change, then it has to notify the DiscoveryService which then invokes the DiscoveryService in home assistant, which then fires an event that notifies the ControllerDevice which compares back with the original Controller . You might find this gets simpler to avoid the global dispatch by having a listener on the Controller itself, rather than via the discovery services and notifica
I was looking into making this change as well, and does anyone know if using the "measurment" string value or the homeassistant.components.sensor.STATE CLASS MEASUREMENT constant from the [sensor module]( L100) is the preferred standard when updating integrations for statistics support? I noticed at least some integrations are using the constant value like [NUT]( L71) Good call. Thanks! While the descriptions I read earlier noted the string value. The existence of the constant, as well as the usage in a number of integrations leads me to the conclusion that that the constant is the right way to go.
I noticed the library creates a session for every request. You should the Home Assistant session instead. See note at: make-a-request This change is not a requirement for this PR, so you can change this in this or another PR. That's something I know it's wrong, but something in the way I was using aiohttp wasn't right and attempting to reuse a session resulted in errors. I decided to make it work a leave optimization for later. Silver quality scale requirement: Handles expiration of auth credentials. Refresh if possible or print correct error and fail setup. If based on a config entry, should trigger a new config entry flow to re-authorize. Can an account token be revoked? If so, a reauth flow must be added in another PR. I believe it can't. I can't be 100 sure, it's not like this API is publicly documented, but I haven't seen my session on the browser expiring. A reauth flow is not necessary in this case. The integration meets all the requirements for the silver quality scale :2nd place medal:. silver- F0 9F A5 88 :point up: Docstring :point up 2: Docstring Only the generated en.json translation file is allowed. Don't add other translations in a PR. Translations are handled by Lokalise, this will override the es.json file. Gotcha. The unique ID is case sensitive... email, however, is not. Just calling .lower() on the email when using it as a unique ID should be enough in this case. The en.json file should be generated by the translations script: :construction: Work in progress I forgot about this. I don't use this anymore, I couldn't find in the API any information about this. Have you seen the recently added mdi:ph icon? I did and it's what I tried first, it's not available in the version of the icons bundled with HA right now. I believe HA uses 5.X and it was added in 6.X. I've been told it will be updated eventually but might take time because it's a breaking release. The DataUpdateCoordinator name is used in the DataUpdateCoordinator logs. The pool name may be clearer to users than the pool id. DOMAIN is already in the logger and can optionally be omitted from the coordinator name. Yep, the id is a number and it won't be very helpful. Even if only a very tiny fraction of people will have more than one pool reallistically. Unplug the device and see what happens. You can add this in another PR. I'll check on the next PR. :point up: This description does not fit here, it is used if no data has to be entered. To me it seems a little bit odd when a method has the same name as a Python built-in function. Especially when it doesn't yield similar results. What method do you suggest? I know nothing about python, but knowing ruby ClassName.all felt quite natural to return all the instances of that given class. I think you should also except asyncio.TimeoutError and maybe aiohttp.ContentTypeError and if applicable json.decoder.JSONDecodeError but not totally sure about this. What happens if the token is invalid expired? farmio I do not know, I so far m
Thanks -- It seems I made those changes on commit [c65395fb]( Are you fine with those? Yes, you can mark both comments as Resolved (I don't have rights to do that).
Why removing the icon? It's a specific icon that matches perfect here. ludeeus in the previously PR stated When a device class is defined, icon should not be defined. Please check 54520 We allow for exceptions in some cases, there is no need to drop the icon. Also, this change is not related to this PR, so should be reverted. Lifetime energy already provides this state class, why add it here? As in, this is not needed to add to the dashboard. Additionally, this sensor is not solely increasing, it can go down because of the power consumption of the inverter (e.g., during the night). Therefore, this state class should not be used. Same comment as above. Same as above Should we rename this? As Power is obviously not correct considering the unit of measurement. Should this be renamed to energy? Should this be renamed to energy? Should this be renamed to energy? Should this be renamed to energy? We don't appear to set a unique id for these sensors so changing the name will also change the entity id which is a breaking change. That's true. What is the best practice? Revert the change or set a unique id or leave the breaking change? It's nice to avoid breaking changes when possible. It's also good to add a unique id if possible. unique-id-requirements Preferably we should wait at least one release with changing the default name after we've added unique id. Or I revert the change and set an unique id. Any advice how to set unique id? I've read that's acceptable source as Serial number or MAC address that aren't available in this case... Edit: json key vars should be good I guess... are defined in Solaredge API. What do you think about? json key vars should be good I guess... are defined in Solaredge API. What do you think about? JSON keyvars will not do. We need an unique identifier of the device (inverter) json key I guess. frenck I looked better and site id is a better choice. I chained it with Energy and json key. Please check my code... I hope no more change please :D I will test this in a minute, would be awesome to add the unique IDs. That would also allow us to add DeviceInfo pretty easy though. - Let's use f-strings. - Let's drop 'Energy', as there are no key collisions. - Let's move the unique id property to the SolarEdgeSensorEntity main class - Let's override the unique id property to SolarEdgeDetailsSensor (with only the site ID I would suggest) That way, all provided sensor entities have a unique ID and abstraction is correct. terminet85 If you need help with this, let me know! frenck Here we go :) So as it turns out, json key is not unique. 2021-10-27 14:47:37 ERROR (MainThread) [homeassistant.components.sensor] Platform solaredge does not generate unique IDs. ID redacted STORAGE already exists - ignoring sensor.solaredge storage power However, the entity description key is unique. I have tested this PR with the above-suggested change. I'll suggest a different approach. I don't like use key because isn't in solaredge API. Storage problem is
Remove it from the DEVICE CLASS. It is better for to handle this as a single cluster device. And I don't think we really need this one here for now. Can you remove it pls? After changing the registries, this should be a cluster specific match, not just endpoint
Config Schema and async setup is not needed when you provide a config flow. Didn't know that. Fixed in ae4fc6495345d204448e803ab6f0ba5076bf2f19 and ae4fc6495345d204448e803ab6f0ba5076bf2f19 You can also use entry.entry id as a unique ID. Missing return type annotation. Consider using f-strings instead of .format or use-new-style-string-formatting Ah missed that one. Fixed in fd9db6fdc0274a2d501165cb796c92e0263753c5 percent is an invalid unit for device class signal strength available-device-classes What do you think that is the best we can do? As the valid by the API is in percentage. Just remove device class ? I'd remove device class and configure a nice icon. Maybe it can even be converted Agreed, I've removed device class in 2ad596de7f9b5ff0b647f306b4af11631a388d71. Maybe in the future add a conversion to the correct unit. this should already have happened at L72 Thanks, fixed in b945a09e690a5c995742befbb4806d31da51a6ca This integration should be called homewizard as that's the brand name. Don't store this in context but just on this config flow instance No need to ask for the name. Entries can be renamed in the UI later. No need to ask for confirmation. If the entered IP address works, add it. We do not allow polling API update intervals lower than 5 seconds. Raise UpdateFailed directly and drop the try except Don't include static information in the returned data. Instead, let entities that need this data access it on the coordinator. You can add helper properties on the coordinator if it helps clean up the code. Disable this one by default. It spams. No return value on async setup entry for platforms. Why is update before add set to True? You're using an update coordinator and all data has been fetched during startup Not necessary, CoordinatorEntity already does this. This the default behavior Assign to self. attr name to have the name property pick it up. Custom name should be dropped, just use the config entry title. these are not used. already configured is used. ip is missing. This file will be automatically generated based on strings.json . During development you can use python3 -m script.translations.develop to re-generate this file.
If one time charge is not an operation mode reflected as current operation we should not use the set operation mode service to activate this feature. Use a custom entity service instead. entity-services I'm not sure. In the end one time charge should be reflected also in the state. Unfortunately there is no data point on the api which tells us if it is still active. Usually it's just a matter of minutes, so I guess the implementation here is not so far-off. The one-time-charge state will be shown as active until the next update of the entity. If the api doesn't return it as a current operation state we shouldn't do that either. We should just reflect the device state not invent our own. MartinHjelmare as oischinger rightfully point out the API from Viessmann is not supporting a rich enough API to actually show the state changes. This does not mean that the device does not have that state though (so in other words it is not inventing a state - the state is shown on the heater however not in the API), so this is bridging between lack of Viessmann API and reality of the Viessmann devices. That on the other hand should not mean that with adequate effort it should not be possible to utilize this important feature from Home Assistant, done the right way this actually helps to save a lot of energy for hot water heating. If I were to decide on which principle wins here I would suggest Home Assistant supports helping users save energy (in this case often oil or natural gas) rather than having to wait for the API to be "correct", and hence do this completely correct. I would hence recommend the change as it serves a purpose. I understand that creating custom entity services is a way forward however it is also a larger effort to create. That was just my IMHO :-) Sorry, but we don't allow creating state in device or service integrating integrations that the 3rd party API doesn't support. oischinger jborup The current state, if one time charge is still active, can be retrieved via: getOneTimeCharge() . It's simply true or false. Maybe it should be a switch entity? I was not aware that the status of one-time-charge is available on the API. If that's the case I guess both, switch or heating would be OK. MartinHjelmare What's cleanest from Home Assistant perspective? oischinger to give my two cents, I actually would prefer to have in on the water heater type. Similar as in Homematic device where you can enable "boost" from the operations' dropdown list. This basically just requires an additional API call in the current operation method to check for True on getOneTimeCharge() to return the dedication operation. that would also be my preferred way (as mentioned above). Just wanted to understand if there are any reasons why switch would be still be preferred by HA Core devs even though we can process the state in water heater properly now. These are the allowed modes of the water heater entity. Does one time charge match any of those? states I'd suggest STATE HIGH 
There's a race here, there may be old states which are not yet in statistics meta data, for example: 1. Configure the energy cost sensor with a manually configured price entity 2. There is at least one state change of the energy sensor 3. Update the configuration of the price entity to a different currency and restart Home Assistant before statistics runs 4. There is no metadata, so self. currency will be None 5. When statistics runs, there will be conflicting UoM Fixed by getting past unit from stored state instead
New integrations that communicate with devices and or services should be configurable with a Config Flow instead of YAML. For more detail read [ADR-0010]( decision) The documentation is available on The scaffold script can help you set up everything you need: I added it in the new commit
Updated. Prefer f-strings over . use-new-style-string-formatting Updated. This is not validated in the config flow. If this string was a mistake remove it or explain why only a single instance is allowed. Was a mistake, so removed. Just kept it as it was created by HA automatically. Removed it now. Generate this file: Done. The name is shown in the coordinator logs. It should be a unique recognizable name. CONF HOST can be used for this. You mean like ? entry.data[CONF HOST] is enough, the domain is already included in the logs. I'll change it to f"{entry.title} ({entry.data[CONF HOST]}) Data Update Coordinator" to also give a non-technical hint which configuration instance has problems if there are multiple. Use attributes instead of properties for constants to make the code more readable. Docs: entity-class-or-instance-attributes Climate: L182-L205 Done, thx for the hint! Consider using absolute import for better readability (you absolute-imported other things from the helpers package). Done. If you rename this method to async update data you could omit update method self. update data, from the super(). init . Done. If you used a NamedTuple or TypedDict or Dataclass as return type instead of a dict[str, Any] you could omit the casts in your CoordinatorEntity class cast(StatusInfo, self.coordinator.data["status"]) and have the properties typechecked. I'm using a NamedTuple now ( ToloSaunaData ), but typing for self.coordinator.data.status still complains, so I went for cast(StatusInfo, self.coordinator.data.status) . Add from future import annotations and use instead of Optional Move this to init .py if you plan to do more platforms from the same coordinator (assuming you will from your discord conversations) Where exacty, in which method? async setup entry ? Only line 46? Where exacty, in which method? async setup entry ? async setup entry in init .py Only line 46? Yes elif is not needed after return. The check for not power on is also redundant then.
Config entry is set up in parallel, so you need to wait till that task is done before patching out async setup entry to avoid potential flaky test.
Can it be not None?
This doesn't need to be a coroutine function since we don't await inside. Done. We shouldn't store an entity interface in a shared container for outside use but use our dispatch helper to signal the entity to do the action instead. Example: L300-L304 L191 If we need to wait for the action in the dispatch caller we can use an asyncio.Event that the entity sets when done. An alternative to this whole approach is to remove the entity when disconnecting and add it again after connecting the client, and let the entity handle starting and stopping its scheduled update. That may be cleaner and keep each responsibility contained in place. I have now changed to use the dispatcher a MUCH cleaner solution. However I am not sure your alternative is workable for a couple of reasons: - It would require that we store discovery info, in order to be able to create them again (remember this is configuration.yaml) - Deleting the entity seems to have effects on both the UI and collection of curve data (just made a fast test), setting the entity to UNAVIALABLE seems much less intrusive. At least deleting the entity would require a lot more testing, so see there are no side effects (in scripts, data collection and UI). - The start stop command are to allow the user to do make the decision, there are not scheduled updates as such. It is also something that have been wished for (reload integration) just as you can do with config flow based configurations. Do we need to cancel a potential running timer here first? no start cannot be called twice (the command from outside is restart, and it calls stop first). I don't see where we call stop first. Now we do. It was in the old restart code (modbus.py 200 ), but dropped out with the change to dispatcher, however it is more clear to have it in base platform.py. Done Side note: If we'd add support for removing the entity, we'd need to disconnect the signal when removing the entity, by using self.async on remove here. Thanks for the hint, and your review suggestions.
Our current standard is to raise ValueError here with the message as exception argument. I've refactored the code and updated the tests. Thanks. We don't use asserts like this. I moved it to the test case. Instead of this, just add an else after the elif. I started with elif but changed it to this to be consistent with other code in HA. When I searched for ValueError I saw most methods validate their arguments first and then perform their actions. Also, lse doesn't always work because the it would raise when the value didn't change if preset mode PRESET AWAY and not self. is away We shouldn't do this. If someone passes an invalid preset, we should raise, not try to match it up. I was hoping to be able to control both this thermostat and my ecobee's with the same presets. Looking into ecobee code they will match 'away' and 'Away', even though the modes they report are those returned by the ecobee api: Looking at the other climate impls they all use the lowercase presets, so probably better to enforce it being lower case. This needs to always be a list. Now that you're reuusing SUPPORTED PRESETS , you should make that constant a list again I would create this list when we process config and set self. away temp and assign to self. attr preset modes and drop this property. You can then also compare to that inside set preset mode . Why not make another if-check to see if preset current preset and ignore ? However, should we actually not call it? Or would it be to the to-be-called service to decide it should ignore it.
Maybe say that only the ISO units are allowed, besides default currency? Sounds good. Should we drop the CURRENCY US DOLLAR constant, it's only used by the isy994 integration? We can drop it here for now but we can move it to that integration to still have a constant there. Should this be USD (the currency code), or (a non-specific currency symbol)? Would it be more appropriate for this to return L instead of c L? Note that the here is AUD not USD. It would pave a way forward for currency conversion later down the track (not that it would be super relevant for this as it's local to AU NSW anyway)
Not sure if there is a better way to show the original username. For now it's editable but ignored. Not sure if there is a better way to show the original username. For now it's editable but ignored. If we use vol.Literal(self. original data[CONF USERNAME]) to validate the username only that username will be accepted. But that may still be confusing for the user if they try and change it. The alternative is to just show the username in a description placeholder template. I have seen description placeholders used on fireservicerota, but when I tried to implement it nothing would show up. Does it need a special code inside strings.json ? L106-L111 I think fireservicerota was an example of what "not to do" regarding description placeholders. I've looked at zwave js and worked out how to use the placeholder. It should be ok now. done done Maybe invert this check and show the form if true. Then we can outdent below and have more of the code outdented. done Pass the unique id and the config entry id in the context too. That's what's passed when raising ConfigEntryAuthFailed . done
Should we do this in init , so we only have to do it once? Good point Maybe? method should be a required key (without default) with type just to be safe. You'll need to create a mixin dataclass for that. You'll need to create a mixin dataclass for that. I think I need a little help here :) This here is a good example L55-L66 Thanks, done. This could be written as a list comprehension. Done Why construct the unique id here? You already need to assign self. attr unique id and both, item.trackable and description , are passed to init . I don't know the exact datastructure, but it seems like it would be easier to just pass item along and go from there. Good point, done. Could you add type hints? Missing for some of the functions below as well, especially the return type (even if None ). I want to add strict typing support for whole integration in the future PR. Can you add types for the arguments, too? Done trackables.trackable is a bit difficult to read. Why not change trackables to item ? You have used that before. Not strictly necessary. I like to do it anyway. I wouldn't use underscores here. That quickly seems like a private protected instance variable. Yes, you're right, underscore is't needed here.
has a default icon type. I don't think it should be overwritten. i've removed it, I just don't like the default icon (same as power and power isn't energy) L141 async request refresh already has a debounce to prevent multiple refreshes in the window. Good to know. I'll remove the unnecessary safeguards then These look like a new type of sensor (lots of if self. accumulating branches). It should probably get its own class and share the existing sensors with a new base class. great idea, indeed makes the code much more readable and remove unnecessary tests Can we avoid the try except block if we know the unexpected value? I'm not quite sure I follow. The value is unexpected so how can we know it before hand? It looks like you are trying to guard against invalid data in state.attributes.get(ATTR LAST UPDATE) being passed to dt.parse datetime or float(state.state) not being parsable as float. How is that expected to happen? I'm doing the same way the integration integration is doing. I can't think of how it could happen, but seeing that integration handles that case, I followed the same logic. L132 If I'm reading this right, it looks like every entity that is restored is going to call self.coordinator.update last run which means it is going to get called multiple times? Ideally store the data in a single place, and restore it in a single place so we don't have it copied to every sensor. Not quite. coordinator.update last run only let the coordinator knows that the next run will need to retrieve data from that time. While each sensor should have exactly the same last run value; it doesn't have to be (either inconsistency in the data, a sensor disabled and re-enable later etc). So the coordinator will restore from the most recent sensor and update all the sensors from that point in time. I'm not quite sure how I could get the coordinator to store that time and restore it. The refresh only occurs once. Ideally the iotawattpy package would take care of remembering and restoring these values which would avoid the need to have much of this logic in the integration itself. You could trigger it to write it the state to disk on the EVENT HOMEASSISTANT FINAL WRITE event. The disadvantage to this approach vs what you have now is that helpers.restore state writes to disk every 15 minutes which means less data is at risk of being lost if home assistant doesn't shutdown cleanly. The upside is we wouldn't be storing a lot of last update attributes in the database that really aren't useful outside of restoring catching up the data. The iotawattpy is a stateless library; it's only designed to retrieve the current data and that's it. It has no room for having persistent state , and I don't think you would want it to. Works just like a fancy WGET that also happen to parse the output data ready for HA to use it. It's much more logical for HA to do it, it has all the infrastructure to do so. In a sense, this works in a similar fashion to the integration Riemann integrati
L88 watts doesn't seem to be listed as a variable here Where did you find this value? I have the NUT to influx exporter and it come through as a parameter. Looks like that document hasn t been updated since 2016. Might be a new measurement? We should probably opt this into long term statistics as well by setting the state class
Maybe add pm25 device class to the corresponding entity description? Done
If local stands for using the local API, the domain and name should be zeversolar. It is also possible to do an integration using the remote API. So I decided to do it similar to what the solaredge integration is doing: It's preferred to use home assistant constants from This is already logged as INFO (MainThread) [homeassistant.components.sensor] Setting up sensor.zeversolar local in: L235 Run the following script to generate this file: If I have multiple inverters the names will be the same. Is it possible to get a name from the device? That was a bit puzzling to me too. But I thought in the end it would be managed by the unique id property of the sensor? The unique id is composed of the inverter-serial-nr. I could use this on the name. But I would prefer to have them somewhere in the sensor properties (like state-attribute or something) Is it possible to get a name from the device to use as config entry title? The title is used to identify the config entry if you have multiple config entries for the same integration. I'll add the inverter id to the title Put the debug log before the try. - [x ] There is no commented out code in this PR. - Title should not be stored in data - invert o r - invert e r (Typo?, it is also in the docstrings) - Remove integration name from title Host might be a better title as it is easier for the user to recognize. Edit: Host can change. Please don't partially type. Add AddEntitiesCallback and - None Wrong docstring. Don't patch validate input, but patch the library instead. I don't understand. Can you explain a bit more ? The validate input function should not be tested separately. You need to patch the library [as you did in the validate input test]( diff-80be57af6c262a6f0205be7667b7d04c4f6ea3d2f8d3b73f6d412ea82bea1c94R81-R85) in the other tests too. So the test should not contain patch("homeassistant.components.zeversolar local.config flow.a config flow function" but instead patch("homeassistant.components.zeversolar local.config flow.library.a library function" . These are tests for the config flow, so we should not skip patch any parts of the config flow. We are not testing the library so we skip patch the library. Ah. I understand. But I am not sure I agree. I have tested the validate input already. So patching it while testing the actual ConfigFlow feels ok to me I guess. Don't patch validate input, but patch the library instead.
I think this is borderline calculating a new state which device and service integrating integrations should not do. The standard is to set the state that is reported by the device or service while following our entity design. Understood; I'll close this. The parameter should already be lux according to the function name and how we use this function.
The way we conditionally call the super class' async added to hass() with the purpose of setting up a EVENT HOMEASSISTANT START listener here is ugly and prone to not work as expected if the base entity changes. GroupEntity could for example be refactored so that functionality is separated from async added to hass in a follow-up PR. I don't really understand this code or the suggestion. I copied this from light and cover in the same package. It seems it's better to be consistent, and if the package is refactored, all of the classes could be fixed at the same time. OK, let's do the refactoring in a separate PR Instead of this and all below, can we include group's config schema too? That would also add support for a configurable icon. My first attempt was to place this in the group config schema, which turns out to be worthless. The reason the UI and everything else then doesn't treat the device like a binary sensor. With this method, if I create a group of leak sensors the UI is going to show wet dry and the correct icon. In the group schema you will get the default three dot icon and a true or false text. That's OK, this can be improved in a separate PR, also refactoring the other groups. unique id is normally not user configurable. If we want to support it for groups, this should preferably be moved to GroupEntity though (in a follow-up PR). I copied this from light,cover, and media player in the same package. This is already done in GroupEntity OK, I was trying to call GroupEntity's init method but flake8 kept complaining. Maybe the super is getting called, but it seemed this method was needed after I removed the explicit call to init. My mistake, I confused GroupEntity and Group , sorry about that. This test, or a new one, should verify that the configurable unique id and attributes (name, device class, icon if added) are working. The same improvement should be done for the other groups in a follow-up. Aren't the tests for the base classes already covering this? I don't think so, since the base class don't support configuring unique id etc.? I added a test for it. They can later be removed from all classes in the package if the attribute is not recommended. this tests the behavior with all True , we should add one which tests the behavior with all False too. The same improvement should be done for the other groups in a follow-up. Agreed. The odd thing about using the binary sensor base is the state is forced to be either true false, and the unavailable state is removed, so you can't actually return unavailable if the member entities are unavailable. Anyway, happy to add the addition test case or cases if this PR has any hope of being merged. Availability is still supported, but it's done by implementing the availability property attribute, not by writing to the state directly. Either: Or: We prefer using a list comprehension instead of map lambda. We don't have an all option for the other group platforms. Eg see the light platform which also h
I'd suggest moving this and coordinator to new files the common pattern is entity.py and coordinator.py. it makes it a bit easier to exclude from certain things like coverage or typing if needed. also easier to review on per file basis. I don't see how mac address can be unique for every entity? balloob currently the is the base class and is extended in the file in the class . In this class the method is overwritten returning a unique ID for each sensor. SensorEntity shouldn't be used needed here. CoordinatorEntity extends Entity so should just need it alone. this should include the SensorEntity usually common preferred to use constants here like CONF NAME inplace of "new". there are a number of common ones in homeassistant.const not familiar with the python module in use here but does it perhaps support passing None for username pass to avoid two paths here? This is no longer needed. Why store the api object? It's already accessible as coordinator.api What can raise a KeyError ? Let's not ask for a name and just use the host as the default name. Mock the package out instead of the validate input code: You are not asserting anything on these results? Mock package instead: Use formatting strings: Can this name change every request or can you define this inside the constructor? Not used This param needs a better name since this is the entity class. It looks like it is better named key ? We don't allow YAML configuration for new integrations that communicate with services devices. This should be removed, and you can then remove the async setup functions since that will not be used.
Why do we change the demo integration in this PR? For tests to pass. Without this tests do not pass Ah, the demo integration is using the manual alarm control panel, I didn't see that Why are these tests changed? I did not change them, just reordered one to group all test for home mode. I can revert this if needed no more relevant since tests refactoring Instead of duplicating the tests, consider parametrizing them, maybe something like this: I will try to do this Done
This is in the manifest. L126-L127 Is not used. Please don't partially type, instead it is preferred to fully type it. Use CONF NAME from homeassistant const.py L141 Wrong docstring Wrong docstring. You don't set native value in init, so you probably need to update. description placeholders is not used. There is no need to create a separate function for this, it is used once and just calls another function. Check if the host, username and password are correct before creating the entry. If the data is not correct, show the form again with an error. You can try to log in or if possible request the name of the device and use that as the title for the entry. Unfortunately the library in use doesn't return the device's name. Use the default title (from the manifest) if possible, this saves us a translation. - Use the default title (from the manifest) if possible, this saves us a translation. - You can make a key reference to the integration strings. I'm having trouble mocking the library's InvalidAuthentication exception, any pointers? This is how I did it in the [Nanoleaf config flow tests]( L114): Unfortunately I can't help you much with this. I spent a few hours looking for this Nanoleaf solution last week. :disappointed: Oh, I need to mock requests as well that's what it is.
Please add import coverage It looks like port is used in validate input in the config flow Do we need to keep it here? It is included in device config. I only convert the config to the new format. Moved the part to async step import to make it more obvious.
Please use ENERGY WATT HOUR from const Same as above Please use POWER VOLT AMPERE from const same as above Please use DEVICE CLASS POWER from const Please use DEVICE CLASS ENERGY same as above Guessing "AdGuard" should be Eco
For user-friendliness, allow for either area ID or area name?
Should we use keep all the values in the existing entry so we don't have a bug later if something else gets added?
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1: Ok, I'll try to find some time for the refactoring. I'm quite new in home assistant-land so it might take a while. But looks like a good way to learn.. :) Why not use the ip address as unique id? Why not use the ip address as unique id? Because that is not allowed. unacceptable-sources-for-a-unique-id

The same event is often received several times. This to only update the sensors for new values ATTR LIVE TRACKING REMAINING will not always be present. Source will be bluetooth if the tracker is close to a phone with the app Should we use SOURCE TYPE ROUTER if event["sensor used"] "KNOWN WIFI" ? Do we know what states this sensor can have? If so, we can add a custom device class and make these states translatable. So far I have only seen 'NOT REPORTING' and 'OPERATIONAL'. Do you have any examples of how to do that? Sorry for the delay, busy days. My tracker also raports not reporting and operational states. I think we can make these two states translatable. [Here]( you can find documentation about translating entities states. So you need to add a custom device class for that sensor e.g. tractive tracker state and strings to the file strings.sensor.json . I think states have to be lowercase to be able to translate. Are you sure we have to use get() for live tracking ? I suppose it is always present in the hardware event. After 8h of catching events, I have one without live tracking : Sorry, my bad. However, the tracker state was always present in the events. Also tracker state is always present in the hardware event. I think we could use mdi:av-timer here. What do you think? Or mdi:clock-end . The unit is necessary here. Why? The unit for device class battery is percentage, available-device-classes Because we don't have a unit now ![image]( ![image]( From documentation: ![image]( This logic has a negative side effect. For example, we get an exception in the listener and the entities become unavailable . After w while the listener will return online: but the entities stay unavailable because the event has the same time as previous one. Such a state of unavailability may last several dozen minutes. Good point. I think this should solve it Yes, this will solve the problem. I'll investigate if we really need get() here: I can confirm, get() is not needed here, time is always present. I think we can use continue instead of else and reduce the indentation of the following lines. We shouldn't store countdown times in the state machine. Convert it to a time stamp instead The received time is not very accurate, so the time stamp will change for every update. I removed the sensor for now, but might give it another try later. If this sensor only has two states maybe it should be a binary sensor? Maybe. We do not really know if there are more states. I think I have seen something like starting up. I Will try to log the different states again I have now tried to turn the device on and off a few times. The streaming API (the one we are currently using) is only pushing 'not reporting' and 'operational'. If we poll for the state I also get starting up and shutting down. I think the Shelly integration poll for data if we have not received any updates in a while. I want to test out a similar approach for this integration and then it will be 4 states. Currently, it 
Is this going to hit a rate limit if there are large number of pulls? yes (and fixing that is planned for another PR) This is the same behavior as the old (which automatically expanded paginated results), so that issue is not new Well even home assistant doesn't have enough pages for it to be an issue so should be ok yeah, I don't see it really being an issue, but it can and will be better anyway (later)
Could really use some input here - is there anywhere else in the code where we do a similar mapping, and does it make sense to keep the percentage - description mapping consistent? I think this is fine for now. Also here: is it worth testing for multiple battery levels? No not really. Possibly edge case of full since. We prefer early returns. So please do like: In both the charge and the non charge case. Fine for the "charge" case, but in the "non charge" case the late return is a fallback case, an early one will make the if statements unnecessarily complicated now irrelevant What effect is this expected to have? Seems like some toggle service (didn't even find it in dev docs). Seems it could either start cleaning or pause. vacuums that are docked are already in PAUSE or STOPPED state, so that toggle will either be an UNPAUSE or START, either resuming an existing cleaning or starting a full one now irrelevant
This is used for the unique id of the existing entities, thus will be breaking for existing users. Migration for existing entries needs to be added. Can't we just use the "model" key of the device information for this, it's kinda fitting and this information is static pr. entry? That seems like a good plan, let's figure out how to do that. How do I call the value associated with the model assert?
agree Could just assign self. attr oscillating here and omit a property wrapper? Perhaps we can do this for new code where possible. I think Fan class doesn't support attr oscillating . You are right CAUTION FanEntity does not support attribute shorthand for property implementation: it would be nice to map this and not reassign direction. We should assign self. attr oscillating and self. attr current direction and call self.async write ha state() set rotate() method only rotates the fan at a slight angle, and nothing else. We don't have current direction variable. In the gui we only have oscillating (boolean). Perhaps we could add some attributes to a sensor to readback the current state. Caching is not needed in that case. There is no current state related to set rotate() . We have only oscillate value. We should set self. attr oscillating here and call self.async write ha state() What are the valid steps here? 30, 60, 90, 120 and 140? 30, 60, 90, 120 and 140? Yes. Hmm 140 is not a multiple of 30. I'm not sure what to do about it. This is tricky. The supported angles are a bit different per model: Take a look at the miot specs to be sure. I assume some models supports stepless ( step 1 ) rotation between 0 and 120 degrees. Some devices are limited to 30 and 120 degrees. I think this is the only outstanding item and it should be good to go I have already split the oscillation angle into two separate entities which are used depending on the device model. Look here L116-L135 is 0 a valid value. Will it turn off the feature? Yes and yes. Fan also supports (I think at least) also the models shown here L12 (p5 being sole miot implementation). zhimi.fan.sa1 , zhimi.fan.v2 and zhimi.fan.v3 added. Why set the speed when calling set preset mode? This model doesn't return the set mode. The recognition of the mode and its adjustment depends on the change of the speed of the given mode. So to get the natural mode we set the natural speed, if we want to set the normal mode, we set the normal speed. This one is a bit odd case, but since percentage is not being passed in, I think its ok async turn off looks like it already writes state Should we write state at the end of this function instead? I'll use async oscillate() here instead. Write the state at the end is not necessary. Looks like async turn on will write state as well async turn off looks like it already writes state async turn on looks like it already writes state Maybe change this to differentiate from the error message below?
What's the use case for knowing the entity ids? I don't like this change since the entities are not the source of this event. from observing conversations in zwave, users often have a primary entity ID for a device that sends something a notification or value notification event. For notification , it is typically a lock, and for value notifications, it is often a switch of some sort. At one point I had proposed an idea of having a primary entity for each device, but that would be difficult to get right, so the idea here was to pass all entities for a given device to make it easier for users to create match conditions for these events in automations. All that being said, they could use the device entities function to achieve the same thing, so maybe it's not worth adding redundant info
Emoncms also provides things sensors like, (daily) averages, right? Ah, I think there are two answers to this, but you're right it's not something I had considered. 1. Things sensors - Yes. There are other non-power possibilities, such as the emonth units which record temperature humidity. 2. (daily) averages - Yes and no. EmonCMS itself provides functionality similar to statistics as I understand it, however those are only exposed via the UI. Available APIs are only available for un-aggregated feed values, which is what the current integration uses. Given this, I think perhaps it would make sense for me to update this to support feeds of temperature humidity for inclusion in statistics? Is this about what you were thinking, frenck ? No, I was aiming at the fact that for example: the "Average Daily Energy in kWh" sensor, should not have a STATE CLASS TOTAL INCREASING . hence the question. If they are not present, that is fine for now. Although, for a future PR, it would be better to explicitly define the entity description in Home Assistant (and now spawn the from API data). For example, if now an average sensor would be added by EmonCMS, things go south. That said, that is nice for a future PR.
I think there's a race condition here if hourly statistic generation is running in parallel with this Yes, you should create a statistics mutation lock or insert the cleaning as a task into the recorder task queue. insert the cleaning as a task into the recorder task queue That sounds like the better option, with no risk for any deadlocks etc. Would it be enough OK to mention in the docstring for the WS API that the wiping does not happen immediately, so the call just returns after posting the job to the recorder queue? Yeah that's fine. This is not necessary because we have this in recorder models: This should be marked requiring admin access There is nothing async here.
Could you add test coverage for this service? I've added test-coverage for this service
There are multiple platforms in this first PR. Please limit the integration to a single platform. See: 5-make-your-pull-request-as-small-as-possible Thank you frenck for reviewing my PR. I removed the cover and binary sensor platforms, and left with light only. missing requirements If its async you can use async write ha state Move this into async added to hass async added to hass You can use attr unique id Examples in wled light.py You could use a comprehension here. You need to set the unique id to a value as well unique-id-requirements Thanks for pointing about this. Looks like I don't have unique id for this device, so I'll omit this call. If you want to retry, raise ConfigEntryNotReady I was wondering how to do that. Thank you Unique ids a per platform, so light isn't needed here. Please use snake case for the core code. typo? You can use attr should poll instead to make this smaller You can use attr name instead to make this smaller import callback from homeassistant.core Looks like this got missed Thanks This looks like its not needed You mean that bool coroutine is too simple and can be done inline? As far as I know (and I might be wrong), if I want to replace this function, I can use future, but I think it will look weirder. Is this what you meant? Please use snake case for variables objects in core code.
I think you should check the silence parameter. If silence is True you should not really retrigger a locate command. You might even want to error out on that. good point It's marked with default of false i docs. So i think they could leave it out in a request.
I think either of CONF METER DELTA VALUES "delta values" or CONF METER DIFFERENCE VALUES "difference values" would be better; with this configuration the data points is a series of differences deltas not a series of differentials. I originally called it "summation", and dgomes [suggested "differential" in this earlier comment]( pullrequestreview-735489328). This made sense since my understanding is that differential is the adjective for the noun difference . From [Merriam-Webster's definition of differential]( (Entry 1 of 2) 1a: of, relating to, or constituting a difference I'm happy to change it if you feel strongly that this usage is incorrect in this context. Delta would be a synonym, but I think differential is on target It's confusing IMHO because of the meaning of differential in mathematics: Let's all agree on Delta ? Done. I'll update the docs to reflect the change next.
Can the problem be clarified a bit? This race is clear: handle push failed is called after async confirm notification , that's handled by checking if confirm id is no longer in the self.pending confirms dict What's this race though: race condition between call later and another push failing and tearing down the connection Is that if handle push failed is called by two different failing pushes? there is a very rare condition possible where call later of a failed connection is scheduled, but the connection is already started tearing down before it was able to undo the call later call. The tearing down can be caused by a) another message not being confirmed or b) websocket connection being dropped.
Won't this allow an overlap with other config entries that use the home id as unique id? I'll make sure its gets overwritten with the home id before it finishes in the final version Ok, so we won't be able to create a duplicate config entry (good), but the USB discovery flow for a device won't automatically close when creating a config entry for that device from another flow source (less good). There needs to be a confirmation form before we move on with the flow and start setting up the add-on etc. See the hassio steps. Will do Maybe we can just go to async step on supervisor here instead, and passing CONF USE ADDON: True ? I think so. testing it now uninstalled addon, deleted config entry, restarted with the change, discovered, proceeded to set it up and it worked like a charm Maybe I should move this into the usb integration in a followup since I lifted it from zha I'm going to wait for the CI to and once thats in, open a PR to break out the duplicate code into usb to make this smaller This can likely move to usb as well and have zha reuse it. We don't need this since we have a fixture that sets it up and is set to autouse. Excellent. Less code
Wouldn't just serial number be enough ? What if they plug it into a different port? Some of the no name devices don't expose a serial number. I used all of the data since that's what device by id on the file system seems to do I think it would be extremely helpful to have some information about what these devices are. Looking at this list, I have no idea if I can extend this... Even though, I have quite a collection of Zigbee capable USB devices. I'll add a description field once zwave js is merged and back populate them all.
Do we need this check to not break the device? Normally we avoid guarding service calls for polling integrations with state since if we would have the incorrect state the user wouldn't be able to change state via the service. If it's needed: We need it. There is only a toggle feature for lights. So we need to know it's previous state.
If we make USBDevice a dataclass we can use dataclasses.astuple to get a tuple. dataclasses.astuple Good idea. Thats a much better implementation Will clean this up after coffee Done Is this async safe? Yes, no I O. Only starting a thread observer.stop will run in the thread pool like this. Is that correct? Yes, its joining the thread so it could block If we make USBDevice a dataclass we can use dataclasses.asdict for this. Done What's the reason we use the loop api directly? We probably need a comment for that if it's needed. I'm been working on python-zeroconf too much and been using them directly. I'll switch it to async add job Maybe we don't need to add a job for this at all? Just call async process pending flows since it just creates tasks. Agreed. I don't think it even needs to be its own function. Does it make sense to do this hourly? Maybe we can just have the frontend trigger a scan via a WS when the integration tab is opened ? That way we could also include Plex discovery. I figure there are cases where the user doesn't know what to do, plugs in the stick and magically an hour later it appears. Also we only scan on windows and Mac. On Linux we can observe the device appearing. I will work on a followup after ZHA ( and Z-Wave JS ( are done: - Remove scanning hourly on non-observing platforms (Windows Mac) - Add an API that will trigger a scan when loading the integrations page. Switch to websocket here: Need to figure out where to tie in the frontend This throws an exception if libudev is not installed. Is libudev now a requirement for Core installations (i.e. a breaking change), or should the error be handled gracefully? Sorry to comment on a merged PR, but I wasn't sure if this is an issue or not. We should trap the OSError and fallback. Sorry to comment on a merged PR, but I wasn't sure if this is an issue or not. Glad to get the report now while its still fresh I'm still focused on this as its much easier to take care of now. YMMV, but for me its is the case where the PR is days old where it tends to be unhelpful and gets missed. I think we can also skip that also on normal container installation because they don't get the new device mapping to the container dev and need also the udev socket mapped into run for get events with network host. Do have a suggested way to detect that? async get system info from homeassistant.helpers.system info L23-L24 Hassio will work but docker not (hassio work because we map the host dev into container to support plug play and mapping udev into run) Thanks. will adjust after
We should type as far as possible and only do local ignores when needed. Do we need to type the item in the set? Does it work to move the default to the config schema? We already checked the match list condition above. I can combine these checks but the second part of the check is checking against different values, the raw and the translated value We can move the device registry get out of the loop This is dangerous, you're throwing user generated data into an import function Why not just have a couple of static classes and decorate each with their type using a [ Registry ]( L8) Or even simpler:
Is it OK to have mutable dicts in this scope? No, store in hass.data Fixed A slightly more readable alternative: Fixed Can we include the old and new one? Expected kWh, found Wh Fixed
Is this just for the test here? Because gas meter should also get a status class STATE CLASS TOTAL INCREASING shouldn't ? For all devices that can measure both decreasing and increasing values. Changed it to energy meter since it is more realistic to have an energy meter that can both increase and decrease.
For integrations that connect to devices or services, we no longer accept new YAML configuration. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: I believe I have re-implemented this integration using the config flow method I'm not sure that these functions need to be defined, you should just be able to call the enasolar method directly in the places where you are calling these one liners If I do that I cant work out how to mock out the call when doing the tests. I haven't written python before and I started by using another integration which, I now see, was probably not the most sensible thing to do as I didn't understand what all the code was doing. homeassistant.components.enasolar.config flow.EnaSolarConfigFlow. get serial no becomes homeassistant.components.enasolar.config flow.pyenasolar.EnaSolar.get serial no in your patch statement, rinse and repeat for the rest Moved device connection out of instantiation in pyenasolar which meant I could expose the methods directly and hence mock them out when testing. why not just say self. data.update(user input) instead of setting each key individually? I wanted to be able to perform specific validity checks on some data before accepting it. But have used the construct suggested when the data is all OK. same comment here about setting each key manually vs updating the dictionary As above These thresholds (0, 7, 256, 263) should probably be constants Made this constant BIT mask instead. I would make constants for these lists as well Made a constant I'm not sure if this is explicitly required, but I tend to use vol.Coerce(int) because voluptuous will cast a string into an int There is a constant for percentage too in homeassistant.const You don't need this function defined because your integration will never have supported configuration.yaml configuration same comment here about individually setting key value pairs You don't need this. Imports are to handle configuration.yaml entries so that wouldn't apply here what is the point of splitting up the list of entities to create in two? The class instances for meter and data sensors seem to be set up the exact same way I wanted to have two different polling frequencies. Oh I see, you are accessing them separately later See my comments about the update coordinator. It may not be the right move depending on your use case but I have found it to be pretty flexible and using the update coordinator along with the CoordinatorEntity mixin will reduce the amount of boilerplate code. I think you'd be able to simplify all of this update logic significantly if you moved to using a DataUpdateCoordinator . Your update logic and your interval backoff logic could live in there with much less code and then you could inherit 
How attached are you to this debug statement? Feels like it's going to produce a lot of output if enabled. Will it provide much added value for live systems if it is enabled? Can we remove this one please? We don't have it for any of the others (appreciate it was probably handy for you to have this when implementing the tlx logic though) This one should have one of the new "TOTAL" measurement types on it. See the other PR for what to use. This should have one of the new measurement types too. Another new measurement type here As the construct of the inverter is the same as the tlx, I doubt that the inverter logic works without ["data"] but this is out of scope of this PR and I am not able to test this That's fine, it was just the debug statement that needed to be removed.
Why is this an attribute? I would have expected this one to be part of the main schema and allow the attribute to be "free" list of key value pairs defined by the user. do we want to support free lists of key value pairs for attributes on platforms that aren't sensors? This is easy enough to change, I was just trying to match the sensor schema while acknowledging that these platforms have specific attributes that are exposed do we want to support free lists of key value pairs for attributes on platforms that aren't sensors? I would say: not now; maybe later, maybe never. I was just trying to match the sensor schema while acknowledging that these platforms have specific attributes that are exposed The sensor schema exposes the opportunity to expose custom attributes. I think this options (and things like step for number) are technically attributes but that is more a internal thing I would say. Looking at the [Input Select]( it is also a normal level parameter for options . Is this a bugfix? I think it belongs in a new PR Looks like its to handle the change in trigger entity.py correct, we needed a way to render a complex template because the options property needs a list Pretty sure this isn't needed? thanks! missed this in my cleanup Guard for discovery info
A sensor expressed in Watt is not a metered value and so is not total increasing Sense should move to using SensorEntityDescription , it will make it more clear what sensors are being defined. [Example]( diff-cf5109edebb2f7b936709887b718df72730a593027d49aef6c399c033439f8bbR39) Another benefit is that you will be able to implement entity registry enabled default False to avoid having all these new entities show up. Hello. Long time user, first time contributor. I agree that SensorEntityDescription s are a great idea, I'm just wondering if that work should be part of this PR. The more I look into the concept, and look at how it's been done in other integrations, it seems like it implementing it will increase the scope of the PR. Plus, as I said, I'm new at this and it's going to take longer than it would a more seasoned contributor to do this work. Ok to do later. What does this represent? I think that we should consider not adding all these entities by default. Please disable by deafult a couple of non-relevant ones by setting self. attr entity registry enabled default False I have[ a PR open on the docs repo]( that explains the editions. In this case, these two sensors are reported as percentage values from the API for... Net production as a percentage value ( energy produced energy consumed 100 ) Solar powered percentage values, which is supposed to be a representation of the amount of power produced from solar that went to power the household and not exported to the grid ( 100 (usage - from grid) usage ) From Sense community posts, the solar powered number is easily the least interesting, and I will admit that it was just something I added because it was there. I'm working toward having OptionsFlowHandlers that would allow for switching on or off entire sensor classes, like having active sensors, but turning off per-device sensors, as well as letting users choose which trend sensors they want to be enabled. That said, it's easier to type all that then it is to implement it, and I'm at the the Hello World stage of adding the flows themselves. It's going to take more time for me to get them fully implemented, figure out how to translate those choices into the actually reconfiguration of the integration, and then figure out how to update the tests. Let's disable these by default. Home Assistant already has options to disable entities, we shouldn't duplicate those features with an options flow.
Consider making this a select entity in a select platform. If this is the service the user most frequently uses for changing charging it may be more convenient to access it as an entity. I've created PR 55494 but I am unsure if this is a new feature, or if it becomes a breaking change. Consider replacing the vin parameter with device id selector for the car. Example: L1-L11 L115-L133 This looks like debug level. Is this assertion made for type annotating purpose? Yes it is, should I add TYPE CHECKING condition? Only register the services if no config entry has registered them yet. We have hass.services.has service . What does this id represent? Why does the user need to provide it? See reply concerning activated flag below: Renault vehicles have a set list of schedules Consider defining a base schema with the ATTR VEHICLE item and reuse that schema in the other schemas and for all services. Voluptuous schemas can be extended with Schema.extend . Can we define selectors for the other parameters too? I looked at this but I am unsure how to implement. It seems that min and max are compulsory... should I just make a random call on what I think are valid values, and what a good step would be? Also, there doesn't seem to be a datetime picker (only time ). If number is too narrow we can use text eg. Make a best effort attempt. I have done ac start , ac cancel and charge start . However I do not see how I can implement it for charge set schedules . The schedules schema is quite complex! Maybe use object selector? I hadn't seen that selector in the list. Should be ok now. What's the use case for scheduling an inactive charge schema? Renault vehicles have a set list of schedules (ids 1 to 5). The user may want to deactivate schedule 2 and activate schedule 3 without amending any of the other properties:
Please use async get instead. That one is not a coroutine function. async get registry is legacy.
Could use contextlib.suppress here good tip! This seems to be the pattern used in other platforms for this integration, so I am thinking maybe we have a separate PR to do this across the board? Agreed that the others should be done in a new PR. Should be ok to do this one now since its new Fair enough I'm not sure why these are leveled as "attributes"? Make sure you guard for discovery info being None, in case someone uses the platform syntax. (requires LOGGER to be defined too)
Does this always return a bool , or can it return None as well? diff-69a3b80725c7ea0312356fe5c51a7c7c421dea38a1d767099579022063a24835R171 seems to return None in the else-part. If None is returned then it will end up being False ( True and None - False) I wouldn't mind adding s as format for ROUTER IP and WAN STATUS . This way, there is no need to check if the sensor type has a format entry, simplifying code a bit. Next improvement; use SensorEntityDescription for this Assuming you mean not for this PR. :-) Can you provide some more info on what you mean? Did Google search on it but did not seem to find much info on this. I guess you can do it here as well :smile: Do a codebase search instead, over the past few weeks a lot of integrations have moved to that. It will really simplify the descriptions of the entities that is being done (including the disabled by default setting) LOL. Ok, just pushed a commit for it. Haven't been able to test local yet but the tests themselves passed. Figured I'll already push it so you can review and let me know what I need to change. :-) This should be disabled by default integrations-offering-options-to-control-disabled by Thx!!! Updated accordingly, please check if I did it right. :-) Not really, everything will be enabled by default now (which is the default as well) Not following, for the UpTime sensor I provide a boolean to determine if it should be enabled or not. All others I do not provide anything and then yes, it is enabled by default but right now it really is just uptime that is not always supported. diff-1f0fc2dfe3626e3495b8aee8d906009a32c1df3dc753b46b7fda9ed753a1113aR121 Is this what you mean? if so, use enabled False or False instead. So disabling entities now if they ended up return None which would mean not available supported by the upnp device. Those should not be added in the first place. I'm not following. What do you mean they should not be added in the 1st place? At first I was not adding Uptime if not available support by the upnp device but instead should add it but disabled. If the device does not support something, should we add disabled or not add at all? Thx. Disabled is a good default for an uptime sensor. But if we know an entity will never work, there is no need to even set that sensor up, here we have already done a data fetch before setting up the sensor, so we should add a if clause to the for look that add entities to check if this should be set up So the uptime sensor returns back how long the UPnP device has been up. However, not every UPnP device supports this (although per standard they should). For example, my router supports it but my cable modem does not. So before it would create the entity for my router but not for my cable modem. Right now it would create them for both, but the entity for the cable modem is unavailable. So I will add a check in the for loop then to confirm that particular sensor is available from the UPnP device and if it is not then not create the enti
These should be bool L822 Okay. These are taken from L235 That's a bug in the fan code. It hidden by the fact HAP-python will pass it through to valid value and convert it to a bool here L188 You can drop the guard as its not needed with newer HAP-python We probably shouldn't create the accessory if there are no options present (check in accessories.py ) It seems that HASS doesn't allow an input select with no options. Then we can do state.attributes["options"] instead I don't think option can be false here Add select as well client update value doesn't need to run in the executor anymore. These are left over from when homekit wasn't async. Set the options in the attributes here Set the options in the attributes here

We don't set an icon, when we define a device class We don't set an icon, when we define a device class This should be simplified We should not have an if here, it will hide issues Same goes for the other tests added here There are cases where the expected entities is zero (ie. for fuel vehicles which do not have plug charge statuses). I have altered the logic so that if expected entities is zero then we ensure the device and entity registries are both empty and then simply exit. This way it's not dynamic, and will cause issues when if the fixture changes I don't understand your comments. Maybe we can discuss on discord tomorrow. In my opinion expected entities comes from test constants so it is already hard coded and there won't be any surprises "when if the fixture changes" In general we should avoid if checks completely in the tests. Can we parametrize this result instead? Eg by iterating expected devices and iterating expected entities and having all device checks in the expected device loop and all entity checks within the expected entity loop. This doesn't seem correct. We expect one device even if there are no entities for a platform. It's even part of our fixture. I wasn't aware that "we expect one device even if there are no entities for a platform", so I guess this is something that needs to be plugged in, and renders the "if" discussion redundant. I'll start work on this right away. If there are no entities at all for an integration there will be no entities that registers a device via device info . But here that doesn't seem to be the case. I think the reason is that we patch the platforms constant to only set up the binary sensor platform. I think that is not the correct approach since it makes our asserting incorrect. Side note: I'd expect this integration to create one device per car regardless of what entities are exposed. We already have this check below when comparing expected entities to entity registry length.
Is last update an isoformatted UTC datetime string? This saves one line: The format differs between various vehicles, so the renault API has kept it as a string. We should make sure that it's a UTC isoformatted timestamp though. That's our standard for times in state attributes. I have fixed the mypy issue. However for the last update I am not quite sure what you want me to do with the timestamps. These are sample timestamps I have in the fixtures: 1. "timestamp": "2020-01-12T21:40:16Z" 2. "timestamp": "2020-11-17T09:06:48 01:00" 3. "lastUpdateTime": "2020-02-18T16:58:38Z" Are you saying that 1 and 3 are OK, but 2 should be converted to UTC? Looking at it through the UI, it seems to me that it handles both format so I think this is ok. No, all times in state attributes must be UTC time. Please convert the times to UTC. Is there a standard method in HA? or should I build my own? Check the dt util. Maybe try starting with parse datetime ? L124 Once we have a datetime object in UTC time we just call datetime.isoformat. I struggled a bit with pylint and mypy but should be ok now. I've also adjusted the tests to match. If we know that the value is a string we should type it correctly in the signature of this function and not cast it here. Adjust the typing as early as possible in the call flow. I've moved it up. I've moved it higher... Type or cast last update already here. The trouble here is None handling. Don't I need to check that the value is not None before I cast it as a string? We need to handle all possible cases, yes. I have run some checks and cast is happy with None so code should be fine now.
Is there any real benefit to using separate update coordinators. Feels like just more overhead for hass. I suggest just have a single update coordinator that grabs all the data. any suggestions of how I can put this in a single update coordinator? Let the update method return a tuple or dict of values. This call will potentially raise a ConfigEntryNotReady exception. If it does you currently leak the session that is allocated inside the client. You should be supplying the home assistant client http session to the monitor object (async get clientsession) I have no idea what you mean, can you make it a little clearer for me? Look at how you create the object in the config flow. You pass in a session object. You need to close the client object. Do you mean something like this? No: client.close() close the client on exception. (even thou with shared session that might be an noop, it's easy to forget later) I think we can remove this part. EDIT: Nope it should have some exception Last commit will close on exception. min 0? that would hammer the server and cause 100 cpu load on home assistant. So i think that is a really bad idea. I really wonder if there is any point in allowing this to configured at all. It's to prevent users from entering a negative value, because you don't want that when setting an update interval. Yes, but setting too low is really bad too. Maybe min 5 or min 10 then The common practice is to use a tuple instead of list for these blocks of data. They take somewhat less space since they are immutable. I see that [Ambee]( L37) use the same approach on this. It only gives me error messages from mypy when I change this ![image]( tuple[SensorEntityDescription, ...] icon should not be set if you set a device class There was an issue in the frontend loading the icon for this particular device class. you don't need to set last reset for total increasing. you don't need to set last reset for total increasing. you don't need to set last reset for total increasing. I don't know what the practice is here. So just take this as a grain of salt. I would just have put these as python structures inside the test files. I see very little benefit of loading them from json. This approach feels more logical to me, than what you offer as a suggestion Your are missing to handle the coordinator update callback. Have a look at the CoordinatorEntity. It has a method you should override. Do you have a suggestion for me of what I should adjust it to?
The unique id should never be "unknown" Thanks - I started with two properties, and then simplified it to one, but with this I made the error of allowing serial to potentially be unknown. Since you actually does not use self. serial for anything other than the unique id, this would be better: Then self. serial and the unique id property would no longer be needed api.serial number is a property right, so nothing is requested here? It does requests in the property... nevermind then :smile: Yes, beat me to it. L85 Typing is incorrect. It can return None in the statement below. Yes, I see some components are starting to specify the the type as nullable, which is more correct. Most components don't specify the type at all. Sorry - new to the project and I'm just trying to copy working code. What is the amcrest version and camera you are using and what is the response you are seeing here? The current amcrest package version that is being used (1.8.0) should already handle parsing the value here to return just the serial number. Basically, with the current package, I don't think this logic and splitting should be needed from the self. api.serial number output. You are correct. I copied the type from the code above, but it should be removed. My debug log line is I think if the serial number isn't available, for whatever reason, the return value here will be an empty string. With this adjustment, it will return unknown as a serial, why not leave serial None ? That way, you don't need additional logic in the unique id property method to filter out unknown again. That makes sense, self. serial resp if resp else None would be good here. Not even needed, as the default is None already, additionally, serial isn't used for anything else. So all can be replaced with a single My only concern with this approach is if it can't get the serial number, how many times will the api query the device? If you set it to unknown after the first failure, it won't continue to retry. Initially I had hopes of having the camera motion sensor entity also have a unique id based on getting the serial from this device, but I gave up on that. If serial is an attribute then you could browse it, while the uniq id is intentionally not browsable. If you set it to unknown after the first failure, it won't continue to retry. It needs to be set on creating of the entity, it cannot be provided at a later moment. Either way is fine with me - my tested setup is assigned it to the serial property and using that property if available for the unique id. Setting it directly is fine as well - you just can see it in the state browser. no need to check it Please see my comment above. The whole setting unknown isn't needed at all. As for the unique id it is checked against it again to make it None . So; make it None from the start than we don't need all these unknown 's (unresolved this review to make it visible) This is the behavior of the Entity , this should be fine to remove.
Don't store the coordinator until after async config entry first refresh succeeds Done Merge these 2 if-statements into 1 Also why guard for hass.data.get(DOMAIN) ? You also can use hass.data[DOMAIN] because you set it to a dictionary above Totally correct. Removed redundant check. What is this code doing? Wouldn't that mean that every camera entry is going to reload the cloud entry ? why even have a camera entry ? At present I'm using the camera entry to basically just store rtsp credentials for the camera. Had to reload for it to take effect if a user adds credentials for a camera. There must be a better way of doing this, let me think about this one for a bit. Hi balloob, The new text entity might work to store the camera RTSP password. None the less, I will improve on a follow up pull request to keep this one as small as possible. The current behavior works similar to how the integration does it currently. (Just later on to add update listener) We know that the key is in the dict here as we checked that already above. We should use dict[key] . Addressed in 94384 Don't log and raise. It will spam the log on retry. Just pass the log message as an exception argument to ConfigEntryNotReady . Addressed in Debug level please. Addressed in Please separate words with underscore in variable names, CONF RF SESSION ID . Addressed in Combine sequential calls into the executor into one call. Make a function that does all the sync calls and schedule that function on the executor. It's expensive to switch context and use the executor. Addressed in We shouldn't rely on the config entry title for any logic or api calls. The user can change the title. If you need the serial number it should be stored as config entry data. Addressed in Same here. Addressed in
I'm confused, why isn't this state class placed on Huisbaasje Current Power In Peak instead? Because that sensor gives the current power usage in watts and thus is not a total and not always increasing. How is this related to adding statistics support? You're right, it isnt. Let me remove it for now Why isn't this set on the total lifetime gas meter? For a future PR, having an icon and a device class is actually incorrect. When using a device class, an icon should not be defined. However, this is already an existing issue, so ignoring it for now. For a future PR: This list that describes sensors, can be replaced by a tuple of SensorEntityDescription classes. That will make this much cleaner to work with and allows for the removal of quite a bit of boilerplate code. Why add precision on 1 here? Especially when using this with statistics and things like the energy dashboard, I think that might be a bit low as those stats are generated every hour? Maybe 2 or 3 is a better option? I think precision of 3 makes more sense as it boils down to watts then
Should we sort these? Nevermind we don't have to support older python Probably Yes, this need to be applied :) Let's remove it from here and add it... (next comment) And add it here... This is more how we handle this in general :) (Both work though ) That depends on who reviews it Honestly, never seen it being done in the config flow before. diff-b2eb3cdf83d0d28d1efac13da0a16c4f5b81917c90caf278da234a26719d02deR109 diff-c6a34945c92acd3a2d0c2ac8516c50341e8aa906cc3fdfb4bd81ee3cad1a5a63R64 diff-ea9255de1cb2d5d5a53771046f2c99ea2c5518d1bc53d51f697b89f247892de4R194 My review remains the same. I think that is a better location and a more fitting more end-user-friendly message. Unless we first set self. entry data on the instance above on line 60, this line 74 modifies the class attribute entry data so all later instances of the class will see this update. I'd recommend moving the class attribute to a pure instance attribute or initialize the class attribute to None to avoid this dependency that is required to avoid a bug. Setting class attributes to mutable objects is generally error prone. Would this helper give the same result? L1201 We could rename this to async update data and not pass it as an argument to update method . We don't need to set up the persistent notification integration anymore. This test belongs in the init or platform test modules. Why? it is the config entry that we reload? We're testing the config entry reload. No code in the config flow will be exercised by this test. Leftover debug print. Where do we set the config entry unique id? We don't, this should use entry id

If you wrap this in HomeAssistantError and let it raise, the user will get a toast in the UI if this fails If you wrap this in HomeAssistantError and let it raise, the user will get a toast in the UI if this fails stale doc string is off isn't a property for the light entity. Nothing will check this properties Just realized you are using it in async turn off Can be set in init as self. attr unique id device.device id This is static and can be set as a class attribute on the MyQDevice class attr supported features 0 Can be set in init as self. attr name device.name Alternative approach You should add yourself as a code owner when contributing new platforms : 1: You should remove this line :) Oh shoot. I was more looking into what the : did as I had not seen that yet that I totally forgot about removing that line then. Just removed and pushed the commit. This is shared information between all platforms in this integration, the next PR to this integration should consolidate this into a common MyQEntity class. We should remove this. The coordinator entity already handles this by default.
FritzBoxHumiditySensor should only be added, when device provides a rel humidity value That was exactly my concern. I added the None -check. please change the indention, so that is is on same level as if device.has temperature sensor rel humidity is a field of FritzhomeDeviceTemperature , so it makes sense to check for has temperature sensor , doesn't it? that's correct, but the pyfritzhome does always publish the cumulated FritzhomeDevice class, those attribute rel humidity ( also all others ) are always available on device . The more specific classes like FritzhomeDeviceTemperature or FritzhomeDeviceThermostat are only internal used to get the lib better structured. Furthermore with the suggestion FritzBoxHumiditySensor can still be created, even it is part of an FritzhomeDeviceThermostat
Defaults should be removed We do not accept new changed platform configuration ( This needs to implement a config flow (
Stale docstring
Can we get a hold of a dump for a basic CC without target value, so we can keep this test? Trying to get one I originally kept the sensor discovery logic in because kpine thought there may be a use case for it but it appears there isn't one (Al said as much yesterday when we discussed it) so I have removed the sensor discovery logic and related sensor platform code entirely
Is it possible that data won't contain the keys WANIP and or UPTIME ? If so, this will error. Both the [IGDv1]( and [IGDv2]( specifications say it is mandatory, but not all devices implement it properly. Also, self. igd device.async get status info() can return None , in case no UPnP-action is provided by the device. (Should be, as it is required by the specs, but not all devices follow the specs completely.) Same for self. igd device.async get external ip address() . The DataUpdateCoordinator will catch the error, but I think it should be handled properly. Added coding for WANSTATUS and UPTIME within device.py to return None if the result from self. igd device.async get status info() is None. For self. igd device.async get external ip address() not an issue as it would just return None then. Within the attributes I now check and only set the attribute if it's value is not None. Further, if WANSTATUS is not None then I make the binary sensor unavailable. When you add a new platform to integrations you should also add yourself as a codeowner : 1: Both the sensor and now the binary sensor are now setting up their own coordinator, would be great to coordinate this in a shared coordinator in init Any example component I can look at to ensure I'm doing it right? Most integrations with a DataUpdateCoordinator does this, here is one that also has a custom one which might be useful here as well You already refreshed on L59 This is static and should be defined as a class attribute with attr icon "mdi:server-network" We don't define icons when we define device class This is static and should be defined as a class attribute with attr device class DEVICE CLASS CONNECTIVITY Can be set in the init as self. attr name f"{device.name} wan status" Can be set in the init as self. attr unique id f"{device.udn} wanstatus" Can be set in the init as: This data is identical to the sensor, would be great to have a common UpnpEntity or UpnpDevice they both inherit This is static and should be defined as a class attribute directly on the UpnpStatusBinarySensor class It's already specified in manifest.json , is it really needed to add it here too? The [ iot class ]( iot-class) is defined in manifest.json , which has nothing to do with the entity presentation (which the device class does) Don't add the coordinator to the device, the coordinator already holds the device
Only accumulating measurements like energy consumption should set last reset. properties The last reset attribute should return a UTC time (datetime) not a local time. Only accumulating measurements like energy consumption should set last reset. properties Code is cut and paste from Wemo's sensor ( dt was renamed to dt util to match existing Neurio import). L120-L123 The last reset attribute should return a UTC time (datetime) not a local time. Being a daily total, it resets every day at midnight 00:00 local time. Wouldn't converting to UTC would require calculating the TimeZone offset and adding it back to UTC time giving the same value as start of day? Looks like start of local day already returns UTC time so that's good. I was a bit confused by the name and docstring. We still need to distinguish between the power sensor and the energy sensor here. Only the energy sensor should set last reset . We still need to distinguish between the power sensor and the energy sensor here. Only the energy sensor should set last reset . Ok, I'll sort that out. Updated the return to this: Let me know if that's ok not ok, thx Yeah, that's ok for now. A future improvement would be to use our EntityDescription class to describe the different sensor properties. L103 Saw that one in the TPLink sensor; wanted to keep the changes as minimal as possible for speed of acceptance and since I don't really do much Python. This is static so you can set it as a class attribute on the NeurioEnergy class Please move this up above the init method definition. Note that we're simplifying calculating the last reset time in the recorder statistics so this may be able to be replaced by the new state class STATE CLASS TOTAL INCREASING for the energy sensor. This was changed a couple of days ago and we still haven't merged the dev docs update. Yup, this has landed now. deftdawg Please git rebase this PR onto the latest dev and make the adjustments as per:
Do we want to allow specifying an optional entity with the current battery charge? (device class battery ) It seems like batteries can both go to the home and to the grid. Yes, but that will be represented by the same entity. It left the battery, where it then went doesn't matter for the battery.
There is a lot of duplicate code in this PR. Can you break out some of these into functions? Untested, but this should be a bit more DRY It would be good to make it a function so it can be used in other places as well See comment in init .py Reverse the condition, return None, and outdent the block below It looks like this is always called multiple times. It would a bit more compact to accept a list of template dicts
Move this to async setup entry in init .py , and store it in hass.data[DOMAIN][entry.entry id] If they have more than one of these, the second entry will clobber the first entry. Switch this to async setup platform , and import the existing config into a new import config flow with SOURCE IMPORT
Do we need a config option? Maybe just use a sane default? "need" is defined be the user In many situations especially when trying to locate an error (in the hardware etc), it is good to have "lazy error: 0". While in production, you most times do not really care if you miss 2-3 measurements, but having a nasty 0 in your graph is disturbing, in that case it is good to have "lazy error: 3". So I think a parameter is needed. I think there's two problem areas and both have better solutions. If there's a problem with the device reading I'd adjust the reading and if there's a problem with the how the graph draws the accumulated data points I'd adjust the data vizualization. But ok. We can adjust all of these to subtract and assign in one go. Of course, done. Done.
account You could set user input as the default for each schema entry. This would not clear the fields if the user makes a typo. Title may not be allowed for unique id: unacceptable-sources-for-a-unique-id For the config entry unique ids, this is fine : 1: That link is for entities This is indeed fine, its the email address This is not needed. raise ConfigEntryNotReady to retry later on communication errors When a device class is defined, icon should not be defined. Please remove additional languages. Translations are handled in Lokalise Use native unit of measurement instead of unit of measurement in SensorEntityDescription Dang it.. Sorry for that. Was my bad, I suggested the wrong value
May I suggest you use the new SensorEntityDescription, that saves a number of parameters. Yes of course. Could you lead me to a good example which I could adapt? You can e.g. look at components skybell sensor.py that uses self.entityDescription as well as SensorEntityDescription for setup of default sensor types. Please do use SensorEntityDescription as suggested : 1: Done The icon should be None where a device class is defined Done You need to update self. key to self.entity description.key where used No need to set these when using SensorEntityDescription Remove this property and set self. attr native value in async update instead of self. state done remove this property This is not needed, use self.entity description.key instead where self. key is used This has a default of None in the base class, no need to set it here. Please type a function signature completely when adding type annotations. self. entity type attribute is no longer used.
No need to postfix this. No need for a local entities list here since it's only 1 you can just call: async add entities([GSMSignalSensor(hass, gateway, imei)], True) SensorEntityDescription would make this cleaner I doubt black will like this format, but you get the idea This seems to be a number
If we already have a valid area from the above, we could save ourselves a little by not trying to resolve the rest? I was trying to be clever and handle use cases where an area name could match a device ID or entity ID, but I suppose it's not worth trying to handle those use cases? I think one has a better shot in buying a lottery ticket Only wrap the function that can raise. Only wrap function that can raise I don't think that we need this guard. Just seeing if it exists is good enough. That also means we don't have to update this code if device ID would change.
This logic doesn't look correct. Looks like it should use or . It looks correct to me. if siren.available tones and (tone in siren.available tones or is tone dict value) is True, that means the tone provided is valid. The not at the beginning means a False evaluation on the paranthesis block will raise an error We also want to raise if available tones is falsy. At least the old code did that. I think what's tripping me up is the parenthesis. We should just drop them and write the logic without them. Drop the last parenthesis too. Reading from left to right in one go is the easiest. I personally find it less readable without the parenthesis but maybe that's just me
Not sure how this is implemented, but entity description is not a method but a property. Generating entity description here doesn't add value IMHO and only adds complexity. Either define the entity description before creating the sensors entities (create entities based on the descriptions and pass the description into the entity), or use regular property methods. It's much preferred for readability to use a declarative approach and define all of the entity descriptions separately in a constant container. Then just iterate those or look up the correct description based on the description key. Yeah so this is my bad. Fronius has an adapter pattern and so when I was adding support, I had the adapter generate the description for the key that it represents. It's all a bit messy really and I think the adapter pattern should be removed. Moved the definition of the properties "last reset", "device class" and "state class" into the sensor class with correct property methods. Let's calculate this inside the constructor and assign it to self. attr device class Remove this in favor of attr assignment above constructor
This could actually be solved in the exact same manner as "state class" and "device class" which would also be more precise for future changes: all sensors appear to me to be measurements, but not all of them are meters. Good point, was already doubting to set it up this way on the initial commit. Is implemented this way now. Please rebase this PR onto the latest dev branch and make use of the new state classes for this. See: This is no longer needed with the new state classes
This is not a good default as this only applies to metered entities. This is now also applied to the power sensor, which doesn't reset.
This is only used in sensor.py and should be moved there How is attr native connected to state ? Since it's handled in the SensorEntity base class L158-L161 L193-L236 The signals should be prefixed by the domain Will be fixed by: issuecomment-894207201 Not for the new signal added in this PR Should both these be enabled by default? I think the activity time and battery level are very important values. At least for me :) Is this correct? tracker details[" id"] is used in the device tracker entities Yes, activity update message doesn't contain tracker id but contains pet id ( self. trackable[' id'] is pet id ) which is used as id [here]( L153). This is probably a great time to add a shared TractiveEntity with the attributes that both platforms use. You should add yourself as a codeowner : 1: Done Does it make sense to move these constants to const.py ? It's only used here? What if we move class names TractiveHardwareSensor and TractiveActivitySensor to the entity descriptions? It will make it possible to remove the event type checks description.event type ATTR HARDWARE The types tuple should look somehow like this: And the setup: WDYT? Good idea. Make it private? This can't be private, it needs to override the base class Sorry, I don't really get it, the base class TractiveEntity does not have entity description , and even if it had, nothing prevents it from making it private, there is no access to this attribute outside of the self context SensorEntity has it, and SensorEntity uses self.entity description to set properties correctly (same with Entity which SensorEntity inherits) Ahhh, I didn't know it's a part of the generic interface, sorry. This is not needed, TractiveEntity should inherit Entity and should set self. attr device info instead of self. device info
I thought that we now have a standard const, if that PR is still floating we should wait, in order not to do double work. Its still floating. I can add Modbus to use the global const PR once this is merged. Its this PR or the other, one has to be changed... but I think it would be nice to get this in 2021.9 even if the other doesn't make it - regardless of where this constant is saved. It would be nice to have a default and not just None In KNX it shouldn't discussion r683016047 I just did it same here, but Modbus may be different as it doesn't allow string values afaik. What would be the right default state class then, measurement ? When a user doesn't want the entity to have a state class for whatever reason I'd have to change the schema to accept None . Modbus allows string values! Leave it as it is.
device and coordinator will probably always be the same regardless of model.
For some reason, dhcp is running mac addresses twice. Once with the full 17 characters, once where 0s are actually missing, leaving a different unique id based in the mac address. This occurs whenever a mac has consecutive 0s. Can we do additional passive probing and abort if its not a TV? I am really hoping that is the case but I have not found a solution. The only amazon device I have with the amazon hostname that is not a tv is a kindle. My echo has no hostname so that will rule out a bunch of them. We should abort if its a kindle and they shouldn't get a discovery notification Can this be moved to the library? I mean it could but I don't control the package. engrbm87 will have to do it. No answer to my previous PR: This also uses a port that has nothing to do with it. So I think it wouldn't even belong in that package. 8009 is the port labelled as ajp13 according to nmap Every firestick afaik has this port open. This is not logic we want to have in Home Assistant, this belong in the package. This is a good unique id, but it needs to match the one in async step user diff-f8d463c40af97731fd51b0787e990ed01d6693cb488dd4f66a2a5b8135753176R59 unique-id-requirements I know this is existing, but its a problem now because of the discovery. This doesn't look like an acceptable unique id unique-id-requirements Yes, it is but that's why we have DHCP discovery check for existing entries. If one is found, the unique id changes to the mac address. The mac address exists in layer 2 so we only see it via DHCP. If the user tries to add an entry, it aborts even though the mac address obviously never matches the ip. There is no better unique id available for the user step. Non-internal integrations are not currently allowed to depend on others at all. So I can't compare an entry from say androidtv . We shouldn't see the unique id to host though. Its better to not have one than to have an unacceptable one We should enumerate current entries and look for CONF HOST in data instead and set it instead I don't think this PR is a good idea because now we suggest an integration that relies on a third party app if we detect a device that is compatible with the app
Instead of adding things to this tuple, please use SensorEntityDescription, see for example Instead of doing this, assign the entity description to the entity and this will work automatically. No need for adding defaults Replace the use of self. type with self.entity description.key , allowing to remove this variable. This can be set as a class variable instead (removing it from the constructor) Isn't this sensor going up all the time? (As in, summing data usage) Should it be STATE CLASS TOTAL INCREASING? Isn't this sensor going up all the time? (As in, summing data usage) Should it be STATE CLASS TOTAL INCREASING?
last reset should only be used for metered entities. And if it's static, why not add it to your sensor description object? Just address this, and we can merge. Just pushed the requested changes. We have a new concept to define these sensor descriptions, which integrates with the entity base class. See for example The new description seems nice, but this would lead to a bigger change. I don't know if this is desirable because bigger changes seems to take longer to be merged. I'd also like to have this on the stable release channel as soon as possible so maybe this change could happen in a future PR? We did a release yesterday. The next stable release won't happen until first Wednesday of September. I just don't want to stick with a not working integration for a half year or sth. Waiting a Month isn't that big of an Issue... Furthermore, aren't there any minor releases for exactly such patches? The suggested refactor, to use EntityDescription, can be done in a follow up PR. This is already available here: L70 oh, well. I will try to change it to these then. done Please remove this constant. It's not needed. We use None to represent no state class set. Please don't change the formatting of unrelated code. I just used black as required in the PR checklist... Looks like you've removed a comma after plenticore . That's why it's reformatting this line. Please revert the formatting change here too. And here. And here. Is this really an accumulating sensor measurement? What does this measurement represent? Oh, sorry, I see that the Unit is Percentage which wouldn't make too much sense... Fixed. Same question as above? This will return a datetime. It produced linting errors on the last run, that s why I changed it Ig we just need to import datetime
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
Do these also use ppm unit? Usually g m . Yep, g m . Will update the comments and check out the CI errors. Actually homekit specifies O3 and NO2 as densities in g m , so I will dig a bit more into that. We should be able to convert between the 2 ( If ahayworth is still interested in this he might have some input on what to do here as well. I am no expert in this field but I recently became very interested in this functionality in HA and started looking for a good source for my area. During my reading I saw that some countries use ppm, others ppb, and some g m . To link it to this point, I read that the conversion between ppm and g m isn't straight forward, as density is a function of temperature and air pressure. I definitely got the impression that ppm is most commonly used for NO2, SO2 and O3 but not always. Btw, the link above also states: Also, atmospheric temperature and pressure affect the calculation. Perhaps where conversions are done, some average assumptions would need to be made to keep it simple. I also think the units might be localised ([see]( e.g. how Australia uses ppm for NO2 but the UK uses g m ). Have updated all of these to g m (aside from AQI, which is unitless). This is after a review of all existing air quality sensors. Where I could find documentation (6 out of 9) they used g m . ampio seemed to be down so i couldn't check its API. dyson is undocumented, but based on the measurement to AQI conversion happening in homebridge-dyson, it looks like g m blebox has a well documented API, but don't give units. Again, based on their AQI conversion the values seem to be g m In terms of re-exporting the sensors, Alexa and OK Google don't know about these classes. I don't know if Siri can act of them but Siri is aware of them via the HomeKit bridge. Just like homekit controller, this is also g m . So I believe these are the correct units now. If ahayworth is still interested in this he might have some input on what to do here as well. I am generally still interested, but I have no strong feelings on what to do here, unfortunately. I was worried that the device classes here would be totally inconsistent unit wise when I tagged you and wondered if you could remember anything from your own review. But from the one I have just done, I don't think there is anything to worry about for these classes and the values above are good. (There are some completely non standard device specific classes in there, but out of scope of this PR) I think that the entity needs to have a unit of measurement to work with device conditions. How do we solve this for AQI? Is the best thing right now just to not have device conditions for AQI? It looks like it's not mandatory for a device class as MONETARY doesn't have it. Alternatively I could amend async get condition capabilities to allow unit of measurement to be None . In that case, suffix could just be an empty string? If that's the route we want to go down i'd probably pull the AQI device condition out of 
What's the use case for adding node id to state attributes. We've discussed this a couple of times already and always concluded that it's not needed.
I believe you don't need to define the property (it will take the state class from attr state class Ah yes, true will fix that. also apparently my git hook is gone ski have to fix that too
this config validation is wrong. Need also match with the min, max The underlying library clamps the provided value with a setter. What is the best choice here. cv.small float is my assumption but the sonos setting has to be a whole number from -10 to 10 and of course small float allows decimals. My first contribution please feel free to point me in the direction of docs for a way around this Swapped to int You could take it a step further and restrict the range as a validator: I think i already stumbled upon that above. Seems a better way. Thanks! pvizeli Would this be better as vol.Optional(ATTR EQ BASS): vol.All(vol.Coerce(int), vol.Range(-10, 10)), ?
This is already added to yield total , any specific reason for adding it to this one as well? No, no specific reason, I was under the impression that all sensor that start measure in the past and update now needed this last reset . But for the energy component, I assume only one is fine (one for consumption, one for solar production). And than the overall production would make the most sense, I agree. Removed this one. This is already added to consumption total , any reason to add it to this one as well? Removed You don't need to set those. Removed With the entity description, you can remove this method. Kept the combination of device name name as the name of the entity, as it is easier to identify the solarlog sensors, preventing confusion with other energy sensors. with the entity description, you can remove this method. Removed with the entity description, you can remove these methods. removed The arguments don't match the call above. Probably happened with the last change. Not necessary You could use description instead of self.entity description here. Changed con should not be set when device class is defined. Removed them, except for the solar sensors. I think it would make sense to have different icons for consumption and for production. Is that ok? Use device class or icon , not both But with only an icon, will the new energy feature still work? I though the device class needed to be set. Tested it, works fine without device class. Fixed the remaining sensors by removing the device class or icon. Don't do partial typing, do all of the arguments or none of them I don t understand, I see that they do the same in e.g. dsmr-reader and growatt integrations. Which should be changed as well Should be fixed now. Don t I need this for the device info? I use self.entry id there as well. Changed
This is unrelated and should be changed in a seperate PR I do not have any idea, why I've changed this ahh ... python -m script.translations develop does this change ... but as I understand, this should not be done Probably need to rebase your branch rebase does not fix it ... however, I will re-fix remove it again ... here as well :) my bad, this was accidental changed during solving discussion r689853224
You can shorten a lot of these properties by using entity-class-or-instance-attributes Should I do it for all properties like: tests doesn't like that I delete self. name :sweat smile: I didn't find a way to keep switches tests with disabled entities by default :( Mock the entity registry, register the switches, and then enable them so they appear an are testable. There is a mock registry that you can use from tests.common thanks bdraco , done : 1: We should move available into a base class since all the entities share the same value for it. There is the ConnectionStateMixin class I transform it in HarmonyEntity class : We should move this into a base class since all the entities share the same value for it. Unique ids are per integration platform so you don't need to prefix here since there is only one select entity per unique id If you type any of the arguments, please type the whole line Looks unused Looks unused
We can extract this whole part until we get the bridge to a custom voluptuous validator defined inside async setup entry . Raise vol.Invalid if we can't return a bridge. Please only wrap the line that can raise in the try... except block. Our current standard is to raise errors in service handlers on error. Eg here we can raise a HomeAssistantError. next can raise StopIteration if it doesn't find a matching item, if we don't set a default value. We only want to raise vol.Invalid from this function. The default doesn't match the validator. Pylint will probably complain here that we don't raise from .
Please avoid ternary operator expression if it spans more than one line. Why aren't these separate sensors? I might remove them. They don't really accomplish anything apart from splitting up user, system and idle load We could make them separate sensors and disabled by default? Only set last reset for accumulating sensor measurements. We like to avoid ternary operator expressions when they span more than one line. It would make it a lot more readable if we used EntityDescription for these things. We could define a formatting lambda that we store in the description. We would probably be able to drop the subclasses here then. Eg: L81-L88 We already have entity registry enabled default in the parent class. Commented code. Usually it's enough to set the entity description attribute on the entity. The Entity base class will look up the description for name, icon and enabled by default, etc. Only if we need some custom logic applied onto the description, we need to pass the parameter explicitly, eg for name in this case. Eg: L399-L406 Binary sensors should implement the is on property or the corresponding instance attribute. properties Please define the descriptions in the corresponding platforms where they are used. These are platform details. Please only set the attributes where we diverge from the default value, eg None in this case. This is the default. We could consider catching TypeError in the native value property instead to clean up the lambdas here. This should use the update device class
The new service doesn't take any data parameters so we don't need to specify a validation schema. Removed. A side note: Should I be ammending my previous commit or adding a new commit when make changes to a PR ? Please just add new commits after review has started. Amending or squashing makes it harder for readers to track changes. We'll squash when merging. Thanks!

We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries.
Should we catch ValueError ? If we don't catch it we get a log dump added it I think we need a parenthesis around the jpeg or jpg checks. operator-precedence Good catch, that would have been very difficult to track down later. Looks like we have no tests for non-jpeg cameras. I'll work something up
That is the default. Should I not override default class member with attribute member? This is adding simulation assumed state. The action is used to what it is doing vs what it is set to. However, this change does not make that difference. Adding this just because there are some integration (e.g. HomeKit) that use HVAC ACTION to determinate and reflect the status (in detail the icon color) of associated devices. I understand the difference between ACTION and MODE, but inspecting the code I see that many other climate integration implement also the ACTION just reflecting the MODE so I thought that is should be useful. I can close this PR if you think that this is wrong. I think that is a HomeKit integration thing to solve in that case? Feel a bit weird to add something that is not true to fix HomeKit Understand your point, I was just following behavior from other climate integration. Let me just say that information provided is not wrong, e.g. when Melcloud climate is in Cool mode for sure is Cooling (at list for my devices do not exist an Idle state). So should we close? Let's get a second opinion on this. Waiting for second opinion, I think about this on this days and I review behavior of others climate entities. At the end only Daikin do something similar, and anyway try to identify an idle state if the model support this information. Probably provide this property as pure duplicate of HVAC mode does not make sense, may be HomeKit integration should be fixed to use HVAC mode when HVAC action is not available.
Please remove TODO comments from your code. Please remove TODO comment commented out line below. New integrations should not offer a YAML configuration possibility, just a Config Flow. See decision. Integrations that communicate with devices and or services are configured via a config flow. In rare cases, we can make an exception. And if you would need get this exception, the way you currently set it up is not allowed due to ADR 007. See decision. thanks for pointing out. removed all YAML configuration code I am not familiar with I2C, is it always configured with 8 ports? Or did you just use this as a common example? The PCF8574 has 8 GPIO's yes the PCF8574 has exactly 8 GPIO's and this integration is specific for PCF8574. That's why i hardcoded it with 8 switches. in theory this integration can also be used as binary sensor. Do you have any idea how I could write the config flow sequence for that ? I could create one boolean per GPIO to define input or output , but that would look messy ( 16 options on one page ) ? what do you think ? There is a nice blog post ( that shows how to loop config flow, so you could do a loop for each GPIO, but I'm not sure if this would be the best UX. Maybe in the first step ask for the I2C address, port number, and the number of switches and binary sensors. If the user will enter that he has at least 1 switch you show a form with inputs asking for switches names, if he entered that he has as least one binary sensor then a similar form would show but for binary sensors. So you would always show the first form, then second, and third depending on values from the first step. What do you think about such flow? thanks! i've no split it up into 2 to 9 steps. step 1: i2c parameters step 2 -8: configure each pin, and define input output, name, invert logic each pin gets a unique id and therefore the name can be changed later. is it also possible to change the invert logic parameter afterwards ? is it also possible to change the invert logic parameter afterwards ? You can use OptionsFlow for that - Please remove keys you don't use. (and for the others below) Can a unique id be set, if not removed the already configured string. unique-ids I'm using config entry id as unique id. Can I use that for the already configured check ? If not I'd just remove that string Can a combination of i2c address and i2c port num be used? Is this unique? I'm using config entry id as unique id. Can I use that for the already configured check ? This comment is about the ConfigFlow unique id not an Entity unique id. You can't use a config entry id because it is random and generated at the end of the ConfigFlow. thanks. that is a good idea. I changed everything in 6abcca8e4f5436fa42e39840a841e799978b19c4 and now the error message is displayed when you try to create a second integration with the same i2c address and i2c port num Use the self. attr name attribute instead of the property. entity-class-or-instance-attributes Change the other properties
Please avoid ternary operator expression if it spans more than one line. The base set mode humidifier service will handle checking supported features. Side note: It would be good to add a corresponding check to the base humidifier integration service handler. Raise ValueError if invalid mode is passed in the service data. device features is not defined for this case. Why do we need this feature check when we have a model check above? We iterate elements from SELECTOR TYPES (all possible select entities for all humidifier models) and check if this element feature is supported by the model. Is that the wrong way? Ok. But currently there's only one selector, so we don't really need this. Yes, good point, I complicated a simple thing. Tested the code with a real device model zhimi.humidifier.ca4 . All seems working well. We never use the coordinator variable. It's confusing to call this service when it's not a separate service. We're also incorrectly registering a service for this case while that service won't have a corresponding entity that supports it. But we don't register set led as a service. We use this to call appropriate method here: L440-L456 Services mentions here are refering to backend services. WIth the new impementation we remove the custom integration specific sevices and make use of the generic platform services. Right, that's how it's used for the coordinator entity. But a service is also registered in the other entry setup. And that service will basically be a noop. The coordinator entity provides the sync with the backend state. Where changes are, like a switch toggle is perform by the user, the change will be changed offline form the backend state. This avoids unneeded io to the backend. jbouwh I'm talking about the services that are registered for the other entry that doesn't use a coordinator. It's using this same constant to do that. It's confusing and incorrect to mix these two different cases. jbouwh I'm talking about the services that are registered for the other entry that doesn't use a coordinator. It's using this same constant to do that. It's confusing and incorrect to mix these two different cases. We have made an special class for coordinator based devices here ( XiaomiGenericCoordinatedSwitch ) and will migrate all other legacy classes to use the coordinator. I used SwitchEntityDescription class and removed "coordinated" switches from the SERVICE TO METHOD constants. What do you think? Nice! This looks like a constant that can be defined already at module level? Do you mean not getting a mode list from the backend library but defining it as a constant? MartinHjelmare I agree with bieniu. The backend is suppling the available modes. Let us not redefine those in the integration constants. This is consistent with the supported existing models. I mean we can do the list comprehension and store as a constant at the module level. Then just use that constant here. Side note: Would be nice to update the humidifier integratio
Limit initial PR to 1 platform. Move this to async setup entry so async setup can be removed. Use entity class or instance attributes instead of properties if possible: entity-class-or-instance-attributes This was moved to the manifest. Not used.
Good catch
This is done automatically Ah ok PowerConsumptionReport is historical and is not current measurement. It should not be classified as STATE CLASS MEASUREMENT shoot I must have glossed over the start and end I mean it still increments over time, and from what I understand is the energy dashboard would take the data from 00:00 to now to display it on the dash, even with a delay wouldn't this still be viable? the energy dashboard would take the data from 00:00 to now Yes, but what I'm saying is the PowerConsumptionReport capability is a report of utilization in the past (from start to end ), not a current measurement. Per the HA Sensor Entity docs: Examples of what should be classified measurement are: current temperature, accumulated energy consumption, accumulated cost. Exampled of what should not be classified as measurement: Forecasted temperature for tomorrow, yesterday's energy consumption or anything else that doesn't include the current measurement. This capability should not be classified as measurement because it dones't include current AND is in the past. If end now, it is measurement, because the sum includes the current value. If end now, it is not a measurement. We currently don't have the option to import historic data. balloob here's some sample data from one of my devices: The data is captured in 15min intervals. So the data is from 15mins ago. Similar to polling every 15mins for updates. This implementation is only exposing energy when the capability has 4 other useful data values. Perhaps add a constructor parameter to indicate which sub-attribute it's representing, like ThreeAxis does. than replace POWER CONSUMPTION REPORT NAMES[self. index] by self.report name in SmartThingsPowerConsumptionSensor this will solve the pylint error ... sorry, my bad in discussion r680403974 You're not setting state class or last reset. We need those to be useful for energy management. long-term-statistics Ah that's because of the end being set, and so it not including current data.
Test that a bad topic template does not publish, for example a template trying to use a non-existing filter "{{ 1 no such filter }}" Thanks, I've added a test for this type of issue. We need to catch homeassistant.exception.TemplateError too
Why not reload the integration for them? Refactored to validate the URL is connectable and then automatically reload the integration if it succeeds. Does it make sense to update these in the options flow instead? Moved this to the config entry.add update listener handler instead where it will react to changes to the config options: diff-d9439a9617b5e18dd5b41e6744f3a8c5fbca3d8542cf3e98d2e2feefca60dba0R241 There might be a cleaner way to move this to config flow.py , but this was a bit more straightforward. Why allow the user to pick? Why don't we just take the best connection that works ? That's how the website works too. During initial setup it will still choose the "best" option automatically. However, sometimes that choice is not ideal because of network DNS configuration. Or perhaps the "best" connection was not available during initial setup and a fallback choice was used. For example, I've seen users that have unintentionally been routed through a cloud relay to connect to their local server. The alternative today is to have the user switch to the advanced fully manual config flow. This method at least provides a list of discrete options. Why would we store the best way to connect during configuration, and not during startup ? The CONF URL is the definitive source. Since other config options may be changed at the same time, we write the new config options and then immediately check if the new URL has changed in the config entry.add update listener callback in init .py . If a test connection succeeds it's promoted to the new CONF URL and the integration is reloaded. If it fails to connect the config entry option is discarded. Sorry, I meant: why not try to find the best available URL during setup of the config entry? It's not necessary to change the address for the vast majority of setups, and it's still possible to get it "wrong" if a user has a specific preference. For example, they want to ensure they're using a plex.direct address so they can use a secure connection, or they want to use the local IP because they never want to rely on DNS. Can we avoid the broad except handler here? I'm not sure I can provide an exhaustive list for all network-related failures. If an unexpected exception occurs the config could be left in an unexpected state. Should we leave the title as-is if they have customized it from the original default? That was my original intention but that's not what this check does. Will revisit. Can this be broken out into a separate function?
So all Zigbee consumption devices never reset their consumption value? I asked Manuel and he said you need to reset the device. Which implies re-pairing it.
Only energy has a last reset as it's a metered entity (always increasing value). Power is the current throughput. yeah, as usual you are fully right Can this measurement be described with device class power? We have a signal strength devise class for sensors. Device class voltage? DEVICE CLASS CO DEVICE CLASS CO2 DEVICE CLASS ENERGY The signal strength is normally measured in dB. L533
We need to restore the last reset as well as this integration restores state. Let's say it restores 100kWh as a state on startup, and the timestamp would be epoch 0, than the 100kWh is accounted for fully right now. Is that needed when it is constant? we are putting too much energy logic into this integration.... Is that needed when it is constant? It isn't constant. As it restores (which can fail, thus, is a reset). So I would expect this to set the current time set as a default (like state is set to 0), overwrite the attribute with the restored value together with the state value that is being restored. That way, it resets nicely when restoring fails (or when first put to use). we are putting too much energy logic into this integration.... Well, energy is a much-used current example due to the release, I'm happy to talk about 3m gas in my further communication? Doesn't change a thing about this PR or comments. my point is that last reset is not a concept associated to a generic integration such as this one. little bit of history: the code in this integration initially was part of utility meter, but was split exactly to make it generic my point is that last reset is not a concept associated to a generic integration such as this one. It is actually. No matter what is being integrated here, it still has the statistical value, which is what last reset powers is helping to indicate. ? Where is this one? Ohh, was part of an earlier version. Will remove parse datetime will return None if parsing fails. Not 100 sure, but I guess you could do this: Although bit less explicit maybe, so maybe not... feel free to ignore :) I like it :) we should be able to restore device class together with last reset this is determined by the device class upstream? Why should it be stored restored? it might not be set until you get the first state update ? True, added a suggestion above (I guess it will appear below :P) that implements that.
This extends the monitored conditions of this integration, which is no longer allowed to be extended. See: Instead, this integration should be adjusted to remove monitored conditions (or even better: Update to use a config flow as per ADR-0010). Done, removed monitored conditions. I'd like to delay tackling switching to a config flow for a later PR if at all possible. I added a second commit to make the integration automatically setup its platforms, at which point the only part left in configuration.yaml is: and everything else gets set up automatically. Happy to merge squash this commit into the first one if this is desirable (or drop the commit if undesired) We should only call add entities once. Build up the list and then call it. Done Instead pass True as the second arg to add entities (update before add) Done Same comment as above Done Same comment as above Done I'm pretty sure this is going to break existing users who have CONF MONITORED CONDITIONS configured since it won't be a valid key anymore. I think we should leave it and mark it as deprecated instead. This is a bit of a gray area though depending on how ADR0010 is interrupted. Changes to existing YAML configuration for these same existing integrations, will no longer be accepted. I'm not sure deprecating it constitutes the intent of a change though. It does make it easier to convert to a config flow as its once less thing to worry about so I'm kinda OK with, but I'm going to ask for a second opinion as I don't want to make the decision in a vacuum. This integration should really move to a config flow soon per This is correct, this makes changes to YAML configuration without introducing a configuration flow, which conflicts with ADR-0010. A config flow should be introduced instead. Do either of you two have links markdown examples of how to integrate with the configuration flow? That ADR does not make it obvious. The ADR is merely a recording of the architectural decisions made for Home Assistant. Information on development can be found in our developers documentation. Additionally, we have many many example in this repository as well ( ) It is often unclear to me what the types and therefore what methods exist and or return values are, so I just wind up opening a lot of files with vim. In particular with the config value that gets passed to setup() . Hmm, maybe is a decent place to find this information? Let me know if you have a better suggestion. API docs can be helpful, but won't tell a story.
Side note for the future: We should look at using the new EntityDescription class to describe the different kinds of entities and map that to some id that we can look up. At the end of entity addition the entity state is always written so we don't need to do that explicitly here. This doesn't need to be a coroutine function since we don't await inside. Make it a callback .
This is a summing sensor, so it requires a last reset attribute if used together with state class . When only setting a state class (omitting last reset ) is represents a current value, which this is not. Got it. I don't think we can get the last reset with the python-broadlink API. We could track when the state goes to zero and get a timestamp there, but it is kindameh. Ideas? Am I missing something? That can work, this is how ESPHome does it: diff-048f0119fa5f4366e564de0089275f935fbeecc3e0ba937d0a435c6e5cac8e41R78 Please note, this does require to restore a state on startup I made a working sketch. Mind to have a look? frenck Hi. Just to confirm. Now I just need to mark the sensor as STATE CLASS TOTAL INCREASING and the core will handle the accumulation last reset automatically? No need to answer, I found it [here]( It's much better now. Thanks to whoever worked to bring this feature to the core. The body of this conditional is never reached in the current implementation, but I thought it would be nice to have. We cannot test it though. Keep it or remove it? How much precision do these devices offer? Do we need to round these to avoid the same issue as 56999 ? Here is a response from SCB1E: We divide these values by 1000. That's 3 decimal places, the current will look like: 8.169 A. Should we round it? I'd watch the device and round it to whichever amount of digits does not generate frequent state updates when the load is relatively static. Its all going to depend on how good the sensor is. I don't have the device to test, but 3 decimal places should be ok imo, that's the accuracy used in the official app. We can round up to 2 if it becomes an issue.
Should these friendly name attributes be keyed to strings so that they can be translated? You might even be able to reference existing strings in the generic sensor component, eg: "[ key:component::sensor::device automation::condition type::is power ]" . We don't currently support translating names of entities. Adding support for that is out of scope for this PR. Ah. Never mind then. You should raise the Config entry exception. Is it just possible to skip them for now assuming they will be discovered in the future again? honestly I simple copied the prior logic and do not want to also change this in this PR But yes, I'm with you, that this must be improved ( with an upcoming PR )! Last reset should be an isoformatted datetime string looks now like ![image]( We got some cool new helper classes just for this! With that class (which you can extend if we don't cover everything you need), you can also just set it on the entity and the entity base class will figure out the static vars: nice ... will try it Total and today's consumption also include the current measurement. It is needed to be picked up by the statistics. off-topic based on this hint, I've also adjusted the "Total Energy" sensor on fritzbox platform ( 53707) Please don't use switch integration attribute constants to describe sensors. Define attributes in the sensor platform instead. I'd move this constant to the sensor platform to avoid importing from the sensor integration here. That latter is the responsibility of the sensor platform. Please use hass.async add executor job to schedule jobs on the executor. hass.async add job is legacy for normal use. Please don't assert integration details like hass.data in the tests. Assert core state. writing-tests-for-integrations Don't patch our code, patch the library. Check the precense or absence of this entity state in the core state machine instead.
I think we should wrap this in self.async on remove so it gets unsubscribed when the entity is removed? Done It would be slightly more efficient to remove the indent and make this def check last state(self, event: Event) - None: since it wouldn't have to recreate function for every entity Done Don't track state, but instead use a method override on the update callback. That update callback currently does not exist, so add that: - Add method data updated to EsphomeEntity and use that as dispatcher callback - If last reset type is set to auto, override it: Got rid of this because on state update was the only reason it existed in the first place (for camera ). Now that we have it in the main EsphomeEntity class, I see no need for it anymore We can use contextlib.suppress . contextlib.suppress Should this represent epoch 0? Then please use util.dt.utc from timestamp(0) . properties Times in the state machine must always be UTC time. Please use util.dt.utcnow . Does it matter if it is significant? Let say, It was 0.5Wh, now it is reporting 0.4Wh... Yeah, I agree. Will change It's nice to define class attributes at the top of the class body.
In a follow-up PR we should make the MQTT alarm control panel only report features that it actually supports.
These can be removed since they are empty. Thanks. Whilst I'm here, would you be interested in co-owning this integration with me? Yes, I would be happy to. In a funny turn of events, I know the person who wrote pyaussiebb IRL and speak to him often, and he has offered to add features to the python library if we need them. I submitted some recommendations for this file at Use CONF USERNAME and CONF PASSWORD from Use self.source : Move the client construction out of the try block This has now been implemented. What type of services is this and why is a user allowed to control this? So a service can be a internet connection at a premises, or a mobile phone collection. Each "service" requires a unique API call to retrieve its data, so instead of assuming the user wants the integration to poll for data from every single service they are given the choice at setup, and using configure. As it does require extra requests, I believe it meets the requirements of that Architecture decision. That it does, just wanted to make sure : 1: Move the coordinator construction to the init file, this can be shared between platforms This has now been implemented. Implement SensorEntityDescription to define these kind of values Both of these private properties are parts of attributes like name and unique id, but are not themselves members of SensorEntityDescription. Do you mean I should replace these from the parent AussieBroadandSensorEntity class? self. attr unique id f"{service[SERVICE ID]}:{self. attribute}" self. attr name f"{service['name']} {self. name}" Or are you suggesting I remove all the classes and abstract this async setup entry? If so how should I deal with the variations in how state is handled? EntityDescription is our new way of defining values that goes into entities, if you use that here, you can probably get away with just 1 sensor class. Here are some recent PR's that have implemented this So I am having issues using EntityDescription: - The sensor name includes values from the service object, so does this mean I need a create a unique SensorEntityDescription for every single entity in my loop, or can I still override this using attr name? - The state values for many of the sensor are slightly different, so if I don't have unique classes for each ill have to add if then statements to make sure I am reading the right value. Some are just a key, but others are two keys deep. Ill review the other implementations and do my best. You can still override if when needed with attr This has now been implemented. methods should not be partly type annotated. You might need to add type: ignore[no-any-return] or return return True instead of self.client.login() as the lib is not typed. self.services could also be initialized as empty list instead of None [] would account for self.services None too. its not 100 clear to me where self. reauth username comes from - especially if user input None . But I haven't had to deal with auth and reauth yet. Its presented in 
Let's disable this sensor by default ( entity registry enabled default False). Please use the official class attributes instead: entity-class-or-instance-attributes To clarify, you mean use something like the following? (It's a bit confusing as the property method does not do this.) Yes, exactly. Here's the implementation: L334-L341 This should be a separate sensor with device class voltage. Where is this method used? I assumed it was an internal method - it was in the reference implementation I was looking at when I first started on this. Looking at it now, I see it's not used, I'll remove. Side note for the future: It's not very efficient to make multiple calls to async add entities . It would be good to refactor this so that we only need to call async add entities once per signal. Please use our common constants as much as possible. Here we should use this one: L505 Funny you say that, when I started doing this (nearly a year ago), I was using them - but they got removed from const.py somewhere along the way and I needed to [stop using them]( I'll put them back as they have hopefully settled down a bit now. L416 L533 Please inherit SensorEntity too, imported from the sensor integration.
Do you remember why this was added? It's never set nor does it seem to be something we should make part of discovery info. I've used internal external URL as the base template for this change, as it provided me all the spots that needed change... except for this one :) Removed in 54478
This can should be a tuple of BinarySensorEntityDescription OK, I modified it. This is never set, the icon is None in both binary sensors OK, I removed it. None of these 2 are used, why add them? OK I removed it None of these 2 are used, why add them? OK I removed it Don't set None for any keys in the descriptions, those are the defaults. OK, code removed. Remove this property OK, code removed Remove this property OK, code removed Remove this property OK, code removed You only need to pass coordinator and description The coordinator object has a config entry attribute with this extra data OK, code removed Remove this property OK, code removed You only need to pass coordinator and description The coordinator object has a config entry attribute with this extra data OK, code removed You need to move the rest here in under the if as they use flipr id OK, done. If you add the entity description to your base class this if check is not needed, since you can do this logic in the base, and you would just pass the full coordinator and description objects to super here OK, done. Set this in FliprEntity and you can remove the init from here. OK, I removed it and set it in FliprEntity. Set this in FliprEntity and you can remove the init from here. OK, I removed it and set it in FliprEntity.
Do we still need to poll? This handles the reconnect, unless there are better options? The listen task is probably where we need to catch the connection closed exception. A coroutine function is not a callback. We should probably only create a single client instance and not two. We've already created one in async setup entry. Please add a link to a changelog or GitHub commit compare view for the version bump in the PR description. Thanks! Added to description Please put hass as the first parameter in signatures where that is present. The default message already contains the title. L300-L312 Note that this will only work when we're inside the config entry setup phase, not afterwards.
Can you render the template in async added to hass instead which would mean self.hass is available? Not easily, as this method is called as part of the constructor before we even get to async added to hass , and these values are required and passed into the superclass constructor. In this case, I don't think not having access to the HA state (which homeassistant.helpers.template would afford) is remotely a problem, as this template will very likely only be used for basic string substitutions. Actually I forgot that you can use homeassistant.helpers.template.Template since it works with hass being None Nope its actually broken and we don't seem to have a test to cover it
Reverse the condition, return, outdent below We don't use HomeAssistantType anymore. Just HomeAssistant from homeassistant.core Also it shouldn't be needed here since mypy should be able to figure it out since its on the constructor itself. Doesn't really save much in this case, but we usually write these like this If the config entry is missing, we should return right away. Assuming we have a guard that returns as soon as the config entry is missing Stale doc string We're not allowed to use a media class constant for the media content type. The media content type is not the same interface. We prefer f-strings as far as possible. We can create an f-string for the right hand side here.
How do you get here, I don't see this in your data schema? CONF AUTHENTICATION is derived (hashed) from the CONF PASSWORD in user input OK, that makes sense, thx for clearing that up for me. Same question as above, not in the schema, so how does this get called? CONF PORT is for testing server emulation on localhost (as comment suggests). Such a server is created on an ephemeral port on the test machine. I feel like in most other integrations, the internal classes used for things like this are generally named IntegrationSwitch or IntegrationDimmer. Should probably rename these to be more consistent with other integrations. Just mark the ones you have fixed in code as resolved, so that only the outstanding ones remain. changed Switch to LegrandRflcSwitch and Dimmer to LegrandRflcDimmer Just mark the ones you have fixed in code as resolved, so that only the outstanding ones remain. Sorry, I am still learning the ropes. I believe that I have resolved all your issues (some of which, I believe, were not issues at all). Please let me know otherwise Indentation looks broken here? (tab?) fixed indents (2 spaces) Please update the comment to explain why hass.async create task is not correct This is also the reason for asking questions about if things are called from Home Assistant's event loop or not. Is reauth called from Home Assistant's event loop, or does the hub have its own loop? Why is this guarding needed, when can't the discovery info be trusted? Should these checks be moved to the DHCP discovery code instead? Is this comment generic for what's needed for any integration's DHCP discovery to work? Maybe name it LegrandRflcOnOffLight instead You need to list the supported color modes: Is the return value of host() truly unique and can't be changed by the user, (serial number, MAC address etc.)? Is this function called from Home Assistant's event loop? Is this function called from Home Assistant's event loop? We should round here instead of truncate. Also, note that Home Assistant brightness 0 means the light is off, and Home Assistant brightness 1 means the light is at it's minimum brightness. Is that compatible with the legrand API? Does this trigger an initial state update for the lights? Why do we need to setup an actual server, can't we mock out the relevant parts of the lib instead of this? Please set hass.data in async setup entry instead with dict.setdefault . Then we can remove async setup . We have this helper: L586-L588 If there's no case where we need to keep the hub we can pop it here already. Normally we check if the platforms have been unloaded ok before we do that though. See our scaffold script template. We normally don't allow host as unique id: unique-id-requirements Do we need to create a task instead of just awaiting the awaitable? When can port be part of the user input? It's not in the data schema. If this is for the real server test, we don't allow that.
Please use the available property to mark an entity as unavailable. Will send a PR tonight after work to fix this. Fixing in 53532.
if self. camera is None then the MotionEyeActionSensor should just be unavailable camera will only be None if the camera has been removed (camera is no longer in the downloaded configuration from motionEye). If this happens, the entities for that camera will be automatically removed ([ref]( L360)), so making it unavailable is not necessary. However, there is a small window before the entity is removed in which this method may be called, and so dealing with the potential for camera to be None is still likely necessary. So whilst I think you're right (and in fact I even made the change you suggested, and couldn't figure out why the unittest didn't work!) -- I think it's not actually necessary to make changes given the above. Thought about this some more -- even though the entity is immediately removed, I think it's still better to follow your advice and mark the entity unavailable. make the test here, and set the sensor (un)available accordingly (See comment above) Is there a native unit of measurement ? properties It's just an absolute count gauge, so no particular unit would make sense here I suspect. If there are no attributes, return None untested, but something like this should work None is the default for .get() so we can drop the , None
Why not use entity services? entity-services Targets are for use with entity services, these services are registered as normal integration services. This would be a bit easier to read if the schema was a constant Reverse the condition and return, then outdent below Don't pass a schema. Pass a dict with validators and the helper will generate an entity service schema. Given that the service schema uses cv.has at least one key ([here]( diff-d9ed771a84cb1b5703b1f1783b2e314c91f46c7697abf0c41799474ea4628f5cR86)), I'm not sure there's straightforward way to do what is suggested without losing that extra validation? Some alternatives I could imagine: - Borrow code from make entity service schema ([ref]( L876)) so this schema is created correctly. - Apply that validation step in the service handler instead of upfront. Am I missing something, and or what would you suggest in this instance? Yes, using cv.make entity service schema in the schema should also work. Allowing extra is incorrect. It was probably added to not error when passing entity id.
This is the same right? With the previous suggestion, info isn't really used anymore. With the above changes, no return value is needed here. With the above changes, not needed anymore No try catch? Let's remove the empty defaults I don't think this needs translation. Move this into the package init file, setting it up during integration entry setup Would it be more robust if we predefined a list of things we actually want in the integration? (Allow listing vs Disallow listing) i couldn't decide which was better. Sold! Can we provide a unique ID for the entity instead? That will allow the user to customize the entity ID to their liking (which makes sort of unnecessary) Done. TWCManager doesn't provide a unique ID, or didn't until today. Submitted a PR to add one - they're usually pretty quick to implement. We can use entity attributes for this, see: entity-class-or-instance-attributes We should not check if the value is in the entity ID as there is no guarantee of what the entity would be like. Instead, you should really on data from the upstream device. We should not check if the value is in the entity ID as there is no guarantee of what the entity would be like. Instead, you should really on data from the upstream device. We can use entity attributes for this, see: entity-class-or-instance-attributes Additionally, please use the available constant for this: STATE CLASS MEASUREMENT Are all sensors provide measurement values? I don't think it is a good idea to rely on replacement logic like this. Predefining might be better. Anyways, if kept, this can be compacted and combined more into a single regex and could be precompiled to be more efficient. The config flow provided by this integration no username password? same as above Same as above Same as above I cannot find this patch target. Same as above Same as above
Maybe just omit default optional variable here: (As a reader, its not clear what it does, and i'm not sure if its worth explaining) While False is indeed the default value for update before add, all other platforms in this integration look the same. If this is an issue, I would suggest fixing them all together in an own MR. Sending a follow up PR to remove seems good to me. I noticed some of these were not listed in the documentation for siren -- consider updating that too.
Side note: We should create constants in the client library for all value names etc we use in the integration. Ie "targetValue" should be a constant that we import from the library. Endpoint was removed.
You should be able to use python partition function here instead. group id, , device id partition(event.device.id string, ":") if self.group id group id... Then have the group id of the entity a precalculated property. Python is not my native language, so thanks for the tip!
What type error are we ignoring? Please specify it, eg ignore[bla-bla] to make it easier to resolve in the future. Looks like we handle this case already in get data .
I'd use keywords for all parameters to make the call more clear. How would I do that? Would I have to add an intermediary service handler that breaks out the parameters into the function call? No, just use keywords here in the call. Python will handle that. Etc. The WS api and service changes don't look related. They should be two separate PRs in my opinion. - The service PR is about adding the options parameter. - The WS api PR is about adding progress update it seems. sure, I added them here because they were both added as part of the dependency bump, but you are right that functionally they have different purposes
It would be a bit nicer to repurpose mac already configured into async get existing entry or similar. Also self. async current entries() is preferred to self.hass.config entries.async entries(DOMAIN) It would be a bit nicer to repurpose mac already configured into async get existing entry or similar. mac already configured has been removed, since it is no longer needed as an own method Also self. async current entries() is preferred to self.hass.config entries.async entries(DOMAIN) I was not aware of self. async current entries() , thanks for that hint Sorry I wasn't clear here. I was suggesting making this block its own function in lieu of the one that was removed diff-3244ee65c5cc437721e344395286a950122e83803035dfe4f23dc01fd795d20eR254-R258 Can you get the existing entry by setting the unique id? await self.async set unique id(...) will return the matching config entry if it already exists unfortunately not, since at this point we do not have the serial available of the NAS ( not part of SSDP discovery packet ), which is used as unique id, those we need to grab for the mac address ( part of SSDP discovery packet ). Furthermore using the mac address als unique id is not possible, since there are NAS devices available with more than one nic.
personally I would inherit from HoneywellUSSensor: HoneywellUSSensorTemperature and HoneywellUSSensorHumidity Totally agree. I will implement this as soon as I have a few spare cycles. Done. I just implemented two separate Sensor classes to represent outdoor humidity and temperature readings. These are already part of the climate entity, should these be disabled by default? I can remove them. Only reason I had them in there is to make it easy to add them to lovelace dashboards without using the climate card. Removed indoor sensor options since these readings are already in the climate entity. Mark it private by prefixing it with an underscore? Removed this accessor since I don't think it was needed. This can be set as a class attribute: entity-class-or-instance-attributes Done. Instead of having a bunch of methods that figure this out, maybe pass in a lambda when instantiating this instance? I feel like this makes it a bit complex, by jumping into multiple methods while that is not really needed. Implemented temperature and humidity as separate classes to remove need of control logic like this. There now will be multiple sensors triggering this update independently, is that being counted for? This has been addressed in other PR. I've limited PARALLEL UPDATES to 1, entity reloading on various honeywell API errors, a device loop update sleep time, and increased time between updates in order to hopefully reduce the chances of hitting any rate limiting and handling it if we do. Related PRs:
Need to catch a more specific exception here. My impression is that since this is a platform you want PlatformNotReady here. Reduce the scope of this try except as much as possible, and also catching Exception is too broad. Perhaps the client library needs to throw its own specific exceptions instead. Perhaps the CannotReceiveDeviceInfo case should be pulled out of the try block since it can just add to the error dict directly rather than using exceptions. Did you consider setting CONF MAC and CONF MODEL in the callback above? It seems like it could be simpler to just fill in the values there rather than needing to check them again below. Not sure how I would do this. The callback only return the raw data, and I need to get the actual value from the avr object, that is not part of the callback. I'll separate the connect into its own function, and remove CannotReceiveDeviceInfo These seem a bit redundant with the messages above So just to confirm: this only ever receives one of these types at a time? Yes. The TCP stream is parsed into separate command and the callback is called for each command. I believe all patches like this need a block until done call: Even when the side effect is raising an exception? The descriptions in some of these tests look copy pasted. ahah. Well spotted :) Use Platform enum L22 Can we use the host as the name instead of asking for it? Unfortunately the host is the IP address, and we there isn't any relevant information from the host we can use for the name. One other question on the name... Since the name is optional and may be empty, it seems like we still want a fallback here, and using the IP:PORT as the fallback seems reasonable? However, I also see name is also used for display in the media player where ip would be a little odd. Would it make sense to make it required rather than optional instead? Why not use a default name and if the user wants to change it can be done on both the config entry and device after the integration has been setup. I already setup a default name as part of the default value in the schema. And it is automatically taking the default value if you don't define anything in the UI. I've tested it. But you think we still need to make sure we setup the default value again here? Essentially take out name from the schema and use DEFAULT NAME all the way through so we don't ask for the name What about if the user want to setup a custom name? We just rename the device and entity after? sorry, just realised this is what you said in your previous comment :) I suppose I could do this. I thought asking for a name was the default way of doing for every integration. I suppose the easier to setup the better :) After few test, I still think it is better to keep the name. It was part of the previous yaml config, so it is mapping directly the value when we import. And if you want to rename after the integration is added, you need to rename the integration, the device, entity name and entity Id. I think it is
It might be nice to tell them they only need to fill this out if Multi Factor Authentication is enabled as they may not know what MFA is This change needs to happen on lokalise as it will get overwritten here. Ah, thank you. Did not know that
What happens on lines without those values ? Like for example FTTC FTTH ? For non DSL Lines where these values are not available it fails gracefully. Tested with ethernet WAN connection on Fritz!Box4040. The error is caught in the upstream library. The output is either null or 0 (have to check at the Fritz!box4040 test setup at the weekend... I think we should create the sensor only if the device return those values, and not always That seems a good solution, My skill in Smarthome programming is not good enough to do conditional sensor values. Is a simple if statement enough? I this we should add a call to: and base entities.append on that. Simone Schmidsfeld, are you planning to proceed coding this part ? Simone Code updated ;-) In this parts are no changes by me. Many of the values are given in byte instead of bit by the box upstream library. I agree it should be in kbit s to be consistent with usualy used nomenclature. kb s kbit s , just different notation What you are referring to is instead kB s Lower " b " is bits, upper " B " is bytes. Simone Thank you for the explaination - since it wasn't my code originally i was not sure if it is correct... BTW: I got a bunch of errors from the change form unit of measurement "dB", to unit of measurement SIGNAL STRENGTH DECIBELS, is that unit of measurement not implemented? I am cautious to implement such a thing far upstream (realy new to home assistant)
It looks like all the unique ids are changing. We need to migrate them from the old format to the new format to avoid a breaking change for the user. There is a helper for this homeassistant.helpers.entity registry.async migrate entries I reverted the change in the unique id. Actually the platform type was added but I realized that the entities are always looked up in the registry by a combination of unique id, platform type and domain. So there should be no need to add the platform type. L35 We don't allow updating the source (or any other config entry prop) like this, and it's not guaranteed to be saved either, until something else in the system calls update. Why do we need this? I would suggest we store something in the config entry data to indicate it's been cleaned up Admittedly this is a hack to check if the config entry was just imported from configuration.yaml or if it was stored in a previous HomeAssistant instance. I found a better solution: I moved the registry cleanup into the import step of the config flow. This guarantees that the cleanup only occurs if we just imported from configuration.yaml. you're making a copy of all these objects, that's expensive, use [ chain ]( itertools.chain) to avoid that Done We have a non-awaitable version now: Means also this function can be non-async. Replaced everywhere. Since this is the last if-statement of the function, you can turn it around to clean up the code. Used the guard clause. We're not allowed to update the config entry data in place. Please pass the new data as a parameter to this function.
This can be a NamedTuple instead (as it doesn't provide any addition methods) Since that is unmutable, i likely need to change it at some point in the future, but if you prefer for now I'll change it. We should only wrap in the try that can actually throw. Right now everything is wrapped. Limit it to the throwing parts. Anything can really throw. This is not for handling or logging the exception. It's for making sure we clean up the scanner if anything failed, to avoid system leaks. I would have used a context manager preferable. But can't since if all goes well i need tokeep the context. We don't need this large scope for guarding against leaks. If we encounter an unexpected exception we'll fix that bug at that time. For now we should just handle the known places where calls may raise and stop the scanner when shutting down home assistant and when unloading the entry. I agree that we should consider making this an integration. Prefer if we can set it up in a way to allow different implementations in the future because I want to start using ESPHome nodes as Bluetooth remote clients eventually. Bleak works on osx, Linux and windows. So it's a rather good base. We don't really need any other implementation i think. I agree that we don't need an alternative local implementation. But the problem is that a) houses can be big and b) Home Assistant might live in the basement. In those cases having ESP32 devices scattered through the house to connect to things via Bluetooth would be great. Right indeed. Struggle with that myself. We could maybe push a network backend to upstream bleak. That would be even better Don't bluetooth devices have a name? It does. But it's fixed to COOKERHOOD FJAR. A rather nonsensical name. There is no way for user to change it. No need to specify since it's same as manifest. It will be automatically set. I think this was added by the scaffold. I will remove. Can't we just use the word "Device". I don't think the word "address" adds value since it's a dropdown. Other thought: why even allow picking up addresses? Why not just discover all devices and set them up automatically, or are we doing some pairing dance? No not really. I suppose we could add all. Not sure how to handle later found devices. I would have to add som reconfigure flow. Couldn't you just do an occasional scan and go from there? Well i need to always scan. It updates data in the announce. So i will see new devices there. So i can just add entities as they are discovered i suppose. I just add all devices found now instead. Please remove empty items. If possible it's better to patch the time slept. Make a constant for the time to sleep to make that patch easy. Invert this check and return if true. Then we can outdent below. It looks like we're mixing typing and calling the class. Maybe only use English letters here?
In general, is it better to use a URL processing library instead of trying to string-process URLs. E.g., using yarl . I'll look into yarl this is the first time I've ever heard of it. Have removed yarl logic now since the URLs are all pre-formatted choices. Do we know which servers exist and provide a choice instead? Unfortunately not. The best solution I could come up with (other than having to submit a PR everytime someone comes up with a new one) was to provide a default (which is used for all new Growatt systems) and then allow people to override it. I think a list is easier to use for end-users. A free form field requires technical knowledge of knowing which endpoint your system is using. So, I would vote for the list and extend it over time when questions are asked I've pushed changes in alignment with your suggestion and feedback from the Growatt users in the community forums. Just hoping the tests now pass (I have manually checked everything at my end already) We should not extend the platform schema with a new option. The platform config is legacy. Please remove this. 54325
I might have misunderstood something, but I see no reason for the filters to inherit SensorEntity Not that I can recall : since tests didn't break and coverage is high, I'm ok with this Any reasoning for choosing 3min ?
Thanks, good spot. Why is this cloud and not local? classifiers iot-class Gotify is self-hosted but doesn't have to be on the local network, therefore I think it is most correctly called a "cloud" service. I looked at the class of other similar integrations such as the pushbullet and pushover notification services and the matrix chat integration, the later of which could also be self hosted and can be used as a notification service, and they are all classed as cloud. I think unless someone can definitively say this is incorrect I will leave it as its. All communication to external devices or services must be wrapped in an external Python library hosted on PyPI. 5-communication-with-devicesservices Understood. A quick search shows an existing library on pypi which should be suitable so i will look at translating the remote connection to that library. New integrations that communicate with devices and or services should be configurable with a Config Flow instead of YAML. For more detail read [ADR-0010]( decision) Ok, I will look at how to set this up. Hi, I've attempted to migrate this new component over to a Config Flow. This is new to me so I have pushed these changes onto a new branch and would like someone to informally review and provide and guidance suggestions if things need improved before I merge those changes onto this branch for the PR. The new component has been tested locally and functionally works, the config flow is tested and also seems to work fine. milanmeu could you please take a quick look at [these changes]( and provide any advice you can or let me know if you think it's ready to merge into this PR? I tested this locally as well and it works for me milanmeu could you please take a quick look at [these changes]( and provide any advice you can or let me know if you think it's ready to merge into this PR? Here is my comment: Merge gotify config flow into add gotify integration so other users reviewers can see what's happening. Thanks milanmeu. I will merge your changes and update tests, then merge into this branch. The name from the manifest is automatically used as title, only set the title in strings.json if it should be translated or if it is different from the manifest. Can we set a config flow unique id? unique-ids If this is not possible then delete the unused already configured string. I don't think a unique id is suitable in this case having read through the linked documentation. I will remove this string. This will be overwritten if there are multiple config entries. Use hass.data.setdefault(DOMAIN, {})[entry.entry id] ... . How do i get access to the entry id again inside the get service function? I think I tried to use this method before but realised that a blank config was being passed to my get service function since I moved to using Config Flow. milanmeu is this possible as I don't think the Notify platform has an async setup entry method as per documentation here: for-platforms How do i get access to the entry id ag
Let's move the service name constants to .const so that we don't need to import things from another platform. Let's move this check up as high as possible before the dict comprehension. Do we need boolean again? whoops, we had this discussion before. I've moved this schema to .const to keep it consistent with the service call schemas Can we avoid using details of the platform in the tests? Can you clarify what you mean here? I used the same pattern I used in the other device automation tests so depending on your response I may need to update those as well If possible it's better to start the test with a core interface, eg by setting up the automation integration, or a common helper function. I don't know if we have a good alternative. I think in this case there isn't because this is something the frontend would typically call Can we trigger an automation instead that calls the action? Setting up the automation fails on config validation so we don't hit this check. Should we just remove the check then? Is there a scenario where someone would have an invalid type when async call action from config is called? Maybe assert that the automation setup failed and assert a log message? That's what I did, it just leaves that one line uncovered. Maybe that's ok? We can keep it like this for now until we possibly find a better way.
kpine will hopefully post more details, but when testing this he discovered that on startup, this step raises an exception (once HA is started, this is no longer an issue). It seems that this validation logic is run before the zwave js integration is fully setup which means we can't get the node because the integration hasn't initialized state yet. I think this is an upstream problem with the automation logic, but looking for feedback on this Stack trace of the exception:
Why not support the full range of values that the spec actually permits? If the option is missing would it be preferable to throw a ValueError with an explanation of the problem (a couple other integrations do this)? Note that we have another PR in progress that will validate the option in the base select integration: Are we sure the primary value.value is never None?

Last reset should be a datetime object The additional list wrapper is unneeded, add entities accepts a generator.
This looks like protocol level info that should be part of the device library instead of Home Assistant. I agree, and it's in fact taken from an upstream change to the pyHS100 library. But that change is unreleased and the library is now abandoned by rytilahti . The only other solution I see is for me to fork the library, change it there and point the manifest at the fork (difficult without pypi access though). rytilahti appears to be working on a new library but I haven't seen any HA integration work for it yet.
Side note: We can probably refactor and use entry.async on unload instead. I'll submit a separate PR for that after this one is merged If available tones property is set the tone parameter must be part of available tones and this should be validated by the base siren service handler. Let's make a separate PR for that. OK so in this case we are accepting both the key and the value. Making that change would mean we would not be able to support the keys. Is that what we want? OK I went ahead and made the PR for the above ( If you think this is the right approach, then we can merge that PR and I can update this one. Yes, the integration needs to include the supported tones in available tones. Round doesn't truncate.
suggestion: this could be shortened slightly to: Change applied Change applied Change applied If the status is assumed state then there is no reason to update when adding Set the assumed state property in this case Actually I guess you don't know at all. So its probably fine as is Is this used? SubaruEntity inheritance removed. We don't usually show persistent notifications for service calls. raising HomeAssistantError is good enough Removed There are multiple unrelated changes in this PR. Please pull them out into separate PRs Changes unrelated to locks have been removed. Nothing is checking this value Then outdent below You can use vol.In to limit this to valid values. Change incorporated. You can remove the guard if you do the validation in the schema as suggested above Please break docstring lines around 72 characters per line. It's easier to read if the constants that are only used in one module are defined in that module.
I don't think we should add this logic, as it can be problematic in terms of how it works how one excepts this to work. The problem is, is that templates are dynamic. The results of them change over time, however, that is not the case for this trigger. If the result of the template changes, the trigger doesn't adjust or change with it. Move this function to a new file homeassistant components homeassistant triggers util.py so we don't need to duplicate it. Done! Can this be called from the schema instead, then an invalid configuration will make the configuration fail instead of just generating a print in the log. Instead of cv.template or entity ids , refactor the validate entities as needed and use that instead. Let's move this to a new file homeassistant components homeassistant triggers util.py
These are already attributes properties of the light itself and should not be set "extra". That also resolves the mypy issue Makes sense would move both into FritzboxLight. init () I don't think we can do async calls in init () . Can we? that's a good point, honestly did not noticed, that this does I O to the device ... so yes, keep as is define COLOR MODE as constant, those comment can be removed, since code is self explaining define COLOR TEMP MODE as constant, those comment can be removed, since code is self explaining use constant COLOR TEMP MODE from above use constant COLOR MODE from above
Let's sort the keys in the schema Done but left the vol.Inclusive's together Can we add this to the configuration schema, we should allow either humidifier or dehumidifier Added this to the config schema. Have a look at the validation method. I used a regular expression. Let's remove this, conversion to and from a scale other than humidity in can be implemented via the target humidity command template and target humidity state template instead. Remove this functionality This implies we should not add more of these helpers. Call the service directly instead, we can add helpers in tests components mqtt test humidifier.py if it makes sense Removed the helper file. Added some helper functions in test humidifier instead. Use voluptuous.In instead: Why first cast to a float and then truncate to an int? Also, don't we want to round instead? If the value template gives us a float value, it passes it as a string, E.g. '60.0'. This cannot be converted to int directly using int() or round(). So to make sure it is a number, I convert it to float first. To your suggestion I have replaced int() with round, which is a better fit.
I was looking at some other examples of using enums for config in home assistant and came across what zha does with the RadioType enum: L233 Some of this logic can go away if the access is defined as an enum with the scope baked in, something like: Then I think you can just get the enum value from the config and pull the scope out of it all inline. Didn't realise this was a thing. Updated. I would suggest making the above change then doing a check for the entire scope url to simplify this logic, and perhaps make it less error prone. That is, I think what this is trying to do is assert that the tokenfile contains the desired scope, so explicitly checking if the desired scope is in the file may be more straight forward. (I realize this PR extends the existing pattern, so i'm more suggesting the existing pattern is a little brittle) Updated to hopefully be more robust I know I asked for this to be more robust -- but maybe just check the scope to avoid over asserting on the json format. I am only saying this because I saw a few days ago where folks were compressing json and then it had a subtle side effect of breaking a regexp. Reduced down to quoted scope. This is needed because read write scope is a subset of read only scope. I completely missed that, oof, so I get it why the original check was just for the suffix then. Are you still happy with this approach? The new approach is fine. I think you were right to bring up the potential risk of whitespace messing with the check, and this new check is a bit more robust than the old way. This PR violates ADR-0010 allenporter How should we proceed? I would vote revert this PR. I was not aware of this. I assume this was done to force old integrations to the new UI flow? If this was to be converted, what would the ACs be? I assume this was done to force old integrations to the new UI flow That is not the sole reason. If this was to be converted, what would the ACs be? The "ACs"? Sorry, the acceptance criteria of the conversion? For example, "The client id secret and access level should be set via the UI flow" It would need an OAuth flow (config flow). Client ID secrets are part of the YAML configuration, not the UI. Just looked at the integration, seeing the settings for the specific calendars, I can see this will become problematic. Let's keep this PR in for now. Thanks for looking closer. Are we good on documentation? Forgot to update the PR links so sorry about that. My assumption is this is like which I aborted, and I haven't put time into exploring a separate oauth UI. An alternative is we do a hybrid of yaml plus config flow for everything but oauth. Also interestingly this is configuring the oauth scope so it's even more borderline. OAuth scopes (variable conditional) can be handled in an OAuth flow, that is not a problem. Thanks for the reviews guys and sorry that what I thought was a simple PR ended up being a controversial update. I'll try and remember the ADR in the future. What you guys are doin
The user should not choose HVAC mode, that is normally something the program does (or more correctly the automation connected). Some climate controls deliver the hvac mode, but there are no standard in modbus for that. That is correct - there is no "standard" for the hvac mode. I would argue the same is true for a modbus "climate" device in general, this entire integration doesn't really follow a standard. It's supposed to be generic enough that with enough configuration of registers, types, etc, that Home Assistant allows the device to be used as a thermostat. I want to add support for more thermostat features - as generic as possible. That being said - I spent quite a bit of time writing this to be as generic as possible, and to allow the user to map a device register to either the active mode HVAC ACTION and or supported modes HVAC MODE . The user then specifies when Home Assistant reads those two registers, what the values actually mean in the context of a thermostat (the values configuration variables). The active hvac state is read out of the device and interpreted according to the hvac action supported list. The hvac mode can either be read from the device and interpreted according to the hvac mode supported list, or it can be written to the device using the async set hvac mode() function. The only possible thing that I can think to do to make this more generic than it already is would be to allow the user to set the register types (holding register, etc), count (number of bytes), structure (python struct type), etc. It would add more configuration variables, but I'm willing to do it if that's what's necessary to get this PR approved. you cannot assume our internal hvac mode is what the modbus device needs. I'm not sure I understand - this function is what home-assistant calls from the UI (or elsewhere) to update the device's HVAC mode. If we have a register defined in the config file, and register values that have been mapped to home assistant's HVAC MODE s, then we should be able to use this functionality for modbus devices. If I have a control loop (thermal or otherwise) on a modbus device, I should be able to set it to something like 'cool', or 'heat', or 'off' from the UI. This wouldn't be any different than a home thermostat being changed from 'heat' to 'off'.
Update the test to verify the state changes when you got an updated state from the API Verify the API was called as a result of the service call This is both hard to maintain and hard to read. Maybe do something like this: We probably don't want to patch the API response here, we instead want to check that homeassistant.components.freedompro.put state was called with the right parameters. Maybe try something like: (I'm not sure if we want to test values of session , api key , unique id , so I just left them as ANY.) State update is tested in test switch get state already, there's no need to test it again I think. Instead, test that the state is still STATE ON since we rely on state updates from the API to update the state. Same comment for test switch set on . self. type isn't used outside of init method. It can be a local variable instead. self. characteristics is never used.
Can the test be expanded to actually check the sensor state, as well as test all three sensors? Also, test that an updated state received from the API updates the sensor. For example parametrize the test: Note: This is not a complete suggestion, the test needs to be updated to use the new parameters sorry, my mistake Please set unit of measurement and state class too Add some constants instead, it makes the code more readable. Based on self. type we should know which key to test for, instead of trying them all?
Suggest to remove this, we don't know if the fan is on or off at this point. Conside giving these classes more descriptive names (a general comment for all Freedom pro components): Update the test with a state update from the API Test also model, name, manufacturer in one of the tests Don't mix logic between constructor and the property function, just do: Remove this since FanEntity doesn't support attr-style shorthand for the supported features You may want to implement percentage step as well, unless Freedompro supports all speeds in the range 0..100 freedompro supports the whole range 0..100
Suggest to use a map like for the sensors to improve readability Since the cover supports position, you can very easily implement open close: You don't need to test for this argument, it's enforced by the service schema: L110-L115
Please clean this up like done for the other components, drop the self. hass etc. Move this to a map Move this to a map, and handle the case where the user is attempting to set an unsupported mode, by logging a warning for example. Move to a constant SUPPORTED HVAC MODES . Add SUPPORT SET HVAC MODE never mind this comment Note that it's allowed to pass in a HVAC MODE to this service call: service-climateset temperature, please handle that too. You could consider renaming the test: The base component does not guard against the user attempting to set an unsupported mode. So you need to do something like: Please also verify this in a test case; put state should not be called and you could also do assert "unsupported hvac mode" in caplog.text Same comment for async set temperature Please pass the session to the entity instead of hass . Sorry I didn't understand what you mean Instead of passing hass as a parameter here in the signature of the entity, pass the aiohttp client session. Ie get the client session first before creating the entity. ok I undestand The constant attributes can be defined as class attributes as they will never change. Sorry I didn't understand what you mean Define the constant attributes as class attributes instead of instance attributes: Note that generally mutable objects should not be defined as class attributes to avoid bugs, but for constants it's ok since they should only be defined in one place and never updated. Nowadays our standard is to raise a ValueError in these cases with the message as exception argument. Sorry I didn't understand what you mean Replace the log with raising an exception instead. Dumping the payload looks like something that should be handled by the library. Please improve this in a follow up PR. Generally it's nicer for library users to not have to deal with "payloads" at all but instead deal with class instances that represent a part of a library feature, eg a device, and instance attributes that represent sub features, and have methods that update the state of the instance. I recommend using a data validation library, eg pydantic, to help with this. ok thanks I will do it in a next PR This could also be moved to a class attribute.
Please test that state updates received over the API work. By doing this, code would be duplicated between light and binary sensor. Perhaps now is a good time to make a FreedomProDevice general class for all freedompro devices, then subclass it with the specific elements for light, sensor etc. Also having multiple classes named Device could become confusing. hi, it might be a great idea, but since I have several pull requests at the same time, and the others are in the process of being approved, I would prefer to keep the parts divided and optimize them later. I think it's a good idea to remove duplicated code now that light , sensor and switch are all approved. Add a FreedomproBaseEntity or similar which sets the common attributes in its constructor and maybe also helps out with handle coordinator update Either add it to this PR or open a new one. Why initialise to off? Doesn't this mean that if HA starts while a sensor is physically in the on state it will always report as off- on? A binary sensor can only be On or Off , it doesn't have a None -state. If attr is on is None, the state of the binary sensor will be Off . However, it is unnecessary to set self. attr is on False here, and it can be removed: Unknown state during startup or as a result of a failed API refresh is handled by CoordinatorEntity which will set the entity to unavailable. It could be nice to add some test for that, you test it by making the API data coordinator fail, something like: Or: Would it be more useful to patch the api call, and verify that a change of state propagates through to your integration? Currently this seems to just initialise the integration then read back the default state (off).
Should this have a higher logging level? I assume we want to inform the end-user of this configuration error? Thanks frenck. I toyed with this in my head a bit. The counterexample I imagined had a holiday that may not exist every year, but the user wants to remove it any time it does. Perhaps I was overthinking it maybe log a warning and let the user choose to lower the log level for the integration? I think using a warning is the least we can do. It's a pity that holidays only returns holidays for the current year I think It's a pity that holidays only returns holidays for the current year I think Oh wait we already control that, I wonder if it's worth pulling the holidays for the next 5 years or so? L81-L82 I do think we want to avoid the case where the user suddenly receives a configuration error on January 1. Would we want to hardcode a number of years into the integration? We'd need to include past years for some cases as well (jubilees and royal weddings come to mind). Well not sure what the solution is. But if we can't tell the configuration is correct or wrong, the user will be in flux if it will ever work. I don't think that that is an acceptable situation. I agree we cannot have a situation where a valid configuration becomes invalid on 1st January. Hackily L82 could become obj holidays getattr(holidays, country)(years range(year-10, year 10)) but that's storing 20 times the data we had before and obviously may break in the extreme case of offset 3650 (or if someone doesn't update restart for 10 years!). On the other hand, if a removed holiday goes by a different name in a new year, the user would want to know it will not be removed. As much as it would be a nuisance for the valid configuration to suddenly become invalid, it seems better than the behavior that could result from hiding the issue. There doesn't appear to be a perfect solution for every case here, but I think it'll be best to log a warning. As long as the integration continues to process configuration and otherwise works normally I don't think this will cause too much grief users can always filter out the message if so inclined. I'm really undecided on this to be honest. I really like the feature but I think it's hard to get it versatile. I see two closely related issues: we can't reliably ensure that a configuration that doesn't produce warnings one day won't the next maybe this is not that big an issue. The second one is holidays is rather picky about casing and punctuation as best I can tell. For example: it will require "St. Andrew's Day" (which is actually wrong by British style guides...) "St Andrews Day" or "st. andrew's day" won't work. We can't reliably user title to fix the latter as other cases would fail (e.g. "Platinum Jubilee of Elizabeth II"), I guess just point the user towards the source to check the format? Checking the log after reload restart just to confirm the format is correct is not ideal. This at least can be fixed by loading the holiday list a con
Can you do something like this instead: Then add the same to script, in homeassistant.components.script.async turn on()
I feel like a quick comment wouldn't hurt here to explain what's going on. Sounds reasonable. I'll add a comment to explain the handling of units. Is the precision property ever really tested? I feel like a new test here should make use of it at least once, to make sure it does something. But the old ones (with precision 2) didn't have to get their result changed, and new test has precision one. I did not write new tests for the new configuration variables, as pointed out in the PR: - Tests for the History Stats sensor (tests components history stats test sensor.py) were updated to include reference to the two new configuration variables. In addition, a new test sensor was created for two test methods that make use of a non-default time unit ("min"). New tests that specifically test precision and time unit were not included. I added an extra sensor ( sensor.sensor5 ) to two of the existing methods to evaluate a non-default time unit , namely min (minutes). However, as you correctly noted, precision does not play any role there because the evaluated time window (half an hour) can be expressed as 30 minutes (the time unit tested) or 1800 seconds. On a second thought, I could change the time unit for d (days) instead of min , which would give us a value of 0.02083 and then also test precision (for 3 , the output should 0.021 ). I'll make this change, per your recommendation. Edited : Miscalculated the hours to days . Fixed it now. I believe you broke this line when CONF TYPE TIME became a list This will impact sensory type further below Thanks for chiming in, dgomes . I'll address each of your concerns separately. Please notice that CONF TYPE TIME is not a list. It is actually a string (namely, time ), as defined in L41 of the same file. I think you got confused with its usage in the UNITS dict, in which it shows up as a key that has a list as value. People will bring pitchforks if they history get values 0.31232312312312312312312 The rounding operation for ratio type sensors was moved from the static method you mentioned to the state property (L208-212). That is, the ratio value is rounded immediately prior to returning the state value of the sensor. By default, it will always round to 2 decimals but with the addition of the new precision: configuration variable, users can now modify the number of decimals as well. so UNITS[CONF TYPE TIME] is never used, right ? it is used to validate CONF TIME UNIT (see L80-82), which is provided by users via the new time unit: configuration variable or defaults to h (hours). please notice that the addition and usage of the UNITS dict was not my idea. I simply adapted the implementation of the new configuration variables to the previous code.
All your static properties and instance attributes should be defined as class attributes Done. Moved all the static instance properties to class attributes. Use self. attr state instead of self. state and remove the state property Done This is not allowed as a unique ID unique-id-requirements Hi ludeeus, Can I remove self. attr unique id?

It's my understanding that pymodbus cannot handle calls to write register with floats. It only accepts values that will fit within 2 bytes (size of a single modbus register). If we unpack with the struct format specified by self. data type , then floats will still not work. If there was a DEFAULT STRUCT REGISTER COUNT const dictionary something like this, it would be doable. the user must use count: if needed, fir DATA TYPE STRING we cannot know the size, so the general idea is that the user knows what he she wants. pymodbus handles write register with floats very well using the array call.
This line is missing a test. Test added. This line is missing a test. Test added. Thanks! Done. Thanks! Done Why do this? you could just modify the config in place to convert the templates back to a string and pass that to the import Thanks! Done. Thanks! Done. Set self. attr unique id in init instead to simplify the code Thanks! Done this will let you outdent all of the try block below. Get rid of the return at the end since now it is not needed. BTW the walrus operator still works in this case, stream source will be available for the rest of the function Thanks! Done. Thanks! Done Thanks :) Done. I think this is doable here because you are still in your if block Thanks! Done If these are optional parameters, do you need to use user input.get instead for the defaults? Agreed. Done. you shouldn't need this because of the walrus operator ( : ) above To be consistent with the config flow None is redundant here Why do some of these default to an empty string versus the others which will default to None ? If there's a reason for it that's fine, just curious I know that sometimes for things like username password you have to default to "" otherwise you get the User input malformed error. Pretty sure any optional string needs to default to "" .
Not used. This can be removed from the sensor and switch platforms too.
The return type is str None - but this returns float . Which one is correct? The return type of this entity property must be float My bad, copy pasta error Why is this needed? It will get converted back to float anyway in the protobuf... Removed Number static info has no device class attribute as far as I see Removed
Are these percentages or Linux load values? This are equal to the value provided in the AsusWrt UI. I assumed it was percentages, but may be I'm wrong, also because I don't know what exactly are Linux load values . In general load averages are not expressed in , looking at the values in the test, they are loads, not . I should use in any case a unit of measure to have the values represented as graph in HA. I do not found a standard UOM for this, should I define a new one? It doesn't have a unit What I would say is that if we don't assign a UOM to these sensors, in the history we will have something like this: ![image]( instead of a graphic like this: ![image]( I think that a graphic in this case should be preferable. Unitless states do not have graphs. And loads do not have units. We should (and will not) make backend workarounds for a frontend representation issue. Ok, will fix accordingly. Missing 5 min? I do not enabled the 5 min sensor and do not test it, but I can add, not a problem. Just think that if first and last was ok, also the middle should be ok Just a couple of lines to add that coverage, I would just do that :) This is related to sort? So I should also invert the first 2. Yeah probabaly :) Sorting nice :) These could be considered less commonly used sensors. Should we disable these by default? All sensors with exception of the device counter are disabled by default: Shouldn't these all have SENSOR DEFAULT ENABLED: True ? See previous conversation Yup
We need to assert the transition update somehow. I didn't see a way to assert it. Shouldn't there be a args["options"] with the duration? Good point The default is None, is this necessary? Should add to watched value ids be set to False ? I thought add to watched value ids defaults to false doesn't it? edit: nope I see it defaults true Not unless we live in opposite universes. L165-L173 Why didn't we need this value before? Are you only using it to determine whether or not the device supports color transitions? Yes only to check for transition support. Just a thought, you use these same conditions twice (checking if brightness transitions are supported and checking if color transitions are supported), might be cleaner to make class variables that contain that logic and then reference them twice. e.g. then if self.supports brightness transition or self.supports color transition etc. Separately, can we rename self. target value to self. target brightness ? That will make things more readable now that you have introduced self. target color Side note: This constant should be moved to the client library in the future.
Data resolution: 1 hour for the free version, so maybe that should be the update interval? integration is still WIP, the interval will be adjusted Resolved. get will return None if it's not defined so this is not needed. Due to the way or option flow works, it can be an empty string as well, that is what this is catching I'll add a comment to clear that up A personal account has a resolution of 30 minutes. Can we derive from the API key or an API call what type of account it is? Or maybe it's a header in the response or we can derive from response when we call again? That is not part of the info available, unfortunately. Hence it picks to be on the safe side for either case. You think we should use different values? I wanted to be on the safe side for the remote service as well. Thinking about it, I guess we could... We get more or less info, so let set it from 15 - to 30 to match the personal account. I believe klaasnicolaas wanted to add more sensors based on what is available on your account, as soon as that is in, we can determine the right interval based on that. Do we really need to test this ? It's a cloud API so we can just assume it's ok? Hmmm this is not a connection error actually. I'll adjust that to make that more clear. For example, it could be a bad combination of parameters (although we protect against that). So I've removed it. We don't connection check on the options flow either...
Maybe we can stream that like: L192
The device class should not tell something about the measurement point's scope. We have state class for this. Yeah, I agree DEVICE CLASS TOTAL COST is not very good, it's an amount of money being measured and it doesn't really matter if that amount is a total cost or something else. If it's a price per X or a currency conversion rate, we would want mean , min and max . Ah never mind, that would be for a DEVICE CLASS PRICE . This is for just total cost.
It also needs to be tested with DATA TYPE INT etc. since the validator allows this. This is not resolved try e.g. CONF STRUCTURE: i . How do you solve when CONF STRUCTURE request 2 bytes, but register size is 4 ? According to the validator that is a legal configuration. What about float ? What about a struct like e.g. 4i , those are affected by the register size change as well. Eliminating swap is a bad idea, because that means your solution will not work on little indian processors (network format is big indian). If you want to add a different register size you should support all standard configurations. Try regsize 5, how would you do SWAP WORD What happens if the parameter is not present. But normally register size is 2 (according to standard), when register size is omitted, so it is kind of hard to understand the error message. Apart from that count is valid in combination with register size, so you could have e.g. register size: 4, count 2 Register size: 8, count 1 Count: 4 And they all have the same size. Now test 0x0100, 0x0000 with i , you cannot store 4 bytes in 2 bytes.
We could omit creation of empty xknx devices when this function is not configured. Then we can just check for None instead of self. total energy sensor.sensor value.readable or self. total energy sensor.sensor value.initialized . Done
Generally we've kept the device automations limited to simple use cases. For more extensive use cases people can use normal state conditions etc. Are all these types really what we expect non-advanced users to use? I also see that all node status types get their own condition. That seems overkill. Why not just have a single state and a dropdown to pick the state? we can do a single condition for this. The reason I added this is because we disable the sensor entity by default but you can use the condition even if the entity is disabled
There's no reason to store the entity. It's enough to store the segment id in a set. yeah, that is a nice more generic improvement, thanks!

This conversion seems wrong; Home Assistant expects hue in the range 0..360, not 0..65536 and a saturation in the range 0..100, not 0..255. Since yeelight uses the same ranges, no conversion should be needed. Maybe add a warning logging here to inform the user in case an unexpected color mode is returned by the device? Makes sense, fixed in ff18010 checked in tests Are you sure this is correct? According to yeelight spec, hue is in the range 0..359 and saturation in the range 0..100. This is why I removed the conversion: diff-5fe9c3ca5816491ba88aab8cec171a10ab6f5e199923faadf128b09743daf861L579 Could you help to verify hue , sat , bg hue , bg sat are as documented and not in the ranges 0..65536, 0..255 as assumed by the old code? I have no a regular bulb that does not report bg properties, but you are correct about the hue and sat . My previous comment was a bit unclear, I was just wondering if the RGB value change was intentional or not? Oh, I see. I changed the bg rgb to make it different from rgb to be certain the integration picks the right property for the background light. Ah, great! Okay, let's get this merged then and handle fixes later on, if necessary? shenxn zewelor ? :-) For me it looks good, and I think we should merge and tweak. I've also dig into upstream lib and there is also stated that hue is in range 0...359 and sat 0...100. L844

Instead of creating your own services, please use the capabilities of the media player , which already provide methods for this.' See: grouping-player-entities-together Okay, I did not know about that. Is there a way to create groups in the UI using these methods? The mini-media-player does not support these services, which were defined in the media player. There is already a [task]( for this, but I would really love to support this card from the beginning. Would it be okay to implement the methods from the media player and add the domain specific services (as I did it) to support the mini-media-player? Is there a way to create groups in the UI using these methods? They are exposed as services. The mini-media-player does not support these services That is a third-party component, we do not support those and don't adjust our designs on those. Would it be okay to implement the methods from the media player and add the domain specific services No, please use the ones provided by the media player. okay, done All of the info logs in this PR should be at debug level. All of the entities in this platform are MusicCastMediaPlayer instances. Why do we have the check for that? If we are worried about mixing them with other platform entities: Entities are a platform concern. It's usually a bad pattern to store them centrally. We should use a subclass of HomeAssistantError . In Python we don't need to check the length of containers to check if they are not empty. It's enough to just do: Please clean this up where we use len .
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
This will also convert a boolean to a integer. Is that ok? What is the following boolean validator then used for? Hmm probably not ok, we want to preserve the intent of the input. The idea behind switching was to support converting the string version of true to true. Perhaps I can re-add bool at the beginning and keep cv.Boolean where it is? Do you think that's redundant? I don't think we need to add support for converting a string "true" to True .
Does this look right? I have this in a local branch, but I'm not sure if it makes sense to open a PR against your initial PR The implementation of changing an option is implementation done by the integration, not by the entity component. For example, if one selects an option, an action usually comes out of that. E.g., in this example of the demo integration, changing the actual speed of the spaceship. A result of that might be that the state has changed, but that is not up to the entity component, but the integration implementation. This is no different than e.g., a light or switch component. Ah, so an integration might (or might not) expose a service to change the option, and then update the select accordingly? Conversely, simply selecting a different option in the UI, should tell the integration to do an action... am I understanding that right? Ah, so an integration might (or might not) expose a service to change the option An integration must implement the method to change the option (otherwise a sensor entity should be used). Conversely, simply selecting a different option in the UI, should tell the integration to do an action Well it tells the integration that the user wants to change something :) For example, in case of a light: change state of the light to on (turn it on is most likely the result in that case). I think that we discussed that we should change this to just be . bramkragten can you confirm. I've adjusted this PR to use state. .{option} , as there are no conflicting states in the demo example, that should be fine. I've pushed a commit to the frontend part as well, to take into account. Aaah right, seeing the build error now in hassfest (which didn't trigger on my pre-commit?) I remember again. stringssensorjson So, is global for the entire Home Assistant codebase, as it results in a lookup for: component.select.state. .light speed These translations are not bound by the integration domain, thus we required them to be namespaced. For example: component.sensor.state.moon phase.new moon I'll revert my last commit in this PR. I'll leave the support on the frontend PR, as we could make some generic translations available for things like "on", "off", "auto" maybe... OK confirmed with bramkragten this is actually global, so the current method right now is correct. We should definitely further discuss translation and how integration maybe can provide them better easier (as shortly discussed on call just now). But that is a different cup of tea and probably out of scope for this PR. Why should the option be None ? That doesn't match with our service data validation. We normally raise ValueError here. We're not in a voluptuous validator so we shouldn't use those errors. Hey! I've stumbled upon this in other core integrations as well. One I recall: L290
don't use latest, set a specific version Done! same here, don't use latest, set a specific version Done! No need to add unused fields Done! don't use latest, set a specific version Done! Please remove commented code, only add comments if they document something Done! Unless you mark your PR as draft, make sure it is ready for review, don't leave TODO's in the PR Done! You defined constants in const.py : DEFAULT HOST, DEFAULT USERNAME, what is the use for them? Now I use those constants, done! Are these used anywhere? Some are now :) This is not used as a callback, it is only called from a callback no need to mark it as a callback Done! This should probably be implemented in an external library yep, see: I've created an external library for the modem and use that now. Config flow must have tests (and you have) so it can't be excluded here, add only the relevant files to be excluded I don't think we should add this under that name. It should be just zyxel and supported models should be reflected in the documentation.
Comment uses the word "resume" but I don't see where you suspend the polling? oh see it now inside listen . - The WebSocket can be triggered by: async update data , which is a scheduled refresh first time triggered update. - In the first line of listen() is sets self.update interval None causing the next schedule not to happen. Removed that part, as not all state changes cause a push of data over the WebSocket. The data is available but only pushed when some other event that does trigger WebSocket updates is triggered. So I'll keep polling around, at a slower rate. Expected that most devices will support WebSockets anyway. WebSockets are around in a hidden experimental state since August 2020, and the integration will actually work with those ancient versions as well. The update coordinator actually has a helper for this: self.async set updated data . It will already reset the polling too. L268 Thanks, that cleans up nicely :) This method can be a callback. I'm dumb. Could this be a race condition when a user calls homeassistant.update entitiy and it hits this method 3 times, and then creates 3 tasks to start the WS? If you make the use websocket method a callback, and then check self.unsub , you won't have this problem. Done
Will the version string always be convertable to an integer? short answer is yes! We already guard for a non supported version above. Thank you. You are right. I have committed a simplified version with v.7 as default and if v.6 change the api url.
What's the use case for the station id in the state attributes? Station id is a uniqe id per station. In Api you can filter per radius around one location or you can define the monitored station in cinfigure.yaml. You got the station id only via api, not via website. so if you would define the station via station id you must grab it from the api. theres no other chance. so if the station id is visible via ui then you can easy get it from there and can modify your configuration.yaml Delta1977 you can use the "tankstellen finder" webpage ( mentioned in the tankerk nig integration documentation to get the station ID. Without the need of the API. ahh. i need new glasses. So this can be closed. Thank you for the hint
Should be extra state attributes Here is an example: L178-L190 Done Wifi switches fail. I suppose that 5GHz and 2.4GHz switches get the same unique id (description matches): I think we should add a uniquer way to set the unique id. I think this happens because you have the same SSID for both 5 and 2.4. We should skip the creation of the second, because in the end it's only 1 WiFi network. Simone I disagree. Although it's one SSID it's two distinct networks. Disabeling one doesn't disable the other. Fixed with latest code tested together I would remove friendly name from switch info. The advantage: Can be removed from init of individual switches. I'm strongly against it, you can have 2 router of the same model in your environment BTW, we use the same naming convention in the rest of the integration ;-) Looks a bit unclean to me. I think it should be handled internally in the classes and not outside. Maybe action GetInfo from UserInterface service has the needed info. could we generalize service call action to also work here? Indeed, as I told you on Discord we should replace all fritzbox tools.connection.call action with service call action Usually we don't include identifiers if connections is already present, unless its needed for a via device Removed Make this its own function, and run it in the executor. Have it return a list of entities to add and then call async add entities in async. You can drop all but one call to async add executor job and all the add job this way You shouldn't need a lambda here if you pass the function, and then the args Use functools.partial instead of the lambda use f-strings Make a mapping dict to convert the key names Only put the code in the try block that can throw an exception Only put the code in the try block that can throw an exception
then outdent below Can this throw? I guess it's possible when we try dump in pickle during saving cache but it seems very unlikely. We are not getting devices, nor are we logging in here. We are simply loading the cache if it exists and errors are not thrown if not found. We just move to login inside the try after that. commented code Why does this have a type: ignore? does this need to be normalized? sometimes-acceptable-sources-for-a-unique-id-for-cloud-services Email address can be changed easily by the user so I would not like to see this as the unique id. Should this still be normalized with lower() ? Please update the upstream library so we don't need protected-access I had to create a fork Consider using keyword arguments since this list is long and likely to be error prone on refactor We are inside the executor here, how could this be done? wrap it in functools.partial I'm not sure how to mock this when using functools. color-modes Maybe make this a decorator instead and save some indent see example in zha config flow tests Just to the executor once until of multiple times. Drop the unused arguemnt This needs an quick update Can you use asyncio.gather here? It would be cleaner to make this a dataclass. Example in lookin.models Looks like these are coordinated entities now so we probably don't need update before add True Usually we separate unique ids with - and names with If server unique id is truly unique then we only need one or the other Please leave reauth for another turn. We need to check to make sure they don't switch accounts here and its better to simply return False in the async setup entry to keep this from getting any bigger for now It looks like this will break if there are multiple entries This could be a generator expression comprehension
Removed the previous login about disconnecting from device. this will keep listening to the device when turning it on without HA. Also I don't check if turn on off feature is available, since I prefer to get an error, so the user will get the error. Keep the device always connected since - r646072824 Link doesn't work anymore and I don't remember... why is this? Seems backwards that a platform would trigger this, it should be handled by the component once all platforms have been loaded properly. Which I think is the case now? I guess the problem is the "start off" option? Replace with better comment Any reason why you check this here and not in turn on (or vice versa)? Yes, in turn on - if it will be executed when it's already on, nothing will happen But, in turn off, if turn off will be executed and the state is already off it will turn it on (while we want to keep the tv off) Not used?
Fixed. Fixed. Fixed. Do we really need to add these attribute to every single sensor? It's not strictly necessary, but I thought it would be useful to have a reference to the station and the timestamp of the measurement. I can move that info to somewhere else, or get rid of it altogether if this is not considered appropriate. We generally try to reduce attributes as much as possible. My main issue would be, that they apply to all the sensors added. So every sense will have the same station data in the attributes, which will be stored and logged each and every time anything changes to this entity. Got it - I've removed the extra attributes for now. I would like to keep a reference to the station code, but I'll think about how to do that without duplicating data. SENSOR TYPES[sensor type].get(SENSOR TYPE ICON) Meaning you don't have to set them explicitly, as None will be returned from get() when it is missing. Done. Done. Done. SENSOR TYPES[sensor type].get(SENSOR TYPE CLASS) Get will return None when it is missing. Done. Done. Translations are managed on the Lokalise translation platform, please revert this change. Translations are managed on the Lokalise translation platform, please revert this change.
Use entity class attribute instead entity property methods that are returning a constant. This should return an integer. Position is required by the service schema. Position is validated as an integer. We don't need to copy it to a float. Position is already validated as an integer between 0-100. Looks like we can remove this case.
48381 remove the need for an integration async setup in case the integration provides a async setup entry . You could move setdefault to your async setup entry and get rid of async setup Done. You can name your config flow class LuxorConfigFlow to make a clear distinction between the core ConfigFlow Done Does the device have a unique ID you could retrieve? unique-ids tldr: unfortunately, no. Background: the Luxor system has devices that have serial numbers, but the devices themselves aren't what get turned on and off. The installer user puts the devices into named groups. Only named groups (and themes) can be turned on and off, so that's what this integration exposes. The groups and themes do not have any for of ids assigned to them, only human configurable labels. The options flow strings are missing here There isn't anything to configure, other than the host, which is in the strings. Is there something else that you were referring to? (There isn't even a username password required. The protocol is unauthenticated and is in plain text) The config step strings are missing here I added the Host translation and added a title. What happens if an exception is raised by illuminate group ? It will throw an exception, that will end up in the log, and the change won't go through. The integration will continue to work as soon as connectivity is restored, including updating the state of the devices. Is there a best practice in ha for how to handle this? What happens if an exception is raised by illuminate theme ? See the above answer for 'illuminate group' Testing should not affect code (or comments ) warn() is an alias Its the only untyped method here... maybe add typing :) Maybe add typing for completeness should we setup the coordinators in the integration init? That would allows easier addition of other platforms in the future. Additionally, the first refresh of the coordinator can throw exceptions the integration setup can use. However! We are moving away from supported features for lights. Please use color modes instead (but can be set in a similar fashion as shown in this code comment). This should be the integration name, which is a brand product that generally doesn't need translating We should patch the client library, not the config flow.
Verify admin access It's weird that this is a list. Why not do {"version info": version info, "node": node.data} Any reason we're making this a new endpoint and not just trigger a download via the frontend? That's what we do for the download trace button. To clarify, are you suggesting that, instead of creating a JSON file, we pass the data directly to the frontend and let the frontend do the work to convert it into a file, or something else? OK found the trace code and I think that is indeed what you are suggesting Should we use camel case or snake case for the strings? I wasn't sure. If we use automation traces as an example, the keys coming from the backend would be snake and the keys generated in the front end for the download are camel. But the state dump from the backend will be camel, so we are going to have everything be camel but the version info if we switch. But they are also two separate commands, so maybe that's ok? I'm good either way, I spent more time thinking about this than I expected to Let's go with what you prefer. I'll switch to snake since we may use that command for another use and that's the standard for dicts we send
why do we need to combine it with the guid. Isn't the whole idea behind a uuid that it's unique? Also, how will this work with a device that has two entities represent different parts? The device UUID is just the unique id of the device in that config. It's not a globally unique identifier across every lutron device in the world. The GUID of the controller uniquely identifies that controller globally. So to produce a unique id for each entity, we need to append something to the GUID for the controller. I'm unsure of your second question. There isn't an instance of a device that has two different entities in the current implementation. One only has to add a single battery powered device and we're going to have two entities :) Although a UUID might be only unique within the config, if it uses something like uuid4 spec, the odds of it being globally unique are 99.999 . What about lutron device.id , how unique is that ? Can you clarify what you mean by adding a battery powered device that would have two entities? I have pico remotes in my setup, and each button ends up with it's own entity with its own unique id. lutron device.id is a 3 or 4 digit number, that appears to be generated via some scheme based on the device type, and when it was added to the system. I think balloob is referring to the fact that in most integrations battery sensors have one or more sensor entities for their actual state (motion temp humidity etc) plus a battery level sensor, or some switches have sensors for power draw or usage, etc. I'm not familiar with the lutron integration to know what all it supports though. Ahh I see. Lutron doesn't have anything like that. The closest thing are the keypads that end up effectively having multiple entities and they're modeled as scenes. Any other concerns with this PR?
Maybe make rebooted a constant or better yet an enum Maybe make discovered a constant or better yet an enum dispatcher send since this is in the executor Maybe make configured a constant or better yet an enum Thanks An event like this should be exceptional. However there are some users that seem to be hitting it more often than they should. Visible warnings this has occurred may help them uncover a latent issue in their particular setup. That being said either way is fine. Do you have strong feelings one way or the other? Let's keep it for now and downgrade if it's too frequent for some users for uncontrollable reasons.
I am not happy with these type: ignore work arounds. But I am fairly new to python3 typing and dont quite know how to fix. Im getting the following without them and I dont know a fix for mypy. homeassistant components modern forms config flow.py:72: error: Unsupported target for indexed assignment ("Optional[Dict[str, Any]]") [index] The problem is that user input may be None , in which case it's not correct to treat it as a dict ; None[CONF HOST] self.context.get(CONF HOST) would throw. Cool thanks, cleaned up. I think this can just be omitted if not needed. removed What is this backwards compatible with? Leftover from a cut and paste. Removing Do we need to shutdown the ModernFormsDataUpdateCoordinator somehow? I am unsure, but using other Coordinator based integrations as a guide, wled for example, I don't see any explicit shutdown or removal from of a coordinator. Please add a test for this case Tests fixed done should this be update fan , or maybe just update func ? sure done Can this be typed in the base class instead? Yeah moved this higher You could consider doing like this to make it clearer which Device this is: Yeah fair enough Please remove this debug print Done Please remove this debug print Is "segments" correct here? Stale docstring You don't need to set an icon, the frontend already knows about fan entities. If set to None , frontend will pick the default one. Done Unless you plan to add entities which are not part of a device, you can just merge this class with ModernFormsEntity Done
In general: We don't want to expose a scan interval, unless absolutely no other solution is available. Please elaborate on why this change is needed and why there isn't another solution available (and which ones you have explored). Push updates are not currently available in the api. The connected anywhere feature uses mqtt over tls to aws which is not currently something I can penetrate. The direct connect option only works with the smart phone app. If I could do the direct connect option, HA would have to directly connect to the device's access point which is not possible, right? This is a battery operated device. Every poll would obviously drain it a little. With this option, the user would be able to choose an interval more appropriate for their use case. If they keep it plugged in, they can afford to shorten it. If they plan to use it outside unplugged with solar (on a cloudy day), they may want to poll it less frequently. So the question is: Why not adjust the current polling rate to a sane default? Alternatively, an option can be implemented to disable automatic updates completely (which we generally prefer over scan interval settings) 30 seconds seems sane to me for a battery operated device, don't you think? So I would directly replace scan interval with a disable automatic updates option or should this be in a service? 30 seconds seems sane to me for a battery operated device, don't you think? I can't judge that, as I'm not a user of this integration device. So I would directly replace scan interval with a disable automatic updates option or should this be in a service? Yes, there is now a PR open for waze google travel time, implementing something similar. Add an option to disable updates, user can update entities using the homeassistant.update entity service on their own schedule and terms. PR: is now closed, will wait until the system options work is done.
We should use the new endpoints: store addons just store or store repositories in that case : 1:
During importing configuration without a name we will get KeyError here. name is optional name IP address hostname is not acceptable source for unique id unacceptable-sources-for-a-unique-id This can be corrected with getting the mac address using dhcp discovery which I plan on doing. I would need any hostname prefixes that android tv devices use since I don't have one, just fire tv. I think AndroidTV uses androidtvremote. tcp as service name. Any suggestions on a unique id? I'm not sure how to use config entry id as the last resort. We don't have to post or prefix it with the DOMAIN, it is already unique within the namespace of the integration domain. This is not the entity registry and therefore does not have the same unique ID requirements as entities have. So the host can be used (given that a single used can only be configured once). I don't think you need to update CONF HOST . Just abort because the host is already configured. Also this check should be done before trying to connect (if we are not going to add it anyways) The last parameter here should be the original config passed to async setup above. So we need to store the config in hass.data to have access to the config in async setup entry . See the tibber integration for an example. We normally don't allow using host as unique id. What kind of value is the host? unique-id-requirements This is incorrect use of cv.deprecated . It takes a key name for the deprecated config key. For platforms we normally don't use cv.deprecated but just log a warning during platform legacy setup. Log a warning and import the config here to a config flow instead. Then return None. Don't import the config here. Do it from the platform setup. Platform config can take different forms in YAML so it's not safe to import that from here. No need to copy to string before passing the argument to the logging message. If we use a context manager here the file handle will be closed after returning the file handle. That is probably not what we want. We only use CONF prefix for config key constants. That isn't what this is.
This doesn't need to be a coroutine function since we don't await inside. We can make it a callback. good one, fixed in a new PR. It's safer to put the integration base class first in the MRO since we pass things to the init method of the super class.
Then we can remove this. These are static, so can be moved to keep the constructor smaller But a matter of taste though I think it's nice to have them all grouped. The others are static too, just derived Let's put the attributes that don't need parameter input as class attributes per the suggestion. That's our current informal standard. Why did we re-add these properties? I asked to put them as class attributes. Doh misread. Will submit a fix later today This will only work after at least another sensor has been added for the config entry. I think we need to make it more robust. good catch
Should this say?: Done, will be pushed shortly Instead of guarding inside the method, maybe check before calling continue media() ? Done - I moved continuation guards into parent call, and I ended up removing the type checks in favor of exception handling. This will make more sense with new code, but please do let me know if that's not consistent with the design - and I'll move them out. To keep the terminology consistent. This suggestion seemed totally reasonable at first, but this caused difficulties because mode arguments are delimited by ' '. For example 'unwatched first' is mode: 'unwatched' and arg: 'first'; However, 'on deck' will parse into mode 'on' and arg 'deck' which would require special handling. I ended up changing this to "ondeck" instead, to try and find a compromise - but I'm happy to add special handling if you strongly prefer "on deck" (I've no strong feelings either way). Can you instead use Season.episodes() and Show.episodes()? In this case I was searching the deck collection for an appropriate instance of a show season episode, and only wanted to gather episodes that were on the deck (rather than Season.episodes() or Show.episodes() which would gather all episodes). May seem silly, but I did this because I couldn't find any assurances in the API docs that deck would not contain multiple episodes from the same show :) Anyway, since you brought my attention to it - I do think this was needlessly complex, and I found a much cleaner way to do this in a single Plex API onDeck method call: plexapi.video.Show.onDeck plexapi.video.Season.onDeck New code looks super neat, IMO. Perhaps the possible mode values could be made into a lookup dict or Enum ? I'm deeply sorry, but I wasn't entirely sure how to interpret this suggestion (I understand literally, but not entirely sure how it's intended to be applied). May I ask to take a look at the updated code shortly to see if dict enum is needed? and if so, how would it be applied? Just translating string - enum and then if then check based on enum value instead of string comparison? Very sorry if I'm missing something obvious. I forget how it looked before, but the current way seems just fine. The query asks for all episodes in the show, but the selected fixture is all episodes in the season; this is intentional. Since the show currently only has 1 season, I figured I could simply re-use its fixture with the list of episodes. Please let me know if this is not desirable and I will duplicate it into a separate fixture instead. I think that's reasonable. Instead of having a static method on the PlexServer object, maybe this method would fit better in media search.py ? I was very apprehensive about keeping it inside of the server object, but had somehow rationalized it to myself (don't remember how anymore). I'll move it to media search.py, and will move the tests as needed to pursue consistency, thank you done, and tests were moved accordingly to stay consistent Is there a need to prefix th
One thread per bulb is not going to scale if the user has a lot of bulbs. It also looks like the listen implementation doesn't handle short reads so it will miss any fragmented packets The protocol looks really simple. How about using asyncio.loop.create connection and buffering on data received , then you can do all your callbacks in async Thank you for the feedback, I was also wondering about the threading. I know the Xiaomi Aqara and Motion Blinds integrations also use this threading approach with one thread per gateway (not as severe), they use a socket to a UDP multicast adress. Would this same function also work for UDP multicast connections? bdraco do you have an example of a asyncio.loop.create connection implementation? I will look into it when I have some time. I'll put together a proof of concept this weekend. It may even be possible to use asyncio Streams as the protocol is very simple. Here are some UDP examples. The second one shows passing in an existing socket (which is probably what you need) L89 And passing an existing socket (note that this code should be moved out of Home Assistant core as protocol details belong in a pypi)... something on my backlog: L87 starkillerOG Functional example Example: async reader.py The proof of concept I pushed will break if you send multiple commands though before awaiting them. I'll push another commit that supports sending as many as you want (as many as the bulb can handle) at once and then sorting out the responses along with support running commands async so you can fire off a few of them and await the resposnes Cleaned it up a bit more an squashed it into bdraco Wow that is amazing, it looks like you already figured out the whole part for python-yeelight. Would you be willing to make a Pull Request to python-yeelight of your fork? Would be awesom to have those async fucntions in there. As soon as i have some time, I will start testing with your fork and addapt this PR to use those async functions. just tested it, it works like a charm :) Should this be device bulb ? thanks, i fixed the typo Can you cover this line by patching async listen to raise BlubException I tried, but I can't get the tests to work, I tried this: FAILED tests components yeelight test init.py::test async listen error[pyloop] - Failed: DID NOT RAISE class 'homeassistant.exceptions.ConfigEntryNotReady' FAILED tests components yeelight test init.py::test async listen error[pyloop] - homeassistant.exceptions.ConfigEntryNotReady Stupidly enough it seems like it is complaining that the test did not raise and raised an exception. Assert the config entry is in retry state instead. The ConfigEntryNotReady exception will be consumed by the config entry code itself. assert entry.state is ConfigEntryState.SETUP RETRY I changed it to: but still get these errors: FAILED tests components yeelight test init.py::test async listen error[pyloop] - AssertionError: assert ConfigEntryState.LOADED: 'loaded' is ConfigEntryState.SETUP RETRY: 's

This is passing metadata in the media id parameter, not in the extra parameter, so you're not testing the new functionality. tests.components.media player.common.async play media doesn't support extra , you can just call the service directly instead: Good point. Changed as suggestion.
With update on add set, this is no longer needed. This annotation does not match the code Lets mark it available first, if the first attempt fails, it can be marked as unavailable. With the use of attr available this is no longer needed To prevent is constantly showing an error in the logs on each try, you could add a check if it was marked unavailable already. This can be set as entity class attribute, making the code more compact: entity-class-attributes This can be set as entity class attribute, making the code more compact: entity-class-attributes This can be set as an entity class attribute, set in the init , making the code more compact: entity-class-attributes This can be set as entity class attribute, making the code more compact: entity-class-attributes This needs only to be calculated once, right? So maybe pre-calc it in the init so it doesn't get figured out each time the property is requested. Additionally, the entity class attributes might work for this in that case as well. This can be changed during normal operation, so it wouldn't be correct to pre-calc it This can be set as entity class attribute, making the code more compact: entity-class-attributes in the init : The returned value is never used? The title seems a brand name, I guess that doesn't need to be translated Please do not mock out core functionality, instead, mock out the client library so the full flow in the core can be tested. Mock out the client that raises the side effect resulting in InvalidAuth instead. Same as above, mock the client with a matching side effect instead. Frigidaire is [eventually consistent]( which requires this hack for things to feel right These are all implemented in the parent entity climate class :) Looking at the upstream code, it seems like this method can throw exceptions. We should catch those here and throw a ConfigEntryNotReady in case of connection errors and for authentication errors, we should either abort or trigger reauthentication. HVAC MODE AUTO is used for when on a schedule, learned behavior or AI. I don't think eco matches that? I think this should probably be part of presets.
Should it be a float or an integer? It makes more sense, thanks! If the service is not specific to this switch platform, please move the registration to the integration init module instead. Done! I moved in the setup ... I don't like the way I collect the controller in the code ... I would prefer to get it from setup controller . I would prefer to change and use setup controller instead of use the hass.data dictionary and the nested array.... We can only register a service once. We need to address the correct controller somehow. We could pass the host address of the controller we want to target in the service data and look up the controller with that information ( controller.rainbird client.rainbird server ).
Integrations that integrate devices or services should not compute new state. They should just provide the state of the device or service. We have other integrations that compute state, eg template integrations. So, does that mean this PR has no chance to get integrated? Yes, sorry. We divide the responsibilities between integrations that integrate devices or services and integrations that calculate state based of input from other integrations or user templates. We don't allow mixing this up.
We don't store datetime in the state machine, so there is no need to store this as a datetime in a property. I would just forward the data as-is. We should also make sure we document in the dev docs what the isoformat is for datetime.fromtimestamp(0) , such that MQTT devices can send that as-is. last reset is documented as returning a datetime though: We could update it to allow either a datetime or an ISO-formatted string? Edit: We still need to validate the ISO-formatted string received over MQTT and make sure it's in UTC, or should we accept anything? How does the rest of MQTT work? Do they validate incoming data? Yes, we validate the data.
Move this before ATTR LAST TRIGGERED to better group things and keep them in alphabetical order. Done : 1:
I agree, these should not be added to default integration. Add to microsoft integration instead.
Why this if continue, doesn't the next if handle this? I had to refactor this because I couldn't use the python 3.9 scope. I forgot to remove the continue. Thanks! Fixed in ef6a2042a768f493eec7b53db363c923e60bacd4 Should the key be service type location? UPnP defines a UDN as a unique device name, specifically used to identify devices. Some devices randomize ports of their location thus this will be seen as a new device. However, some devices randomzie their UDN and thus will also be seen as a new device. So its a choice between two 'brokens', not sure which is the best pick in this case. This is the existing behavior so I didn't want to change it. If the only reason that we still rely on netdisco is UPNPEntry , we should consider copying that into this integration and finally dropping netdisco. We still need netdisco for discovery , but at least we could drop it here. Dropped in the last two commits
Please add a schema to validate the input instead of validating in the service call handler itself. To validate the device id , add a validator function to the schema. Suggest to call this parameter device id instead since it's a Home Assistant device registry id. Please don't use dict.get to access a key that we know exist in the dict. Use dict[key] . We can speed up the look up below by using a generator expression instead of a list comprehension. Just swap the brackets for parentheses. And pass the generator directly to next here. break when we find a match. If we're raising an exception we shouldn't also log the stack trace. Include the log message in the exception argument instead. Please don't use conditional logic in the tests. Use pytest.mark.parametrize instead to test different cases. Avoiding conditions in tests will make them more robust and easier to read.
We don't need to accept kwargs here. We can just name the parameter the same as the service data attribute, ie days .
For integrations that connect to devices or services, we no longer accept new YAML configuration or changes. This integration needs to be refactored first to use a configuration flow and config entries first. More information about this can be found in Architecture Decision Record: - ADR-0010: decision For this integration, there is a PR open to migrating it. That PR needs to be completed before this feature can be added. Any help getting the PR that adds the configuration flow merged, is always appreciated .. Frenck I see, my bad for not checking. I believe this feature is being added in the other PR anyways. I'll check what I can do to help getting it merged ;)
How much data is this requesting from the tractive server? Each call to create trackable entity also triggers 4 requests to tractive? Would it be better for tractive if we not do all these in parallel? Not so much, matter of 1-2kb for all requests. I can try to optimize it and reduce the number of requests I guess it's ok. Since I also work in a company with an open API, I see some integrations that generate a lot of unnecessary loads, I always try to think of that :) Anyway, the requests are only made on the startup, if the user won't restart HA 1000 times in row, this traffic won't be noticeable. Also I don't think there are lots of HA users who are tractive clients. Danielhiversen BTW, would you like to join me as a maintainer? Sure Can "position" and "hardware" be in the same event, or are these always separate messages? I can't know exactly, but from my experience they always come in separate events, except the very first one which is received right after the connection is established Is a recommended way? My library which my other integration [Syncthing]( is based on also supports passing a session or an event loop to the client, but I was asked to not pass a loop, didn't try with a session. It is recommended (and required for platinum level: platinum- ) This is a brandname, I think that doesn't need to be translated in this case. Please update the translation file after change the strings If entry type is not service we don't need to define it. For it to be silver-rated, it needs handle expiration of auth credentials. Handles expiration of auth credentials. Refresh if possible or print correct error and fail setup. If based on a config entry, should trigger a new config entry flow to re-authorize. silver- F0 9F A5 88 Currently, the integration only checks this in the integration config flow, but doesn't have a flow for handling reauth for when e.g., credentials expire later on. It is handled by [aiotractive]( L85) zhulik A package cannot offer a home assistant configuration flow to ask the user to update change their credentials. frenck got it, could you please point me at an integration that does it properly so I'll use it as an example? Sure, search for config flow.py's that have async step reauth implemented I've just gone through a couple of them, just to confirm: I need to wrap all 3rd party authentication errors into ConfigEntryAuthFailed and implement async step reauth in the config flow.py ? All the rest will work automagically or I need to take care of something else? I think that is correct. Raising ConfigEntryAuthFailed will cancel future updates zhulik You could also remove the quality scale and add this functionality later. Would be nice to have this merged. If it's an authentication error we should probably raise ConfigEntryAuthFailed and add a reauth step in the config flow, to let the user re-authenticate. For other connection errors, that we think may be resolved automatically, we raise ConfigEntryNotReady . It doesn't loo
Does this make sense to setup a yaml config for a new integration? Leftover from the HACS integration : Will fix This isn't used anymore I don't think the brand name needs to be translated? Don't forget to update the translation file after this change. This is a single line call to another method (proxy). Maybe just place the contents of setup directly here? async add entities accepts an iteratable Defaults can be removed. This can probably be moved directly into the user step method, above the try block. That way you don't need (and can remove) the AlreadyConfigured class as well. Bonus points for adding typing to the whole integration. The footprint is rather small, so maybe it is nice to do that straight from the start. That would also require typing added to the Adax library? That depends a bit on the place or usage. You can always opt to handle Any , cast or ignore a specific typing when interacting with the library. It will at that point still be valuable on this end. Nevertheless, it isn't a requirement to type. Please only wrap the line that can raise in the try... except block. Maybe we can use the account id as unique id for the config entry? unique-id-requirements Host isn't included in the form. Invalid auth string isn't used.
We are using both invalid and insecure . Is it actually invalid, or is it just insecure? If it's just insecure, we should also update the label to be "Allow pairing with insecure setup codes" Insecure makes more sense here. The logic was these are trivial , therefore insecure , therefore invalid
It it a good idea to remove the device class ? it is not removed, it is now set as a class var, together with the others. entity-class-attributes thanks. If you change these to use .get , you can drop all the entries where you set an attribute to None from your code above ATTR LAST RESET: None (this could be done in a future PR) I'm doing a bigger cleanup when ClimateEntity has been migrated to support class vars for its entity attributes, the whole additional entity abstraction in this integration can be removed at that point.
would assume to broadcast based on mac should be enough to perform WoL :thinking: If they have a bifurcated network directly sending to the ip address may be needed since 255.255.255.255 will go to the default interface and the tv may be connected to another interface does "bifurcated" include "vpn" ? (this is the day to learn new words magic packets can only be send inside the same own broadcast domain, so no to vpn, nor other only routed reachable targets ;) But yes to add also ip in the first, to be able to handle multi NIC setups does "bifurcated" include "vpn" ? (this is the day to learn new words It could any network interface vpn or otherwise. In this case its likely a second network physical interface. Note that we should not allow adding any options for this wake on lan usage. If users need options they will need to use the script.
Can I get some help on how to use the media browser? My use case is to supply a temporary hosted URL to the API. I've browsed through other implementations and couldn't find one that worked I suggest making a separate PR with that feature.
Minor: Move line 74 to line 81 where it is used Done not sure what we are winning by only having the controller ID in case of multiple controllers. Backwards compatibility? Most users only have one IHC controller, and you only need the controller ID if your have more controllers. This is to make it simple for most users. When using service functions and you have multiple controllers, you must specify the controller id. Showing the controller id also helps you to identify the ihc device when you have multiple controllers. oxford comma The change has been applied. Had not seen the async forward entry setups function - this is much nicer. Thank you. For the sake of leanness you could use the config entry id directly for the domain dictionary as that will never change. I use the controller id because if you have more than one controller, you need to specify the controller id (controller serial), when using the ihc services. This make it easier faster to look it up. Can there really be a default IP? The default IP is the IP an ihc controller will have in a default setup. It is also used as default by LK (the ihc controller manufacture) in the software for the controller. I know that may look strange but it will have this IP even if you don't have the 192.168.1.x network. You can change it in the controller setup, but you need to do it from this network originally (or use a usb connection), so I think most users will leave at this IP dovalidate has been renamed to do validate According to the dovalidate method the serial is already a string The cast to str is there because entry.unique id is str None mypy will complain if the cast is not there. That is also why I have the comment above, because we know is it not None. I have changed the comment a bit to make it more clear. This file needs to be removed - no longer necessary. This file needs to be removed - no longer necessary. This is type hint improvement - unrelated to config-flow. Please move to preliminary follow-up PR. This is type hint improvement - unrelated to config-flow. Please move to preliminary follow-up PR. This is type hint improvement - unrelated to config-flow. Please move to preliminary follow-up PR. This is type hint improvement - unrelated to config-flow. Please move to preliminary follow-up PR. Not needed Unused This is type hint improvement - unrelated to config-flow. Please move to preliminary follow-up PR. This is type hint improvement - unrelated to config-flow. Please move to preliminary follow-up PR. This looks like useful validation, but is it really linked to config-flow? Adding device info is great - but is it dependant on config-flow?
We never had a light platform, we can remove this part. removed. The imports need to be in alphabetical order. Use isort light.py to automate the process. ok, updated. We are implementing an abstractmethod, so we need to mark this class as ABC: updated. Some lights do not support RGB. These could be attributes of the child classes. We also need a rgb color property in such cases. this is actually still an artifact that is not actually used. The get state does return red, blue and green values and these can also be set but is it actually useful to also include RGB-support if HSV is already included? won't RGB get automatically converted to HSV if someone does choose to use it? so the question is: do I add RGB-support to the BroadlinkLB1Light and remove it from BroadlinkLight or do I just remove the feature entirely? We can only fetch data via update coordinator, so data await self. device.async request(self. device.api.get state) is not allowed. We can set these attributes at init instead of initializing them with 255 . The state comes in coordinator.data . Here we only need to subscribe to updates. ok, I've changed it to what you proposed We need to update the state attributes here. ok, I changed it to use the coordinator.data just like at init. It seems to be working. No need to get the data here, right? This needs to be False. changed. We can remove this property. removed. Please separate words with underscores for PEP8 compliance: color mode , color temp adapted to the standard. This can lead to bugs, we need to think about side cases. What if the current color mode is 2 (SCENES)? We are storing it as COLOR MODE HS and here we are setting it to 0 (RGB). The scenes color mode is for now not supported as I didn't implement any of the effects. For now, I put it as COLOR MODE UNKNOWN. Is this ok? We don't need this. removed. We don't need these helpers. removed. We don't need these helpers. We don't need this exception. Need to remove the constants we are not using. We have 3 color modes: 0 (RGB), 1 (WHITE) and 2 (SCENES). We need to store this information to set the state correctly at self.async turn on . We don't need this. removed.
echoromeo How did you intend to do this? I figured out a way to do it, but when looking at the climate UI, I think it makes sense to keep the current behaviour and just remove the todo. This is a brand new integration there is nothing to import. Please do not include additional languages (only the main strings.json and en.json ) Config entry setup is already logged by the core, I don't think it is really needed to log this again. Since we don't need to track the unsub anymore, we can just store the hub directly. I think we should stop the hub, once all entities are unload (to prevent possible calls from those against a stopped hub) There is nothing to import. We don't support custom integrations. This does not belong in our core codebase. Should this have been started in the integration setup instead? See: entity-class-attributes
Nope, that is an alias I have been getting rid of. There is no reason the hide such a simple typing in an alias. It hurts readability and will to break that down. I think it has only one advantage that it's easier to refactor if we decide to change it with something more specific. That isn't a problem, as the signature changes at that point, which is linted for as well. So even for that, aliasing this, doesn't add anything. The only thing it does, is that it is unclear what "DiscoveryInfoType" entails for a reader of the code that is less familiar with the code base. I think it should be more generic rather than this specific case. Why would I make this less specific? In case someone decide to change this schema, this type should accept arbitrary schema. But in this particular case it doesn't really matter. ok Should it be triggered on empty dict? Sure. The unittest suggests "addon" may expand to "motionEye add-on", which makes this a little repetitive: "... provided by the add-on: motionEye add-on". I just put in "something". Will adjust it to the real-world example one I'm able to do end2end testing. Adjusted test strings to the real world. Since the real value of 'addon' appears to be "motionEye" (as per your screenshot), I think this title probably needs to change. Imagine a case where there's a separate motionEye server and the addon, the titles shown on the frontend would be: - motionEye - .. which is fairly confusing. I think f"{self. hassio discovery["addon"]} add-on" or equivalent is probably clearer. Lets remove the name, and just "Add-on". The discovery service is limited to 1 add-on per service type anyways, thus it cannot collide. We could set the value in the existing empty dict instead of creating a new dict, right? Yes, we could. I found this a more readable solution, as it keeps the schema in the original place (could be just my wicked mind though ) I'm not following about keeping the schema in the original place. It's nice to avoid creating new instances, generally. I misunderstood... Adjusting. I hope I understood it right :) Should we also test that the discovery flow is aborted if there's already a user flow in progress and that an existing discovery flow is cleaned up if we finish and create an entry for a user flow? We could, however, that is handled by (and extensively tested by) async handle discovery without unique id Yes, but if we remove the use of that helper or replace it with something else, we want this to be tested for this integration and fail if it doesn't work. Added new tests to cover that, discovered a bug in our flow handling using it... Fixed in 51105. This PR needs a rebase after that has been merged.
Don't catch Exception -- it should only catch more narrow exceptions. Since this is just re-raising Exception anyway it looks like this can just be removed. Can this be updated now that the PR was merged? Don't catch Exception, prefer a more narrow exception. The value on the right: Should it be "Auth Token"? to match style used in other config flows. Alternatively, could consider a name like access token -- even if it is not quite the same terminology used in the API. Can you test completing successfully after an error? If a user changes the value of host, then clicks submit, then there is an error and the form is re-renderd it seems like the value they entered for the host will be overridden with this host. Am I reading this right? Any tests for discovery? Is this needed? Typo 'Vetadata' Is it ok to update metadata without updating volume if volume fails? You can omit None from all of these, since it is equivalent to calling get("title") Should this only be called when muted is false? It seems like its undoing the mute in the mute case.
Can we implement the property instead? yes, but let's do that cleanup in a separate PR, or do you mean add the state class as a property? The latter, yes. OK, fixed in 6a8c869
This is a hack purely to add test coverage to an almost impossible code path. Unfortunately, I cannot get test environment to tun on my local machine so I kinda do it blindly. I'm actually tempted to just call "private" function data. update site() instead because this one fails due to event loop constraints. This is a state not an entity. Please rename the variable appropriately. Can I do this in a separate PR? There are 100 references of entity in this file and renaming them all would really pollute the diff Yes, it's ok to address this in a follow up PR. : 1: Please don't access integration details in the tests. Move time forward as needed to have the integration poll and update state. Please use this helper: L149-L155 Please only make a single call to async add entities . Please don't use ternary operator expression if it spans more than one line. Use a regular if else block. Please break long strings around 88 characters. This modification should be done with a patch from unittest.mock. This call only seems to happen during integration set up. Why call it explicitly here? Pretty much the only reason this test even exists is to add test coverage to the case where site doesn't exist when update hourly or update daily is called but site doesn't exist. This is a very hypothetical situation and the only way I could reproduce it is by explicitly calling async update site again. Why aren't we inheriting from CoordinatorEntity? We could clean up a lot by doing that. You are absolutely right, we should use it! And it will definitely make things much simpler. Optional improvement: This could be a dataclass: dataclasses.dataclass To be honest, I'm not sure there would be much benefit from it. I would leave as is. The benefit is the typing and not having to define the init method. Yeah. The problem is that it's kinda tricky to type these things. Datapoint doesn't provide good types for forecast values we use here. Yeah, it can be an improvement to be done in the future.
This might work. no dice on that one Thanks for checking Please add Final to constants. done Why is it not in const.py ? No good reason, just haven't moved it yet. These are automatically inferred. Maybe add it to .strict-typing as you have it mostly annotated already? Optional[X] is usually translated to X None . It actually should be other way round. async response should be applied first. The websocket command decorator just stores some data on the function it wraps. All other decorators should use functools.wraps which copies that info. The only thing that matters is that require admin is above async response because it means we check admin rights in a callback before we schedule the async command handler. To match types async response should be before other websocket api decorators. Because it takes async and returns sync function. Other decorators don't modify function signature. That means websocket command should be also above async response . Adjusted in 770ce44a7d Maybe just import it from conenection ? Adjusted in 770ce44a7d Alternative is to import it inside the function where it's used. switched to the late import Maybe we can avoid pyroute2 usage here by opening a socket to the next hop and checking the local address ? Need to test that If that works it would be more portable We could also provide a function for integrations like dlna to find the right interface to bind so it's reachable as listen ip isn't being detected per the url The functional test (non-blocking) worked as expected and should be more portable. The pyroute2 requirement has been removed. To save one yield to the event loop, chek if ZEROONF exists. Isn't the config schema already applied in the websocket command? Do we double up here so that we can call this function from something else than the websocket command and still validate the config? Is there a use case for knowing the configured adapters too from outside this integration? I was reading the tests and if we would have access to both network.adapters and network.configured adapters via helpers we could use the helpers in the tests. We could use the helper(s) here and not have to access integration details in the tests. But if there's no use case outside the tests, we don't need to add it.
This PR is changing our entity model. Before we can review this PR there needs to be approval in a discussion in our architecture repository. changing-the-entity-model Oh that's odd as I have another PR [47049]( which implements similar changes and hasn't been flagged for this. No one has looked at that one yet.
Let's call this coordinator. Why do we need this method? Please wrap all the sync work into a single function that we can schedule once on the executor. It's expensive to switch context between async and sync. Probably make all the refresh helpers sync. Just access the attribute. Please separate words with underscore in variable names etc. This is the coordinator. We can use the first refresh helper. Hmmm, it used :) It's set by the parent. L47 Please change all of these. The coordinator is exposed as self.coordinator in the CoordinatorEntity. done We can remove this. It's already supported by the base media player entity. L840-L850 It would be better to make a function that loops and does the sync calls and then schedule that function once on the executor. done
Pretty sure this will work, but I don't have zwave up and running at my current location to validate it Updated. Can't verify at the moment either, but tested that the service call passes the schema validation. The backend on pyisy can handle either integer or string and casts as string before calling the resource anyways--don't see any reason why it wouldn't work. Respond Using state attributes like this is very unconventional. as an entity extra state attribute Will fix typos when I push the new test for the system health info. RE: returning parameter as state attribute, I agree it is a bit unconventional, but I didn't see another easy way to return a value from a user request and make it available for use in the state machine automations; the ISY994 integration doesn't yet have the same per device configuration options that the built-in Z-Wave integrations have--I just wanted to share my reasoning: 1) Similar method is used by the androidtv integration [services]( services) to return requested information. 2) PyISY (upstream module) is designed to return new aux properties (state attributes) on the fly as they are sent by the ISY since not all information about a device is available during the initial query. This is an extension of that principle and uses the existing infrastructure the module and integration provides, except that the value is formally requested by the user rather than just sent upon first change.
Ideally we setup the integration and patch pyisy instead of accessing hass.data directly, but this isn't a show stopper I was modelling this off the other system health tests from the different integrations. Several were just patching in the data. I'll see if I can come up with a better way to patch PyISY--I was worried it was going to make the test too complicated since you'd have to patch out the full connection initialization sequence in PyISY--doable in V3, just not simple. Seems like every? integration that implements this is doing that. Please address this in a follow up. The other existing tests are not well implemented.
Why do we create a new lock here? Why not create the lock in init method of this class? It must be created from within an async context. All SonosSpeaker instances are created in a sync callback now. Shouldn't we create the lock before we subscribe? Is the subscription started two lines up? Yes, sorry. I misremembered the purpose of this method.
MINOR: import DOMAIN. That may be confused with the MQTT DOMAIN , i think this is OK as is.
We don't allow device interfacing integrations to consume states from other integrations. That is reserved for integrations that only consumes other states and doesn't interface with devices directly, like template integrations. So would this be something that could be integrated into the climate frontend integration instead? No, it should set up the sensor platform and provide its own entity based on the same data.
Why checking twice the same value DEFAULT CONSIDER HOME.total seconds() ? Thx, copy paste error ;-) Since for now this is the expected return type To be uniform with FritzBoxToolsFlowHandler How can dev info be falsely? Fixed logic Change the test to set a non-default value so we know it changed Why change this? dt util.now isn't always utc. Its in local time if they changed the time zone as this is used in a attribute we should display the local time: Last time reachable: 2021-05-22T22:57:20 02:00 The UI should translate the time to local time if its in isoformat Unfortunately, it doesn't if it's an attribute. This is why I changed it MartinHjelmare can you give your advice here please? Looks like we only convert it to local time if its DEVICE CLASS TIMESTAMP L73 We should leave the backend as is and make a PR to localize isotime attributes instead as localizing is a job for the frontend display layer in L108 Times in the state machine should always be UTC. Reverted, should be good to go now. Side note: we need to check other components for wrong usage of now() Not sure if its worth checking though So you suggest just a bare update ? Is there any other time we update the config entry that we would not want a reload? Not now that we have only 1 config option attrs isn't used anymore. Will be removed here:
Please inherit from SensorEntity too. Please also set the device class property to "humidity" . available-device-classes We normally don't set a custom icon when setting device class. It will already have a specific icon in the frontend. Does this sensor measure carbon dioxide? Then we could use the corresponding device class. Its not carbon dioxide, at least not directly. Following the official website, the Twinguard measures volatile organic compounds (VOCs) such as evaporated cleaning agents or vapours from furniture. Is this temperature measurement not available as a separate sensor for this device? The ratings are an enum with possible values Good , Medium , Bad , which is compared to a preset profile (livingroom, bedroom, ...). For the temperature measurement, a temperature entity is already added above. Ok. I think we should make these separate sensors unless they are dependent on the main sensor state measurement somehow. Please set the device class to energy instead. We also provide binary sensor device class for battery which may be applicable instead. I will move this to the binary sensor platform. What does this measurement represent? Can we make a separate sensor instead that is disabled by default? The state is an enum with values VALVE ADAPTION SUCCESSFUL , VALVE ADAPTION IN PROGRESS , RANGE TOO BIG , RUN TO START POSITION , IN START POSITION . They actually belong to the valve tappet position, so I would keep them as state attributes. Yes, good to keep them here. We don't want side effects like logging in entity state properties. Please move it or remove it.
We should avoid this and open up the API as public instead. Yes that makes totally sense! How should we proceed? By making that happen? Haha :D I see. I will open up a PR at the API. Did that: Fixed by 50798 and upcoming commit. Fix file docstring: Should be "Sonos alarm" Thanks! I will change it! discovered is a dict keyed by uid . Is this method necessary? Oh I totally agree! Please don't remove this. Alright. I will readd it Should use async context. I'll change it This should not be explicitly set. The name property will take care of this. We could do this in principle. However, the name is chosen to be dynamic (i.e. it can change when you switch the room or change the time). This would lead to wrong entity ids. If these alarms are expected to be transient, should we bother adding them to the entity registry by setting unique ids? The unique id is set by the alarm id which is unique, will not change and is not recreated. Therefore, the current implementation uses unique entity ids and unique ids that are indeed unique for an alarm. The other entity types don't store this as an attribute anymore. Can this be removed for consistency? Sure why not New standard is extra state attributes . I'll change it Updating the platforms ready set is done in entity.py here: L59-L61 This call will mark it as ready too early. Yes that's True. But we need to add it at least in an else statement, because there might be no alarms for a speaker. Fixed it in new commit. This shouldn't be necessary. Perhaps the platforms ready call above caused the need for this? No its still necessary, because there might be alarms added during runtime. Upon entity creation they will call async handle new entity and will try to resubscribe. I think there is no way around it. But I think it doesn't do any harm. You don't need to store this and can use get alarms(soco) in the loop in 78 directly. Thanks. Fixed it. Instead of another local attribute to keep track of, can you just return self.alarm.enabled from the is on property?
Shouldn't we only pop it from hass data if unload was successful? Or else it has been removed pre-mature. Should not be needed This isn't used anymore Why are you casting None here? These are not part of the current try-catch block and should be placed out of the try scope. Why is None casted here? I usually put fields that are initialized later in init () so it's clear what fields that class actually has. Just self.uart None doesn't go well with mypy however, so this is what i came up with. In case of uart this fields stays None in case a USB fails to setup, and in light.py it is compared with a None to see if the cloud or a USB should be used. What would you recommend? Initialize them as class attributes: I think you'd could remove this step and use the list in step usb config , add a "Don't use USB" at the top of the list. This is a manual path flow. Why are we trying to outsmart the user in this case? fair point, will remove the by-id check. You'd benefit from: entity-class-or-instance-attributes Reduces the LOC a little bit in this class. Add usb to dependencies or after dependencies and call usb.get serial by id instead Is there an account id that can be used instead? sometimes-acceptable-sources-for-a-unique-id-for-cloud-services yes there is, good catch Since there are multiple ways a flow can be finished. Please rename this to show intent. Don't start a new flow here. The removal and or addition should happen as additional steps in the options flow. Its not a great experience for the user if they have to switch to a new flow once they reconfigure options. I assume the same step (code) that is used in the config flow for the usb currently, but living in the options flow? Do you know an integration that does this that i could look at as an example? Does this need to be canceled when the config entry is unloaded? this is done in self.sse.close client() in async unload . It closes the connection, and exits the async context manager, which finishes the task see L268 Reverse the condition and outdent the block below It looks like there are already guards to prevent entering this function if self.existing entry id is None . The str shouldn't be needed here In a future PR you can raise ConfigEntryAuthFailed to start a reauth flow. Reauth would be a nice addition in the future indeed in case a user updates their password :) This looks like it could moved into a new function, maybe async setup usb ? Is this safe to run in the event loop. Does it do I O? The eventbus is a singleton Initialized here The unsubscribe function simply removes the callback from a dict. but from what i've seen the eventbus seems to run in one of the UartManager UartBridge threads, but i don't maintain this one so it's hard to say. Is it wise to wrap this function you think? Is this safe to run in the event loop. Does it do I O? Then outdent below
Please add test cases that asserts the device class state attribute after setting up the integration with corresponding device fixtures.
We already have this in the entity registry: users-editing-the-entity-registry This PR follows this approach - integrations-offering-options-to-control-disabled by That is not meant to be done per device or entity, but should be some kind of group. We can already disable entities per entity. The intention is to not pollute the device registry with all known devices, if only one or two will be tracked. In my case, my Fritzbox knows about 40 devices ( tv, radio, alexa, laptops, pc, FireTV, tablet, NAS, some VMs, guest clients, and my smartphone ) but I only want to track my smartphone. Yes, the entity won't be tracked if it's disabled. This is why we added that option in the first place. So that we wouldn't have to add this option specifically to every integration. Mhhh ... so if entity registry enabled default will be False for all device tracker entities, will related devices ( regarding to device info ) still be added to device registry with disabled device tracker entities, or does neither the devices as also the entities were registered? EDIT: After some tests, now it is clear to me, that if entity registry enabled default is False , device is still created registered, but with disabled device tracker entity. So now I'm still a little bit confused, if it is still OK to register 40 devices, where 39 has each a disabled and only one device has an enabled device tracker entity :thinking: :confused: Devices can be disabled too. If a device is disabled, all its entities are also disabled. So the user can disable a device and all its entities or go down a level and disable specific entities. The devices and entities will still be registered in the device and entity registries. But that doesn't impact performance really. So there's no point in avoiding that. The devices and entities will still be registered in the device and entity registries. But that doesn't impact performance really. So there's no point in avoiding that. ahhh ... ok, that is good to know, thanks : 1: chemelli74 What do you prefer 1. add disabled devices, which inherits to connected device tracker entity 2. add enabled device, but with disabled device tracker entity would prefer 2) since it is quiet easier and less complex to implement and entity handling is more user friendly on frontend, than device handling I would vote for 2. as well The agreed solution will be implemented with 50791. This PR will be closed unmerged. We already have this as a system option: config-entry-system-options-setting-default-value-of-disabled by-for-new-entity-registry-entries Where is this used? It is also used on configuration options, in case a user want to add all devices to be tracked. But where is it used in the integration? when CONF ADD ALL TRACKER is set True than CONF ADD NEW TRACKER will also set to True and all devices will be selected here: L291-L294 So if we don't add the other options we don't need this one either? :wink:
self.coordinator.data[self.index] appears quite a bit in this integration It might make sense to make a And then use self.data Great idea! I implemented this change. From your comment it doesn't seem like your intent was to schedule an update, only write the state of the entity. From your comment it doesn't seem like your intent was to schedule an update, only write the state of the entity. Will async write ha state() call the is locked() function again in order to recalculate the current state? I need to make sure it recalculates the state so that it will use the assumed lock state instead of the state from the API response. After some testing, it looks like it does call it again, so I went ahead and made this change. Should we refresh from the api after the unlock to make sure it took effect? Should we refresh from the api after the lock to make sure it took effect? After re-reading your comment above, I'm going to say no. Should we refresh from the api after the lock to make sure it took effect? After re-reading your comment above, I'm going to say no. The problem is that after locking or unlocking the doors, it takes several (2-4) minutes for the API response to reflect the new door lock state. That's why I didn't bother to schedule an update right after sending the lock unlock request. The vehicle status wouldn't be any different from the previous update. We get the latest status every 60 seconds anyway, so I figure it will update on its own after a few updates. That's actually the reason I implemented the "assumed state" logic. With this logic, it will optimistically assume that the door lock unlock action was successful. When the vehicle status timestamp updates, or a 5-minute timeout period elapses, it will revert back to using the API state instead of the assumed state. An alternate option to avoid the refactor would be to store the client as a property of the coordinator in a subclass Example: L80 Its fine either way, but this might be easier to maintain. I think I'd like to keep it as is, if that's OK. But thanks for letting me know about this! There is a STATE UNAVAILABLE constant available Ideally Home Assistant doesn't know about the implementation detail that locking takes up to 300s We should abstract this implementation detail in to the pypi package and ask it for the assumed lock state (or similar). If you need to change the time window, or details a bit in the future, you will get a much faster review merge since it won't affect core code. OK, I see your point. I'll have to figure out the best way to move this logic into my pypi library. It might require a bit of refactoring. bdraco All right, I've moved the assumed lock state logic out of this integration and into the pymazda library. Verified no I O L121
Just a note, and it wasn't handled for states before either, but this will send over the attribute even if it hasn't changed. Yeah, I found that odd as well. So, if I create 2 sensors in ESPHome for the same entity, but for different attributes (e.g., a light state brightness). Change one will trigger an update on both. As you stated, was already handled for states this way, hence I kept it like that. However, it might be a good time to change the behavior to only communicate changes? The initial state is synced on the initial connection, so I guess it works if we just send changes? It might be considered a breaking change though.

Mac address should be exposed in the corresponding property. properties The other info is static and not part of our entity state model for device trackers so that's not allowed to be added to state attributes. MartinHjelmare So, to clarify, only the MAC address is (currently) allowed as part of the state attributes? My main use case is to display use the software version and model (and manufacturer, but less important as I can hard-code that) in state template sensors and for display on the frontend dashboard. Is there a way of accessing this data from the device tracker in this way? There's currently no way to do that. Templates only get access to state, ie not device info. Just reviewing the rest of the UniFi integration and it already appears to be providing static attributes into state for tracked client devices, as well as attributes not on the Device Tracker Entity properties list -- e.g. L33-L56 Since this is currently happening for client devices, providing relevant attributes for infrastructure devices seemed like it would be in line with the current code base. If this isn't acceptable behaviour (as Kane610 was mentioning), then where would a change for providing access to device info in the state be best discussed? Should I start a discussion on I'm not wedded to the idea of putting this data into state attributes, but just somewhere it's possible to interact with on the frontend and available in templates templated sensors. Yes, you can open an architecture discussion. Discussion opened at MartinHjelmare Do you have comments for the discussion at so we can make progress on this? Sorry, I don't have any comment. I don't think it's high priority at the moment to solve this.
Missing return value typing. This feature PR has been fully reverted during the beta, as it locked up Home Assistant as a whole. Right, forgot about that. fixed in We don't care if this fails since it only fixed in I don't believe get mac address is async safe. Maybe this is the reason for the slow downs that made us revert this? that would do it, and it makes way more sense then suddenly a problem with subprocesses. fixed in
"A4CF12" is one of the ranges registered on Espressif, is it documented that goalzero devices will always use this range, or is it better to ommit it? Yeti power stations use what's called Mongoose OS which Espressif recommends for ESP32 chips. My yeti uses an esp32-wroom chip. I believe they will continue using them. OK, but espressif have multiple registered MAC address ranges, not just this one. Would it be acceptable to use multiple ranges? This error string isn't used. When is the flow title used? This is unique enough that you can drop the oui and implement async step dhcp in the config flow to abort in the very rare case (probably won't happen unless someone is very creative) you match a non-goalzero device. You should also implement in async step dhcp likely in this order 1. Set the unique id (likely the mac) 2. Abort if unique id already configured 3. Abort if the specific host is already configured 4. Abort if its a non-goalzero device 5. pre-filling the ip in the form and showing the form Or even better, don't show the IP in the form at all, as it is known at that point. Since no auth is required, you could also do self. set confirm only() Please don't share errors between steps. The errors are specific and private to the form of the step that generated them. We can raise an exception instead. We have self. async abort entries match now that does this. We don't want to update an existing entry when creating new entries. This can be removed. I would name this something else if we do more than try to connect. For unknown error I'd log the exception stack trace at debug level. Pass exc info True in the debug log call. Pass an empty dict. It's just a confirm form. Please assert the abort reason too. This is very similar to async step user . Maybe break it out into a function that returns errors instead? But that's probably not what you want since you are doing return self.async abort(reason errors) . You probably want to return just unknown Then do a
This is a very expensive way of doing if not self. attribute.starts with(f"{attribute} "): continue It's only used if self. service SERVICE ALL TRIPS so no need to fetch earlier.
Should this be "Water Heater" entity or light? This is fixed. Good catch. This is reverting a change that should not be reverted :) Thanks - reverted back. Fixed Not really required, but it would be nice if we could type this method. While we're in the patient... no problem. Please move the definition of constants up to the top of the file Because the definition uses the OmniLogicLightControl entity it has to be defined after that class. I chose to keep it at the bottom to ensure no issues. If I move this to the top it creates an error. "entity classes": {"lightState": OmniLogicLightControl}, Not sure if there is another way to manage around that? I'm guessing that moving to entity descriptions likely will simplify this and it will get sorted out. Instead of an else clause, guard it. E.g., first the inverse expression of you have now, raise if that is true. Next, you can continue without needing an indent. OK - think I got this one. Same as above, if you change it to this, and move it up, you can un-indent this all. Not anywhere near as valueable input as frenck's, but one food for thought. Depending on how this is refactored, it might make sense to make the message be related version 2. e.g. to avoid confusion in the event that version 3 lights are one day released (which would be treated as V1 "by default"). One possible way to adjust the message: "Light effect speed and brightness only supported with version 2 lights." The wording is also a hint that the h w once it is imagined and produced may support, but the code needs updates. Have changed to a guard frenck edrikk if they release a lights version 3 we will need to actually do some work in the Python library to extract any of that new functionality so I would address that at that stage. I have found it very hard to "future-proof" anything related to this integration. Fixed. Please consider using EntityDescription s instead. Not sure what you mean on this one. e.g. something like L27 ? This can be re-written without the need for using else Got it.
Not sure of the conventions of HA does the fact that these don't have leading underscores imply that these functions are public and part of the API, or is it understood that this is all private in some way? Good call, lets make them private You should be able to skip the .replace(tzinfo None) on both sides of this equation, since intra-zone comparisons only look at the na ve portion of the datetime anyway. Since each .replace requires constructing one datetime, and datetime is somewhat expensive to construct (fast paths on my laptop are around 100ns, though weirdly dt.replace(tzinfo None) is consistently measuring 1 micro second!!!), it's probably best to avoid the extra work. Test still passes non folded.dst() folded.dst() is unnecessary here. Ambiguous datetimes will exist only when the UTC offset has changed specifically when it has gotten smaller. There should never be a situation where dt.utcoffset() dt.replace(fold not dt.fold).utcoffset() but dt.dst() ! dt.replace(fold not dt.fold).utcoffset() unless someone deliberately designs a tzinfo object to behave in this nonsensical way. Removed in a97305e635 This will return True for imaginary times as well: I think you can write this function this way: Though in the current usage, datetime ambiguous is only ever called if datetime exists is False anyway, so maybe you don't care (though it may be worth a comment if not an assertion). LGTM. Replaced in 01e4a8ab1e Thanks! Why is type: ignore necessary here? mypy seems to work fine for me with this on Python 3.9 (though maybe y'all are doing something weird, because the pipe syntax for returning unions is a 3.10 feature, but it seems like tox.ini -e typing would run on Python 3.9... We still support python 3.8 homeassistant util dt.py:51: error: Returning Any from function declared to return "Optional[tzinfo]" [no-any-return] On Python 3.8 it considers the import from backports to be Any . Not sure why. ![image]( Maybe I am shipping the type hints for the backport incorrectly, or not at all? I will look into it.
We have already stored data in hass.data at this point. Fixed. Why not reload? The reload listener will trigger a reload as well. diff-523dd41ae1bde45cdfb516593d8f2f178477bf5ad2706205c96b9d14234c5cd2R191 We can drop this one. It will add the manifest name.
Can we test this by firing the different interview events?
Lets start from the top with your PR text. You have selected 2 items in "Type of change" you are only allowed to select 1 and this is a new feature, not a quality improvement of the existing code. The "Checklist" needs to be marked in all fields (and of course you need to have taken the actions). Documentation is needed for this feature, but that can be added later (before approval). What does this mean ? we do not want commented out code. please remove the empy line. How is that going to work, the name "register size" tells it is the size of a register (e.g. 2 or 4 bytes) you use it as a multiplicator. If it is a multiplicador the name need to reflect that. If you say ALL devices have a multiple of 2 for which there are no guarantee a multiplicator would work, but it is not easy to understand. Why not keep register size as the size of a register. Please remove empty line, and I can see line 129 have not been corrected (independent of multiplier or size). Please you complicate something simple...why have both a register size which in your case is fix 2 and an multiplier...it is a lot easier and more understandable to declare the size of a register (with padding etc). I am lost between regSize and entry[CONF REGISTER SIZE] as the names say they should be the same. default is 2. I don't want break your code For now stays 1 That is your choice, but I thought your idea was to get the code approved, which it will not be. You add a new feature which is super, but you need to add it correctly. default for register size is 2, look at the modbus standard, so you really need to correct this. I can't use 0x11223344? That depend on register size and what you want returned. As it is it returns 2 registers each 2 bytes. Count 1 byte 4 I think that is tests engine error Because work in real world Only fail on tests.... Yes the config with 2 registers will produce an error if you specify count: 1, that is logical. But don't only think, debug and find the problem. I do not think conftest.py care about the register size it returns what you ask it to return. This test pass as it is. Soo... You simulate that the device returns 2 registers 2 byte each, but your configuration says you want 1 register with 4byte so you need to change the tweak. We do not tweak tests, they exist to confirm that your code work as expected. If it fails with 1 register 4 bytes something is wrong and you need to find it. "Tester engine" only work with words... That is basically the same as DEFAULT STRUCT FORMAT, that looks wrong, unless there are a good reason in the code these 2 structures needs to be unified. If that is no longer needed, then please remove it from const.py, and explain why change the name. What was wrong with DEFAULT STRUCT FORMAT (which still are in const.py) I do not understand the need for 2 identical (or near identical) structures. Without having tested it, I am sure you miss more adjustments in the rest of the swap code. The swap is sensitive to the register size, so
Since the preferred string can grow by appending numbers its possible we wouldn't catch it. Maybe check test string at the end against MAX LENGTH STATE ENTITY ID ? I had protection in place for that at some point, not sure why I got rid of it. Will go with your idea Context ids are a single type so we should only need one constant The check at the end is probably all that is needed. It should be very rare that this hits
We don't need to create a dict and update the attribute dict. Just set the appropriate key in the attribute dict. Thank you, that is probably better. I made a commit changing the three extra attributes as suggested.
Is this label not at risk for breaking changes? I don't find it in the docs. I am assuming this is coming from the device config and is just undocumented (I spot checked a couple of our fixtures and they match). Do you think it would be safer to use the device config label instead? My assumption is correct: L614-L616 Maybe a bit safer to use the device config label attribute, yes. We do have the node label attribute in our model, though. Is the value of the label at risk for change? Well because it is coming from the device config, it theoretically is, but practically speaking I don't know that it will. Do you have an alternate parameter suggestion? I am fine with switching it to something more deterministic, I just don't know what that is short of putting in the effort to support firmware version ranges. now that I think about it some more, it doesn't hurt to try firmware version ranges. There's no discovery schemas using it right now, just this one, and that is what the device database uses to distinguish unique configs. We can use it for now and then if it breaks in the future we can reevaluate Should we use AwesomeVersion already in the schema dataclass attribute, to avoid creating that instance multiple times? Good idea, I can do that in post init
I just checked the mac addresses of the devices I have: KL130(EU), KP303(UK) are using this, but with different hostnames (simply using the model as the hostname). HS110(EU) uses unlisted, unknown vendor (based on macvendorlookup) B0:95:75. Tplink has an odd allocation strategy. They don't seem to constrain a specific device type to a specific range, and just use the next available for their device run. I'll add yours. Looks like B0:95:75 is listed here at least Oh, I just googled the first vendor lookup this time, which said unknown for that hs110 v4 plug... My older hs110 v1 plug has one that's already there in the PR (50:C7:BF) :) Would it make sense to remove the hostname filtering altogether? Looking at this specific change, it may very well be that there are kl and lb bulbs using the same prefix. I thought about that but I don't know for sure that tplink won't hasn't used the OUI for other non-kasa devices.
This has moved to manifest.json . Why do you use get() if host is required? Why do you use get() if username and password are required? Exactly What if the user configures two instances of the integration? The second instance coordinator will replace the first instance coordinator . You can use hass.data[DOMAIN][config entry.entry id] coordinator to avoid this. Why do you want to raise PlatformNotReady during config entry setup? Please add yourself as codeowner. Is it possible that system and firmware will not be present in system info ? And name , model not present in system version not present in firmware ? You are right, the API always returns the values Why do you create device entry here? I realy don't like that api.get system stats is called two times during setup. One time in line 62 and one in 98. You can create device entry in sensor.py file in device info property. Why put an "else" because the call for "return self.ASYNC SHOW FORM " must allow it try .. except .. else means if there are no errors the function will return async create entry . async show form is returned if user input is None . Ok, I understood, I did not see that you were withdrawing the line 77. Thanks. variable is a very bad name for variable Maybe sensor type ? Maybe sensor info ? Or description . Please rename to self. icon . Please rename to self. unit Please rename to self. name Please rename to self.sensor type Please rename to self. enabled This is unnecessary if we're not using the config flow options. I think we could use constants here instead of these magic numbers. For example: ATTR ICON 2 and self. icon sensor info[ATTR ICON] . The code will be more readable. We don't use config flow options .
I don't think we should trigger re-auth each time the update failed. This will now trigger when there is a hiccup in something else (e.g., internet connection interruption). This empty dict is already created in async setup ? This isn't used anymore. Don't initialize a dictionary in a class variable, as this will apply be the same dict for all instances of this class. And actually, you won't need it. I'm not 100 sure, but I believe you can drop this one. You don't have to prefix the unique ID staging? Might be nice to set an icon? "caches" ? Might be nice to set an icon "caches" ? Might be nice to set an icon. "points" ? Might be nice to set an icon "souvenirs" ? Might be nice to set an icon "points" ? Might be nice to set an icon Default don't have to be set Stale code? Stale code?
Nothing is check this value. It should be removed Keep this at debug level as this will generate issues that we won't be able to do anything about Does this do I O? By I O, you mean talk to the API library? I believe it does, I mimicked the other parts of this integration for this part. it worked on my tests. It looks like its accessing a cached property and doesn't do any I O when calling .brightness L37 This should be fine This looks like an exact copy of VeSyncDimmerHA . I don't think we need this since the code is the same that is true, pretty similar, but the library api has two separate domains to reach,one for the bulb and one for the switch ( VeSyncBulb. and VeSyncSwitch. ): From the webjoe pyvesync docs: Dimmable Smart Light Bulb Method and Properties VeSyncBulb.brightness - Return brightness in percentage (1 - 100) VeSyncBulb.set brightness(brightness) - Set bulb brightness values from 1 - 100 Dimmable Switch Methods and Properties VeSyncSwitch.brightness - Return brightness of switch in percentage (1 - 100) VeSyncSwitch.set brightness(brightness) - Set brightness of switch (1 - 100) Also I thought the separate classes would be the way to go for the next step in development, to add a Color Temparature methods specific to the bulb, which I already started in a separete branch, still WIP. using the new color modes . From the webjoe pyvesync docs: Tunable Smart Light Bulb Methods and Properties VeSyncBulb.color temp pct - Return color temperature in percentage (0 - 100) VeSyncBulb.color temp kelvin - Return brightness in Kelvin VeSyncBulb.set color temp(color temp) - Set color temperature in percentage (0 - 100) I thought first a pull request to add the new bulb platform as simple as possible. Without changing a whole lot of code at once. Leave the refactor for the next separate pull. Maybe make a base class for them to share so we don't have to re-implement all the pieces for both types I thought about the base class too when starting to implement diferentiation for the tunable white temperature version, I'll keep that in mind. Also, as I'm diving deeply into more of the code, Maybe I thought some of the names of the variables objects had some importance. but I think you are right, they are just arbitrary names and nothing else. So I will remove the duplicate class for now, as they are really the same. Only bad thing is I don't have a wall dimmer switch to test , just the bulbs. so I hope I don't break anything for the devices I don't have. So, please hold on from merging, I will push another commit first simplifing some stuff and taking your suggestions. Feel free to request a review when its ready as I'll probably miss it otherwise. The mireds values don't look like they are in mireds. 2700K translats to 370 Color temp needs to be in mireds properties This is going to be in mireds and needs to be translated for pyvesync the brightness part is already up to the standards as in the documentation, with values from 1 to 255. the commented c
This doesn't look correct. Is the intention to report the torrents as an extra state attribute? Yeah, so this adds a new sensor, it's state is how many torrents are currently in qbittorrent, and im setting it's attributes here to a json object that represents all available data for each torrent. With this data, a card can be made to view all current torrents, and display things like name, progress, size, eta, size, downloaded.... see here for more info ( get-torrent-list). But yeah basically it's just a way to get all qbittorrent torrent data into a card so you can see, at a glance what all your torrents are doing. Setting it on the hass instance is not correct. We should think about what data is useful in the state machine. Is it useful for automations or just for visualization? If it's only the latter the data doesn't belong in the state machine. i've just followed examples i've found, it worked for me so wasn't aware this was not the correct way of doing it. I'm sure this could be useful in an automation, but primarily, this was the only way i knew of to send this data to a card. If there is a better way of doing that i'd love to hear it as i'm still very new to home assistant. What are the examples you've found? self. hass isn't defined at all for this entity. I don't recall exactly, I was looking around on the web until i found something that worked and this worked. Like i said i wasn't aware this was not the correct way to do this. I'm happy to rewrite it, but i guess the bigger question here is, what is the best way to add this data to home assistant, if it's not useful in the state machine? There's no good way for custom cards. For built in frontend features we normally use websocket commands. ok, well i guess let me know if you're interesting in adding this into home assistant, and i'd be happy to rewrite it to not use the hass instance to set the attribute. but if you don't think its a good addition, feel free to close the request To know if it's useful we have to unpack the data and list each item explicitly. Do you have a list of the items? the json object is a list of torrent data, here's an example of what it looks like copied and pasted directly from the Developer Tools, states tab: 64a980abe6e448226bb930ba061592e44c3781a1: added on: 1620647619 amount left: 2579335168 auto tmm: true availability: 63.08300018310547 category: '' completed: 239403008 completion on: -34200 content path: 'C: Users Username Downloads ubuntu-21.04-desktop-amd64.iso' dl limit: -1 dlspeed: 3629964 downloaded: 239605502 downloaded session: 239997352 eta: 703 f l piece prio: false force start: false last activity: 1620647694 magnet uri: - magnet:?xt urn:btih:64a980abe6e448226bb930ba061592e44c3781a1 dn ubuntu-21.04-desktop-amd64.iso tr https 3a 2f 2ftorrent.ubuntu.com 2fannounce tr https 3a 2f 2fipv6.torrent.ubuntu.com 2fannounce max ratio: 0.3 max seeding time: -1 name: ubuntu-21.04-desktop-amd64.iso num complete: 1352 num incomplete: 30 num leechs: 1 num see
This parameter is supposed to be the type of event. You're just putting the domain of the component which will make it very tough to use since its so generic. Would recommend setting the type to something which describes what is happening. See here: firing-events
I don't think either of these are needed as they are hardcoded in the config and can't change? emontnemery I disagree here. They are set once per shutter and not hardcoded. I did not find a way to access this setup variables via the entity id, but I find it very useful to have, as I can copy a template and only have to update these values and not the template. I prefer to keep them in. Why is this removed, is it a merge mistake? must be, I will check Same comment as above, these should not be needed as variables as they can't change. It's easier to understand the impact of the change if you don't remove tests, but only add new ones, can you re-add the ones which are removed? I have validated that all previous tests pass so indeed we should keep them, it makes sure there is no breaking change in this PR agree, was not intentional Instead of this plus the float() conversion below, maybe like this: py try: percentage payload self.find percentage in range( float(payload), COVER PAYLOAD ) ... except ValueError: LOGGER.warning("Payload ' s' is not numeric", payload) return Please don't modify existing test cases, including this one. To not duplicate code, parametrize the test case instead: updated This is logged on every MQTT message, should not be in info level Why do you cast the payload to float? This makes tilt to return floats instead of integers and will violate the cover base definitions: [Cover Docs]( Agree, but the template might return a string, containing a float, which raise an exception when cast direct into int. updated acordingly This change will not be needed if the tilt is not cast to float reverted to int template should return a string so TypeError should not happen
Add to line 11 Remove function as not used Add missing attributes from alarm entity L178 I think you should write all in async I understand the concern, I just don't have the time to do it. I think we can leave this as an improvement since many people are waiting on this. Seems not so friendly name How about f"Securitas {self.client.installation alias or self.client.installation num}" Valiate -- Validate
We can use hass.config entries.async on unload to handle the unsubscribe. It's better to move the check before calling this method.
I think you mean register size , because data size would be the size of the complete structure. Expected data size No what happens if you configure datatype: int32, that has fixed size. what you want in your case is more like Remember I can define a struct that contains e.g 4 int32, that would be: data size would be 16 and then you would expect 16bytes in each register not 4bytes in 4 registers. That will not work if count is 1. Work. I add default 2 Should do the same if dont use the data size No it doesn t because you removed the count check, so what happens if I specify count: 5 you need something like register size count ! size That needs to be related to count. Your suggestion breaks existing configurations. Have a default Only above 2 bytes will break But you dont support yet With this custom is fine No need for other datatypes count: 4 will break, look at the test cases that is supported and tested. apart from that you break current valid configurations and that is not good. : 1: Why are you touch the binary sensor ? You are adding a call structure that we have changed. Please use binary sensor.py as it is on dev. Mistake. That is the old configuration, that is frozen and changes are not allowed. This will fail for "old style" configurations, because CONF REGISTER SIZE do not have a default. Suggestion use entry.get(CONF REGISTER SIZE,2) this change is needed all places where you refer to CONF REGISTER SIZE. Line 127 seems to have a problem too. Line 162 164 needs a new calculation, because they assume register size of 2. Line 302 depend on register size but I am not sure if that needs to be changed. entry.get(CONF REGISTER SIZE,2) this fails You can see we it in a lot of places, and we are still supporting the old style configuration that do not have CONF REGISTER SIZE default. Ok I try again Because if I add ",2" got an error await asyncio.shield(task) File " config custom components modbus sensor.py", line 146, in async setup platform if entry[CONF REGISTER SIZE,2] entry[CONF COUNT] ! size: KeyError: ('register size', 2) You can see we it in a lot of places, and we are still supporting the old style configuration that do not have CONF REGISTER SIZE default. defaults only are needed when reading yaml... if not found register size set default Why change everywhere? Variable lose it's value? because we need to support register size everywhere. you dont know who will use register size in which configurations. you will use it in your setup but others might use it differently. Adding register size makes it legal to use it for every datatype and every struct. If I add ,2 everywhere fails I properly test? pycache is evil I remove register size from yaml, and failed in DEV Then worked in 2021.5.1 (as custom component) Now current code works in DEV... I don't changed anything in the code I dont understand this. Confusing text because it is not really register size. Suggestion something like "Structure size ( d bytes) mismatch d registers of size 
Can you explain why are you removing ondelete ? For Oracle DB it is invalid statement and for all HA supported DB engines "NO ACTION" (or RESTRICT) is default action and is applied even if not specified explicitly, thus it does not change anything in terms of functionality and behaviour. This should be fine as long as our migration logic doesn't need it. The created table will not have the same definition, but it should be functionally the same. This might actually break update states table with foreign key options in migration.py . We need to create a mysql table with ondelete CASCADE and then put it though migration to schema version 11 to make sure it gets set back to NO ACTION with this change. Ideally we add a test for this. Why would you like to test ondelete CASCADE? Without proposed change it will be ondelete NO ACTION and according to [MySQL reference manual]( - RESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO ACTION) is the same as omitting the ON DELETE or ON UPDATE clause. - NO ACTION: A keyword from standard SQL. In MySQL, equivalent to RESTRICT. The MySQL Server rejects the delete or update operation for the parent table if there is a related foreign key value in the referenced table. Some database systems have deferred checks, and NO ACTION is a deferred check. In MySQL, foreign key constraints are checked immediately, so NO ACTION is the same as RESTRICT. and: For an ON DELETE or ON UPDATE that is not specified, the default action is always NO ACTION. so I am a bit lost why to test what you proposed? Older versions used CASCADE and we migrated back to NO ACTION. We need to test that the migration still reverts a CASCADE to NO ACTION on step 11. Please don't get me wrong, I am trying to figure out what to test, but I dug a bit on models.py and I cannot find any revision with ondelete CASCADE. Previously ondelete was [SET NULL]( L120), before that ondelete [wasn't specified]( L109) and before that [there wasn't ForeignKey specified]( L108) so now I'm lost. Looks like the logic won't remove it with the change Its still there Looks like we actually shipped with SET NULL instead of CASCADE for that column so my query should have been ALTER TABLE states ADD CONSTRAINT states ibfk 2 FOREIGN KEY (old state id) REFERENCES states(state id) ON DELETE SET NULL; We need to do a database migration to remove the constraint from existing installs I pushed a commit to remove the constraint
Any objections to calling these climate target temperature high c and climate target temperature low c ? Existing metric names (especially temperature c ) are ambiguous and don't align with the [naming guidelines]( but renaming them would be a breaking change. New metrics, however, should have more explicit names. Sure, np Or would it be better to use labels for this, e.g. climate temperature{type "high low ..."} ? then if you just graph climate temperature you get all of them Yeah, labels could work as well here. I would suggest these two new measurements to use point "high" and point "low" , while the existing target temperature should keep being reported with no additional labels set (this should be easy to verify with a test). Note that I have just sent [a PR]( renaming the existing climate temperature metrics to align with the naming guidelines. It might be easier for you to build on top of that change, but I won't mind rebasing if you get this PR finished first. Thanks! I'll wait for 50156 to settle before going forward with this one There's been some pushback in that PR from one of the hass maintainers, so I suspect it might stall or be rejected eventually. I am not thrilled about adding more labels to a metric with a super ambiguous name (temperature c), so perhaps the best way forward here would be to add two new properly-named metrics (climate target temperature high celsius and climate target temperature low celsius). WDYT? FYI, 50156 has finally been merged. mdz, would you like to rebase this? knyar PTAL The way this is structured now makes it seem like it's possible to set different descriptions and label keys for each of the three uses of climate target temperature celsius , while in practice the metric will be created when it's first referenced. This might be surprising to someone who is going to be looking at this code or changing it in the future. Do you think there is a way to make the description and the label names defined once for each metric? I'll just switch back to using three different metrics, that will avoid the issue you're describing
Please explain why we need these options. MartinHjelmare the current integration relays on multicast pushes to update it's data, however I have received multiple issues from users that have trouble with the multicast pushes because their network is blocking them (there router is blocking multicast messages, or the HomeAssistant device and the Motion Gateway are in diffrent VLAN's, or the multicast messages do not arrive with a cause that I they could not find solve). However those multicast pushes are not strictly nessesarry since the gateway will also return the state of the blinds from its cache memory using direct communication. But that would mean we would need a higher update intervall giving unnesasarry RF communication between the gateway and the battery powered blinds, maybe draining there battery faster. So the possibilites are: 1) default: CONF WAIT FOR PUSH: True, CONF FAST UPDATE: False Updates every 15 minutes where correct communication with the blind over RF is checked with the arrival of the multicast push, if the multicast push does not arrive after 5 tries of 5 seconds the entity is marked as unavailble (the battery might be dead, or the blind lost its communication with the gateway) 2) CONF WAIT FOR PUSH: False, CONF FAST UPDATE: False Updates every 15 minutes but the RF communication is not checked (multicast push), this means entities will never be marked as unavailble and you can opperate as normal, but the state is not garenteed to be up to date (can be lacking up to 30 minutes if multicast messages are not comming trough because the cache update always lacks behind one update command). This can be usefull if you do not want the entities beeing marked as unavailble whenever the RF communication fails (sometimes happens), normally in this case the gateway can still send commands to the blind and control it but the RF communication from the blind to the gateway fails, so the update command fails. If the entity is not marked as unavailble, it can still be controlled (although of course not garanteed if RF communication is bad). 3) CONF WAIT FOR PUSH: False, CONF FAST UPDATE: True Updates every 1 minute, this makes sure you have a fairly resent state even if multicast messages are beeing blocked. Ok, thanks. Any more suggestions, or is this ready for merge? I haven't reviewed everything yet. Can we remove this option and let the user turn off automatic updates and schedule their own update interval if they don't want the default update interval? In principle that is possible, however since I have had multiple people complaining about the multicast messages not comming through to there HomeAssistant (probably something to do with the network setup, but maybe code related), the default update intervall of 15 minutes is to slow in case the multicast does not work. Therefore this gives the people with multicast problems a easy way to increase the update rate to not relay on the multicast messages. So basically because this is a com
Does this handle a None value? Specifically I'm wondering about vol.Lower . No, that won't work. And maybe it's weird to set the STATE CLASS UNKNOWN to None ? If we need an unknown class I'd name it "unknown" . But maybe we don't need to differentiate between that and not implemented ( None )? Yeah, we don't need unknown if we have None . There is no reason to do this, as we won't use the data anyway. Let's just expect people to return None . Fixed in cb50f9d Why do we change the broadlink tests? That might indeed not be needed, I'll double check before merging.
Wouldn't it be easier if we just store a dict in hass.data[DATA FRITZ] that links the entity id to the corresponding fritzbox tools? I didn't find a way to hide all entities from the UI, so I handled both device and entity . Yes handling both sounds good. If the goal is to target the binary sensor entities, register these as entity services entity-services The idea was to target only a device, but didn't find a way to filter out all entities from GUI. So I choice to filter by binary sensor and allow both to work ( device and entity). I recently wrote a helper that will get the config entry ids for you: from homeassistant.helpers.service import async extract config entry ids await async extract config entry ids(hass, call) Switched Should we use asyncio.gather here? Actually no since it's generating executor jobs. We would save some context switches if we would wrap the iteration inside a function and make the service helper sync. We have hass.services.has service that could be used instead. We don't check for None below. If that's not needed we should use dict[key] instead of dict.get(key) .
Still missing 7e on the temperature sensor This line is probably what caused the need to rebase originally. Can you please reset it with the type hint? Thanks is it "7e" or "7E" it is confusing. I would have asked you to make a constant for "7E.222222222222", since it is repeated multiple times possibility or errors. However I can see you follow the pattern in the file so that change is for later. same here.
We can drop the else and outdent below. Will clean this up when I get back from grabbing lunch.
Can we calculate all properties that rely on self. settings inside the constructor to avoid calculating them on every state change? I think it is ugly to have a big constructor doing all that stuff, maybe we should some kind of decorator that handles this? Similar to lru cache(...) or singleton kinda deal? once or something? Pre-calced until we have the other option Will this print stack traces for connection errors too ? Could we create a decorator for the various services that will set it to unavailable if a connection error fails? Will this print stack traces for connection errors too ? Yes. From the Python docs: Logs a message with level ERROR on this logger. Exception info is added to the logging message. This method should only be called from an exception handler. ( logging.Logger.exception) Example output: Sorry, I misformulated. I don't think that we should print a full stack trace for connection errors. Those are known errors and so should be handled accordingly. So I added this one because of feedback in the previous PR this week. (Don't get me wrong, I myself was perfectly happy with just the error message). So let's say this happens, how would one get more information? Adjusted to what it was (which was fine IMHO) Side note in general for HA: I always wonder if we should even have descriptions like these, that are not really adding much value since we have already integration name in the title. I guess, dunno, I think describing the action one is taking, in general, is a good thing.
Where are the code to use this new Variable ? But that is exactly what "count: 2, data type: uint" means.
These are strings, use equality operator instead of searching for substring. Thanks. I couldn't find where I copied that from but that's telling me we probably could use self. async abort entries match any({CONF HOST: "1.2.3.4"}). Since nearly every integration that does local discovery has this pattern and it's written out 100x of times in the code base. This looks a bit weird. Why do we need to iterate if we always return the first item? Apparently, too much time spent in non-python that day.
This is the fix for 49254? Please move that to a separate PR. Move this to a new PR Move this to a new PR Move this to a new PR Rewrite as a guard: Goes hand in hand with the introduction of configurable state characteristic Without these the user will quickly lose clarity about how the sensor is setup - what it offers. I don't think we should expose the configuration in attributes. The user should consult the configuration documentation instead. On second thought, I agree. This breaks with the norm and the user would normally put what is relevant into the entity name . I brought this into a helper function and tidied up the logic as was meaningful. All related testcases remain green. emontnemery you were the one to move the this into add state to queue in Is deriving the unit upon every new state value really necessary? There's no guarantee the source sensor did not change its unit. We can decorate derive unit of measurement with functools.lru cache(maxsize 1) to avoid recalculating. Nice. I can still learn some things from you :) I gave this a shot but as far as I got, my conclusion is that I would need to convert the function into a staticmethod. Not a total showstopper but feels like it's not worth it for this arguably low-complexity function. Will leave as is. Yes, you're absolutely right about that. We would have to use some 3rd party library to have it work as expected. This introduces an unwanted race. We should use homeassistant.helpers.start.async at start instead. I need to read into this. Any additional help example documentation you can provide would be appreciated!? It's simple, just do: async at start is just a helper to make it simple to have something happen at start without risking introducing a race condition. Okay will change and test. Does this relate to issuecomment-964584678 ? Yes, that might very well be the case! It does! :) How come we don't need the try except anymore? Because the only reason these will throw StatisticsError (instead of ValueError or TypeError) is when there are not enough samples in the buffer. I've made this implicit condition explicit, which makes the whole function cleaner and less nested.
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
Maybe a separate name with option to avoid the pylint exception? I think this is a compatible, transparent way of overloading, with a compatible signature for existing code. IMHO pylint isn't wrong in this case. Especially considering adding kwargs as a parameter is allowed I'm happy to split it, but... we could as well just add it upstream (which is less clean imho) I've had to work around this before too. I wish mypy could detect that it's just optional extensions, but meh.. I just feel it can be somewhat more error probe to disable linting. There is always a risk of somebody now feels like adding another non optional non compatible arg to the function. They won't get the heads up on the fault.
We need to discuss if this is the right approach. Keeping the device specifics in the discovery is fine, but as soon as we add device specific Entity details it's getting messy and we'll have a hard time to decline more device specific details. That's a fair concern and I'm happy to discuss further. FWIW I couldn't think of another way to support this device easily without introducing a lot more complexity into the base class that would still end up being device specific OK I tried a new approach that's more generic. Let me know what you think? We shouldn't create this entity if it's missing this. Why do we need this check? it was to get around a mypy check. I will figure out another way to get around it I think we should create a dataclass for each problem case and attach an instance of that to the discovery info. This will define the problem more clearly. It will also allow us to do more advanced parsing and compiling here in the discovery. Eg one problem case is the dynamic current temp case. It should be the problem case discovery data class responsibility to compile the device data into the interface that we want for the problem. Then it's the problem case Entity class responsibility to use that interface to create the platform Entity interface correctly. The compiling here belongs in the discovery data class for the problem case, I think. This probably belongs in the lib if we stick with this design Can we still put the data template instance accessible on self.info and have the data template have a function that takes the resolved data and returns the zwave value (from the lookup table etc)? That way we keep the knowledge about how to parse the dependent value in the data template that generated it. done! Import Iterable from collections.abc instead. Maybe make this a static method? We can disable no-self-use here. We can disable no-self-use here.
We no longer allow integrations to add a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. By we'd love to see an adjusted version Thanks already! : 1: This package uses webscraping to gather information, unfortunately, this is not allowed for our core integrations. Example upstream code that scrapes: L17-L21 For more information see: bummer. Thanks anyway
Any of these constants that are defined identically in multiple files should be added to a const file and then imported. TYPE , ID , PROPERTY NAME , PROPERTY VALUE , etc Should we give the user feedback if this fails instead of doing it in the background? This actually does give feedback. There are events that are triggered in the background when the ALDB is changed and the status of the ALDB is always tracked so the frontend already knows that a change has occurred. Should we give the user feedback if this fails instead of doing it in the background? See above. Should we give the user feedback if this fails instead of doing it in the background? Make the regex a constant so you don't have to compile it every time Done. Copying a dict to a list will copy the keys by default. We can remove .keys() . Please import and use async get from the device registry helper to get the device registry instead. The currently used helper is legacy and we prefer importing names over accessing hass.helpers to help typing. This looks like protocol level details that should be moved to the library. Most of the code here, besides the websocket commands, looks like it belongs in the device library.
The extra () s are likely not needed Fixed You can probably drop the () s as well Fixed Should this call self.schedule update ha state() to write the new state after its changed? For this I didn't change the way it was implemented before. But I think you are right. The call to the api will stop the shade at a position X, and we should simply notify HA to update to the new state to get the current position instead of setting a value of 50. So I would use your suggestion instead of setting to the value 50. Make sense? It's fine to set the state optimistically like you have it but if you don't call self.schedule update ha state() it will not be reflected in the state machine until the next poll and update Understood! I have fixed this by creating a function "set position" in the super class, handling the state update and call to "self.schedule update ha state()". Usually we raise HomeAssistantError in this case so the user gets a message in the UI Yes it totally make sense. Would this also work in the case of an automation, where the user is not in the UI? It will work for automations, scripts, etc as well Fixed Please see comments in stop cover tilt Please see comments in stop cover tilt Fixed Please see comments in stop cover tilt Fixed silver- Usually we only log once at warning level when it becomes unreachable, and once again at info when it reconnects Fixed in last commit, let me know what you think! keys() is the default Fixed Please use f-strings here Maybe make it a function so you can keep it DRY Fixed Also I have changed the error messages to be different for each action. Therefore I didn't make a function. Usually we don't make logger messages constants since it adds an additional step to find the message. If you find yourself logging the same message over and over, the usual advice is to move the logging into a function. Fixed I have removed the constants and used different error messages for each action

This can raise HassioAPIError , right? Do we catch that somewhere? Nope, this just fetches the cached values L301-L308 Right, hassio is the module not the handler instance. : 1:
Maybe simply self here? Doh! I was looking at using unique id first... Thanks! "Sensor" seems redundant here, we don't say "Battery Level Sensor" for batteries either.
Perfume amount I can understand. At times one probably wants a different "intensity". However, I assume, in most cases, the devices will mostly fixed in their rooms. Shouldn't room size be an integration entry option instead? I don't know what the effect of the room size is on the operation of the device. Technically it's just a jar of perfume blown over by a fan. Adjusting the strength changes the speed of the fan. I have no idea what room size can change, probably it's only used to calculate how much perfume is used. the devices will mostly fixed in their rooms The first version has a battery that makes it easy to move the device to another room. In this case, it may be useful to detect the location of the device and then automatically change the room size. I think not many users will use this entity but here is a feature request by Pirol62 in In the app, there are options to set the roomsize in m2 and the intensity (low, medium and high) Then it would be great to have them in HA as well. Room size must be set to 15, 30, 60, or 100 in the app. In the API this is 1, 2, 3 and 4 respectively and this is how it is now in this PR. I think it would be better to show the values in square meters. Should this be done with the number or input select entity? input select entities are not usable for integrations. So I guess that makes the current solution in this PR the most logical one than It's safer to start with the integration specific class in the MRO since we pass parameters to the super class. It's nice to break long strings around 88 characters.
Is there no helper in the library to do this? I have not been able to find one. The socket library provides part of such a function, but not all we need. I tried to google, and this was the most elegant solution I could find. Ok. I think we're crossing into the protocol details here, so it would be nice to offload to the library. But it could be ok for now. I agree it is in the grey level. I will make a PR against pymodbus and see if they are willing to accept in for one of their future versions. Done.
I think that makes no sense. I get the mac address to allow entities to be linked to the device: ![image]( I agree. L642 Since nothing is going to be await ed in the function, change this to def async device setup and decorate it with callback Done You shouldn't need this as it will get instead of create if it already exists These should likely be separate sensors under the sensor platform Agree, will remove from this PR and make a new separate one. Simone Rename this update , move your code from async fetch update() here and it will run in the executor and you won't have to won't have to wrap everything in self.hass.async add executor job Done Only catch exceptions that are expected. We shouldn't use a broad exception handler here. Let unexpected exceptions blow up so they can get reported in the log and we can figure out how to handle them. Ok, done Nothing is checking this. We can remove it Done Does this do I o? Seems not Since this entity is part of the device you are setting up in async device setup , you can set the device info here instead. Since you plan on multiple entities, make another base class in common.py ..maybe FritzBoxHostEntity and put the device info there so all the new entities can inherit that base class and you won't have to write it multiple times. Then you can add via device to device info in device tracker.py Fixed Drop the property and just set self.model as nothing is happening in the property Done Drop the property and just set self.sw version as nothing is happening in the property Can we just set self.mac instead ? I think we can leave this as-is. The base class should only be for the fritz box itself so you can drop the manual device creation. Why not using it for both ? Works flawlessly Since the fritz box itself will have an entity now you don't need to create it manually and can set device info on the new binary sensor's base class
So now the default is whatever is in self. url, is that really wanted? The URL can actually not change. It might change in the user flow and has to stay the same from there on. Same here
We prefer to unpack these if the ternary spans multiple lines Will do.
Remove all the TODO comments. Don't use empty async setup Remove stale print Remove stale comment Stale comment Stale comment Wrong comment Remove todo Remove placeholder. It would be great if you could differentiate between a "authentication is not open" vs "cannot connect" so the user can be instructed accordingly in the UI. That sounds like a good idea. I'm thinking mutesync can return a 403 if authentication is not open. Is that fine by you? How would I catch a 403 and raise an InvalidAuth ? I can catch and process InvalidAuth in async setup user . Is that fine? You're not raising this inside validate input . Remove the ones you don't need Don't use a placeholder for invalid auth. Instruct the user to where they can open up authentication in the app. You don't currently throw this error so it's not needed. The config flow cannot be excluded from test coverage. Remove this line and ensure the config flow had a 100 test coverage. These are empty defaults and can be removed. Does this need translation? As it seems a brand name, which generally isn't translated No translation needed, it is indeed a brand name. Then remove it. It will fallback automatically to the name in the manifest. This file is out of sync with strings.json . Run python -m script.translations develop from the project root to update it. I guess the value got lost during refactoring? available reflects the state of the device is available by itself. For example, it should become unavailable when the device is unreachable. (Not person availability). With this suggested implementation, this would mean the device entity is completely unavailable when I'm not in meeting? Is that correct? So my guess is that it should be this: So balloob and I were thinking of using available to mean whether or not there is a meeting going on. Are we not allowed to use available for that purpose? Is there some other concept we should use in BinarySensor ? Your suggested change would make it always return true whenever status is available, which is consistent with your suggested use of available . But we were hoping to use available for a different purpose. If a meeting is going on, then the mute status becomes available, otherwise, it is not available. Does that make sense? It is basically hiding an additional state in a property that is meant to indicate there is a problem disconnect with the device providing the entity. So, 2 possible solutions in my opinion: - Make it a Sensor, as that would allow for multiple states. - Make multiple binary sensors (one for mute, other for "in-meeting" state. Personally, I would take the latter. I do realize this would also add additional work. The unique ID must be stable, this made it dynamic. Probably the user ID needs to be part of the config flow and stored in the config entry? That way, we can be sure it is available here. Stale log? A test for the unknown case in the configuration flow was missing.
Meh, this is still not ideal. Support play media doesn't mean it's supporting channels. Please limit this and also check the device class media player.DEVICE CLASS TV This is a bit strange assumption that the channel number is also the id of the channel. I know there might not be a better way now. But for example Philips TV doesn't support this. The same number exists on multiple favorite lists so the media is have to take this into account. I have no better idea at the moment though :( But given that the media type is set to CHANNEL, it should not look at favorite lists right? Well at least on a Philips tv, you need to tell the tv which list a channel belong to. When we browse say a channel list in the media browser, we also need to indicate which channel list it's on when we issue a play media command. The tv will select the channel on that list (satellite, cable , terrestrial, favorites X) as well as switch to that favorite list. Also it's identifiers is not a channel index. Ie its like a primary key in a database. The fact that it has an associated channel number is different from it's identifer. I see it a bit like entity id vs unique id. When we browse media, we need something unique to identify the exact thing. Here we are a bit more vague in saying some channel index. User Machine It can likely be handled in the integration, but would need special handling for every integration.
It's better to use urllib.parse.urlencode here. You didn't address this comment. This is the place where ConfigType can be used. What's the problem here? This looks like something what should be in const.py . voluptuous is untyped but this is actually this type, you can try it: I'd add Final to all const. We should not construct URLs like this. Instead, use a library to handle that. For example, we have YARL available by default. With the context that this URL is not being fetched here, but rather is being passed to motionEye in JSON -- for motionEye to (significantly) string manipulate and then fetch: I need the query string to say URL unencoded, i.e. I need to permit raw [ {} ] characters in the result. YARL automatically encodes all query string parameters and I cannot find any way to work around that. I've very slightly modified this so I'm using urljoin rather than a naked string join, but you may still be unhappy with it. If you have an alternative library recommendation (or any other ideas), I am very happy to dig into this further. Sounds weird and all, as if this is an URL, this should be URL encoded. If motionEye can't handle that correctly; it should be reported and fixed. Constructing URLs manually like this, is IMHO something that should be avoided. That said, if there is no other way at this point Yeah. Personally, I think it's mostly okay, if we think about this not as a URL but a URL template . It's not being fetched here, and motionEye does string manipulation to this value anyway prior to fetching. From a motionEye server perspective I wouldn't expect a user to provide a URL encoded value in the UI for the webhook (esp when it will be doing string replacements on the raw value), so I think the same is reasonable for the API. Furthermore, depending on a change getting committed to motionEye itself is not practical IMO, as experience suggests that would take a very (very) long time :-( Why not use the webhooks integration that Home Assistant has available, instead of writing your own solution? This will generate an external URL for the webhook, if available. Should we check for active HA cloud and use that as well? register webhook in Netatmo might be a good example of this. Had a shot. Please take a look. Note: I have no way to test this beyond unittests. You can do this nicer with YARL . It's already installed as part of HA core. Yeah, I made the same comment here: pullrequestreview-668060069 dermotduffy Maybe add a comment to that? Good idea. Added a comment explaining why we cannot use YARL. should this really be a "bitwise or" or should this be "or": Thanks for checking: Bitwise. We want both branches of this statement to execute (not just the first one), and then the async create task call to be called if either of the branches return True. So I see that you're generating cloud external webhooks but isn't usally MotionEye stored locally? Wouldn't it make sense in that case to try to configure the internal url? If you look at
I can't find the dev doc for all selector possible values. Is that possible ?
Is this a bug fix? Why are we changing the climate tests in this PR that should be about adding more switches? It add's a bit more coverage, but I can also remove it if you prefer. Yes, please make a separate PR with the climate test changes.
Don't use extra state attributes to expose this kind of data, please add sensors instead. An exception could be to expose monitoring frequency as an attribute. How is display temperature unit useful as an attribute or sensor?
The changes in generic just allow it to take in CONF LL HLS from the config and pass it along to the stream component through stream options. We pop off the CONF LL HLS from the stream options because the remaining options get passed along to pyav. We increase the MAX SEGMENTS by 1 because the last segment in the queue is usually incomplete. It gets pushed as soon as it is created, and we can access the last segment's parts as soon as they are added, but the whole segment is usually not available. When we use LL-HLS we no longer have to use really short segments as the latency should be based on the part duration as opposed to the segment duration. Longer segments can reduce the amount of processing and messaging overhead from using more segments (at the expense of using more memory per segment). Edit: From B.1: The recommended Target Duration is six seconds. The presentation of the refactoring here is actually a bit misleading. The previous StreamBuffer and the new Part are not really related. Previously, StreamBuffer was defined in .core and only used internally in the SegmentBuffer class. I thought the class naming and hierarchy was a bit confusing (leading to things like self. segment.segment) and it was easier to remove the StreamBuffer class and place those attributes (segment, output, vstream, astream) directly into the SegmentBuffer class (renamed as SegmentBuffer. memory file,SegmentBuffer. av output,SegmentBuffer. output video stream,SegmentBuffer. output audio stream). The refactoring in Segment and Part is primarily to replace the segment BytesIO object with Segment.init and Part.data bytes. The rest of the new attributes are metadata that allow keeping track of how the data is distributed between Part s and how far along in the segment the worker has processed. The previous event is used to signal when Segments are ready. We need a new event to signal when the Parts are pushed. Just a renaming that should be more descriptive, as segments could mean data or numbers If we start sequences from 0 then we should test for None instead Used the new last sequence property to avoid iterating. The timeout has been added in order to support blocking playlist requests. Just changed this to take bytes instead of BytesIO . Actually we use this to search the init section, so we could consider renaming the parameter form part to data or init . Since the data is now stored in a bunch of bytes objects but pyav works on file objects, we reconstruct a BytesIO object from the bytes objects. This is just the refactoring discussed in .core . Instead of creating a new StreamBuffer here, we just reinitialize the analogous attributes in the SegmentBuffer class using reset av() below. Since we call reset() which increments the sequence before we start, we can initialize this to -1 in order to start from 0. Starting at 0 is more consistent with our part indexing as well as HLS default indexing. Just a simple rename for clarity. Reset the new part attributes alo
Lets mark this sensor as disabled by default. We know they will be there, as we define the dictionary in the coordinator data. data["firmware"] cannot be None , it contains a dictionary defined by us. I just dropped available override I think this is incorrect as a device class. It is not really "safety", it could be, but not really something we could know. I think we should remove this for now, and maybe consider requesting a "DEVICE CLASS UPGRADABLE" (or something) in our architectural repository. So, here is the thing I found out during testing: This makes the integration no longer usable with regular users and thus requires one to use an admin user for the alarm system AND requires you to disable 2FA for such a user... To me personally, I value the security of my system more than the firmware update status. I'm not sure right now; if or how, to move forward on this. ah sorry, I actually have an admin user with MFA disabled, so I didn't spot it. As I can see, vusre is supporting MFA, so, would it be acceptable to require an admin user and support MFA through config flow ? (I think synology dsm is already working the same way)
Credentials need to be stored in the configuration entry, not in custom JSON files. Tabs vs spaces. Use prettier on JSON files. Do not include other languages in the initial PR. Please remove this file.
Invert this check and raise a ValueError with an appropriate message as argument if true.
We should keep track if these devices separately outside of the entity, and fire the event outside any platform. One example is the deconz integration and how it handles custom events. Are you thinking we track this in the device registry entry as well? Re: outside any platform, that means that we will fire this for all value updates for a given device? This falls outside of the boundaries of discovery then since that's done on a per value basis, and goes more broad than I expected. The advantage of keeping it within the entity platform is we can scope the updates down to the values that suffer from this issue or are we thinking of having an event platform which has its own discovery independent of the platform discovery? So in addition to the switch entity we discover for a given value, we also discover an event instance? Yeah, we can create an event instance triggered by discovery. Why can't we scope this per Value? I misunderstood in the first comment. Should we create a separate discovery scheme for events or can we just create the instance in the node ready callback when the assumed state property of the discovery info is true? let me know what you think of the changes I made. We are now capturing discovery info when assumed state is true and using that to watch value updates. In the future, we can move this and the handling of notifications and value notifications out to a new module like we do for services Is this needed? All of our custom events will be the same domain. No I copied it from our other events but none of them need it Hmm, is that some standard that I've forgotten about? It does seem redundant. No, I think it was added to the value notification event and we missed it, then I copied it into the notification event for consistency. I don't see any value in it, but theoretically it would be a breaking change to remove it Looks like we're overwriting the value variable with another type here. good catch
Is the plan to blow up with KeyError if the node is missing? Ie this is just a developer mistake? not sure what I was trying to do here but I added node validation back in Should we validate that the id is in the command class enum? done
This looks like to be a pretty common bug. Fixed in 49505 Leftover debug print? When do we get a template error here? Does applying the validator cause a template render? ah snap, that's old. And no longer possible.
I think we can simplify this a bit by collecting the battery info before we jump back from the executor then we can do all this in the event loop I took care of this I think this is typically written as Optional[datetime.datetime] from other mypy examples I've seen :shrug: The current notation in this PR is the new notation and is correct. Probably unneeded debug message We should use the dispatcher instead since soco will never be serializable I did see log messages about this, in fact. fixed This should move into a base class moved We should avoid all the jumps between contexts and do it all in one We shouldn't all the entity directly, we should do a dispatch This is duplicated functionality elf. seen timer that can helpfully be moved to the base entity class This should really be cleaned up before merging. Does the battery info also come in from the events? If so we shouldn't poll if we are getting it via events I'm not seeing any events triggered in my local tests when removing from its power source. ... I am seeing battery data in the events for the roam And when I plug it in This is provided with the deviceProperties subscription. Unfortunately it looks like the event payload is not as complete as calling the status batterystatus endpoint on the speaker directly. The latter includes information like the battery health and specific power source (i.e., plug vs dock). Perhaps we can use the event payload for battery percentage, and also as a trigger to call the endpoint for more complete information when the charging status changes. Having the additional information for plug vs dock would be useful for certain automations. Polling when we see the charging state change to get more info is consistent with the other places we poll after we get an event that affects some state we need more information about We should use the dispatching instead of storing the entities in a shared container dispatcher send(hass, f"{SONOS SEEN}-{soco.uid}", {"soco": soco}) We should use the dispatching instead of storing the entities in a shared container We should use the dispatching instead of storing the entities in a shared container We can do this in a loop dispatcher send(hass, f"{SONOS UNSEEN}-{soco.uid}", {"soco": soco}) In async attach player Then consume the dispatcher this in the sensor (we can move it later to init in a future PR) Looks like should poll being False is missing (probably good to move it into the base class)
I'd merge the opt in and opt out commands and add a boolean parameter to mark the choice. Put this logic in a decorator, it is used for every WS handler. Example: L21-L52 Is this writing to disk? It's not writing to disk. Stale doc string. This shouldn't be necessary. could have sworn mypy was not passing because of this but maybe that's when it's not in a decorator
Do we want to make this always a float, would int not be appropriate? I.e. divide by just 10. What kind of values do you see for this and the uplink one? I'm fine with rounding. See the updated code.
In a future PR, it would be cleaner to call this entity.py since its already in the overkiz namespace.
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
It already have a perfect unique id in the form of the mac address. Don't add other config option.
We probably don't want to add device specific code to the platforms. That should be solved some other way, preferably upstream in the zwave-js project. zwave js implements the Z-Wave protocol. AFAICS (please correct me if I'm wrong), the Manufacturer Proprietary command class of the Z-Wave protocol is explicitly designed to contain device-specializations. By providing access to the Manufacturer Proprietary values, zwave js is doing its part by implementing the transport layer. It mustn't know about semantics of the payload. It's up to the driver to make use of the payload, and the driver is home-assistant. We had the same approach when we implemented this for OpenZWave ( and it was accepted back then. We'll only accept this PR if the device specific code can be abstracted into a problem case in discovery like we did here for dynamic climate temperature values: Understand the ask, but I won't have time to re-design this. So feel free to close this if no-one wants to step in. Two thoughts before you do that: First, in the spirit of pragmatism, why introduce an abstraction for a problem now, before it is clear if there ever will be a second user of said abstraction (there might be, not denying that). The PR in its current shape will introduce less code than with the abstraction. Why not defer it to the time a second user emerges? The PR as it is right now will probably enable a bunch of users of the FGR222 right away ( Second, each device that has some manufacturer-proprietary characteristics might have some unique quirks here or there. For the FGR222, for example, it is the tilt-position interfering with the reported cover position ( diff-e6292e73b3e851acd39ec60f47355d032083c995521448faa206c8105c620fe6R252-R255). Of course, you can abstract over this specific problem as well, but doing that for each new device can bloat the abstraction over time as well. I still think that viewing Z-Wave as a transport communication means and not as the driver itself makes sense as well. We don't want device specific code in the platforms. I don't think we'll accept the workaround for the tilt. That should be fixed by the device.
If there is a better way to represent an arbitrary number of states within the entity model, I'm all ears The return value should be optional since we may return None . Are these times local time or UTC time? Times in state attributes must be UTC time.
I am not sure if this is best practice. Why not store it under the domain and entry id? (this will also allow users to set up multiple Velux config entries. python3 hass.data.setdefault(DOMAIN, {}) hass.data[DOMAIN][entry.entry id] { "velux module": VeluxModule(hass, config entry) } This has been resolved. We have a VeluxModule per config entry now. Also cleaned up some other stuff. I don't think you can remove the config schema when you still allow YAML config import. I did test the importing of the existing configuration for configuration.yaml to config entry multiple times on my dev machine and it did import fine. But maybe I am overlooking something. The CONFIG SCHEMA should still used to validate the YAML, thus removing it will remove this validation step. Makes sense. Thanks, will re-add this. added again youless? :-) Perhaps check for duplicate entries? I did read the section about unique id's in the manual, but host ip is unacceptable as a unique id. So I could not use this as there is no Mac address, serial number exposed by the Velux API. I believe this unique id is only used for the Config Flow, thus the host (ip) could be smart to use so that users can only set up every Velux box once. Done I am not familiar with the package, are there other exceptions that can be thrown? Perhaps add a broad catch like: I will have a closer look if there are other exceptions possible. Thanks I did have a look at the underlying library but could not find any other exception thrown than PyVLXException , I have added you suggestion to catch broadly so we don't break the config flow. Also I have added the original exception message to the first catch. Is this used anywhere? Good catch. Removed. It seems you mixed up the en.json and the nl.json . Please remove your translations files, since it will be added via Lokalize. You can keep en.json to make testing easier, but I would advise to generate it via python3 -m script.translations develop based on your strings.json. async start() may fail (see in which case you should raise ConfigEntryNotReady. That would really resolve 34844, I guess. The issue was closed due to inactivity. No newline at end of file.
Looking at it seems that SUPPORT BRIGHTNESS is deprecated. Good catch, will change this asap Did have a look into changing this but this give me some problems. - In the frontend (lovelace cards) there is no option for the brightness slider when supported color mode is brightness - The return type - set None gives me errors TypeError: unsupported operand type(s) for : 'type' and 'NoneType' . - No other light component implements this method yet. Wanted to have a look if it works correctly on other components. Seems this is a feature which is still in kinda alpha state. I don't have that much experience in Python programming yet and knowledge about the home assistant core to deep dive in this problem. I have left the supported features SUPPORT BRIGHTNESS in place for now as this is working correctly in the dashboard card. Maybe a core member could elaborate why the following (non deprecated approach) is not working yet: You probably need to rebase this PR in order to get correct color mode support. But iMicknl is correct, this needs to be replaced with color modes. This has been resolved. Implemented supported color modes and remove supported features. Also implemented by setting attributes as this looks like the new preferred way. Would it make sense to create a VeluxEntity to abstract some of the velux logic, which is used in all platforms? It's only 3 methods which are similar, which don't contain much logic. I'd like to have DRY code, but in this case it seems an unnecessary abstraction complexity to me. Would maybe good in a follow up PR. The repetition would be in init , async register callbacks , async added to hass , unique id , name ? And for example device info could be added, to enrich the entity registry. See Somfy integration for an example; L182-L194 I have added VeluxEntity abstraction which cover and light entities reuse. The device info would be good for a follow up PR. Why would you not wait for completion? All other calls to the velux API in the whole integration are wait for completion False , for example all the calls in cover.py and scene.py . Not sure why. I did try with wait for complete True a few months ago when I was developing this feature, but did not succeed in getting this to work, so just did the same as the original author of the integration. Will have another go at it when I am testing the integration a final time. btw I found the PR where things has changed back in 2019 This caused home assistant to lock up somehow. The two core developers of this integration and pyvlx API agreed this change was ok. I will have another try, but if I also experience flaky issues I think we are ok to leave it the way it is. Changed to wait for complete True and this seems to work correctly now.
Schema is optional. Cleaned up the existing unneeded one as well
This in-line method can be removed, and unindent all of its contents to make it just part of the entry setup. Reasoning: The setup entry is called for each entry already (which is why you have removed the iteration) I think we can remove this one, will comment below on how to resolve. Why not use entry.data["host"] directly on where you need it? Each config entry already is unique for the host? Does this need to be namespace? The client is already made above in this same method, we don't need to fetch it? It is already available It would be better to fetch this on entry ID Store it here in hass data, using something like this: For 2 reasons: - Keeps above code cleaner - If something goes wrong above, Home Assistant can retry the entry setup without having "rouge" data from a previous attempt. This I'm not sure. How would this handle multiple instances of the domain, every one of each with its proxmox client and coordinators? In a later comment you suggested coordinators hass.data[DOMAIN][entry.entry id][COORDINATORS] but here it seems like there is no entry.entry id object inside hass.data[DOMAIN] Did you mean hass.data[DOMAIN][config entry.entry id] {PROXMOX CLIENT: proxmox client, COORDINATORS: coordinators} ? This is already logged by Home Assistant debug level This isn't used anymore. Please type in line, not in comments We should avoid disabling Pylint for these reasons. Instead, e.g., an instance variable can be used to make that difference. avoid disabling pylint The log is not the right place to give user feedback like this :) Adittionally, mark the config schema deprecated, which will take care of this part. We should keep the config schema, even though it is deprecated, we do import it, so we do need to validate it. Please restore the validation (for at least 2 release cycles). async setup should not be used to set up the integration, instead, it should trigger an import step in the config flow. After import, that async setup entry will handle the imported entry. Why not directly use these when creating a ProxmoxClient instance, instead of creating all these variables? This line should be outside of the try except construct, as it doesn't throw these errors its it catching. If using typing in methods, please fully type the method. Proxmox is a brand name, and should be capitalized according to their brand styling (small thing, but it isn't done across all error messages in this PR) Should Home Assistant retry setting up this entry instead? Should Home Assistant retry setting up this entry instead?
Please use our common units as far as possible. Eg: L486 L490 L489 Where are these needed? I think I copied this over from weather.py without thought. Will remove I'd separate the assertions one per line.
Let's group the test assignments together at the end of this list. Makes sense, done
Please define this new key in FlowResultDict . This seems weird to default to True I would expect it to be defaulted to None and typed as bool None. What should be the difference between True and None then? None means not set. True False means the config flow explicitly passed in True False. Fixed.
Not related to this PR, but apparently the pylint rules did change after last rebase to rework tahoma . This will start a reauth flow bdraco I already put this one (and some related changes) on my todo list. I did assume that we still needed some additions to the Config Flow, or is this not required anymore? If so; I would like to do that in a follow up PR, to not clutter this one. We also left out the the zeroconf dhcp discovery part from this PR. Yes you still have to implement async step reauth. bdraco will do this in a follow up PR, together with some other minor improvements around recent core changes. See We cannot use Zeroconf (like Somfy integration), since it will only broadcast that service when the device has HomeKit support. Many Overkiz hubs that are supported with this integration don't support HomeKit. dhcp is going to use the default unique id of DOMAIN which means its likely going to get unexpectedly rediscovered. You could implement a async step dhcp that aborts if self. async current entries(include ignore False) is true and otherwise passes to async step user I was waiting for since the gateway id is part of the hostname, thus we could add a async step dhcp that checks if their is a config entry with the same gateway id. I thought other integrations also had this DHCP option, without having the async step dhcp implemented, but happy to take it out here and implement the dhcp with gateway detection in a follow up PR. I'm wrong on this one async handle discovery without unique id actually already handles this case So this good as is. Sorry for leading down the rabbit hole.
It would be a lot better to add tests. Tests is an excellent safeguard against bugs. Furthermore you often find problems when you start writing tests. I see you have tests later, why not make them at a level that satisfies coveragerc I forgot to remove files from .coceragerc Integration has full test coverage. why a .pop ? it might be correct just wondering. Because after unloading config entry, we have to remove coordinator from hass.data[DOMAIN] . It is no longer needed after unloading config entry. You are right I saw it. I recommend adding a short comment. Honestlly, I don't know what comment is needed Most of the integrations use the same code here. It was just a recommendation, no problem if you feel it is not needed. Where did the p1 come from, I suspect you set it somewhere else. If so it should be a const. The device sends data with this suffix. You're right, I'll make it a constant. No warning or anything (else part)? This is a DIY device so it can have different set of sensors. We check if the sensor is available in data from the device, if it is, we create an entity for it. Warning is not needed here in my opinion. good argument. Please use named constants for your magic numbers Please use named constants for your magic numbers Please use named constants for your magic numbers Please use named constants for your magic numbers This has moved to manifest.json . Please rebase identifiers aren't needed if you have connections Much nicer Looks like mypy can't figure it out without it. Without this line mypy gives me those errors: Looks like mypy can't figure it out without it. Exactly
Hmm.. there is a race here since they can call stop before startup is finished. We probably need to set this as soon as we hit the point of checking the future. A user would have to request a restart between when the hass started.result call finishes and the variable is swapped. If we set the var before we check the result then they can't stop the instance because something is blocking startup which probably won't work anyways. Probably best to set it before since they upgraded intentionally and we are already at the point of no return. Is this event only used in tests? Yes
Wouldn't you also want to call async cleanup here and for interview failed since there will be no more messages for the original command to refresh? Once the frontend receives those events it unsubscribes which should trigger the cleanup Move this check up before we do anything else. Please add test for all four types of interview events.
I'd prefer to await the task if it's not done and then send the signal. Adding a callback to the task is a low level api. Hmm ok. That's the original approach I went with but it meant making all of these callbacks async, and I'm not sure how to set up the event listener ( node.on ) with an async function, do I need to wrap the call in an asyncio.run coroutine threadsafe to do so? I'd let the event listener create a task that wraps a coroutine function. Can we use asyncio.gather here to await concurrently? Should we still return early here if we have already unsubscribed the node listeners? Maybe we should continue and try to clean up and disconnect as much as possible. I like the approach of trying to clean up as much as possible. Update incoming
The core will log this too at debug level so we don't need it here. Fixed We set this variable to a list below, so we should keep the same type here. I was trying to avoid allocating a new list, but fair enough (empty lists are all different, whereas the empty tuple is the exact same object each time, thus no new allocation). A better way may to make event codes a set at this point already, and extend it just below, but I wanted the lowest disturbance risk by keeping the changes as local as possible. Changed to use a list.
Measurements that are not related to the hvac operation that we control should be separate sensor entities. Thanks for reviewing the PR. I put it there because the Danfoss eTRV stops heating if the window is detected as open (and also because it is reported in the thermostat cluster). So in that sense I thought it was related to the hvac operation in the same way occupancy is (which is reported as an attribute). Or why should this be different than occupancy? We should only include attributes that represent measurements that can also be can controlled from the device. If it's just a measurement it should be a separate sensor entity. Old code doesn't always follow our design rules, so it doesn't help looking at that. You can manually set whether a window is open or closed, and it will stop heating in that case (this is also not currently exposed in the UI). Do you think it still needs a separate sensor entity, even if this can be controlled from the device? Zha currently can't do multiple entities based on the single ZCL cluster (thermostat) it's on Todo but no ETA If we name the attribute like 'thermostat auto off on window status' would that qualify as a thermostat measurement? It's not about the name. This measurement is not a representation of an operation mode that is controllable (like eg fan mode) and not a measurement of an uncontrollable operation feature (like eg hvac action). So it should be a separate sensor entity. If we would have implemented the climate integration today, current humidity and current temperature would not have been included as built in attributes either.
This is a state hidden in an attribute and should be its own entity. In this case a binary sensor.
I cannot unselect tracking wired clients without following change: Oh, so true. Thanks!
Please update the service descriptions to our new format. See: service-descriptions Done. I have updated the service descriptions to the new format. Please use a constant for the service name. Added constant for service name. Please use a constant for the service name. Added constant for service name. Please use a constant for the service name. Added constant for service name. Please use a constant for the service name. Added constant for service name. This will silence all errors. Additionally, debug is not a default log level. I'm afraid the end user will end up sitting there without any clue on why it didn't work. Is there any specific reason for this? Should we just raise instead? Added try except to services, with error logging and exceptions. My question was not about the other services, my question was about this service... frenck, Apologies, I meant to implement proper logging and exceptions on all services. Missed enable disable of motion detection. I have changed the logger to be more descriptive and it raises on proper library exception. Same as above We don't both log an error and raise an exception. If we're in a service handler we can just raise an exception with the message as exception argument.
Remove this case. I forgot to push Should this optional? SIGH. No.
bdraco templates are grouped during initialization by the TemplateEntity . But if we decide to try to render the name earlier, it is not grouped with the other templates because hass is not set on the others, and hass is part of the equality check. I worked around it here by setting hass again to None . An alternative is that we always set hass inside TemplateEntity.add template attribute . What do you think is a better approach? I think its cleaner to do it in TemplateEntity.add template attribute since its only doing it just a bit sooner than L783 will Done in 49094 It's nice to break long strings around 88 characters. Why should we allow the new format here? Isn't this whole section considered legacy? It was mainly that I had to add support for those entities to accept it anyway . but I guess you're right, we should propose to get rid of the platform integration completely. Not deprecate, just don't promote. We removed this case, right? Aaah yes, cleaning up.
We should update get or create in a new PR and remove that it can return None , that's just weird. it's because of this, but shouldn't we just raise an exception? L264-L265 We should be able to remove this now if we rebase. We can do this in a separate PR. Instead of calling setdefault , just use a defaultdict :) thanks for the tip, never used it before but a good idea to keep in the back pocket You could break out here early if you hit len(existing entities) 2 Shouldn't we check endpoint is different? We can just so the function makes sense, but the migration logic is such that it won't change the logic because we return early if we find an existing entry for the discovered value We're not hitting the continue with re-interview comment in the code. Are you thinking we don't need it or do you think we need a test to hit that logic? I actually was doing some testing and I don't think that we send another node ready event on re-interview, so we're currently not handling changes that occur during a reinterview. Something to look into later If it's a case that needs to be handled we should try to test it. Turns out there was a bug in my logic because of my use of defaultdict so I'm glad you mentioned this!
This is so good.
Temperature and humidity measurements should be sensor entities part of a sensor platform.

A future clean up is to move this to async setup entry and remove async setup . The latter isn't needed anymore.
What kind of time is this? In the lib it's a datetime object. Do you want me to convert it to a predefined format? If so, which format would this be? Times in state attributes must be UTC. Please use our dt util if we need to convert the time. Do we need to convert the time to UTC here too? Yep, forgot that part sorry. Fixed now.
Not sure if "strict" is a good name
What does this do? deCONZ has two main resource types sensors and lights. These have later evolved into supporting many different types of devices. In this particular case it filters out sensors that are of the type ancillary control. AncillaryControl is a subclass of deconz sensors and ZHATYPE is a tuple with the different types that fit into this device type. L179 Stale comment? Yes, thanks Stale comment? Yes, thanks We use None to represent unknown state. I will fix. Thanks MartinHjelmare I fixed it in this PR MartinHjelmare
We should understand why the config flow test failed, and not fix the code to pass the test. It may hide a problem were the coap context is created before hass.data[DOMAIN][CONF COAP PORT] is initialized so that instead of running in the configured port it will run in the default port. Back to original implementation and fixed tests When you add a new option and you need to change the set up in the tests, it means that it probably won't work normally? Because Shelly is not set up when the first config flow is started, there is no COAP port saved. Instead of always pulling it out of hass.data , check if DOMAIN is in hass.data , otherwise just use the default port. I was told that async setup is called by core before starting the flow, and trying on a live HA instance this is true as code worked fine with and without the yaml key. Only the pytest was failing. Anyway, fine for me to change the code as suggested. coap port is the only (optional) key in DOMAIN you can still put shelly: {} in your config. New commit
According to the docs, ar-AR OmarVoice is deprecated by AR OmarVoice . According to the december update: December2020 A lot of voices will be removed and replacements added. Currently, this PR only processes the new additions. Should it clean up as well? I preferred not to break existing user configuration, and scoping my changes to only adding new voices. Maybe another update, with deprecation warnings, could handle the removal of old voices ? IMHO this belongs in the same update. As additions made here, are not additions but renames. Sure, but according to the documentation you previously linked: It will continue to function for at least one year but might be removed at a future date. So, in my opinion, it should be easier for users to be warned about a future deprecation of the voice they are using, instead of breaking their current configuration during next HA update. it should be easier for users to be warned about a future deprecation of the voice they are using Yes, thus a deprecation warning to the code should be added when those voices are used. I would suggest on making 2 lists here, adding a list with deprecated voices as well. When a deprecated voice is used in the configuration, a warning should be logged. I'll do it as advised. Thanks for your input. Small tweak... We try to avoid side effects in init methods. Please move the logging to get engine instead. Right Adjustment PR: 50716
I think this one needs to move with the frontend, mainly because it provides means to debug things as well (e.g., an add-on that provides access to logs or access to fix "stuff"). That said, I wonder if it wouldn't be enough just to move the recorder into the stage 1 list? I tried that first, but then the logging prefs gets lost for recorder if recorder moves along faster than logger setup :( I will test moving hassio as well soon working as expected. verified no events are fired from hassio so it should be fine. hassio provides entities since 2021.4, thus can fire events. There is a small risk that the recorder won't subscribe to events in async initialize before the first event is fired, but that seems worth the tradeoff to get hassio running sooner in case something goes wrong with startup later. If it did happen the impact is we wouldn't record the initial state of the sensor in the database. I could go either way on this one but I definitely see the value in having hassio up and running without waiting for the database upgrade in case something goes wrong. Came up with an alternate solution where the recorder does its initial setup to make sure it installs the event listener and then finishes up as soon as the frontend gets loaded then creates a tracked task to make sure its done before stage 1. No changes to bootstrap and recorder doesn't block stage 1 from starting only stage 2. Well I had to add a check in bootstrap. I was really hoping to have it not know about it but we have to wait for recorder to finish complete set at the end of stage1 otherwise the events back up enough during a long database upgrade that we could risk exhausting the available system memory. This will go away in the next PR This will go away in the next pr
The scope of variables could be reduced here. Or maybe the entire thing can be shortened. I think something like this can work? I realize this PR has been sitting for months -- now probably worth adding DeviceInfo here given that style was changed. Consider updating to attr icon ICON at the top of this class. (I realize this was a new style introduced after this PR was sent)
I'm assuming that we intend to remove it in 2021.6.0. We normally deprecate for two releases, so then we should say 2021.7.0 since this deprecation will be released in 2021.5.0. MartinHjelmare yep good spot and updated
Leftover debug print? yes, sorry for that :( This would be a bit easier to follow if we did something like this above Done Thanks :) We don't need to store entry options in hass.data. We have access to the entry in the media player platform. Nothing is checking this return value. We can remove this statement.
use async config entry first refresh() for intial data fetch move hass.data.setdefault(DOMAIN, {}) into async setup entry() , than you can completly remove async setup() would suggest to use constants from homeassistant.const like CONF HOST and CONF PASSWORD DOMAIN is used, so disable should not be needed same as above - use constants from homeassistant.const drill down the imports to what ever you realy need ( guess we will not need the whole homeassistant.core in here ) please add type hint for data since get() defaults to None :wink: put a blank new line at the end blank new line at the end and again a missing blank new line at the end :smiley: define such kind of constants for this keys, since they are used multiple times in different places.
Instead of this, check if CONF TILT STATE OPTIMISTIC is set by user or not. Agree You may have to remove the default from CONF TILT STATE OPTIMISTIC , unless there's some way to know if the option was set or not (not sure if that's supported by Voluptuous). It defaults to false and thus I see no problem Let's not add an instance variable for something that is only used once. Agree Since this used only by position message received , do we really need to separate this? it makes it harder to follow the flow. I think it would be better to name this tilt payload received since it is also called from position message received upon receiving position so it would be clear to understand it is not called only upon tilt message I messed up this PR, as I always do if I have to merge with upstream. I created new PR 50236
It's weird that we modify the config after setting up the component. oh good point, I'm surprised the test still worked "test" is not a valid entity id. I'd use a valid format. I think the default unittest TestCase class doesn't support coroutine functions as test methods. The coroutine is probably not awaited. black will be failed on this Martin, a little question: is it allowed to do this routine in loops? Yes, if we can avoid any conditional checks.
Check for missing node first. Stale comment?
Again it would be nice if we could avoid having to exclude it. I plan to... Duplicate ?? Good catch! The same will be in Light too. I'll fix that. This same duplicate is in switch.py . Looks like this init can be safely removed if nothing else going to be added later. I'm not a Python guru, but looks like this would be just enough: And codecov would be pretty happy about it. You're right. I was thinking to make the code more explicit and to increase readibility. But when I thought about this, unit tests should guarantee my code works as expected. I will simplify as you suggest. Please add a link instead of "documentation". if you have made the right heading in your doc PR, you can lights to send the user right to your documentation. OK, will do. Please refactor to not depend on another platform. Do you mean the Switch platform? The idea was to build Light on top of Switch because it does the same functionality. Light class can be then further extended to add other feature. If I can't depend on Switch , basically I will need to duplicate (copy) the Switch code. It's not a problem, I just want to clarify my approach with you. vzahradnik I would do that for now, we need your 2 new platforms. btw. did you also update the documentation? Yes, the documentation is updated. So I will duplicate the code for now, and later we'll refactor. We normally add a guard clause here: We can return here instead and outdent below. It would be better to import the fan integration domain and use when loading the platforms. self.hass is None, that seems wrong. I suggest you also add hass as a parameter.
Why would we not want a unique id ?
Didn't we already merge the effect service? I thought you did. Yes, it's merged so please rebase on latest fetch of the target branch: We don't want stale commits in the branch of this PR. Rebase done. Thanks - forgot to do that! Does this do I O? Yes but we wrapped bulb in the async during setup entry. Please make it a method instead of a property. I O calls should be explicit. Accessing a property is not expected to do I O. OK - updated and pulled the IO into a method which is called by the two properties that need it. I meant that these properties should not be properties but methods. Gotcha - fixed We should cache this call in a local variable so we don't need to make it twice in the same update. Also it looks like our if elif logic isn't optimal. We're checking the same mode more than once. Please optimize this. Please merge the blocks here with the corresponding blocks above. My mistake - misunderstood the ask. Done.
No AttributeError here ? Nope. AttributeError only happens on first setup if the device unavailable. It's likely a bug in the upstream library. I have a PR queued to clean it up as there are some other tweaks as well I want to make. Wow didn't notice that when I moved it. That's weird This is shorter faster:
We need to provide a default here in case the options flow was never completed before. Thanks for the review. I've added True as default value now
This should be implemented as an entity service: entity-services Hi frenck sorry but I'm not sure if I get it correct :confused: The service I want to implement is not related to a specific entity sensor or platform, but to a device - therefore I added this service as integration service. To be honest I was also wondering why I have to extract the device ids from area id ( and filter them to get only shelly devices ) to get afterwards the ( config )entry id from the devices and in addition have to care about that no duplicated device ids were processed :thinking: Nevertheless it works as expected - yesterday I have already updated 5 Shelly devices at the same time with one service call :sunglasses: Surely it is more realistic that I'm total wrong and have missed something essential :see no evil: I would be very grateful for hints on this, also about extended examples. When implemented as an entity service, it will support a target , in that case Home Assistant will resolve handle devices, areas and entity ID references for you, and call the matching entity services (no matter what the user has put in). The example is in the link above. If you search the codebase for async register entity service , you'll find dozens of examples. Note that ShellyDeviceRestWrapper is not created if the device is a sleeping device, the service should not rely on this wrapper, but on the main wrapper - ShellyDeviceWrapper see: L133 In addition we should not try to trigger update for a sleeping devices, as I see it we have two options: 1. (preferred option) For a sleeping device, store a flag that we need to trigger an update and trigger an update upon CoAP event from the device, can be done here: L184 2. For a sleeping device log a message that device is skipped since it is a sleeping device - the method is now moved into ShellyDeviceRestWrapper as async trigger ota update() - async trigger ota update() uses the flag self. ota update pending for scheduling an ota update for sleeping devices If REST sensors are not enabled, the status will be the status of the first init of the device which may not reflect it's current state, even a REST sensor is enabled, the update period for it is 60 seconds, so the status may not reflect the correct device state, since it is used to decide if device needs an update, it would be better to first pull the device latest status: Example can be found here (need to wrap with timeout and catch the error): L299 async trigger ota update() use now async refresh() from DataUpdateCoordinator to update status data Also here, need to wrap with timeout and catch the error. Note: We intentionally don't do any http request directly from HA, but add a method in aioshelly library and call it from HA, might be a better option to do the same here yeah for sure ... I've created an PR home-assistant-libs aioshelly 90 to add a new device method ... this is already used in async trigger ota update() wraped with timeout in try-except-block I think we should
Logging is performance critical. Please - Precompile all your regexs with re.compile - Match them all in one filter instead of multiple 1. I had the same thought, but using cv.is regex in on L45 (to my surprise) has pre-compiled them! 2. Great point. I do a lot of performance-related work at my 9 to 5 so I did take perf into consideration. This approach has no impact except for on the services that it is enabled. The impact on those services is bounded by their log volume and the complexity of the patterns. Can you combine all the values and make a single call to add log filter in case they have multiple Nevermind, I misread this. I see what you are doing here When p is precompiled with re.compile use p.match() Amending, since this (neatly) removes the dependency on import re We do have a caplog fixture that could be used to provide a more end-to-end test. Good to know. I've updated the tests. I also added a test case to ensure filters are scoped to their respective services.
async start discover doesn't accept the event time parameter. Fixed ...and pushed a test to cover this. Doesn't patch.object patch a coroutine function by default with an AsyncMock? If not we should use AsyncMock instead of mock coro maybe as a side effect. mock coro is legacy. Absolutely it does now. I cleaned them all up and rebased to fix the conflict. I fixed as well
Maybe this should not be a ZHA-specific thing... what s the protocol here? I was under the impression that things usually start out in integrations and then back their way into core... There is no protocol, it has been discussed more often. If the PR title reflected the actual features in this PR, I would have responded to it way earlier. IMHO, use the effort to solve this globally.
Does it make sense to connect to the ip address here instead like we do with esphome to avoid resolution mdns lookup delays at startup time. Unless IP address would change. There were at least two different people asking how to change the IP address for the serial-over-tcp config entry. Or we could store both and try to establish connection directly to IP and then falling back to mdns resolution??? not sure if the additional complexity worth it esphome used to have issues about not being able to connect to the device on startup until we switched the default behavior to create the entry with the ip, and then update it ( L95) when we get a zeroconf discovery. I don't think we need to store both since the current solution that is working for esphome would likely work here.
If it's an unexpected exception we usually want to log that at exception level to be able to figure it out. Expected exceptions we can handle specifically. I added handling for the expected exception types and logging for the unexpected. Check the reason too. Done Looks good! Just one thing... The mock comes with host, mac, type etc. How about we abstract this information so we can easily replace the devices in the tests? Ah, just realized you need the MAC in a different format. That's ok. But it's kind of strange to mock with a different MAC. Could we use the same MAC as the mock by adding ":"? Sorry saw your comment after I merged. I'll adjust that in a new pr shortly Fixed here
This should not be added as an attribute. It will cause a lot of state changes. What would be an alternative approach? Separate sensor(s) that you can add via the integration configuration flow? Could also add a configuration step where you explicitly choose which attributes you want to add. Could also add a configuration step where you explicitly choose which attributes you want to add. We used to call that monitored conditions, which we try to get rid off What would be an alternative approach? Separate sensor(s) that you can add via the integration configuration flow? Separate sensors that are coupled with the device it belongs to, disabled by default in the entity registry on creation. That way, a user can choose to activate them. Separate sensors that are coupled with the device it belongs to, disabled by default in the entity registry on creation. That way, a user can choose to activate them. The current flow only creates them when enabled afaik: ![image]( If extending that is acceptable I'll work on it. If we need to change that flow as you mentioned by creating the sensors in a disabled state to allow individual control, I'm afraid it'll be too complicated for the time I'm able to spend on it. Let me know if the existing flow can be extended to include a signal sensor. Yes, a new option is the way to go here And a new sensor class with test coverage, should probably be mostly copy paste work for you
You should use home-assistant constants for username and password : L191 same here for "auth" as you use it multiple time ? This function is no longer necessary if it's not doing actual work. Don't store auth in a file. Instead store it in the entry.data . Also how can loading a file cause a ClientConnectionError? And what about all other client errors? After loading the file, this method checks if the access token is expired. If so, it does the authentication with the backend to fetch a new token. I'll refactor this to use entry.data. Actually, no need to save anything. We can always use username password here. It also takes care of updating the SAID (appliances) list too. Don't return False, raise ConfigEntryNotReady("Cannot connect") Is this doing I O ? no, it just checks if it has an access token and its expire date, both of which are already in memory after auth is done. This looks like it is doing I O so it should run in the executor. it just reads from memory. SAID data is fetched during auth. This should not be a warning but debug. Why only add the first and not all ? Because I can't test that everything works fine with more than one (I only have one AC). Don't disable broad-except. What exceptions do you expect, catch those. I really intend to catch anything. If the fetch name() method fails for whatever reason, the integration should still proceed. I could catch the current known exceptions, but if latter the library is updated and someone forgets to update them here, they could cause this method to fail. Don't log everything with full stack trace. Is this doing I O ? no, cached data. Should this be logged as warning, because it is an unexpected mode? I would expect the order to be AUTO High Medium Low Off What about other aiohttp client errors You should set the username as the unique ID on this config entry. No need to add a title if it's same as manifest name. It will automatically fall back to that. Host is not a key used according to the config flow. oops You're not raising this error.
We no longer allow new integrations to use a platform config section or old integrations to do changes to the platform config section. See Please refactor this integration to have the config schema in the base integration module and the config yaml section under the top level integration domain key. Also, this should not be a new integration but instead a config option for the existing bme280 integration. The best option would be close this PR and refactor bme280 integration. Then add the config option with SPI. Can I use some example for refactor integration to have the config schema in the base integration module? Here's an example of the config schema for an integration that configures platforms from the top level config key of the integration: L83-L105 Here's how to load a platform: L244-L248
This is no longer needed. Haha I've been telling people this all week and I forgot to go back and update this. . Thanks! Will fix it when I get back home. Likely will make the test fail since it's mocked. You can end up adding a channel if the "paired with channel" is set up after this channel. Why not check versus channels ? And what if paired with a channel that is not active? Paired with means it uses two CTs to monitor the combined power usage. Paired with is configured when the system is installed so it's unlikely to change without putting in a new circuit box. If it's paired they both have to be active. Channels are always sequential and the paired channel will always be next to either other. Ie 1 and 2 can be paired, 3 and 4 can be paired, but not 1 and 7 etc. I used a set here since the hash lookup is faster then the list. We no longer need to disable pylint here. It was fixed upstream. done in Check the abort reason too. done in We should abort for already configured entry with same unique id here. done in
need ATTR DEFAULT DURATION should this be ATTR DEFAULT TONE? no I think it's ok to use tone as the parameter name should this be ATTR DEFAULT DURATION? same comment as above should be self.default duration data[ATTR DEFAULT DURATION] self.default duration self.set default duration We can use class attributes instead of properties. Please add type annotations for this signature. Here too. This complex schema will make it harder to validate the service call since we can't use supported features. It's simpler if each service only does one thing. We should filter parameters like light does when using a complex schema. L287-L288 We don't register set active tone . it's now set default tone but I missed the change in the demo platform. We normally check that the value is not None too. at the beginning of the function I get supported features or 0 so a None check is not needed We could add support for class attributes. I'd remove the word device at the end. "params" isn't part of the service call data by default. That's something that the light integration has added.
We should probably store the callable that this returns and cancel it when the entity is removed in async will remove from hass Done It seems like these might be easier to use as entity services since we can validate them. entity-services Done If you add typing, please type the whole line Faster to make this self.async call later callback so we don't have to recreate the function every time import this from homeassistant.core Then outdent async add entities Let's not register the entity service if there are no entities that can use it. Actually can this even happen? Theoretically, if someone created an account and didn't finish adding a unit to their account, it could happen. Ok then let's return even earlier if hub.account.robots is empty What's the appropriate way to check that a platform wasn't loaded in tests? vacuum.litterrobot would be missing from hass.config.components I'm not sure we should check that though as that implementation detail could change in the future. Probably check to see if the service is registered instead Or should I move the check for hub.account.robots to init .py and return False in async setup entry ? If known the platform isn't going to do anything maybe exclude it from async forward entry setup here? All of the platforms are directly related with a robot at the moment, so it wouldn't make sense to include any if there aren't any robots. Maybe something like: That works
Since the key is always there, use square brackets. If you want to have teh default live here and not in the config schema, remove default True from MQTT ENTITY COMMON SCHEMA
Do we need to create a new context here? No. Script context is passed in, that's fine. The result of this is never checked, and exceptions may be silently swallowed. Should that be fixed? Yes How? Shouldn't AutomationTrace be renamed or, if it is automation specific, be in this file? Make up your mind: r600041503 Fixed in 48288 if it's automation specific, should we keep calling it automation id ? Fixed in 48288 Let's move this to automation trace.py Fixed in 48288 script trace.py Fixed in 48288 Fixed in 48288
icon and device class are mutually exclusive advanced-properties Battery iconography should be handled on the frontend The API returns a string, not a percentage: "Full", "Nearly empty", "Empty", etc. Should I convert this string to a percentage? Or should I remove the device class? Ideally the underlying package will do the conversion and present a percentage so its abstracted away from home assistant Please see comment above bdraco Same as above. Should I remove the device class or the icon? Usually we prefer device class to icon These have been renamed to extra state attributes use f-strings use f-strings You can drop async setup since it does nothing I had to do a rebase. We don't need this list. The devices dict is enough. Charging on off should be a separate binary sensor. Please remove the extra state attributes. What kind of measurement is this? It should probably be a separate sensor entity. The description of the state as shown in the app: charging , low , empty , ... What measurement is this? Same as the battery. The description of the state as shown in the app: low , medium , ... Why is this not a fan platform? discussion r574022109 If we can't control the speed it should be a separate sensor entity and not a state attribute. It's a setting in the app, see other comment discussion r611499855 We can't use the sync api in async context. Use self.async write ha state instead. The room size should also probably be a separate sensor entity. fan speed and room size are settings in the app. I will add a number platform for fan speed and room size so you can change them. issuecomment-812887265 Ok. Please remove them here then.
Make sure you document this on the dev blog. Is the plan to create a measurable entity that can handle any unit conversion or should we consider mixins per unit conversion (ie TemperatureEntity ) I think the former, it's fairly common pattern for integrations to have a shared class for all sensors, then just set the attributes, including unit of measurement , based on some input from the lib. If we want to specialize like this, those integrations would have to be refactored. I agree. Besides temperature, I think we should only convert units based on device class. That will allow us to have a look up table for the conversion to apply and a clean implementation in a single class. we should only convert units based on device class I actually implemented it like that first, but there are two issues: 1. We will need to be backwards compatible for some time to handle integrations which don't set device class on their sensors. 2. How to handle integrations such as input number which allow configuring a unit of measurement but not a device class ? The first issue is not a problem, but I'm not sure about the second one. If the unit of measurement is configured by the user we probably shouldn't convert it. OK, that makes sense for input number . Not doing the conversion could be considered a breaking change since we currently do convert all temperatures, but maybe it would be for the better? unit of measurement is also used by base components geo location (for distance) and air quality (concentrations, I think). I really don't think device class and unit of measurement should be coupled. I think in the long run it would make more sense to device a measurement class type. We are more and more mixing up the object and the measurement it provides. For example, temperature vs garage door. In the long run, this is going to bite. device class and unit of measurement need to be coupled for blueprints and to export it to Homekit Google Alexa. It's not possible to make code that can work with everything. If it's a device class, we can categorize the entity and know how to deal with it. Native or raw? raw is not so good, I would expect that to be the raw binary value read out from the sensor, before conversion to a standard unit. Should all sensors get this logic or should be applied to the right ones? I guess that is a migration we can't do anymore at this point. Right, because it's a migration it's not feasible to do anything else. We could do something like this though: The migration would then be to MeasurableSensorEntity , but integrations can move to SensorEntity for sensors which don't represent a measurable unit? Can we decrease the scope of this block to just the line where it will raise and return early in that case? Improved in dc3cad1 This looks like we're introducing incorrect behavior to handle incorrect tests. We always want to convert the state if the device class unit matches the conversion criteria. If this is really only a condition that happens i
Is this necessary? Obviously won't cause any issue. Just wondering if you meant to take it out after debugging. simagick can you remove this log?

You can remove these lines (they are empty) import the camera domain name this does not comply unacceptable-sources-for-a-unique-id I agree, it does not. There was a [very brief discord chat]( on this. In summary, I have nothing else available. It's either host:port, or the config entry id. Whilst I am happy to change it to the config entry id, I don't understand why that is better. As it stands, at least basic non-malicious duplication will be prevented. If I use config entry id, I can literally recreate multiple devices pointed a the same host:port. Thoughts welcome. Do not add a unique ID if you have none. Config Entry ID is not going to help, it's only for deduplication. You can still do host deduplication but you need to iterate over the config entries yourself instead of using unique ID. Thank you for the authoritative answer balloob ! After the original feedback from dgomes , I took the liberty of stripping the unique id entirely out of the config flow -- so I think what is here is now compatible with your suggestion. Note that I still use the config entry ID [as part of the unique id for entities]( diff-3ca7aab36b02ba61a5678566eae81031138bf82c42a2866a36a95523d1259ba7R60) . Perfect and yes using config entry ID is great for entity unique ID. This is no longer necessary. Instead add hass.data.setdefault(DOMAIN, {}) to async setup entry. Don't create a task for it. Just inline it here. All actions are callbacks, so it's faster to not create tasks. Although suggested, it's not currently enforced that each identifier is a tuple of 2 values. So this can fail. Should no longer be used. Use entry.async on unload() This method is only used in the camera platform, why not inline it there ? Because there are more platforms to come :-) Several things in this PR may look a little less inlined than would be expected, this is because this is PR1 in moving this functionality out of [the custom component]( That's not your problem though. Let me know if you'd rather I inline it now, and break it out in the following PRs. ok let's keep it like that. oh and remove the list. For things that are safe to run inside the event loop, please decorate with callback . Done. For my understanding for future, given that this function isn't called directly from the event loop (but rather indirectly from handle coordinator update , which is decorated) -- why is callback appropriate required used here? It makes it easy for the reviewer to know how the function is intended to be used. If I see a non-annotated function, I assume it's meant as a sync function and is allowed to do I O. If it's async or callback , it makes it easier to spot functions that do I O . Just store properties . Or even better, why even generate properties and not just store the camera? Here is how the current arrangement came about: 1. I need to set the variables of the underlying MjpegCamera camera from which I inherit, so I'm not sure how I can escape this litany of self. foo something without more 
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
If AirQualityMonitorCGDN1 doesn't accept a model parameter, set miio class to a lambda discarding the model parameter before calling the AirQualityMonitorCGDN1 constructor or something like that.
Please keep this in the zha integration. Adding it here would require approval first in an architecture issue. Done.
We can't send the non serializable coordinator in discovery data. Nevermind. I forgot we changed to use the dispatch helper for discovery. We can! I fixed that a couple of releases ago, it's now sending this via the dispatcher. did we not fade out template ? I accidentally updated your suggestion instead of copying it to a new suggestion in a comment. Changed it from continue to else: This line doesn't seem needed. When the entity is added to Home Assistant, nothing is rendered yet. This line will make sure we fallback to have at least the configured object id . as name. Doesn't the line above with the walrus operator already catch that? You are right. Stale docstring? Stale docstring?
Please rebase on latest dev branch. We've updated our typing standards lately. One thing is that we use HomeAssistant instead of HomeAssistantType . Please move the service registration to async setup entry . Check if the service is registered with hass.services.has service if more than one entry can be configured. Please use async get in the device registry helper module to get the registry. That is not a coroutine function Please use dict[key] when we know that the key is in the dict. We know since the service schema has validated it. Use coordinator.async config entry first refresh . L142-L154 Use hass.config entries.async setup platforms . L1002-L1005 Please use: L1032-L1034 Please add return value typing. Please add return value typing to all the functions. None is the default value returned if the key is missing in the dict. We don't want to raise in other flows if there's a discovery flow in progress. Please inherit from SensorEntity too. Charging binary state should be a separate binary sensor instead. Static info should not be part of the state attributes. Can we make a timestamp sensor for this instead? Make a separate voltage sensor disabled by default. What's capacity and capacity max? Not 100 sure, it's what gets reported from the systeminformation node module: L69 For all of the measurements in this platform, please make a separate sensor for each non static measurement. Remove the static info. If there's any exceptions you want to make we can discuss it. I've cleared out most of the attributes and made a couple of more sensors from these. I've left the filesystem and the load ones. These can be useful, and only change when state changes, but I don't think they need a dedicated sensor at this point. There are a few more to add from recent releases, but I'll leave those until future additions :smiley cat: Only remove the service if it's the last config entry for this integration domain. We only need to check for one of the services. This check is built in in the call above.
async get registry is deprecated Hmm, when I add this change exactly like you suggested, this line (with async get() ) blocks forever. No idea why this would be happening, I'm not getting wiser from [the source of the method]( L619-L638). Do you know what could be up here? Nevermind, figured it out. Apparently the hass parameter is automatically bound for both methods, but for the callback the binding process blocks forever. Sounds like a bug, but unfortunately don't have the time to investigate now. Apparently the hass parameter is only bound for the coroutine, not the callback. That triggers an exception. Would be slightly more efficient to call this as self. set reconnect instead of the nested function I think this could be a callback since nothing is being awaited Done We can use asyncio.create task instead. From Python 3.8 CancelledError inherits BaseException instead of Exception. So we don't need this case. This is not to catch CancelledExceptions, but rather so that if the reconnect task is cancelled (meaning the reconnect loop should stop) we will actually cancel the loop, not just log the error and continue forever. Yes, except Exception: won't catch asyncio.CancelledError . Ah sorry, yes now I understand. Thanks, didn't know that! Will fix this later. Use asyncio.create task .
You can change the elif: to if: to fix this error. else: return can be replaced by a basic return . So: Fixed, thanks You can change the elif: to if: to fix this error. else: return can be replaced by a basic return . So: Fixed, thanks else: return can be replaced by a basic return . So: else: return can be replaced by a basic return . So: Fixed, thanks Is the user able to change temperature in the auto mode? We have rules for what modes should be used. L12-L17 In esphome, there was no AUTO mode, and AUTO was mapped to HEAT COO . Now that we do have that it is properly mapped here a well. OttoWinter can comment more. Is the user able to change temperature in the auto mode? Someone familiar with esphome and its auto mode needs to answer my question for the review to progress. OttoWinter jesserockz glmnet Can any of you comment on this. Edit: Here the intention seems to be to map the enums from HA to enums in esphome. It would seem very odd to have the same set of values on both sides, but they map to each other inconclusively. It looks more clear to me to have the mapping 1-1 as is, so values on both sides can be interpreted without confusion. In esphome, climate devices should own the correct implementation of the HVAC modes, and properly adhere to the intention. TL;DR; Mapping AUTO to HEAT COOL and vice versa seems very confusing, given that they exist on both sides. I guess this would need to be a soft rule on esphome as it is in home assistant. The esphome climate component is just an abstract base class for a number of devices specific implementations, so I guess those will need to ensure that AUTO will only be mapped to device states that do not allow manual setpoint changes. MartinHjelmare I have just been "fixing" the esphome codebase after a few forgotten things around esphome esphome 1471 and came to understand what the difference between AUTO and HEAT COOL was. Currently there are now no components in ESPHome that use the AUTO mode. But until the HA side is merged they will not be able to be developed as the HA connection side crashes when connecting to an ESPHome node with supported mode AUTO.
What impact does this change have? I could not find any references to this event in use. I did find that automation, scene, and template all have reloaded events called {domain} reloaded but I don't believe they support config flows so they wouldn't conflict with any of the config entry reload events that this change impacts I reverted this change based on bdraco 's comment and increased the limit to 64 We shouldn't change the max length in this PR. That should be a separate PR. Let's just add the exception in this PR. Ah right, that's why the linked PR has to go first. Thanks for checking me on that Or are you suggesting we bump this down to 32 so we can merge and then rebase the other PR to change the limit using the constant? Let's merge this with 32 and we can adjust it in the other PR since you are ready Done - Just a reminder about issuecomment-802926833 - reloading that config entry type would raise this exception if this gets released before the other PR Should we check value , property name , and max length are set correctly? hmm I'm not sure how to do that, is there a way to capture the exception as part of setting up an exception assertion like this? assertions-about-expected-exceptions with pytest.raises(MaxLengthExceeded) as excinfo: Then you can check excinfo
We represent unknown state with None . It will be translated by the base entity. State problem state ok are normally binary sensor values. Should this be a binary sensor instead? No it is not intended to be a binary sensor. The issue is that the printer can assume a multitude of states (as can be seen by the number of state constants) but I struggled to find the correct "translation" to a human readable state while allowing compatibility with the HA standards. Is this a reasonable approach? Which constants could be used instead? If the sensor doesn't use a device class we don't impose limits on the sensor value, besides the common features like unknown state and unavailable state which we represent in specific ways. Maybe we don't need a translation of the other states? "Warning" and "error" should definitely be represented by (preferably distinct) values. I realize the sensor might acutally be accurately represented as a binary sensor with OK NOK (and unavailable unknown). Can we instead create separate sensors for the detailed state and disable that sensor by default? Is disabling via setting "enabled" to False correct? Or is there a different kind of disabling? We need to use this: integrations-setting-default-value-of-disabled by-for-new-entity-registry-entries I am wondering: is the "async update" method called for disabled entities? because updates in this sensor are (as of now) the only "real" updates, all other sensors simply rely on this sensor to fetch the new data. No, the default polling will be turned off for disabled entities. I see. Then the polling should move outside of this entity - maybe into an independent async tracking task? Use a data coordinator instead: coordinated-single-api-poll-for-data-for-all-entities If it's a binary sensor it should move to a binary sensor platform. I was unsure whether I could merge the current Syncthru super class with the BinaryEntitty super class and have now defined a binary syncthru super class separately. I hope this fulfils the intention. We need to create a binary sensor.py module where we create the entities and add them etc. Okay, I split the definitions. Do I have to notify the config flow setup that there are multiple sensor types for this integration or does it find out by itself? We should forward the config entry setup to each platform from the init module async setup entry . done Please use an f-string instead of string concatenation. This property can move to the parent class. This isn't used here. It would be good to set the state attribute keys explicitly here so we can check what they are and their formatting. Can be done in a follow up PR too. Same here. And here. And here. Please exclude this module from coverage calculation in .coveragerc . Please type the signature completely, including return value, if typing any part of the signature. Ok. I will remove the signature completely since the current setup forbids me to set the correct signature The reason is that set and tuple
Any ideas on how to get pytest to trigger this branch for codecov ? instance.engine.driver is hardcoded to "sqlite" in test env and ignores config option db url . You could use patch.object on hass.data[DATA INSTANCE].engine to mock the driver. The statistics PR ( resolved this. Stale comment, or does this belong next to purge filtered states ? Moved Outside the scope of this PR, but is the function signature reversed on purge filtered states Should it be def purge filtered states(session: Session, included entity ids: list[str]) - None: ? I think the original use-case for this was to "re-apply" the exclude list to the database i.e. as a retrospective, corrective action. Your suggestion may be more intuitive for broader use. Maybe Done
ConnectionConfig.route back is of Type bool , not Optional[bool] . Please provide a default value. you should run black locally and push instead of reverting the commit. See checklist of your initial issue comment. you are right. i wasn't familiar with black
Why do you suggest that? Just for fewer chars in the line? An if without a condition implies bool() applied to an object. If I just want to check that it is not None, I should check that and avoid any overhead bool() might have. My intention was more about readability I understand. But were you aware of what I explained? If not, do you still think it's worth to have that slight readability improvement knowing it's not free? SmartAssMode Sometime if val: is slightly faster than if val is not None: , but mostly it is the same :nerd face: SmartAssMode I agree that if val: is not the same as if val is not None: but in this case i would prefer the if val: because of readability Hehe now do it again with an instance of a class with sleep(10) in bool () definition or that affects the state of the instance. I'm sure is not None is quite readable as a generic approach when we don't want to care about the instance implementation. Though, yes, I do agree most bool() implementations are quick. Cheers on the feedback anyway, always good to share get() is not needed, because config[CONF SSL] always contains a value ( at least by default DEFAULT SSL ) Thanks! Not really familiar with HA codebase, so I preferred not to assume so (and didn't have time to check). Future ones, I'll know get() is not needed, because config[CONF VERIFY SSL] always contains a value ( at least by default DEFAULT VERIFY SSL ) Can you change the patch target to just patch ssl in the integration instead of the global one? sure but why, out of curiosity? As patch is restored within the context manager (after the test) and shouldn't affect threaded tests either? It's clearer to see what's being mocked when patching the original package We try to avoid broad patch targets because with asyncio anything in the loop can happen while the patch is in place which makes it hard to debug tests when the CI is failing intermittently. While it's unlikely in this case that something already running is going to need to create an ssl context while the patch is in place, we treat this as a best practice to avoid the problem in the first place. makes sense, not really familiar with asyncio (even python3 is too recent for my old python :trollface: ) I'd expect pytest unittest to properly segregate event loops for tests to avoid mocks and monkeypatches commonly done in these scenarios.. but definitely better to be safe than sorry. change done :heavy check mark:
This will make calling set state twice, we should only do it once here: L251 Leftover, fixed Bulb Duo ( SHCB-1 ) and RGBW2 ( SHRGBW2 ) shows the following effects on web page: ![image]( And also Shelly Color Bulb ( SHBLB-1 ): ![image]( shelly-bulb-overview So I think we should split into two sets. Also to be aligned with other places in the integration and with the manufacture names we should use capital first letters ( Shower , Change ) Order is fixed in latest firmware ;-) We better use this list only for Shelly Color Bulb ( SHBLB-1 ) and make another one for all other devices Thx for noticing. I copied the name from Shelly App Cloud. Will update to capital letter in next commit This will be very problematic, In my opinion the default should be 3, currently there is only one model which supports more than 3 effect types which is SHBLB-1 . I think we should have a basic set of 3 effects, use it for all devices and expand it only for devices which have more than 3 effects and drop the RGB EFFECTS INDEX We can do the other way around, DEFAULT to 3 and SHBLB-1: 6 ;-) This coding allow to easily expand change thing for current or new devices, while maintaining a single list. BTW, you voted on Allterco GitLab for the index solution ;-) DEFAULT changed to 3 as most devices have only 3 effects. Looking at all existing types I think we can have just two sets of lists BASIC and EXTENDED . What if next devices will have more effects ? Just create a 3rd list ? I don't like the idea. IMHO, is a lot more cleaner and easier to maintain to have a single list and "cut" or "expand" based on a simple index per device type. But that won't be easy if you have to start mixing matching. I prefer having standalone lists hardcoded per model too. Just curious: what is not easy in maintaining a simple index (that in future firmware will even come from the device itself) compared to maintain both the specific lists and the if model xxx in the code (there will be few) ? I don't get the point. Anyway, code updated. Testing. Same here follow base component: [Base light effect]( L674) Follow the definition of light base component: [Base light effect list]( L669) and make sure we don't return list for devices which does not support effects
async setup is no longer needed when using async setup entry . Do we need to create a new client each update? Not fully typed, missing return type Not fully typed, missing return type The entry setup should check for this too The upstream package pins aiohttp strict at 3.7.4 , this is something that cannot be used with Home Assistant. For example, we are at 3.7.4.post0 and thus incompatible according to pip . It is advised to use a version range instead. e.g.: 3.7.0 Shouldn't these be separate sensors? This can be set as attribution Why is the unit of measurement in this list? Is the name user changeable upstream? This could be pre-calculated in the constructor. This could be pre-calculated in the constructor. Use attribution for this. Use attribution for this. Unit of measurement should not be in here Shouldn't these be separate sensors?
Best practice is to start with if user input is not None and handle the checking first. Then after the if block, return the form. Also, not a bad idea to have a catch all exception check here. Thank you. Though the problem with the catch all is, how would I make the test cover that? It was there before but I removed it because of the test. I personally wouldn't know how to do that. You'll have to patch the method that's being called in your library to return some kind of exception. HomeAssistantError is a good one to use. Let me know if you aren't familiar with patches, I can help a little more but I'll have to take a look at the library to see what's happening and what should be patched. Here's an example from the integration I wrote. It patches the faadelays.Airport.update method because that is what the library is using during the setup process to retrieve data. L105-L120 Okay, I think I managed to do it. Gonna test it now. Thank you very much for the example Use the common string here. See [documentation]( introducing-new-strings). Use common string. You can use the constant homeassistant.const.CONF ADDRESS here to keep things standard. Pretty minor comment, but this should reflect that this test is for an unknown error, rather than an invalid address. Ah my bad, you are right. Missing return type Only use relative imports within the same package. No longer needed to disable, pylint fixed this bug. Workers and pool are controlling if certain entities are created or not. This is should not be part of the config flow. In the config we only ask the bare minimum that is needed to set up the integration. Entity visibility is controlled via the entity registry and a default feature of Home Assistant (no need to control them here). Incomplete typing This could be typed Instead of a list, you could use a dictionary, that way it would be more clear what each item is. E.g.,: Or something similar... iot class is missing discovery info is not part of this signature Please add all available entities. If an entity is less common, disable them by default. Please add all available entities. If an entity is less common, disable them by default. This file can just be combined with sensor.py . I thought it'd be cleaner to seperate. I have merged the files. The title doesn't need to be translated, right? Each sensor will do its own request. This way, the number of sensors (multiplied by the number of users) can put a real strain on the upstream API. Please consider implementing a central DataUpdateCoordinator that fetches all info for all entities once. See: coordinated-single-api-poll-for-data-for-all-entities
Please sort . We don't need to include the platform name since the entity registry is aware of both the integration domain and the platform domain. Let's move these tests to test init.py since that's where the source code is that we want to test.
While you're in here, please change instances of "battery" to DEVICE CLASS BATTERY (make sure you import it from homeassistant.const ).
What will call these methods?
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
Is the time UTC? All times in state attributes must be UTC time. The 17track API returns those times without TZ info unfortunately. It should be local time for the location of that package. I currently don't have an international package delivery to confirm this assumption but for a package that is travelling in Germany, time is in the German timezone. As this depends on each package (and for international packages also on package's whereabouts when travelling through multiple timezones) I see no easy and reliable way of converting to UTC. Is that a hard requirement? I've seen localized timestamps on other addons so I wasn't aware this is a must. Yes, it's a hard requirement. I just raised a PR over on py17track to convert the timestamp to UTC. This is based on a timezone the user provides as a config param. If no timezone is provided by the user, timestamps are expected to already be in UTC. Example: 17track returns timestamp "2021-03-01 09:30". - by default py17track will expect this to be a UTC timestamp and simply return full UTC format "2021-03-01 09:30:00" - if user provided timezone of "Europe Berlin" py17track will assume this to be a "Europe Berlin" timestamp and return it in UTC "2021-03-01 08:30:00" (which is correct for 1st of March as Europe Berlin is still in CET ( 1h) and not yet CEST ( 2h)). 17track API only returns origin and destination country, not a timezone. It's impossible for some countries to return a definite timezone (e.g. United States). It can be assumed that users will mostly track national packages, not international. That's why I decided to let the user enter his her timezone and base timestamps off of that. They will be incorrectly interpreted for package states where the package is travelling through a different timezone. I can't fix that unfortunately as I can't make up data that 17track did not provide. We no longer accept additions or changes to the yaml config of integrations. See: A config flow would be needed. Why can't we just use the timezone of Home Assistant, hass.config.time zone ? Why can't we just use the timezone of Home Assistant, hass.config.time zone ? Yes, good idea. Will be close to zero instances where a user would want to choose a timezone different than that.
I would return from each if block instead of nesting here. Then just return None at the end in case none of the blocks are met. Thanks for the sugestion Should the IoT class be adjusted to CLOUD POLL instead of LOCAL POLL with this change? I know it can now be either or, not sure which should be reflected in the integration as a result. I don't think so because even when the cloud credentials are used, the cloud is only accesed once on startup of the integration to get the subdevice list. All other communication also getting the status of the subdevices uses local communication (local polling). We can probably use entry.async on unload to take care of the undo listener callback. We need to have defaults here unless we set defaults in the entry options during config entry setup. The options flow won't be run by default on entry setup. The cloud settings credentials are all optional, if they are not specified this gives None and that means the cloud is not used and only local commands are used. The default is therefore None which is now handeld, but I will make the default False, which makes it a bit more clear. We also need to check credentials in the options flow. I added checks with proper errors in the options flow. Why are these options part of an options flow? Normally connection details are part of the main config flow. Shouldn't we ask the user to choose what kind of connection to use when creating the entry? It is not really chosing, currently the local connection details are nessesary and suffiecient to set up the gateway. The cloud credentials are optional and not needed, but the local connection details are always needed. If cloud credentials are specified, the cloud is used to get the list of subdevices which can also be obtained by local control for most models of gateways, except for the EU gateway model (it lacks the required local command), the EU gateway itself can be controlled through local commands, only the list of subdevices cannot be optained (they can be controlled localy). So the cloud credentials are currently an option to get subdevices for the EU gateway. Do all country gateway types support the cloud option or only the EU gateway? Do the other countries benefit from using the cloud option? Maybe we should only ask for the cloud option when the user configures an EU gateway? All gateway types do support the cloud option (that is the way the xiaomi miio home app works). It is not really about the country but the model of the gateway (I call it EU gateway because that model has an EU power plug and it ment to be sold in the EU but obviously you can also use it outside the EU countries or use a diffrent model gateway inside the EU, the diffrent models are listed here supported-xiaomi-gateway-models). At the moment other gateway models don't really benefit from using the cloud option, although I have seen some issues where localy retrieving the device list gives errors (related to max message size in miio local portecol) if
Could this just return a None value instead of the string "none" ? That probably would be better. I'm trying to stick with what the integration seems to be doing in other places, and not be too disruptive, so a string seemed a good choice. Yeah, I realized my below comments were not actually on code you changed. But, since you're doing an improvement already, might not hurt to clean it up a bit. I'm up for cleaning it up further, it makes sense. I'd rather do it separately from these changes. As mentioned below, I've noticed the integration is checking for the string values in other places, so I'd want to take a deeper look before proceeding. You're right, a different pull request would make sense for this. Would it make sense to return 0 instead of a string since the unit of measurement for this sensor is millimeters? To me at least, 0 mm makes more sense than not raining mm . It makes more sense to me as well. However, like in the above comment, I'm trying to not be too disruptive. The integration makes checks for those strings in other places, and I wanted to be careful not to break anything. Same as above. Should the SENSOR UNIT for ATTR FORECAST PRECIPITATION just be "mm" instead of "mm h"? If the forecast mode is "onecall daily" or "daily", I think (from what I can tell from the [docs]( parameter) and testing different latitude longitude) the OpenWeatherMap api is responding with the total forecasted rain snow for the entire day (mm) instead of a precipitation intensity (mm h). Similarly, if the forecast mode is "onecall hourly" or "hourly", the api responds with the total forecasted rain snow for the hour. In this case, "mm h" works but I think "mm" also applies since the forecast period is one hour. I'm still coming to grips with this integration, and I don't have a paid subscription for OWM so I'm only looking at their One Call API. The forecast "mode" seems to be used to decide whether the data is pulled out of the hourly or daily keys in the JSON, but it's also pulling some data out of the current key. There's also a minutely key (which also includes precipitation data) that doesn't seem to be used. Under the current and hourly keys, precipitation for rain and snow is provided as "volume for last hour, mm" so I viewed this as precipitation intensity with "mm h" units. You make a good point about the forecast period being one hour - that means a "mm" unit also makes sense. I'm chasing "feature parity" between this integration and what I had before with the DarkSky integration (which provided precipitation intensity) so I chose the "mm h" route. Under the daily key, precipitation for rain and snow is provided as "volume, mm" - you're right, this would make more sense having a unit of "mm". The right thing sup TM sup to do seems to be to use a sensor with "mm" units if the forecast is "onecall daily" or "daily" and use a sensor with "mm h" if the forecast is "onecall hourly" or "hourly". Maybe even better, instead of different units, use 
What is 2600, 2601? Can it be made into constant so it's easier to follow? Other devolo devices react to the same zeroconf domain, but we can only handle models having that property in this integration. I moved it to a constant to make the purpose clear. Not 100 sure this will work, but much shorter if it does It does and indeed looks better. We're potentially moving directly to the user step form from here. We shouldn't do that. Each form is private to its step method. Await the step method to change step instead.
Can we avoid the disable protected-access with a change to the pypi package? This one is going to fail the CI since we require 100 coverage for config flows. python3 -m script.scaffold config flow can help generate the base tests Not sure this is needed since we have dhcp discovery below Will take a look. Need to double check on this though in the morning after some sleep This this data is already accessible and stored in coordinator.data , it would be a bit cleaner to have each platform use it directly instead of creating the intermediate data The raw data stored in the coordinator has more fields than are useful as platforms in home assistant. This intermediate data is a filtered down set of just what should be exposed as a platform. It could be done for each platform in async setup entry(), but I felt that is was more readable to have a singular central place to do see that. Maybe call this device data ? (naming is hard..) instead of entities as there aren't home assistant entities which is going to trip up future reviews since we have a specific prohibition on storing entities in a shared container. Can definitely rename for clarity. img width "380" alt "Screen Shot 2021-03-15 at 8 14 40 AM" src "" Can we filter out modes that the aren't supported (ex Solar ). Also, I think Don't Change can be removed Supported by the user's specific configuration of the pool controller or supported as a standard mode in Home Assistant? I'll look into removing Don't Change . Supported by the user's specific configuration of the pool controller The four pools I tested it on don't have Solar so I wasn't expect it to show up. I'm wondering if we can tell from equipment flags if it has solar or not. Maybe L9
Don't define this agian, import from .const I would try to re-write this so that you only have 1 sensor class, use input arguments to define which attribute to use etc. There are way to many attributes for Miio defices to have a seperate class for each attribute, I think we would end up with 25 classes which is just not maintanable in the long run. Besides there is a lot of code duplication between these new classes. Schould be defined imported from .const The problem with this is that we are now creating 3 sensor entities 1 fan entity that all have seperate polling updates ( async def async update(self): ). While a single update contains all information for all 4 entities. Besides these updates are not synced, so they may happen all at once. I am not sure what will happen, but this might cause stability problems, not sure how well xiaomi devices handel a lot of requests at once. (Besides the fact that this is a waste of network resources and resources of the device running Hass). Therefore the preferred way to go would be using a DataUpdateCoordinator. Unfortunateley that is not so trivial (see issuecomment-787442355 and discussion r587736441) So for now I think we can except this duplicate updates, but this defenately needs to be changed in the future. rytilahti what do you think? If I understand correctly, DataUpdateCoordinator should be implemented globally (in the XiaomiMiioEntity class), I guess this may break other devices, so I think it's an argument for another issue PR. Anyway, I'm preparing a commit to fix the other issues. This calculation doesn't match with the percentage that we set on line 909. What kind of value is the motor speed? Temperature and humidity should also be separate sensor entities. Please move these as well. This Air Purifier model (3C) does not have neither temperature nor humidity MartinHjelmare this comment seems unrelated to the pull request, which simply aims to add support for the 3C model. The temperature and humidity values are already listed as attributes in the original home-assistant repo: L167 Could you open a separate issue to aim to improve this by splitting out the mentioned attributes as sensor entities? The current code is already scoped beyond adding support for the 3C model, which you can see if you read the sensor platform additions. If we only want that scope, we'll need to slim that part down. This doesn't match with the percentage property calculation. Is this better? Yes, that looks correct. abrilevskiy could you commit this suggested change? I cannot write to your fork abrilevskiy:abrilevskiy-xiaomi-mb4
Can this be covered by tests? Is this really right? Well send chime may go away soonish. Dependent on what happens with: Ah, so "send chime" did really mean "send command" and Danielhiversen pyRFXtrx 116 renames the function. Does this PR need additional rework now that Danielhiversen pyRFXtrx 116 is merged? This is an action, maybe use imperative mood here? It's in imperative form here? it's not used in the the form "Status Trigger". In this order "Trigger Status" it's a command to trigger status. But we could name it Send status update? I don't know the context well to judge if "Trigger Status" will be understood as a command to trigger status. "Send status update" can't be misunderstood though. This will show up as "Send command: ..." "Send action: ..." in the frontend, is it intentional? It is intentional. To allow sending of a command that is not yet listed in the backend lib or part of a device type that don't have any listed commands. How is the subtype used? It's referenced neither in async get action capabilities nor in async call action from config It's mostly used for display purposes. There is a direct correlation between data and the subtype value. I could potentially allow the data field to be either an INT or a STR value. Then if it's a str value in the call step. do the translation to int in that step instead of at generation time. So SUBTYPE is used during config and display. Data is used when we execute. I've dropped the data part. Now we only have subtype. Move this check to when the automation or script is setup instead by defining a function async validate action config . If that function is defined it will be called to validate the action instead of using the ACTION SCHEMA . Technically it cant happen. You can not setup this invalid subtype. It can only happen by manual changes to yaml, or breaking changes in lib. So not sure what the benefit would be. I would still need the check here, since i need to do the lookup. It could just raise an exception instead. The benefit is to give helpful error messages during automation and script setup, ideally with filename line of the yaml file instead of a fairly anonymous log message. You can remove this check because it's impossible for an automation or script with an invalid action to be setup. Here's an example from deconz (although for device trigger): L601 I can add that. But i can't remove the check anyway. I need to do a reverse dict lookup. So the for loop need to stay anyways. There lines of else: log, break is not much of a reduction in complexity. It would just nee to change to else: return. But i don't mind adding the validation function. I have added validation now.
Remove this. Instead, add it to DEFAULT CONFIG DEVICE INFO ID and DEFAULT CONFIG DEVICE INFO MAC , and update test helpers help test entity device info with identifier help test entity device info with connection to make sure it works. Thanks for the suggestion, the tests were adjusted accordingly.

Rather than doing this as a side effect of reading a property, I believe a best practice is to do this at the time of update. One example I found was here: L294 where the entity overrides async update, then detects that the entity is unavailable. My impression is that something like that might work here too. It looks like this may schedule multiple refresh requests, one for any time this property is accessed. Consider giving this one a descriptive name too like: UPDATE INTERVAL FAST RETRY done In this context, where async update data is a method as not a member of a class, is self actually passed as an argument? I would have expected this to only work when making a subclass of DataUpdateCoordinator . yea that is kind of what I am afraid of too. Will test this as soon as possible, but not sure if it will work. Otherwise I don't have a good idea how to go about doing this. I made a subclass of DataUpdateCoordinator and now it seems to be working. thanks for your input, could you revieuw again? Nothing is passed to the update method from the coordinator, so this will not work as you intend it to do. Thanks for clarifying, I made some changes and now it schould work. Could you revieuw again? There is nothing being passed to self now there is, I made a subclass of DataUpdateCoordinator - DataUpdateCoordinatorMotionBlinds . That overwrites the async update data function to make sure it does pass self . could you have another look? Move async update data so that it is now a method on DataUpdateCoordinatorMotionBlinds , rather than passing in a self to a method that is not part of the class. (This technically works, but is not an expected style, so should be avoided). I don't think that is a good idea, async update data relays on update gateway which in turn relays on motion gateway which is only defined within the async setup entry function. So I would also need to move the DataUpdateCoordinatorMotionBlinds class within the async setup entry function. I think that might be possible, but I don't find it verry alligant. Besides in this way I change the DataUpdateCoordinator class as little as possible (only adding in the self argument in order to be able to changes variables on the DataUpdateCoordinator class). Therefore I think the current method is more elegant. MartinHjelmare the current code works, but I am not sure what would be the approprate style way to achieve the same in the most ellegant way (changing self.update interval of the DataUpdateCoordinator class within the update function). Could you shed some light on how the preffered way of doing this would be? Pass the gateway to your custom coordinator class when instantiating that. Save the gateway as an instance attribute in the coordinator. Move the gateway update functions as methods in the coordinator. Thanks for the clarification MartinHjelmare, I just made the changes. Could you look if this is what you intended?
This will most probably not be accepted. Anyway I think it warrants its own PR, I don't really know much about the GA integration I removed the setting and added a direct override in deconz plugin for SPZB0001 devices. len(self. hvac mode to deconz) is 3 for SPZB0001 It doesn't look like you have the dev environment set up correctly, else the commit hooks would have caught this. The test doesn't follow the structure of the PR I mentioned. You might need to rebase your PR against dev to make it work. We need this because the Spirit has only two modes and no coolsetpoint so that would throw an error. That is managed by the if statement on line 128 Maybe a bit more descriptive? Same here SPZB0001 has only two modes but is not controlled by on off Yes in this case it seems to be necessary Sorry for wasting your time, I misunderstood you with the global variable. now it is as expected This is evaluated on line 128 now, so its not needed anymore Mention here that deconz defines the limits the temperature if I understood you correctly This test needs to be updated to follow the structure as is implemented in this PR 1. Don't use deepcopy but rather patch.dict 2. Don't use gateway.api.event handler but rather the new websocket fixture This is not fixed yet This is not fixed yet. Better description about what you want to validate with this test.
This is minor but let's use a numeric value here. After all, bearing is an angle and many weather integrations actually return a number there.
This tests if ATTR HS COLOR is truthy, ATTR RGB COLOR is truthy, or ATTR XY COLOR in params . The first two are defined so this code is always executed? Oops, tests are needed for the new code Couldn't you use intersection here? Not sure if more readable: You can also do Make sure every fallback has a test. Sure, the tests for the light component needs to be updated to test the new features as well as all the backwards compatibility cases. You could go all wallrus: It becomes 4 lines instead of 2 after formatting though: Should we log this as error the first time per-entity? I think we should start doing that in 1-2 releases, not yet. I added a comment in 63e4f4d.
Are you sure you want to update the firmware status at the same interval as updating the hub itself? Seems like more of a once a day type operation? Yes, this is what I said in my first post, It could be reduced, once a day sounds good Lets move this into the sensor itself, as it does not serve a wider purpose. We should probably not poll since the coordinator is polling for us. This call should be moved to the coordinator update method async update data . This is not included because it doesn't refresh as often as async update data , for now, it only refreshes once 1 day. I think it doesn't make sense to update it every 2 minutes or so. (this is also way should poll is to True ) The method is throttled so it won't matter, I'm thinking.
This should be fine since its constrained to roomba- This change is not related and should not be added. Please revert this. frenck will do, i am at a loss how to use the devcontainer process, suggested earlier, to run a dev instance that binds to the network host - without that i can't test the changes in my PR because DHCP packets won't be seen by processes in the container will they? I left my first devcontainer running for an hour and it detected nothing on my network whatsoever. The dev container does not bind to the host network, as the host network is not supported by all operating systems (e.g., MacOS, Windows is problematic as well). Developing on protocols that require that, is generally not recommend to do in a dev container for that reason. ok, that makes sense to me, i only did it because i was prompted to i will go create a dev image and use macvlan on a linux host, or just use a linux vm. thanks Please run black on this.
This logic is weird, so if turn off is called, without a transition, we are not using the default transition? Yup. Same reasoning as the other function. But in that case, this code makes no sense, as well... the default transition is never used, thus this logic isn't needed at all. Ah ha. You are very right. It kept too much complexity when I copied it from the turn on implementation. I never noticed this in the year I've been carting this change around in my private branch. I'll simplify. It is always a "complex" call, right? As there is a default transition? It is complicated... The LiteJet system internally has a default transition per-light that HA can't access. LiteJet uses this internal value only for the simple call of on or off without any parameters. If brightness is specified then a transition also must be specified to LiteJet. Think of the HA default as a fallback default to be used only when a transition value must be specified from the HA side. I can comment this to be more clear to future maintainers. In this case, a comment might help. Alternative suggestion: The default transition is never used. Please set up the integration before starting the options flow to make sure that the config flow module is loaded.
I wonder if we should merge this with the breakpoint set. That way the registered unsubscribe function can also clear the breakpoint. You might want to set clear several breakpoints during a debug session though? Stale. Fixed in bc24777 Stale Fixed in bc24777 No need to be async. Fixed in bc24777 Fixed in bc24777 Fixed in bc24777 Fixed in bc24777 Fixed in bc24777 Breakpoints should not be using events. Use the dispatcher. Fixed in 2fcce66 Fixed in bc24777 For required items, use square brackets. Fixed in bc24777 Switch to dispatcher signals. Fixed in 2fcce66 Decorate all commands with websocket api.require admin Fixed in bc24777 for the breakpoint related commands. Should we require admin access also to view and list traces? dispatcher Fixed in 2fcce66 Fixed in bc24777
How would the end-user know which account it to use? As this integration supports multiple instances, there is no indication on which account one has to reauth with. Right now, if I log in with the wrong account, the wrong accounts gets updated (because existing entry await self.async set unique id(account.id) fetches whatever matches). Leaving me with the impression it was successful, while in fact, it wasn't. Thanks for the review. I think I should do two things: 1. Display the (existing old) account email address in the form, to give the user a hint as to which account we're talking about 2. When the user provides updated credentials, verify that the account id matches, and if not, abort Does that sound right? That sounds right Where is a good place to store the account ID? Normally it's retrieved from the API when we authenticate, but if the authentication fails then we don't get an account ID. So we need to persist it somewhere in order to check whether the new credentials refer to the same account or not. The account ID is the unique ID for the config entry. Once you retrigger the auth in the controller, you could send it along to the config flow. That way, the flow has a reference to the entry that triggered it. Thanks, I used that approach user input cannot be done The test isn't simulating with raise ConfigEntryAuthFailed does. I'll add a suggestion We don't want to switch steps while taking user input Then conditionally set description placeholders {"email": self. reauth input[CONF EMAIL]} in async step user We should also assume the user might change their email address as well so you won't have to even set description placeholders if you make it the default when building the schema. Example above The email address from the failed login is displayed to give the user a hint as to which account failed auth, it isn't used otherwise. frenck was concerned that a user would enter valid credentials for a different account than the one which failed. Is account.id the unique value here and not the email address? If so they may have changed their email address so as long as we validate account.id doesn't change (and its not tied to the email) then we should allow them to change their email. Looks like L137 is the account unique identifier so in theory it should remain stable if the user changes their email address so that is what we need to validate did not change in the reauth process. I copied this code pretty much verbatim from reauthentication, so if this is no longer the preferred approach that should probably be updated I can't say I'm a fan of that approach as I think code that passes user input around blindly in a data structure is riskier, but since there is precedent for it if you want to do it that way it seems ok to me. If you reverse the conditional to if user input is not None: you can fall though and show the form again when it fails. Also build the database schema with defaults Then they can still change the email address if they
Don't we want this to be a member recipients in the data dict instead, or are there other integrations using target in this way? Yes, target is the generic field to specify recipients in a Notifications service call. See the doc here: This is very useful for sending one time password using email. For the current implementation, each user will have to create it's own SMTP setup with recipients hardcoded, then use that specific setting as the auth mfa modules. With this change, the admin can setup a SMTP entry as the "server", with a default recipient. Then each user can utilize the GUI and use this SMTP server entry but specify their own target email address. Please not that "target" field is directly configurable via the MFA notify GUI, but "data" field is not. Please set up the integration and patch the library. Then call the notify service and assert that the mock library is called as expected. We don't want to interact with integration details directly in the tests. writing-tests-for-integrations
Thanks syssi, your suggestion looks cleaner. One of my concerns is we are not sure if all of the future miot devices will share the same feature set. Maybe we can take actions when that happens...
I updated the rest of these to use constants in Times in state attributes must be UTC time. Please use our dt util functions as much as possible. We have utcnow . This is a bit tricky, because the reminder is based on the device clock which is not time zone aware (mine is currently 1 hour behind local time because we recently began DST). I think I should just remove this attribute, until I can implement it more correctly. We have renamed device state attributes to extra state attributes .
Will some entities be disabled that used to be enabled for users now? No, this should use the same logic as before. Will review it later to make sure that statement is accurate My statement was accurate, nothing has changed here Why does the user need to select api version? Is it not possible to just go with version 4? Is the api key tied to an api version? Could we try the api key against the api versions and check validity and determine api version automatically? Yes I checked, they assign different keys for each version : . We could remove v3 support entirely but it's technically still supported through July and some users are already using the v3 version Let's do whatever you think is best here. Looks like the timestep migration tests can use pytest parametrization. Could we do this migration without changing entry version? Changing version makes it impossible to roll back. Maybe we can just check for api version in entry data and migrate if the api version is missing? Ie don't use the config entries migration api but just have a check inside async setup entry . Good idea
Copying a dict to a list copies the keys by default. We can remove .keys() . Fixed in 47721 This could be a callback instead of a coroutine function since we don't await inside. This is corrected in 47632
Need to fix this as it's a merge conflict I can move part of this into the pypi since I'm forking it now and reduce the code here Can gather here This might be able to gather
Are both of these necessary if they are both raised from exceptions.HomeAssistantError ? They are used to show different error messages to the user, so these class definitions are just to define the different error types. IMO, this should be in a separate PR as you are changing something this does not pertain to the PR title. It was only due to a failing style check that I added it here. But to be honest I don't know the policy on adding entries here. It seems that every config option used in any config flow needs an entry here? Some of these sensors are not very useful? I've removed some not really useful sensors and made a bunch of others disabled by default (as suggested below). Home Assistant has the option to have specific entities be disabled by default. You should include that support here so that things that are not critical to a great integration can be opt-in instead of opt-out. Use the entity registry enabled default property for this. No need for this if you inherit. We shouldn't await a broad exception. What exceptions can your PyPI lib raise ? I've changed it to more specific Exceptions, the lib returns a ValueError when the response is not proper JSON and a PicnicAuthError when authentication failed. Do we always need the user first before fetching the cart ? Oh I see now that there are sensors that rely on user data and sensors that rely on cart data. It would make more sense to create multiple update coordinators. That way you won't be fetching user data the whole time if no user sensors are enabled. I've removed the sensors that rely on user information and made it such that the user endpoint only needs to be called once after initializing the coordinator. Move this logic to SENSOR TYPES as part of each sensor definition. I'm not totally sure what I should change here, do you mean moving the logic of creating the lookup table to the sensor definition or the conversion from cents to euros, or both? And wouldn't it require more memory to save the whole API responses instead of the data we're using? Instead of creating the lookup table, have each sensor definition have a lambda that knows how to extract the data it needs. Like this L34 I've changed it according to your suggestion, but please check that it's done in the right way . Was looking at the code of this integration. The token you get here L40 , how long is that token valid? I am assuming the mobile app is not requesting the auth the whole time. Would you be able to get away with just taking this auth token and not storing the username password the whole time? Here is a way it can be structured so that if the token is refreshed, it will be able to be updated in HA too I've tested with an auth token I'd saved a while back and I could still use it to authenticate, so it's possible indeed to just save the token. I'll update this as soon as MikeBrink python-picnic-api 11 is merged and released. I've updated the integration so it saves the authentication token instead of the use
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries. The integration fully supports config flows and entries, this schema is a leftover from before that. At the moment it's in place to support upgrades from really old versions, but I agree we should not add to this. Related question: how long are we supposed to keep supporting these kinds of cases? i.e. when can this be removed entirely? Our normal deprecation period is 2 release cycles, ie two months. So should I revert the schema to how it was? Or remove it entirely? It wouldn't be compatible with my changes anyway Please revert it to the existing schema. Only add the option as config flow options. Done :) Thanks for the feedback and sorry for the mess I'm making, it's my first time committing something for Home Assistant and do have to learn a thing or two apparently As I understand it, both options are mutually exclusive. If it doesn't match the first, there's no need to check the second. I would suggest to refactor CONF SETPOINT OVRD MODE to a boolean value, then there's no need for any CONF OVRD MODE vars and we can just do What you are saying is correct. I was planning on doing a boolean at first, but changed my mind because I thought this would be easier to understand for users from the options panel. If you really suggest to use a boolean I will revert the changes for this PR and add the boolean option in a separate PR (splitting the bullets as Martin said) It should be safe to assume that users of the gateway are familiar with the terms temporary and or constant in relation to temperature overrides (otmonitor uses only these terms). Having a checkbox with one of these terms in the options panel should be clear enough, especially when it is further explained in the docs. Another option would be to keep the dropdown in the options panel and deriving a boolean from its value upon submission of the form, but in my opinion the checkbox would be sufficient. Suppose you're right on this one. I will change the option to a boolean, will try to do so in a separate PR. Would mean I have to update documentation and tests as well but that should be fine. What do you reckon on the schema in init .py, should it be removed now? Or should I just remove the parts I modified? See above, I would suggest refactoring to a boolean. Make sure to set up the integration before starting the options flow in the beginning of the test. Use hass.config entries.async setup . This is needed to make sure that the config flow module is loaded if the test is run in isolation. Should there also be with patch() in this test form? Or is it enough to place hass.config entries.async setup(entry.entry id) and await hass.async block till done() under entry.add to hass(hass) ? We need to patch something so that there's no I O in the test. If we only care about the isolated options flow, we could patch the integration setu
Icon and device class are mutually exclusive properties. We should not set an icon if the device class is set. mhhh ... should I than also correct properties for ups.temperature , ups.realpower , ups.realpower.nominal , battery.charge and battery.temperature ? :smiley: Yes please done Icon and device class are mutually exclusive properties. We should not set an icon if the device class is set. mhhh ... should I than also correct properties for ups.temperature , ups.realpower , ups.realpower.nominal , battery.charge and battery.temperature ? :smiley:
Since you have a unique id (a bad one, but on non-the-less) you can just do this, and skip the already configured function. Hold of on implementing this change. I think it might be a bad idea actually. Setting the unique id to something read over the telnet connection would be much better. So after some thought, this should not be done..you could likely set the unique id based on the uuid provided in the announce, but then you need to make sure you also grab that during manual setup. As part of ssdp flow I need to set some unique ID for it so that there will be only one discovered config. Othervise the result is like this: ![ 2021-03-04 08-54-24]( I think that's because the router broadcasts multiple services. And I'm not specifying any ST filter since I'm not sure which will be broadcasted with what set of the router firmware components (customizable). gssdp-discover response: Another option for this would be Ignore discovery without UDN do not have fallback to hostname. Preferably you would find the UDN even for non discovered entries. But that is a bit tricky. Updated to use UDN. Obtaining the UDN on manual setup is kinda tricky and not always possible since: a - UPnP can be inactive on the router, b - router can be on the different networks so that multicast messages won't make it to HA. Missing return type: Typing incomplete Ideally; we should not even ask for the data we got from discovery. So, I would hide the host field completely on a discovered item. Your suggestion will lead to 'None' being a default value in case of pure user setup. I'm passing vol.UNDEFINED here to say there is no default. Passing None leads to instant error message for missing host in UI even before user inputs anything As for not showing the field, I would still want the user to see the host which will be used The host that is used can be shown in e.g., the title of the discovered item, or even in the description of the flow. Incomplete typing: Incomplete typing: Abort reason not keenetic ndms2 is missing from the translations file. I don't think it's needed for ssdp discovered case. It wont end up hitting UI. Still, it should be there to be complete. eh... Abort reason no udn is missing from the translations file. I don't think it's needed for ssdp discovered case. It wont end up hitting UI. Must be complete. We should swap these, and abort if the unique ID is configured first. This is much lighter to handle process. Additionally, you could update the existing entry when aborting on an existing unique ID to automatically update e.g., the host of the entry if it changes. Incomplete typing: Incomplete typing: Complete the configuration flow, to ensure there are no side effects created because it was initiated by the discovery.
Let's make the sequence go from open to closed. Makes sense to me. You never know if someone will want to use the ordinals for something; gives it a nicer flow. Looks like we can drop the parentheses: operator-precedence Why not. I'll add to the next batch. We could also just make these strings? Do you have a specific reason for it? I personally prefer to keep enumerations numeric as you can access the enumeration name via Enum.name (at least in terms of the capitalized formal name) while using the value as an ordinal within a list. I have no issue making the change if you have a use case you can see that would use it, i'm primarily a Java developer and my Python brain is stubborn. I guess I'm wondering what's the use case for the numbers. There's nothing saying they should be numbers. It's a local definition that we use just here and we don't use the numbers. Numeric ordinals are just the default value. The Enum has to be bound to some constant value, and you are correct, you can use Strings for this local use, it doesn't exactly matter. I tend to prefer sequential integers as they can be used for something like an index to a list of other constants, but as you said, I'm not doing anything with them in this local case. I'm ok with keeping them as numbers. Probably a good idea to ensure the values are unique. Part 2 of ensuring unique values in the enum.
Wow, we had no config schema to begin with and just passed that to import? We know if this flow is requested by an advanced user. Let's hide UUID and IGNORE CEC unless users are advanced. Fixed in 4487596 It would be better to validate the configuration yaml in the CONFIG SCHEMA in the init module and give feedback to users if there's invalid config. Yes, that would be better, but the point of this PR is to deprecate yaml config so I don't think it adds much value to add that check now? As long as we do import the configuration yaml, we should do it according to best practices. Alright, improved in fa14da8 Why are we storing the configuration yaml in hass.data instead of passing it to the import step? Fixed in fa14da8 It's a bit weird that we're modifying a constant. Yes, but that's how the lib is designed. It could be refactored to a more sane API, with a setter function, but not in this PR. Do we accept a partial valid config to be more backwards compatible? The alternative would be to extend the config schema instead which would fail the whole config on invalid result. Yes, the intention is to accept a partial valid config by simply skipping invalid media players instead of rejecting the entire config. We need to set up the integration before starting the options flow to make sure the config flow module is loaded. Thanks a lot, Martin! This is fixed by 7ea9378. I'll open a separate PR to move the config flow tests to their own file.

I really do not see the need for this added complexity, it does not seem to make your bit implementation easier, and it complicates the rest. I suggest to remove the lru cache part (unless you have some good arguments, why not). If I have a configuration where each sensor switch has the same address (in the case below it's 514) I have N read calls of the same Modbus register to the Modbus Client. If I have 16 sensors attached to the same address, the integration will end up with 16 reads of the same value through the Modbus. This read cache holds the first read value for one second. This helps avoid making sequential calls. We can remove the cache, however, then we will be making the same read calls multiple times. This is not a big deal, however, may slow down updates. The cache protects from multiple reads only during one update cycle and should be empty on the next cycle, which ensures by the 1 second expiration time. Since Modbus device is a black box, we can't assume that the cache will be valid for a longer period of time. That's why I picked one second. Also, any write to the Modbus invalidates the cache. This might be unnecessary though because the next read cycle will start not earlier than a second later and the cache won't hit anyway. Your use case is a bit different than the normal ones, normally you would just read the 16bits in one go, and then split them. What I do not like here is that you force the cache on all read, and I am not so sure it is a good idea. What you could easily do is make a bit sensor.py, and in that file have special handling for the update call. E.g. you group the sensors (according to the bit pattern), the update call to the first sensor reads physically and either stores the value for the other sensors or updates all sensors. Update call to all other sensors are dummies. I prefer the old way, unless have some good arguments as to why not. It just avoids x16 reads of the same register during the update. If you think the risk is greater than the benefits, I can remove it. I do think the risk is greater than the benefit, see my suggestion above to avoid reading 16 times. again why does a write invalidate the cache ?? in many setup the inputs are totally independent from the outputs. Looking at this I think caching will cause a lot more problems. when read is called we want a modbus transaction to take place. Cache shoud guard sequential reads. Each update cycle starts not earlier than 1 second. Since TTL is 1 sec, we can safely remove it to avoid complexity and confusion again again. In general I think all your changes to this file apart from the 2 loops either needs a lot more explanation and test, or be removed. traditionally every platform have its own domain and own file, but that is not a strong demand it depends a lot more on the added complexity. Lmk your best judgment on that, I can split it, though the file size, seems, manageable. Also, I assume I can't make (and it make no sense in this case) a new do
This is a tad redundant. If the command id 32 you are assured for the args to be a list of [ OperationEventSource, OperationEvent, t.uint16 t, t.uint8 t, t.LocalTime, t.CharacterString, ] alternatively you could do this also improves readability, as now I don't have to look up what command id 32 means. Adminiuga is there a better way to parse the args out? Or is there a better way to do this? not really, cause args would change depending on the command id how come all of these are shifted by 1? Just curious I shifted by one in part because I want this to be "people" friendly as opposed to "machine" friendly, so start at 1 instead of 0; and in part because z-wave locks start with slot 1, and I wanted to have consistency with them. why not just await self.set pin code() ? is that a thing that will work? If so I can update to that easily definitely test it, but it should work. I'm still new to python :) running tox now, will try with my lock in a bit Work got crazy for a couple weeks, but I finally was able to test with my door locks. As you suggested, it worked just fine. Updated commit pushed. There is more that could be done... we can add more API tests and add UI to the device page, but this should be ready for the beta as an MVP.
We have access to the script entity in this location:
Shouldn't this be part of a higher schema to make this behavior consistent across all platforms provided by the MQTT integration? I agree, however, I think refactoring should be a separate PR including other common fields as well, not just the icon. For now, this is consistent with existing MQTT components (and some others as well). I agree with frenck, let's make this a general schema. Please refactor the PR to add support for CONF ICON to MqttEntity , support for CONF NAME should be moved there as well. I was just checking into MqttEntity as well and how CONF UNIQUE ID is implemented. Will do that! emontnemery I have now hoisted the name property, although i kept the CONF NAME schema inside individual files as they contained default values. Forgot to remove the original name functions, gonna remove them soon Are you planning to do more changes to the PR? emontnemery I see that CONF UNIQUE ID is set only in MqttEntity initializer, but not updated via discovery update() . Is this intentional? Ufa jking95 ? emontnemery I see that CONF UNIQUE ID is set only in MqttEntity initializer, but not updated via discovery update(). Is this intentional? Yes, it's intentional, it seems like an unnecessary complication to support changing unique id's as the suggested unique id may be rejected. The individual component schemas change this to "MQTT Alarm" etc, with the intention it will take precedence. Suggest to add a new test helper help test default name in tests components mqtt test common.py call that test from each component's tests to verify the default name is the overridden one, and not MQTT Entity . This would be a cosmetic test though, not a functional one. Is that ok? In addition, i can remove the default value, in which case it would default to DOMAIN PLATFORM (ie. "mqtt switch"). Oh, it does not use DOMAIN as the second part, for example alarm control panel would be just mqtt larm The way I imagine this could potentially break in the future is if the config is validated by the MQTTEntity using the MQTT ENTITY BASE SCHEMA . Hence the suggestion to add functional test help test default name(hass, mqtt mock, domain, config, expected name) which sets up an entity and tests that the default name is as expected. Edit: Maybe it's better to drop CONF NAME from the MQTT ENTITY BASE SCHEMA discussion r587307693 Yes, dropping CONF NAME , default naming is more sensible. Should MQTT AVAILABILITY SCHEMA also be moved to MQTT ENTITY BASE SCHEMA? This would also make it possible to override these values. If that's OK i can't see any problem. Let me know. You're right, and that's already an issue for the CONF DEVICE and CONF UNIQUE ID which we don't want the components to override. Can we do like this to prevent the overriding, and remove CONF NAME from the MQTT ENTITY BASE SCHEMA ? Sure, we can, provided components never need to override CONF ICON (I guess domain default icons are fine). And dropping CONF NAME would make it default to something more sensible, su
This isn't used anywhere. Temperature should be a separate sensor entity. It's exactly like current power w . And with a sensor template: MartinHjelmare Do you have an example of how it should be done better? The temperature measurement should be exposed as a separate sensor entity in a sensor platform. This first requires a separate refactor of this integration to use config entries and config flow.
This looks a bit convoluted, could you replace it with something like:
Do we need to decorate this with callback ? Assert all the things we expect the result to return.
Leak detector pucks measure air temperature, not water temperature. FloTemperatureSensor has been updated to handle both. Flo pucks are passive detectors and have no switch capabilities. Usually you'll have multiple leak detectors, so using the device nickname is important to get sensible device names. so I think I did this originally because HA will auto adjust it based on what the user configures. I need to go through the old PR's to see if this was something I was asked to do. nope... this is something I should have done myself... :( discussion r467460761
Can't we check in async seen() whether the device provides battery info instead of handling this as an exception? I think HomeAssistant complained about network on the main thread when I tried getting the battery info inside async seen, and I did not find a good hint in Pysonos's api to determine whether it supports battery info. There may be a particular bit in the supported features: 457279 that could be used, if it's available at the time of async seen() . Do we need to poll the battery at the same frequency? It should change far less frequently. The battery level changes less frequently, true, but I picked SCAN INTERVAL to update the UI relatively soon after the power source changes. Stale debug? I think we have a constant for this Please use f-strings Please use f-strings If you set the device class, the frontend should take care of this for you It seems not to, probably because it's currently a media player instead of a proper sensor like the refactor branch will be. As a sensor entity, it seems to properly show the charge level, but not the charging status. Since this is already in the base state, it shouldn't be an attribute as well stale comment? This comment, and the other similar comments, explain what the following functions do. Then outdent below timer will always be none. Instead of saving the timer, wrap the call to async track time interval in self.async on remove
According to the service schema in the code, these fields are required, yet in this service schema in YAML they are not? Additionally, can't this use regular entity services, and thus, targets? In the service schema, one of vin or device id is required. I wasn't able to define this in the yaml (only that both are required). We do not have regular services entities, as we do not have an entity that would be suited for this. On all cars, we only have a lock entity available, but adding these services there doesn't feel right. We could have device tracker entity available on all cars - this would make a little bit more sense, but we would add a device tracker entity that on some cars will never show a location. If you prefer, I could go for the second option (device tracker for all cars, with some locations being (None, None)) and add the entity services there. Use exclusive options in a group instead: ideally, "device" is replaced by some kind of constant instead. Exclusive unfortunately allows no data to be sent, i.e. the data dict to be empty (see Of course I could handle a None value in my code (which currently crashed if no data is available), but that would defeat the validation, wouldn't it? EDIT: I could add a custom message to vol.Any to make it clearer? msg f"key must be one of {[ATTR VIN, CONF DEVICE ID]} data" Hey, just checking if anything is missing or needs to be done for this PR to continue (except for waiting of course ) Should be "hide" this one by marking it advanced ? As a normal user would probably have enough by just using the device. (Same applies to the ones below) Sounds very good to me, however it doesn't work on my dev environment (rebased to core dev 10 minutes ago). Copied it from homeassistant.reload config entry but also this one does not hide the advanced field entry id . Is this something that will come up soon? If so, I'll add advanced: true for all VIN entries.
Should we listen to the groups all the time? We only need it when an entity is added to HA rihgt? It means that even if no group entities are created, we are still going to fetch this to stay up to date. I'd have to teach async update items about the relationship between groups and lights as well as store some data elsewhere since its all in the closure. Doable for sure, just adds a lot of complexity. Hmm.. If I do that and they move the devices around it won't pickup the room change.. not sure thats actually a problem though That's not a problem because once we suggest we don't unsuggest. I've implemented that. it cancels the listener after each room update and re-adds it when a new light is added
There isn't a name property here as its actually a different object than the one in the config flow. I need to figure out how to get the name with that we have. I suggest that you fetch it from the config entry directly (see name in attrs higher up in the method).
Should we use the constants that were recently introduced? Maybe also test the unsubscribe by sending another event and checking that calls is the same length? That will not work, as supervisor event will always dispatch the event, but it will not be forwarded, since that subscription is closed. Right. For a future PR: since we only use these values inside the schema that describes the command, I have been actually moving away from storing them in constants in other places. This works too :) It does? Tests locked up when I tried it We can make this a callback We should put this test in test websocket api.py
cv.has at least one key ? Thanks, I looked for that in voluptuous and didn't find it Is any string allowed here ? No, I think I had Any where I meant All ? It must be one of the values in the list which follows (derived from SecondaryFiltrationMode ) Should it be like this? that breaks with: Sorry, I'm finding the voluptuous docs a bit difficult to decipher. I'll look for an example in another integration OK I think vol.In is what i need, will fix This can't be missing since its required This is handled by the async register entity service and not needed in this schema. The entity service makes sure the right entities are called. This causes my test to fail: should I be invoking it differently? diff-cf682d19cefe9521213511541b0f809f32a5a3ad840c5098c97d3b9f6ec5cc8bR60 If you make it a dict it will be passed though make entity service schema which will add the right keys values pairs The service descriptions have changed and been extended, see: service-descriptions Please update your services file accordingly. Ah, I copied an example from another integration. Will do It looks like the new format can have an entity selector, which would be very useful here since there's usually only one applicable entity. But I don't see a good way to do it: configuration-variables Integration, domain, and device class filters all seem too broad. Is there a way to limit the available entities to only the type which accepts this service call? I made a first pass. The docs say to omit entity id from the fields in services.yaml when there is a target selector, but then in the service tool "fill example data" doesn't add the entity id attribute and the user has to add it manually. Is this normal? ![image]( This one, you'll probably have to call cv.make entity service schema and then wrap it again for the has at least one key I think you can omit the cv.make entity service schema since it should be wrapped automatically if you pass a bare dict According to the service.yaml file, both are required? According to this, at least one key?
Please remove all translations .json from your PR. This will be added via Lokalise. You can only keep the 'en.json' to make testing development easier. This will make reviewing a lot easier as well. done, thanks! About your ximmio.com integration comment: this was my initial feeling as well until I read that this was already proposed as a change in the original repo of Frenck, which he rejected because of all the area support you have to do. On one hand I agree with him and additionally this makes it possible to have a more local branded integration (people from Meppel or Twente won't search for Ximmio and probably they even don't know about it). On the other hand having it all in one integration is less duplicate code, targets a bigger user group and more people from the community should take care of the changing area support together. So a requirement will be then to have min 1 developer per area that keeps it up-to-date for his her area. Until it meets this requirement, I think separate integrations are the best solution.
for switch type in (NIGHT LIGHT, PANEL LOCKOUT, SLEEP MODE) .... This would be cleaner to make 3 class of entities since there isn't any shared functionality. All datetimes need to be in isoformat() bdraco, start time and end time are recurring times, meaning they repeat every day at the same time. This is much more similar to how HA handles an input datetime that has only a time component. So is an isoformat still necessary on this? I'm not sure. Let's ask for a second opinion on this. I have one of these, and Nate is correct. They have no concept of day-of-the-week for sleep mode; they only accept a time normalized to the local timezone (which is being done here in code). First, I looked at the implementation of input datetime, and it recognizes when someone puts in just a time... and then the entity "expands" to the next day when the time is reached when the input datetime component fires. For an internal entity, this is probably appropriate; however, in this case, the external entity (the LitterRobot) doesn't have a need nor a purpose for the day at all. Storing the isoformat() time just means that we have to waste time internally updating the attribute state to add the date each day when the time is reached and then turn around and strftime() the time away from the isoformat() time again. Instead, we just set it and don't look at it again until the app config changes it or an event updates it... which leads me to... Second, it's pretty uncommon on this device to continually twiddle the time. Once sleep time is set (that's the time when the litterbox does not cycle), it's usually not touched again for a simple reason: it'd freak them out if it moves at times they don't expect. Cats don't have day-of-the-week support either. :) Personally, I'd give this one a pass. But that's just my opinion. "Cats don't have day-of-the-week support either." That made me chuckle. But precisely what you said about updating the attribute state, which is why I went the route of showing only a time piece. This should be on the light platform. Please remove it from this PR and add it to the next one. Activating this mode on the LitterRobot actually doesn't directly turn the nightlight on or off. It just sets the "mode" of the nightlight - either "off" or something similar to "auto". The actual device turns itself on or off based on occupancy and illumination when it's enabled. Looking at the state of the mode actually doesn't tell you the true state of the light. Which is why Nate made it a switch. As joelmoses stated, it's not a true light, but a mode that is enabled. joelmoses, since you have a unit and as a potential user of this integration, would it make more sense to title this entity class "Auto Night Light" or "Night Light Mode" rather than simply "Night Light"? natekspencer Maybe it'd be better to name the switch "Nightlight Mode" or something? :) That makes more sense to me. Without the context it definitely seems like it's directly controlling the state 
I think that we shouldn't have Calculated for "internal" integrations. I think that they should just have none. I'm not sure what that means? Calculated means: The integration does not handle communication on it's own, but calculates the state. Let's consider sun ... its internal, but its state is clearly calculated. Or the updater integration, is internal, but is cloud polling. I'm not sure why we would hide that? Yeah, the sun is fine. So is updater . But setting default config to calculated seems wrong. I would even argue that counter should not be calculated because it's user input.
Not sure if the service will be ok with it but we could asyncio.gather here Since this is being worked on actively, if this suggestion makes sense, please do it in one of the other active PRs Thanks bdraco, I wrote this down and will have a look at it for the future. Didn't think of this, so will need to have a look at the advantages. Not sure if the service will be ok with it but we could asyncio.gather here What are the advantages off using gather? It will happen in parallel instead of series. Less time we spend waiting for integrations to setup faster startup. tetienne I will have a look if we won't face any API limits by doing those 'expensive' calls in parallel, otherwise I will add it in a future PR. It's just when we set-up the integration. It should be OK I think. Is there ever a chance that placeoid will be missing from areas ? No, placeoid is a required attribute on Device and it will always have an area. (Area could also be 'All-House'). If placeoid is empty, we have other problems before it hits this part :D
If a ternary spans multiple lines we usually unpack it into an if block Fixed rebased. Do we know the MAC address of the device? If so we can use connections instead Unfortunately not.. The Somfy account only communicates their internal device ids. We are already happy that the hostname of the device is using gateway-xxxx-xxxx-xxx where xxxx is the gateway id. In theory we could gather the hostname via the discover possibilities (zeroconf DHCP), but I am not sure if this works for all supported hubs. I will implement the gateway via zeroconf in a follow up PR. Resolving this comment for now. DHCP discovery added and tested in c70bfd4. Use urlparse here instead. Good one! fixed in e98978d. What does this url look like in production? internal: 1234-5678-1234 pod 0 io: 1234-5678-1234 12341234 2 And it can have other protocols like ogp and such.
These will be displayed in a dropdown, we should keep them short and to the point. The description allows for longer texts.
Based on previous feedback, I understood that changing the icon is not allowed. What would be the best way to show that the device is in a 'locked' state, thus that commands won't be executed? Do we know the state of the cover when it's locked, ie open closed? Yes. Only io devices (two way communication) can be locked due to an external reason (wind, snow etc.) and those devices always have their state available. It should be possible to override some of the locked positions via the official vendor app, but we haven't implemented this for HA. It would be good to indicate that all commands you execute via HA, will not succeed. For now, we use an icon since this was used in the current tahoma integration in core as well. My suggestion is that we raise an error in the service handler methods when a device is locked and the command won't succeed. This will show in the GUI to the user. And we drop the custom icon. I have removed this functionality for now. Let's see if users really use this and otherwise add it in a follow up PR. The obstruction detected attribute will be added for those cases already, thus it is visible. Looks like we do this more than once...Can this be its own function? This specific functionality is only used once. We already moved this logic from stop cover to async cancel or stop cover , so not sure if further decoupling is possible and would make sense. Position is a required parameter. Fixed in 3191f1b. As above. Fixed in 3191f1b. Are there devices that only support tilt movement? We normally don't take tilt position into consideration for closed state. Yes, for example a pergola like the Brustor Pergola. In core, there is now also a demo device which only supports configuring tilt position . (not my picture unfortunately) ![image]( Ok.
How will this error message look? Why do we need to join the exception arguments? Are there more than the message? as an example, when we get SetValueFailed : SetValueFailed: Unable to set value, refer to api node?id setvalue for possible reasons As of now we only have one args so I could hardcode err.args[0] , what do you think? Or just pass the exception instance. It has a magic method str . I'm not sure what I am doing wrong, but I tried with and without str() for the following: f"{str(err)}, {type(err). name }: {','.join(err.args)}" Seems to return None (I got this by failing a test which doesn't have args, hence the missing argument after the colon) When I pass err directly, I get a serialization error: and when I pass str(err) , I get nothing: If the exception doesn't have an argument the magic str method will return empty string. I see, thanks, that explains the issue.
BinarySensorEntity will determine the state based on is on If I don't override the state method from SmartTubSensor , it seems to get used in favor of is on , resulting in a failure: That looks like its coming from sensor.py and not binary sensor.py ? Ahh ... I missed that it has SmartTubSensor as the base class. The binary sensor shouldn't be based on sensor . Split SmartTubSensor into a base class without state in entity.py and use it here. Done This would be shorter as a list comprehension but if you add more later, it probably doesn't make sense to change it.
Should we titlecase these? doesn't specify, but looking at my entities list that does seem to be the pattern. Will do. If we only support toggle we should not implement turn on off methods but just toggle. Was addressed here (posting this for tracking purposes)
Time attributes need to be in isoformat (see elkm1 sensor.py ) It might already be (please confirm) Thanks It is ( 2021-01-20T11:38:57.014Z ), though I'm returning the raw value from the API. Should we validate it here or is that OK? I could also wrap this in python-smarttub and return a Python datetime object, which we would explicitly convert to ISO format. Would that be preferable? (if so I can split the filtration cycles into a separate PR) Sounds good to me. Any abstraction that can be moved into the pypi is almost always a win OK, I'll move the two entities with state attributes into a separate PR then. Any reason these need to be their own class? Good point, I can use a generic sensor class for all of these Cruft ? Yes, these belong in will fix
How many devices can they have at a time? I guess it's limited by the size of the subnet? So a max of 252 for a typical class C network that also includes Home Assistant and a default gateway. I've been testing with 22 devices. If they have more than 38 devices it will tie up every executor thread and everything that needs the executor will have to wait. Can we make this async or limit to 3 at a time? Thanks for that. I hadn't realized the limit on the executors. This makes sense, and it looks like there is a gather with concurrency helper that can be used here. I'll give that a try and test things out. All set and tested. I also applied the same change to the initialization of the static config entries. executor threads instead of asyncio executors since the executor can be used without asyncio
Can you return here and skip all the elif changes? can't need to call line 249 (actual meter reset) If this PR gets through, I'll improve the code by moving the other cycles into using croniter and all this elif tree will go away
This won't work anymore :)
If we check that the key is in the states we don't need to use dict.get below. Do we still need to cast to string? We have typed the values to strings: L24 It seems so: homeassistant components zwave js climate.py:299: error: Returning Any from function declared to return "Optional[str]" [no-any-return] Found 1 error in 1 file (checked 1 source file) Yes, I see it. We haven't typed the property detailed enough: L124 Ok. That's something for a future PR to address. might need an additional guard for missing metadata here ? nvm, I just remember MartinHjelmare changed it that an empty dict will be returned on the metadata.states Yes, an empty dict by default.
Why do we need to configure CONF REDIRECT URI ? Initially I was developing from different environments where I had little control of the URL of the Home Assistant instance, while the registration of the application on the Legrand platform requires you to register a specific callback URL. By making the URL configurable I was able to overcome this inconvenience and I thought it made it a more flexible configuration. Is it preferable to remove this config option? Yes, we standardize the redirect uri in our oauth2 helper. Noted. I removed the redirect uri configuration parameter. This should not be part of the config flow, only the configuration YAML. We don't want the advanced oauth details to be user facing in the config flow. I moved these configuration parameters to the YAML file and removed the config flow step that allowed user input of these parameters. Register the update listener in the config entry setup instead. Noted - I included this piece of code in the entry setup function. We should not store entities in a shared container. The entity is a platform concern and should not be accessed from outside the entity. It's ok to store an id of the entity or device to keep track of added entities or devices. If we need to ask the entity to do something from outside the entity we can use our dispatch helper, and send a signal to the entity connected method with optional arguments. Understood. This took some refactoring due to my misconception of the entity handling, but the integration no longer holds references to the entities themselves and only to their identifiers. Changed as per suggestion. Please catch one or multiple specific errors. If we remove a device from the device registry, all connected entity entries and their corresponding Entity instances will also be removed by default. Please nest the items under another dict under the config entry id key. Please remove this. If we don't know the model we don't report that item at all. Please just use the constant directly. We don't allow side effects like logging in entity state properties. Please import and use the helper to get the registry from the entity registry instead. This is probably not needed at all though, since the entity will be removed when we remove the corresponding device entry from the device registry. L574-L577 This api should not know anything about the Home Assistant Entity instances. This is the device api and should only handle the devices. The entity platforms will then consume this api when there is new information, triggered by the coordinator update. Consider separating the entity addition from the coordinator and instead signal the entity addition from the coordinator via our dispatch helper. That will allow the same coordinator to handle multiple platforms which may be needed in the future. It also separates concerns better. Please name the test modules after the init module, config flow and entity platforms, eg switch. Ie make a test init.py and a test switch.py 
Why make this a new WS command and not make it part of config entry update ? oh it's the require restart. get it now. I think that this function name is confusing as it can also be used to enable it again. Maybe: Why do we need to cast it. Is entry.disabled by not typed as Optional[str] ? This is never used. This event causes an error in combination with platform unload when the integration is reloaded. When the entity registry updates the entity entries it will remove the entities since the entity entry is disabled. Since the entities have already been removed by platform unload, removing the entities again will trigger an error.
Can this be moved into the base class? It can. It won't be appropriate for all of the entities (e.g. there are multiple pumps and multiple lights) but I can deal with that in those subclasses.
We should maybe load this from services.yaml I agree. This all feels pretty hacky. Would it make more sense to just tell the frontend to show the say service description and call it a day? Right now the frontend doesn't have access to the say service description, as that service is not registered. For notity it is (notify.notify) Ah, we only include descriptions for registered services. That makes sense (and also meh). Changed it a tiny bit, to load it from the service file. This is an async context and we don't have to check if it exists either. Tests will fail if it doesn't. We know the entry exists.
Instead of entry id, maybe require either integration domain or entity id. If no entity id is passed all config entries for the domain are reloaded. If an entity id is passed we look up the config entry from the entity registry. img width "569" alt "Screen Shot 2021-03-10 at 9 07 46 PM" src "" I've made it accept a target, but I can't seem to find a way to make the target optional since entries like homekit will have no entities. I guess I could make two services but I'd rather find a way to make it optional. Config entry entry id is not user facing. I don't think we should accept that at all. I can take it out, but it doesn't solve for the original case where we want to reload a specific homekit config entry. Reloading them all can be quite expensive. HomeKit has a virtual bridge device so they can hit that. I'll take the rest out. Would it be possible to lookup the correct aid storage via an entity id? It looks like each storage is mapped to a single config entry. Of course that's not a general api. I can lookup the config entry id from the device since async extract entity ids is not going to have any entities to match in this case. Will give this another pass when I have another free window. I think we need a async extract referenced config entry ids to match async extract referenced entity ids because by the time we convert to entity ids we are assuming the integration provides entities. We should require at least one data type. Use cv.has at least one key . Check that there are entries collected before awaiting. Use async extract entity ids instead. We're not allowing area id or device id currently. Should we use an entity service schema? L849 Since it's such an advanced functionality, I don't think it's bad to just accept a config entry id . Will add that as an option and mark it as advanced in services.yaml Will be a day or two as I'm traveling tomorrow
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries. This will probaly take me some time, as I've not worked with it yet. But I'll give it a try. Changing this PR to draft in the meantime.
I'm still not super happy with the way platform conf is being passed to the platform. I haven't come up with a better way though. I could enumerate config[DOMAIN] as well and then pass this as REST IDX and PLATFORM IDX Edit: That didn't seem to work because the platform doesn't have access to the whole config struct. Looks like this definitely needs to change since if there is a template in the config it will cause an error with the recorder as the fired event won't be serializable I'm going to store it in hass.data instead and pass a key to find it in the discovery info I reworked this. Would it make things easier if we force a unique ID for this new way of configuring this integration? That way we can: - reload correctly - provide unique IDs for entities - clean up unused entities Are you thinking a unique id for the data source, and each sensor? hmm you're right, we would then need one for each sensor too. I thought we could make that up, but ofc we can't. Meh. Is this needed? It looks like async process config already makes sure we have data ? Yes, if the platform fails to setup the first time it needs to try again. Weird. This code prepare setup platform is called by EntityComponent and so the integration should be set up: L269-L309 ok, I need to go to sleep. I thought you responded to another comment of mine. Its to handle this case more specifically await inside a for-loop means that we will fetch all Rest endpoints in sequence instead of parallel. Almost got it right. haha. At least I remembered to gather this time :) fixed It's a bit silly to use an entity component just for the async prepare reload function. We should probably extract that function from that helper into a standalone function. (We can do that in a follow-up PR) queued for followup I don't think that this is possible? Agree. I don't think it can. Will remove Nevermind, all the tests explode when I did since it gets called when the platform is setup. This code prepare setup platform is called by EntityComponent and so the integration should be set up: L269-L309 Its guarding against this case: no rest: but Doh you're right. I thought it was hass.config.components , but it's about the config.
This is consistent with the zwave and ozw integrations, and "parameter" is the common terminology. I'm not sure about this. I think "set config value" better suits here. Why? It's suited only for the terminology of the API. "parameter" is common; it's used everywhere, in OZW, in zwave-js docs and code, in the spec , etc. as a non-english speaking user "parameter" sounds a bit strange, that's all. But I'm fine with parameter or param Also consistent with other integrations, and more familiar terminology for users. parameter or config label ? Not sure about this one, but this matches more closely to the zwave-js docs. Users aren't going to really understand what "property key" and "property key name" are, unless they are looking a dump files. I would leave this out completely. Just have each "bit mask property" have it's own config label and set a value for it. Some advanced usage to think about... it would be nice to allow both labels and integer values, for parameters that provide "options". Classic zwave forced you to use label. OZW improved this by allowing either a label or the integer value. For example, [this parameter]( L37-L61): The HA dump shows: With the zwave integration, I was forced to use value: LED always off . With OZW I could use either value: 2 or value: LED always off . So it would be nice to use either way here as well. cgarwood thoughts on kpine's suggested language changes? I'd imagine we want to use the same language for the service that we use for the WS API as well as the library, so we should make a decision now and make sure we are conforming across the board One more thought about the language - while I understand the desire to make the transition easy for users, the reality is that ZWave JS works differently than OZW did. It's easy enough to explain what the different service parameters mean in the service definition, but I think we potentially add confusion by calling it one thing in the service but it being listed as something else in the dumps that's specifically about the property key name to bitwise and property to parameter changes that were proposed above I don't think a user-facing public API should reflect internal details of the zwave-js API. It's easy enough for HA to map them to the correct API. "parameter" is the standard terminology used in z-wave, not just OZW. "property" and "property key name" are obscure and only used by z-wave JS; they have no meaning outside of the context of the API. A user shouldn't be required to look at dump file (and then learn how to format and read it) in order to use this service call. The HA frontend should use the similar terms so that a user could go from UI to service call. There is also the zwave-js device database. Ideally a user should be able to look at that and translate it to a service call. Example: There's no mention of property property key in the DB, but there are "parameters", "labels", "values", "bits" and "bitmask". If I go to the Z-Wave Alliance DB, [everyt
This dependency looks like an outdated fork of python-binance . What's the reason to use a fork or what issue does the fork solve? Ah good one, thanks! That was because back in the day python-binance did not support async operations. I see this has been fixed so I changed the dependency. I'll also rerun my tests to see if everything still works. not needed with async config entry first refresh don't partial type arguments Needs to inherit SensorEntity as well Look at using SensorEntityDescription and attr to reduce code here.
We normally avoid guards on state in actuator methods for polling integrations unless the device breaks when asking it to actuate the current state again. Otherwise if we have the incorrect state it's impossible to change state from Home Assistant. I actually do not know since I don't own such a device. So I can't test it out. I will remove it, and we will get some reports from users if it turns out it does not work.
Maybe create a constant list with valid data keys instead, and then check if any of those valid keys are in the device status, and pass the data key instead of the integer to the entity. I changed it to make it more general and easier to pass aditional info like icons in the future We only need to use partial when we need to pass keyword arguments to hass.async add executor job . thanks for the tip Please sort :abcd:. done Is this change related to the new switches? yes, the switches have the load power attribute
This should the prefixed with the integration's domain, also as suggested by felipediel consider something like emontnemery I added it to the remote component with the idea that other remote components would be able to implement the event and have a common set of base events that would be used. If there isn't any interest in that, I could move it into the broadlink component and prefix as suggested. If this should indeed live in the remote integration, I think the event's data should have a common base with optional integration specific data. In addition, changes to the base component requires an approved architecture issue. I'd suggest to move it to the broadlink integration for now, if the need arises to support this in other integration that would warrant an architecture discussion. Will it be easier to build automations around this if the error cases have their own event type: Good idea. Have updated with the new failed event.
We no longer allow integrations to add or change a platform YAML configuration. More information on this can be found in Architecture Decision Record: - ADR-0007: decision Please note that this integration connects to a device or service and another Architecture Decision Record applies that disallows the use of YAML configuration in favor of a configuration flow via the UI: - ADR-0010: decision See our developer documentation on how to get started creating a configuration flow for this integration: As these changes often involve a bit of work and some significant shift in the current code, we will close this PR for now. We (and our community!) would really appreciate it if you could start on the refactoring of this integration in a new PR. Thanks already! : 1:
If we raise an exception with the message as exception argument it will show in the frontend. Use a 'ValueError . since should be a datetime validator. We can raise a HomeAssistantError with the message here.
Is it possible to check if IP address is configured and abort on that? It's annoying if we have to ask every user to implement the same flag because they are getting spammed. Great idea, thank you! Not sure if we should only check for configured config entries or also ignored unconfigured config entries. Possibly there are some other scenario's where this might not fully work, but it should already be a step up from the current problems. Updated, please review. In practice this is usually an ip address
Just a note: While I worked on another HA integration, I found out that the schema used in Config Flow has certain limits. When I defined a scan interval with lambda function like here, it didn't work in the UI. I just copied it from the old configuration, but you have a good point. I have changed it to "cv.positive int", which does the same job. The old parameter was "register type" with values: holding or input. I guess this is just a typo. Sensor doesn't use coils or discrete inputs. Good catch (Copy paste is a dangerous tool). Removed the file, since it was merely there so you could see the changes easily. In the climate schema, slave was required, but in the base schema slave is optional. Does that change matter? First of all, thanks for a long review, as usual most of your requests makes sense (there are one, where I need to think about how to do it). Slave should only be used when we connect to a modbus device, that have modbus devices "below" it, so it was an error to have it as required. The last parameter should be the whole original config. Nothing is checking this return value. done We should inherit from SwitchEntity not ToggleEntity on the line below. done One of the points with parametrization is that it allows us to avoid logic in the tests. Can we make the parameters be the config instead so we can remove the if else logic here? I agree, but it was easier just to type do type :-) Changed! It would be good to remove this case too and instead extend the parametrization of config. Done
Should this be a service or a websocket command exposed in the config panel? Will users automate the log config, or just change it to debug? Oh I didn't think of that but that's a better idea. Do we need to expose log to file and filename or should we keep it simple and just focus on setting log level? also I don't believe there is a way to read the current value for each of these attributes We'd like to allow the user to capture the Z-Wave JS log at debug level, and save it to a file, with a button next to state dump in integration config panel. That would be the end goal I think. Ie, we want to make it easy for users to get the Z-Wave JS log from the integration to help debug issues. I think that can be orchestrated with the exposed options. Basically, first call sets log to debug level and saves to file, second call resets. We should also have a drop-down that lets users switch back and forth between log levels persistently I think.
Please do not add additional translations in the initial PR. Translations can be managed via lokalise after this PR has been merged. OK, correction done via a new commit and push. This PR contains 2 platforms: binary sensor sensor. Please limit the initial PR to add an integration to a single platform. It would require some rework to remove the binary sensor (which is less important) that I would have to put in another PR right after this one and It would imply to retest everything. Is it a blocker one or could you accept it as is ? Yes, this is a blocker and is described in our developer documentation: 5-make-your-pull-request-as-small-as-possible Done These are empty defaults that can be removed. OK, correction done via a new commit and push. Either set a device class or icon, not both. OK, correction done via a new commit and push. You can remove async setup since OK, I removed this method. Yep, I integrated this change in my commit. Are there other errors that can be thrown? For example when the internet connection is down, or when other failures happen. To be safe, you could catch some other requests errors Actually, I do not know how the server behave in bad situations since I have only see it up and running. I added your proposal in the code to catch other errors to improve it. ?? It is a comment I forgot to remove from the integration I took examples of code. I removed this comment line. I would remove the prefix, just keep the id. The prefix was to be sure there could not be another integration with the same ID if we have no luck. For information, a flipr id is just 5 characters long. Perhaps that the unique id is relative to the current DOMAIN so I agree there is no probability of collision in such a case. I removed the prefix as suggested. I don't think that this is allowed in core, eventually this would need to be something which is in core for all integrations. Since the encryption key is also included and not rotated, I wonder if this makes a lot of sense. Perhaps you can start the discussion here: Is a HTTP error always invalid auth? Not sure how stable their API is, but with other API's I have seen occasionally some other status codes (500 etc.) when in maintenance or when having a bad deployment. Is there no way to validate a flipr id after manual input? You can remove this, you are not using a YAML import configuration, thus this is not required. You can pull these details from homeassistant.const , also have a look at CONF EMAI vs CONF USERNAME from homeassistant.const import CONF PASSWORD, CONF USERNAME By the way, officially pH doesn't have a unit... Thus not sure if you should just name it pH and remove the unit. Would 'last measured' or something similar be more clear perhaps? Perhaps you want to implement device info as well (in a follow up PR)? See defining-devices. This will allow you to group all entities from a particular flipr id under one device in Home Assistant.
get() may return None, which is not iteratable. This shouldn't happen but you're totally right. This does definitely not hurt.
Maybe move this out of the try... except? We have async capture events test helper: L1110-L1120
Unused?
async methods cannot be callbacks. Why use a condition if no async things are happening inside this method? Because if we don't, we'll spin the CPU with an interval of 0.0 to [async get still stream]( L199). Given that Hyperion is streaming the integration individual frames, the idea is to send them to the browser as quick as they arrive -- "but no quicker". So we use a condition to wait until a new frame arrives, which then notify all 's from here when a new frame arrives, and unblocks async wait for camera image below which returns the new frame. If we didn't do this, async get still stream would just call async wait for camera image as fast as it could in a while loop. [esphome]( L82) uses a similar technique. ESPHome actually waits inside the condition. You never wait. nevermind, I see the whole code now. Conditions still trip me up. You do start ... do something ... stop also in the below method. I would suggest to make it an [async context manager]( contextlib.asynccontextmanager) Good idea! I'm a bit surprised. You're going to handle an mjpeg stream but you're only getting a still ? That's right, except it's continuous stills. [Hyperion continually streams base64 encorded frames in real-time]( live-image-stream). The integration decodes them, and assembles the mjpeg stream from the stills. Bit janky, but it's what the [base camera entity]( L400) does too as the default behavior. Why wouldn't you be able to just patch out this method ? Heads up for a future PR, you can now assign names that don't change in the constructor by assigning them to self. attr name and self. attr unique id and then drop these two methods completely. Please type async add entities with AddEntitiesCallback . L66 Nothing is checking this return value. We shouldn't need to assert self.hass anymore.
This is a bit WET even though its simple. I should make a util Does int states in range handle None gracefully? self. step range can be None, if the KNX fan supports setting percentage directly. No, it will blow up. The guard should be in the integration though and not the util I added a guard to return the maximum allowed steps in this case (100) Mark as optional. Should we mark it advanced too ? Yes Mark as optional
why not use the .property , .property name , .metadata , and .value attributes directly? result[value] will return a ConfigurationValue which is just a Value subclass I would also include the type attribute in the result set. That will allow the frontend to show the right metadata based on the type of configuration value I wasn't able to get using .property directly to work: type was included under the metadata key Property with underscore perhaps? yes it's property , and the type under metadata and the type provided directly on the ConfigurationValue are different. Perhaps we should rename that latter type to configuration value type to avoid confusion to rename the attribute now that the upstream PR has been accepted, this should change from type to configuration value type There's no property name key in the result. Maybe add an assert for the configuration value type key? might be good to add the readable property too. I've noticed some config parameters have that set to false. Example: L514
This changes the YAML configuration.
We need to replace the direct request calls with a library before we add config flow. Please extract the device specific interface code and data parsing to a standalone library published on PyPI. 4-communication-with-devicesservices Was planning on doing that as the next phase of updating the integration. I am currently working on the lib, but I found swapping to config flow then introducing the new library DataCoordinator usages to be a cleaner PR. Given this is a direct lift from the existing init with no changes, can we proceed with the lib happening next? If we use a separate target branch than dev branch to allow multiple PRs before releasing anything, I'd be ok with it. We generally don't allow major changes to integrations that don't have a library. What do you think frenck? I think this should be done the other way around :) But either way is fine rfleming71 let me know if I should push a copy of dev branch upstream that you can rebase onto, or if you want to start with the library instead. My preference would be the copy of the dev branch, but I will do which ever process is typically followed. May be a day or two before the lib PR is ready Here's a fresh copy of dev branch: Please rebase your branch on that and change target branch here in the PR. Done. Thanks! These can be fetched from OctoPrint and should not be part of the flow or data set in Home Assistant. Removed It says host , but is an URL at this point. I would recommend it to be a hostname, port and SSL setting separate, to be more in line with how that is handled in Home Assistant in general. Sounds good. Split back apart. Instead of asking for the API key, we should start an external process to auth against OctoPrint. Going to roll this into the next PR with the lib. I was able to wrap most of the auth process into the library. Sensor selection should not be part of the configuration flow. We should offer a sensible set of sensors by default. Switched to include the default sensors OctoPrint has zeroconf, and exposes a Unique ID via this route as well. This has been added in the more recent version of OctoPrint. We will need to migrate the legacy discovery as well Octoprint exposes a unique ID that can be used instead. All tests must be standalone pytest test functions instead of unittest class based. Please use the core interfaces to start the tests. writing-tests-for-integrations Setting up the octoprint integration will set up the octoprint sensor platform too. If we want to limit the platforms set up we can do this by patching the PLATFORMS constant that is iterated to forward the config entry to the platforms. Start the flow with hass.config entries.flow.async init . Don't patch our code in the config flow. Patch the api client. Fixed This doesn't look like it will be long term stable Is there a better option for the unique id here? unique-id-requirements It may be better to use the config entry id here instead We should use the unique ID provided by Octoprint itself. Y
I know it's only a small PR I've submitted. Simple enough. Python is not my primary language. I'm happy enough with line 52 (my first edit did that), but could the "is not None" removal perhaps allow a blank or NULL string to be sent? I'd tested pretty much all eventualities manually, and wonder if this is a tidy for prettiness rather than functionality? As I say, not my first language, and I'm reading and learning as I go. Also, a little late in the evening to test this. Thought I'd just ask the question first before spinning up my test system again. Thanks. It may be worth considering retrospectively building the correct tests for Prowl. Again, an area I'd be happy to help with, but learning as I go. If "" or None (null) if will not be true I'm confused elyobelyob, you resolved the comment and said you were happy with the change, but you did not commit the suggestion? Oops, sorry. I did try one way, and it said that I couldn't as Author. But just found a different button to press.
Bit weird that this is all above the constructor? Why not just return hub , since system is a property on it? Since serial number can be None on a v6 system, should we only append the parentheses if there is a serial? This was actually an invalid assumption before the library was able to decode the encrypted serial number. So i can just assume it exist now. This code is hard to read. From the whole if user input statement, this is the case that will actually need the form rendered again. Would probably be easier to just return async show form here. And then rewrite it to be if not user input: return form too. I always find config flow steps hard to read :). But I agree this ended up nicer. Use asyncio.create task instead. Please don't set mutable objects as class attributes unless it's specifically needed. Just make an init method and set the attribute. Return value typing is missing. If we don't want to type the items of the dict we should use dict instead of Dict . The exception instance has a magic method str . We don't need to copy to string. Only MEDIA CLASS constants may be used for media class parameters.
This is part of the API that needs to be abstracted into the pynanoleaf package. Ok, I've created Oro pynanoleaf 1
This won't return None now, so the return value isn't optional. If we want it optional we should not use the bool copy. If None is returned, does that result in an "unknown" state for the entity? Maybe that is preferable. Not currently, but it may change in the future. I think it's more correct to return None since we don't know the state. These should make their way into the python lib. It would be good to add a test for this case as we expect this to happen whenever the cover is stopped. The type is not hashable. Removed the check for device classes. This allows the cover to support node-zwave-js v6.2.0 and any other potential motorized barrier types that we don't know about. The functionality isn't dependent on the types, only the barrier class. There are some specific types that could result in different HA device classes (e.g. DEVICE CLASS GATE), but I haven't seen this kind of device yet, so just assume garage. This was returning False for the very first value that didn't match, even if the value matched later on.
We don't allow for YAML schema's that connect to a device or service. (ADR-0007 and ADR-0010) We should not use attributes for these things, instead make separate sensors. And for a lot of things, it doesn't matter. For example, the Supervisor, CLI, Observer, audio (actually all, except core add-ons); are auto-updated in the background. OK, should we have separate sensors for each add-on as well? I think so? I would say, we create separate sensors switch entities for each add-on and or other information we have, and decide on which ones we disable by default (so we keep the most common useful ones). does OS get updated in the background too? I'm guessing not. I could add a device and sensors for OS as well. No the OS won't get updates automatically OK I can add that in a follow up PR Since this PR is still open, I just implemented it as part of this If we don't activate the config flow in the manifest.json I don't think we need to define this step. Let's simple use the ATTR REPOSITORY for this Didn't see that attribute originally Not sure there, maybe MartinHjelmare and emontnemery can help there. The hassio step would not be the trigger as we do not send a discovery from the supervisor and we should not mix this source. I think there needs a new step async step system which get trigger by async setup ? We don't have a system source and I don't know that it makes sense to add as part of this PR. I am using a hardcoded string for now so that the config flow is less misleading, this can be switched to use a constant if we decide to add one Shouldn't this be popped after unloading? We don't use the term Hass.io anymore, I would keep it short and simple maybe? Additionally, instead of deriving the name, we can also always pass in the sensor name, removing the need for juggling with the attribute name completely. (As done in the sensors). We don't use the term Hass.io anymore in user-facing text. If a function must be run from within the event loop, it should be prefixed with async Can't we just use attribute name in this case? This returns all add-ons, we only want the installed add-ons right? supervisor info returns a dictionary with an "addons" key, that contains a list of installed addons. supervisor ohh good to know, thanks! I'm not sure it makes sense to have a service to update an addon. Do we really want folks automating this? They will do that without reading release notes, and then complain to the maintainer of that add-on if when it breaks. I guess with this, we could deprecate the auto-update feature inside the supervisor. I guess with this, we could deprecate the auto-update feature inside the supervisor. My thought as well. I could update the description in the schema to have a cautionary note to try to head off complaints frenck ludeeus ? Since we can use this to sunset the auto feature in the supervisor, I'm in favor of adding it, description should warn This should be outside the for loop, it will now run twice if both are missing. It
Please reduce the size of this PR by limiting it to a single platform. Additional platforms can be added later in follow up PRs. See: 5-make-your-pull-request-as-small-as-possible Remove unused manifest fields. See Same as above, See All API specific code has to be part of a third party library hosted on PyPi. Home Assistant should only interact with objects and not make direct calls to the API. Should be the same as in [the documentation]( diff-d4aee1a7bdb0843d4cc9f6ff966319ac817968e14c71a7e940463f6ffe3679e3R7). This is not used. Unused see another comment. [The coordinator update interval is set to 1 minute]( diff-7378423dd22bcf9b7fcb78464b5b559baa0d90906080bbda791a04876354c829R85). This doesn't seem to be used? Use [CONF API KEY]( L36) instead of "api key". And import: from homeassistant.const import CONF API KEY . Make api key required, [L31]( diff-7c754d47535aea42c0a53f79ef22fc5b53992f53d5fd647d90f9f0ec8d46ef32R31) will fail if no api key is given. vol.Required() Sorry, hadn't seen this before. You did it right in the tests and init. Move hass.data.setdefault(DOMAIN, {}) to async setup entry so that async setup can be removed. A rebase is required. title and description are missing in config step user. Generate en.json with python3 -m script.translations develop to test strings.json. Put these together in one if. Use .get to combine these. Save the session so that you do not have to request it every time for put state . self. session aiohttp client.async get clientsession(self. hass) . Is it possible to request the freedompro device account name or something similar to set it as title instead? If not set the title to Freedompro here and remove the info variable, return value, etc. Fixed in pylint 2.7.3 This is now in the manifest and should be removed here. Duplicate code. I think we could remove this and else from line 90 and reduce the indentation on lines 91-101. Why do you use get() here? Because I used this syntax device ["name"] before, and I was told to change it to device.get ("name") We should use here an attribute instead of property: We should use here an attribute instead of property:
The remote send command service already supports a delay parameter. L98 How would that be accessed at the script level? Do you mean in the script configuration? It'll be part of the service data in the service configuration. It's okay. Thanks. Reviewed a couple of the other remote devices and figured out what I need to do. Now changed to use the delay secs attribute and also added in the num repeats attribute too. Use getattr with a default None as third argument and check the return value before calling it instead. MartinHjelmare Thanks. Modified to use getattr as suggested. Should we raise an error, log an error and continue or just continue silently, if the command is missing? I'm happy to log an error, but I do not think we need to raise an error. The supported commands are documented, so it is more likely someone has mis-typed. None of the commands can cause a major issue with the Apple TV, so an error should suffice to enable the user to figure out what has gone wrong. Yeah, I think it's mostly a question of what we think is the best and most expected behavior in case of a missing command. Should we try to continue and finish the rest of the command sequence although one command won't happen, or should we abort as soon as possible and let the user know. It is probably better to abort. Most of these commands drive the ATV interface and if one step fails then the end result will almost always be wrong, so not worth progressing with the next commands e.g. if home , left , down , select is typed in as home , left , done , select , then the wrong item in the UI will be selected. Updated to log an error and to break out the loops Logging an error is ok. Raising an error has the upside that it will show as a "notification" in the GUI. In that case we can raise ValueError with the message as exception argument. I'm happy to add raising an error. In my use case it adds no value as I hide most of my automation behind Siri voice commands and just check the home assistant logs from time to time to see if anything untoward is happening :-) Those notifications don't stay on the screen for long. Do they. I'll shortened the ValueError message to give the user a chance to read it :-) Also, since the ValueError generates 56 lines of logs, is it worth logging an error too, or just go with ValueError ? We usually don't double up with log and raising an error in these cases. I suggest we just raise the error. The goal is to make it clear for the user what to correct and then the stack trace won't recur.
should we even bind this? Maybe not, removed from the new functions. MyPy complained because async get device is not guaranteed to return a device registry entry. Is some actual error handling needed to validate the return value? Modified to explicitly silence the MyPy errors for now, let's do proper error handling tests in a separate PR Modified to explicitly silence the MyPy errors for now, let's do proper error handling tests in a separate PR Modified to explicitly silence the MyPy errors for now, let's do proper error handling tests in a separate PR This test is not needed anymore because the registry is loaded by bootstrap. This test is not needed anymore because the registry is loaded by bootstrap. This test is not needed anymore because the registry is loaded by bootstrap. We probably need to await this at some point if we want it to be ready before leaving the setup phase. Yes, absolutely, fixed in cd5f7e5 Is this assert for developers to not make mistakes? Assert can be turned off in production code. Yes, it's only intended for developers tests. In production, the registries are loaded once by bootstrap.py. Why didn't mypy pick up this problem before? We don't change anything about the device return type typing in the helpers that I can see. I think typing of async get registry must have been impeded by the singleton decorator which is no longer used in this PR. I didn't dig into it though. Yeah, that was my guess too, but I don't see why that should impact the device typing. :shrug: It impacts the device typing because mypy somehow doesn't know the type of dev reg ?
Thanks for your review bdraco. This was automatically generated by a [scaffold script]( I will delete lines 9, 10 and 11. Thanks . Can "dependencies" be removed? It is included in [this minimal example]( Yes it can be removed. It uses a .get() L373 Does it make more sense to implement this as a fan since it has a fan speed? Thanks for your review bdraco. The user wants to turn on the perfume distribution and not a fan. There is a small fan to blow the perfume out of the unit. It is not visible and you cannot feel the wind. The user does not know that there is a fan in it (unless he opens the unit to change the perfume). You can set the "perfume amount" with the app, in the API it is called "speedc" and in reality it is the speed of the fan. I chose "fan speed" instead of "perfume amount" to prevent confusion with the amount of perfume that is left. In the app, it is clearly an setting. But in HASS it is unclear whether it is a setting or a measurement. It would be a bit cleaner if every call didn't have to re-pass the session object This has been fixed in We require 100 coverage on config flows Please add coverage for missing lines I have added two tests ([f8e61d1]( The coverage is now 100 . I was not aware that we had to have 100 coverage, must have missed it in the documentation. Thank you for pointing that out. Can these throw an exception? If not, please move them outside of the try block These should not throw an exception. I moved them outside the try block. Commit: If it makes sense in this case: Then you can replace self. diffuser.data["hub"] with self. hub everywhere. I don't see how this makes the code more efficient or clearer. It's indeed a little shorter but don't think that adds much value. Does the hublot value meet the unique id requirements here unique-id-requirements? I have checked multiple devices, they are unique. The code is written at the bottom with a QR code. This QR code must be scanned with the app during setup. It's possible to set up the integration multiple times with the same account if capital letters are used. Then the ids aren't unique. I will fix this in the next commit. This has been fix in Is this device discoverable via dhcp ? dhcp No. It uses a Espressif chip with default MAC Address and hostname ESP XXXXXX . It could be any devices using that chip. We should verify the cloud service is online and they can login here. return False if authentication fails for now and implement reauth in a future PR, reauthentication If the cloud service is offline raise ConfigEntryNotReady The highlighted code recreates the Account object and doesn't authenticate. Therefore this will never fail. How do I check the account hash and if the service is online? Do I have to make a request and catch the exceptions or is there a function in HASS to check if the service is online? If its a single endpoint, we usually setup DataUpdateCoordinator and then call await coordinator.async refresh() then raise ConfigEntryNotReady if self.coo
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries.
If we do not know the position we should return None These aren't used outside of the places they are set unless the state is missing. We shouldn't return fake state We don't want the library to know the implementation details of Home Assistant (specifically that the integration is named wilight in Home Assistant) This value should come from the integration itself since its a property of the integration. Changed to DOMAIN "wilight" Looks unused Removed! Thank you! I'm not sure the check if needed since ATTR POSITION is a required argument It looks like we do have guards all over the codebase for it though... Edit: seems like that is just older code and the newer code doesn't have it. I think we can take this out. We shouldn't import and use constants from the library in the Home Assistant specific code like eg DOMAIN . The library constants should only be used for the library interface. Done! See:
Actually it would be better to create a new type for each class so we don't have to do this check again in AirQualitySensor We need a separate class for each type as density to air quality will only map PM25 Make a base class of AirQualitySensor and have the new types inhert it After your review, I think we need to do the following modification 1. create a pm10 and pm25 class that inhert the AirQualitySensor class on homekit component. 2. create a new density to air quality mapping for pm10. Am I right? It looks like AirQualitySensor is no longer used? I think the AirQualitySensor can be treated as a generic class for non PM sensor. User can add any non PM 2.5 and PM10 air sensor to the homekit by using this class. There is a density to air quality pm25 above that has the docstring """Map PM2.5 density to HomeKit AirQuality level.""" above but provides a different mapping. The density to air quality is the original mapping function for the original AirQualitySensor class. The function should be mapped with a PM 2.5 value. I found a new mapping scale for [PM2.5]( [PM10]( That's why I create a new mapping method for the PM2.5 and PM10. If we remove the density to air quality , we could not retain the AirQualitySensor class for a generic air sensor. According to the Apple homekit menu, a homekit AirQualitySensor accessory class must provides a AIR QUALITY value. Then outdent the block below Why do we need to return for "if not density:" here? Then outdent the block below It looks like these lines need to be outdented
Let's call it spokestack Why pin numpy and cython ? That's going to be a recipe for disaster with our 1000 other integrations. I originally pinned numpy and cython because of the [docs]( 1-requirements). When I run script gen requirements all.py I get an error also linking to this section of the docs. Is this related to the component using PLATFORM SCHEMA instead of the config entry? The spokestack Python package should define it's own requirements. That makes sense. Thank you for explaining. Please remove this. This should be converted to a config entry. For this one, you mean to add the API keys via [config flow]( defining-steps)? just wanted to verify I was adding it correctly in the updates. Yes. doc string Not needed I don't get this, why not just store entry.data in there to begin with? If it is wrong then I didn't understand the correct way to do it and apologize for wasting your time. Do you mind pointing me to the developer documentation that covers the correct way to do this? entry.data is a dictionary. In L26 you store 1 piece of information in it. Then in line 28 you store all the rest. hass.data[DOMAIN] entry.data would do the trick. ok that makes sense. thank you! For this one, homeassistant.components.tts doesn't have the attribute async setup entry so async setup platforms returns an AttributeError . The way I have it here works, but I'm not sure what to do. Other than adding async setup entry to the base tts component, but we've both seen how well I know this stuff :stuck out tongue closed eyes:. that's not what description is for. the default message talks about missing keys. Your substitute message just mentions the key. BEtter to drop it. same You need to validate the user input is valid You only support a single config entry since you store things directly in hass.data[DOMAIN] , so if a config entry is already configured you need to abort. hass.data is a generic dictionary shared among all integrations. hass.data[DOMAIN] is where you store your information. This code can never work ok, so all of our configuration data should be under hass.data["spokestack"] ? This makes sense, but I just wanted to make sure I understand. you cannot use different numpy than the rest of HA. Thank you for the catch. I removed the other references and just missed this. We don't write tests like these anymore. Write tests like done for the config flow. For this one, what I understood is that the test should use the pytest format and not the older unittest like classes? correct. We only write function-based tests. Use pytest.fixtures if you want to run code at startup shutdown of tests.
We no longer accept additions or changes to the yaml config of integrations. See: This integration needs to be refactored to use a config flow and config entries.
Please don't change translation files. Please explain; these files are used by the alarm control panel component. Do you have a translation team that takes care of this? The translation files are synced automatically from Lokalise. The source of truth for the template is strings.json . You can read more here: Please don't change any platforms in this PR. That should be done in separate PRs after this is merged. So mqtt and manual mqtt changes need to be reverted and put in later after merge? Yes, please. Let's not change the existing support integers. Just add the new mode 32. Fixed Please don't add this helper. We're trying to remove these helpers. Just call the service directly. If i remove this it breaks the tests. If this needs to be removed please provide replacement code as i don't have the knowlegde how to solve fixed with correction support integers Where is this used? helper removed tnx to KJonline What is the goal of this test? This was added because with " " build fails everytime. Please provide a solution if you know how to solve this one keeps giving troubles with using " ". See tried everything, this is not related to wrong coding. i give up. posixx ill take a look and see if I can help with the tests issue.
Is this a stateless device? The HomeAssistant implemantation of this entity was stateless, this PR gives it a state. In my opnion the device itself has a state, since it detects vibrations, therefore the state is vibrating ON, or not vibrating OFF. You cann't directly read this state from the device, but it will continuesly push vibration messages each 1 minute while vibrating so in that way you know if it is continuesly vibrating or not. (The same way motion sensors are almost always implemented). Note that the device also has a battery level ( ), amplitude of the vibration (um), tilt angle (degrees) and oriantation coordinates that are all represented by seperate entities under the same device. These properties can directly be read from the device Our rules are that we only represent the state coming from the device api. We don't invent state. So this should not be an entity in Home Assistant but just custom events. So we can't accept this PR as is. And additionally it also fires events when detecting a tilt, or free fall drop. Sure you can achieve the same thing with an input boolean and 2 automations (one to turn it on at the vibration event and one to turn it off when the first automation was triggered more than 2 minutes ago). But the thing is that many (inexperianced) users that have a vibration sensor probably want to know if the sensor is vibrating or not, that is kind of the point of a vibration sensor. Now all those users will need to figure out how to achieve this and have an aditional 3 entities (1x input boolean, 2x automation, or be even smarter or write more complicated automation or something to do it in less entities) I made this PR mostly for other people that start with HomeAssistant and don't want to figure out how to get a simple "is it vibrating?" state based on events. (and because I also don't like having an aditional 3 entities that will clutter my HomeAssistant). I do get that we need to oblige by the standards rules set out for HomeAssisitant in order to have a uniform experiance accros diffrent manufactures devices. But I think this is beeing a bit to strict. Besides the vibration sensor itself is a battery powered zigbee device. Therefore to save battery it cannot sent states much faster than once a minute (what it does) to the gateway (this is also the case in many motion sensor). Therefore if you want to know the "state" of a battery powered vibration sensor, you will need to have the logic "if no new vibration message within x minutes, turn state to off". Off course the sensor could sent a "no vibration" signal to the gateway after 1 minute, but that would just be an additional message waisting battery (since the logic can also be build in the gateway) So basically if that logic is build in the gateway itself and HomeAssistant reads the state from the gateway it is fine. But if HomeAssistant uses the same logic in its code, it is not. I think that is pretty strict... If this logic would be implemented in the upstr
If value is not truthy, what are we achieving by calling turn on, reset preset mode ? Since there is no unset preset mode, we are accomplishing this by turning on the fan to its default on state which in turn makes the percentage slider active instead of the preset switches.
I recommend using another test name. Eg "Game Room". Good idea. That made my day Let s compute it on load so we can update the normalization in the future good call. Done Use square brackets. If the index is out of date, it's better to crash so we can fix it. If it happens we have a bug. Should we still save load it ? Was super useful for manual testing, but I don't think we need to keep it around. Will remove and push a test to verify it doesn't survive a save reload cycle
Use key references where possible. hey milanmeu - so i see people [using keys like this]( L13), but its black magic to me. could you point me to a list of available keys documentation about how it works? It is recommended to use [key references]( so that we only have to translate common words once in [Lokalise]( Developers docs: translation-placeholders Common keys The common keys list: [homeassistant strings.json]( These have the following format: [ key:common::JSON-PATH::JSON-PATH::THE-KEY ] Example: [ key:common::config flow::data::port ] will be converted to the value from [homeassistant strings.json]( Port . Component keys It is also possible to make a reference to a key in [homeassistant components rako strings.json]( diff-12b41571ac481723939fddc1f22894804eab5959adcaa7c4f56c5c2432fc8099). These have the following format: [ key:component::rako::JSON-PATH::JSON-PATH::key ] Example: [ key:component::rako::config::step::user::description ] will be converted to If pre-populated, Bridge was auto-discovered! More information It is possible to combine references with strings. Example: [ key:common::config flow::data::name ] (Optional) becomes Name (Optional) It is possible to combine references with references. Example: [ key:common::config flow::data::host ]:[ key:common::config flow::data::port ] becomes Host:Port It is not allowed to make a reference to a reference. ( It is not allowed to make a component reference to another integration. Suggestion - Port - [ key:common::config flow::data::port ] (Port) Choose what fits best or don't use a reference if none fits: - Host IP - [ key:common::config flow::data::host ] (Host) - Host IP - [ key:common::config flow::data::ip ] (IP Address) - Host IP - [ key:common::config flow::data::host ] or [ key:common::config flow::data::ip ] (Host or IP Address) This changes "bridge" to "device". If bridge fits better then no reference can be used. - No bridge found on the network - [ key:common::config flow::abort::no devices found ] (No device found on the network) Choose what fits best or don't use a reference if none fits: - Cannot connect to the Bridge - [ key:common::config flow::error::cannot connect ] (Failed to connect) - Cannot connect to the Bridge - [ key:common::config flow::error::cannot connect ] (Failed to connect to the Bridge) thanks, thats really helpful. i totally missed that whole part of the dev docs! Remove unused manifest fields. You can drop async setup since it does nothing. Fixed in pylint 2.7.3. from homeassistant.data entry flow import FlowResultDict "This is a cleaner approach and makes click-though actually useful." from homeassistant.core import HomeAssistant It was renamed in please rebase. ConfigType should be only used in async setup for config argument. For user input use just dict[str, Any] . I think light importing bridge is fine, let's guard it only in one direction. Move it to models.py . With that you won't have circular dependencies for this one. Also a bit better struct
What kind of date value is this? Times in the state attributes should be UTC. Fixed! I think we can use device class timestamp for this sensor. Then we should return the datetime as an isoformatted string. datetime.datetime.isoformat available-device-classes Please implement the device class property in the entity. And we don't need a custom icon when doing that. We don't set a custom icon when setting device class. The frontend should set a custom icon per device class.
This should be a separate sensor entity. See: discussion r492523276
Only trap the exceptions we expect. If the credentials are invalid do not raise ConfigEntryNotReady so it doesn't try to login over and over. Log an error and return False instead. In a future PR add reauthentication Since you already have typed exceptions, you can just use thoose If this cannot throw, move it outside of the try Remove this and let the CoordinatorEntity dictate availability since it will set available to False if the update fails Please convert any multi-line ternary s to if blocks Does the robot know which room of the house its in? If so add suggested area It does not Please convert any multi-line ternary s to if blocks Is this discoverable by dhcp ? It uses a WiFi module that is developed by Espressif, so unfortunately, I don't believe so. Patch the library here instead of manually modifying hass.data Use async call later and self.hub.coordinator.async request refresh Then you can use async fire time changed in the test instead of patching the constant We can likely do away with this and collapse it below as it doesn't save you any lines and returns the same data that was passed in This is really pushing the definition of a vacuum, but I don't have a better suggestion. bdraco, I agree it stretches the concept of "vacuum". It's more of a "cleaner" (dishwasher, washing machine, etc) or more generically an "appliance" (fridge, dryer, etc). Maybe even just "robot"? But that would be an entirely new platform and wasn't sure that I'm capable of thinking through all the possibilities at the moment, haha. Just saw that and pushed an update! Please only wrap the line that can raise in the try... except block. Use an else: block if needed. There will be a trailing space here if the entity type is an empty string. Patch the library instead. Patch the library method instead of our code. Please use hass.config entries.async unload instead. We don't want to interact with integration details in the tests. writing-tests-for-integrations
Maybe this is more readable? That definitely shows the intent a bit better This will always return an integer. Fixed by
Oops. Thanks! fixed in
The return value should be Optional . Add None as return value typing.
Why is this used as an abort reason? The Home Contron central unit reacts on the same zeroconf domain, but actually works completely different. There is an own integration for that. Ah. Does this end up being shown to the user in any way? If so (and maybe even it can't to future proof) then I'd expect this string to be a key to strings.json's config::abort::use devolo home control with an error that will indicate the user needs to do something different. I never saw that popping up to the user in my tests, but the usage was indeed unusual. I adapted it to the other abort methods. Nit: typo availablility fixed Typo: set availablility. Needs a find and replace to fix. fixed I don't know if the powers that be will accept excluding these two from coverage with a gold integration scale given "Tests for fetching data from the integration and controlling it" is one of that level's requirements. Agree, but I put all the data fetching into entity classes.py or did I get the requirement wrong? I haven't seen other integrations do it that way, but shrug . The ones I've seen all use the real entities and a mock for the backing Python module. You'll have to get clarification from someone who is a Member. That's still the way my approach works, I just concentrated the logic in a different file. This does not make big a difference now, but will hopefully lead to less code repetition with upcoming platforms and features. Please follow our standard test pattern. Each platform should be tested in a file named test PLATFORM.py . For gold or platinum level quality scale no module should be excluded from coverage. Since then, I feared, that I might got the instructions wrong. MartinHjelmare , could you maybe look at 49843? If I've done it right there, I know what to do here. Hi MartinHjelmare , I reworked the tests and they should follow the standard pattern now. The indentations starting at line 14 are all off. fixed I'm not sure if this can find the right string. cannot connect is in the error dictionary not the abort dictionary in strings.json. But the details of how these string lookups happen is beyond my expertise. I added cannot connect to the abort block of the strings.json, too. The exception handler will log the exception argument as log message at warning level the first time and then at debug on the retries. We want user flows to take precedence over discovery flows. We could just access self.context here and get the name title.
The details should be in the pypoint lib, not in Home Assistant. The format of the EVENTS dict is not ideal, and the integration will use unsupported device classes. Instead of making a copy of what's in the lib, we should import EVENTS from the lib and in the integration have a dict of what we want so use from the lib, in which each item defines either a proper device class (when HA defines a suitable one) or an icon (when it doesn't). e.g. I'm on it..
outdent this block Please remove commented code.
connection lost and connection closed are very similar, is there an opportunity to make these more DRY? Yes, I'll bring my towel and dry it up! Done.

If we have the specific event ids, do we need this? I included those filters for query optimization. AFAIK the in check is really inefficient. It compares each event id with each one in the list. The two checks above are executed beforehand and thus limit which event ids are even checked. Makes sense Maybe a subquery to get the event ids ? I want to limit the number of max comparisons. See discussion r577346531 for the detailed explanation Maybe a subquery to get the event ids ? I think a subquery wouldn't work here, since the states need to be deleted first. This shouldn't be possible. Did you find a row like this? No I haven't. That was one case where I wasn't sure if it is implied. Technically it would be possible since the schema does allow it ( event id doesn't have nullable false ). Personally I would like to leave it in if that's alright with you. Performance wise this shouldn't matter.
Please only wrap the line that can raise in the try... except block. Use an else: block if needed. Done If we return in the except blocks we can remove this check and the else: block and just set available to True in the normal flow. Thats a good observation! Then we can remove this too. I think showing availability is not bad, this way the user sees when the device is online offline. Or am I missing some implications of the attribute? This class is the adapter, ie not the entity. The available property needs to go in the Entity class. Right, sorry I missed that :)
We only use CONF constants for config keys. We should make an ATTR DOMAIN constant. fixed Same here. In that case, zha integration is cheating ;-) I'll adjust fixed
I think that we should either support a list of strings (current PR) or a dictionary, value Label . That way we can make it more user friendly That's a good point. The idea here, as proposed by thomasloven in the discussion is to provide a similar interface to the input select integration (that is, with the options property being an array of strings). Developers could develop the blueprint with references to the equivalent of the dictionary value, instead of having both the key and the value. User friendliness could be implemented by using good and descriptive values for options. Yeah, I disagree. The translation between human and machine readable strings is easy to do with Ah right, we did decide to keep it in line with the input X options. We should swap these around, first verify it's a list. That's true, I'm committing your suggestion. Thank you Paulus :)
This is OK as Python module is getting all values and those are the names of the keys. See diff-4169c9621f3234cc26bb9b014c9f47648e3b0fc9dc1d752b0a8047421d4dfc36 The unit of measurements look like the name. cpm seems to be the common unit for the radiation. The SI unit of the sound pressure level is dB. As we talking about A-rated values then it should be dB(A) if I'm not wrong. LAeq , LAmin and LAmax are not SI units. ok, thanks for letting me know. Please tell me if I can help in any way. The units of measurement needs to updated before we can merge it. hbitter could you advise in this? We need your expertise.
set cls and then do Not sure this is necessary, as I'll still be appending entities anyway? If I add this to the end, only the last class gets counted. Unless there's a better smarter way I'm missing here? :confused: Don't set an icon if you set a device class. Let the UI pick the icon if you set the device class Make a dict with all the status names Icon is here since there is no DEVICE CLASS, would be cleaner to pass None for the device class in case this gets refactored later Not needed since using DataUpdateCoordinator Is this still needed? Probably not if the coordinator handles all updates anyway? Aha gotcha :smiley cat: The timestamp should be isoformatted. datetime.datetime.isoformat We use None to represent unknown value.
No need for a default case, but you can keep the comment for clarity. Edit: In case you want to run all the tests, follow the steps here: manual-environment This will setup a separate venv for home assistant, so pip should be able to set everything up Done ... tests are working! I think we can do like this, then there's no need to update all cover implementations to call super(). init () : Wouldn't this be a class variable which will change from any object. If i toggle the cover in the kitchen to go up and then the cover in the livingroom which would go down and then the cover in the kitchen again and it would go up again (but i want it to go down) When the class variable is assigned to from an instance, self. is last toggle direction open True , that instance now has its own instance variable which has priority over the class variable. Yes, that is true then we should also not set the class variable. Which will only give us the IDE warning "Instance attribute is last toggle direction open defined outside init " This is not nice coding and that is why i did all the super. init () stuff. I think CoverEntity init is the right spot for this, the super. init () part is very annoying but im still open for suggestions. We should set the class variable, so all cover instances has a defined self. is last toggle direction open . When does your IDE complain, both when the class variable is there and when it isn't? I don't think this is a non-nice coding practice for Python, and we use this pattern already, for example in the base Entity class: L87-L100 IDE was complaining, solved it on my side. So it will be a class variable! This will add an unnecessary deferment of the toggle for integrations that are async friendly (and some tests are failing because of that). Add a helper function to avoid duplicating the logic, maybe something like: And call it like this: This will work very well, thank you for the detailed suggestion! Don't set it here, MQTT cover is not always optimistic. We should still rely on state updates either through received MQTT messages or through optimistic state updates after a service call. Then there is a Bug somewhere ... if i add this "live state" in the gui (and entity state) i can really see what the cover is doing. The "moving state" (opening and closing" is never set anywhere else If the entity is non-optimistic, i.e. it will respect (and expect) state updates to be received from the device over MQTT, the open opening closing closed states are set in state message received . If the entity is not optimistic there's no way to know what the device is doing, so the state will just be set to whatevver MQTT message was last sent, i.e. either STATE OPEN or STATE CLOSED . Ok i will check that, and why Shelly devices are not using this. The problem reported in 43949 is that a received position overwrites the state, so possibly related in case the Shellies report absolute position? You impress me again and again ... yes that seems to be th
This class should be renamed to BroadlinkThermostat, as the same PID is related to devices of different brands. See Here we need to restore the entity. See the logic of the other Broadlink platforms. Please have a look at the current implementation. I'am not sure how to do it, since I can't get the hvac mode or action from the state object. You can restore the state and access the attributes of the state object using state.attributes . All you need is inside this dictionary, except the HVAC MODE, which can be found in state.state . Snippet to see the attributes: If you store the attributes in a dictionary you can reduce the amount of logic significantly. So I tested my current setup regarding the restore and it is rock solid. Temps are correct and mode is correct. We need to add logic for HVAC MODE AUTO. Remove: Add: Add:
Put this before if event.event type in self.exclude t: since there is no need to check the filter or excludes for events we won't be recording.
We should not catch a broad exception here, as we don't know why this happens. Yet, raising a ConfigEntryNotReady here, will cause retries. OK, I removed this catch. This property is exactly the same as implemented in the inherited CoordinatorEntity , thus can be removed. We need to make sure the update succeeded here, before continuing: Case sensitivity of the email address might be an issue here? Nice catch. I changed it so it converts to lower case. Does this title need to be translatable? As in, is it called differently in other countries? Looking at the Android app source code, it looks like the name is different in other countries. Therefore I believe it should be translatable. What is the email address of the account has changed? That's a good point, but I'm not sure what to do about it because the email address is the unique id. How can I find the current entry and update it if the unique id is different? Right... I'm ok with it personally. Nevertheless, I'm going to leave this op for a second opinion from a fellow reviewer if you don't mind Nothing we can do. Also reauth would never pass :) Remove unused values (and maybe format the file using Prettier?) You're doing an await for each vehicle but it's inside a timeout block for 10 seconds. The odds of someone hitting this gets higher if they have more cars. We should do a timeout per request. Also, not sure about API rate limits, but if possible, try to get all vehicle statuses at once. If you don't want to ddos the API if someone has 100 cars but still provide maximum parallelism, you can use gather with concurrency from homeassistant.util.async . Something like this: That's a great point, I didn't consider this. I updated the code to use gather with concurrency . You've re-implemented the exact logic of [ self. abort if unique id configured ]( L898) so use that method instead. It looks like self. abort if unique id configured aborts with reason "already configured" . But I am doing reauth, so I need to abort with reason "reauth successful" in order to display the correct message to the user, right? Unless I'm missing something here. You're right. My bad. The form schema specifies these values as required and so they will always be there. Niiice This can't happen because you raise a ConfigEntryNotReady when the first update request fails. Can the vehicle name change dynamically? Or is this always the same? If it's always the same, you'll get slightly better performance by calculating the name and the unique ID in the constructor. You could take name part and unique id part in the base class and have each entity pass their unique part in the constructor. Actually, the vehicle name can change dynamically. The user can rename their vehicle in the MyMazda app at any time, which would cause the name returned by the API to be different. If the user initiates a config flow, we should not abort if a unique ID is configured. We do this so we can also override ignored entries. Home Assistant will
The items have already been copied to integer in the dict comprehension above. We should not accept None as percentage as it should be an integer. The caller should make sure to pass an integer. fixed Handle the None case here before calling set percentage .
Fixed in Better to move this check to the turn on method and tighten the parameter typing here. Fixed in If the preset mode is missing the fan mode will be None. Our typing doesn't match that. Fixed in Fixed in Do we need to use dict.get? In this case yes py def percentage(self) - Optional[int]: Fixed in py def preset mode(self) - Optional[str]: Fixed in
The implication here is that you want to be notified each time an issue is reported on the MQTT integration and help out to fix bugs and review PRs, is that your intention? Whichever the case, open a separate PR for that. Thanks for the feedback. That was indeed not my intention, but done because of an error suggesting I had to in the pre-commit hook. I'll remove myself from codeowners in a PR update. Same Same You need to update the default lambda when there is no template, see the failing CI test. Added in 2c70b7a87c.
Files in the translations folder should not be included in the PR, they will be automatically generated from Lokalise and strings.json Good to know. Should I remove the German translation as well? This file can be removed. It will be auto generated from strings.json and Lokalise Since this is a new component, importing YAML config is not needed But it is useful to configure the robot just by serial and secret. In the config flow it queries the vorwerk cloud to get this informations. For the normal end user the serial and secret way is overkill but it more stable. So my Idea was to have the simple way in the UI and the technical way in the config. why not have serial and secret way in config flow as well? Importing from YAML not needed since this is a new integration Are dshokouhi and Santobert planning to also be codeowners of this integration? If not we should remove them. I copied the neato component for switch.py, sensor.py and vacuum.py. But I will remove them. :) if you expect to get exceptions back from each of the calls, use return exceptions False in the asyncio.gather call, see asyncio.gather a new integration can only have one component (the additional ones need to then go into a seperate PR) Does this mean that every component should be in a separate integration or should other components added to this integration in a separate PR? I would use constants for these values, so with from homeassistant.components.vacuum import domain as vacuum domain or similar. Most of vacuum.py is a copy of the neato integration vacuum.py. For maintenance I would like to keep both version as near as possible. is the client id the same for all users? Yes it is can't this be tighter around where the actual errors can occur? Why not add a step for this, I don't think you want a user to change their emailadress between the code request and filling in the code? I will change it You can reuse existing strings for this, saves translation work. like "[ key:common::config flow::error::invalid auth ]" for the invalid auth field. maybe move to const? isn't self.robot.name not already a string? Once the other platforms are addd, this probably should move to a seperate class the implements dataupdatecoordinator. why not use the ACTIONS and other const lists to look up the clean state and status state and fill them directly? Not dynamic based on state? docked vs moving vs error? (not sure if there are mdi's for that, but would be fun!) Good Idee. I will add this in a later version. except if False is a valid value, you can just do if self. status state: I don't know if false is a valid value. The code is based on the neato component. Vorwerk robots are branded neato robots, with a different authentication. Can't this be async?
this can be just notification.value once the lib is bumped Can we change this now? done
In general, I think this PR looks really good. However, this part is confusing IMHO. Have a multi-select to checkboxes for things you DON'T want. IMHO, that is the wrong way around. frenck Thank you very much for the review! Just to confirm, before I rework this, you are suggesting that instead of an "effect hide list" we have an "effect show list"? That is, we offer a multi-select where a ticked box implies the effect IS visible. Is that what you mean? The reason I did it this way around was actually to handle the empty case easily -- if there's no value specified for the option at all, I want to show all effects, i.e. the default behavior is inclusive -- no values present no effects hidden. If I reverse it to effect show list, then I will need to also add special treatment for the option not being present at all, i.e. - Option not present at all (perhaps default, effect show list None): Show all effects. - Option present, but empty list (effect show list []): Show no effects. - Option present, but partial list: Show those effects only. So I think it's slightly more complicated to implement, but if you think that's clearer, more than happy to flip it around. Let me know. Thanks! I don't think it has to be difficult. You can still store the "hide" list (as it's easier to process in code). This is about what is presented to the user. So towards the user in the options, you can list all of them, based on the current effect list. On submit store in the entry, you can inverse that result and store the "hide" list. This way, you can keep almost all code logic and it will deal with new effects.
We no longer allow new integrations to use a platform config section or old integrations to do changes to the platform config section. See Please refactor this integration to have the config schema in the base integration module and the config yaml section under the top level integration domain key.
make value a param and get rid if kwargs. The schema will enforce this. Is this being used? If not, please remove. Inherit from SensorEntity too. class EbusSensor(EbusFieldEntity, SensorEntity): This line is untested. Mock async is online to return False . This line is not tested.
We don't do IO in the init of NukiBridge, there is no need for an executor L31-L45 When I try to remove the executor job I'm getting the following warning: Using the following code snippet: I've also needed to move the block inside the try-statement, since it tries to connect as soon as the token is set if I understand the code correctly: L75 We catch this error on validate input , you need to catch the Home Assistant Error exception Please adapt the error handling from scaffold: Added CannotConnect InvalidAuth This schema isn't used. We shouldn't log the config. Don't log the config. We should test the import step too. Set InvalidCredentialsException as side effect instead. Set RequestException as side effect instead. We should test the unknown error case too. We should test abort when an entry is already added. Add a MockConfigEntry to hass and then start the flow and assert that it aborts. L656
Please keep this. Please remove this. Add a warning log about deprecating configuration yaml. Please extract a function that does all the I O calls and returns the filtered list of cameras and schedule that function once on the executor. Please type the whole function if adding typing. Please only wrap the line that can raise in the try... except block. Use an else: block if needed. Why are we removing all these tests. We don't want to lose coverage. Please keep the tests as far as possible. The only tests that should be impacted by this change are the ones where more than one camera is configured. They should be refactored to use the config entry api setup. Please patch the integration setup function on all create entry results to avoid setting up the whole integration. See the scaffold script test template for example. Just return here after the log. Don't return False . A future improvement in another PR would be to add a reauth flow when authorization authentication fails. There's no need to save the password in hass.data. The password is available in the config entry data which is available where we need it. Move this to async setup entry . Then we can remove this whole function.
Typo: "recurrent"? "common" is the word I expected here. When converting to config flow this is usually replaced by an import of the configuration.yaml data into a config entry. Do you have an example of this? I don't really understand what you are meaning here. Do I have to create a config entry when loading the configuration.yaml? Yes, that's exactly right. You'll start the config flow at a special import step that will create a config entry based on the data from configuration.yaml. [This]( is an example in one of my open PRs of importing a configuration.yaml entry. See the setup function. It is for an integration configured at the top level of the configuration.yaml. Yours is configured as a platform so the details will be slightly different. Was this file manually edited instead of generated via the python3 -m script.translations develop automation? The missing space on this line is a suspicious hint of a manual edit. it was manually created yes, I've corrected it now . The same situation applies to the other two language JSON files. I'm not sure how or if those should be checked in without going through the real localization process. Does const.py need to be excluded? I would expect const.py to not have any executable lines the coverage validator would complain about. It is indeed not necessary, I think I've added it to be sure In reviewing config flow PRs I haven't seen one that requires a user confirmation step after the import. If you do it without a confirmation then the import can be done silently and without disrupting the user with missing entities when they upgrade HA. hmmm I would leave it like this. This way it is also a heads-up to the user, in case the old yaml config isn't removed. Each reboot they will get this discovery notification and an error message in the HA logging. ![image]( The Powers That Be will forbid a checkin with commented out code. Was still a work in progress :-) This isn't used here, and should move to async setup entry name seems to be a fixed value of "Qbittorrent" , why would we need to add this to hass data? Use the entry id as the index This is a proxy method, is this really useful? As in, we can just call the thing directly in the places that use it? It is also partly typed, please type methods fully. What would be the benefit of having this in a separate method? This is used in a single place. I think it would make the code more readable if this was just moved into the async setup entry method directly. Unneeded disable No longer used Missing return type Can we type this?
Should it raise? Not sure, maybe better to raise to entirely block the template from rendering? I think it's better to break it and not have it attach the trigger. Because triggers are a pain to debug. Changed to raise, it gets really noisy though: We should catch HomeAssistantError and then not print the stack trace. That will help :) Yeah, fixed in eeac975 We have a variable render helper that renders them 1 key at a time so that newer variables can reference already rendered ones. oh nevermind, this is the payload Can you document what limited does in the doc string. Done! Is it a good idea to return different types, especially since Template has an optimization if it's static and so has hardly any overhead? It's nice to break long strings around 88 characters.
The docstring says it will return a dictionary. The return value is a list and it's later also used to add to another list. Think the docstring is wrong? Since it's never changed, a tuple is fine.
in this case would it not be more fair to put the comfoair in auto fan mode? I understand that this is complicated. Alternative, I would set it to medium. (That is what my Auto defaults to in 95 of all cases) I agree, but since this is the existing behavior, I'm going to leave it as-is. The goal here is only to update to the new entity model. diff-68160764433f2567b3118c66f3a5c55dfefd01cfabb001d7e7311c30472d2e83L116-L117 We might want to include AWAY. It's not really off in this setting, but just the lowest setting. There is no way to turn of the ventilation unit, to avoid moist in the tubes. Although, this might also be correct. I'm not sure how to model the fan since it's not possible to turn it off. I initially used Away mode for off, since it's the lowest setting you can use (and it's really the equivalent for off, since on the official remote, the lowest setting is LOW.) I think what you did to map away to off makes sense in this case. Since in this case we aren't treating away as a speed and rather off , its not included in the speeds since its mapped to off I updated the comment to reflect that. LGTM I think the average user would probably say "I turn off the air exchanger when I'm away"
complete all? restore feels a bit weird as a name for this? As it might sound like it is restoring a state, but in reality, it is unchecking all boxes. uncomplete all? Might be more grammatically sound to rename this to incomplete instead of uncomplete. As I write this, Grammarly is trying to autocorrect my spelling :laughing: Same here and here You've written it here as incomplete so makes more sense to match it in the code We should add tests for these new services. Nothing seems to be checking this return value. It's better to call the services via the core service registry to test this method. Use hass.services.async call .
This is a known issue, you can disable this check on this specific point in the code using pylint:disable unused-import Also, please use relative import paths for imports from the same package: from homeassistant.components.rako.const - from .const
Why not pass the bare entry here? If you put the full entry into the context, you can remove the need to search and iterate for the entry in update entry . Good point. The docs are showcasing passing in entry.data . Being new to Python I was unsure whether it's safe to pass entry . I'll change this. Can this be None? In the current code flow, no. I'll remove it, so future misuse error case will fail loudly.
We have code to guard for None . Should this be? Guess this should also be
Any ideas on what can be done here? Please, don't combine different things in a single PR. Split this PR up in 2 Water heaters and thermostats share some of the same sensors. Trying to reduce the duplicate logic that would be required in order to provide all of the thermostats sensors. Maybe combine the two dicts into a single dict with a nested dict inside? Then we don't need to coordinate the keys of two dicts when adding or removing items. Good idea, done. Can the user change temperature in the auto mode? If so we should use HVAC MODE HEAT COOL . L12-L17 Yes they can. I'll update that. This instance is already saved as self.econet in the parent class. Not needed return. Can we calculate this list in init method and save it as an instance attribute? Makes sense Does this call handle a None argument for hvac mode to set parameter? It won't crash or anything, but it won't work. Ok, then we should check for that and raise a ValueError with an appropriate message as exception argument. Done. Please don't change this formatting. The wifi signal sensor should use device class signal strength. available-device-classes I'm not following here. The attribute is a single string. I think this is right? Needs to move out of the for loop though, no need to calculate it every time. Basically collect all of the possible attributes and then check each EcoNet device for that attribute. No, sensor[ATTR] will return a value which is just the string representing the attribute. Correct, and then on line 51 we check the equipment for that attribute using getattr. It does seems like someone broke with this change. I will need to try to test things locally. The attributes variable is then a list with just the attribute strings. Ie we can't do a tuple unpack like we do now.
If there were multiple stage scales, this key will always be 0. So this picks the last one. In that case why bother making a mapping at all? get stage scale() can return [] , so data["stageScale"] can be {} , so this can fail with a KeyError . Please make sure the function doesn't explode if there is no stageScale. Also the wrapping here gets a bit ugly. Maybe have a temporary variable to get the stageScale out of the coordinator, and reuse that. E.g.
Is this change related to the PR topic? I'd call this change since we're not calculating a difference, ie this value doesn't represent a subtraction. It's a relative change value (old new ).
I needed to add this sleep to let the add-on and server start before trying to get discovery info or connect to the server. makes sense, initializing the driver will take some time. Wouldn't it be safer to put this into a loop, trying to get it every second? That way you can limit it to e.g., 60 seconds (for slower devices), but also it reduces the wait time on faster devices. Sounds good! Should we instead try every 5 seconds 4 times ? That way on slower machines we give it some more breathing space? Yeah. I needed more than 5 seconds on the Odroid N2. Right, but there might be boards that are 12 seconds, in that case 15 seconds will also be checked. This part is a copy of the corresponding part in async step on supervisor . I can make a helper for this to make it more DRY, but wanted to wait for some feedback first in case we change other things in this flow. Why would we store that? To put the integration in control? If the add-on is uninstalled or modified in whatever way, the integration can fix restore it. (at least that was the original scope of the discussion we had for OZW about this). The old plan was to be able to update add-on configuration from the integration at a later stage, I believe. For updating the config, it shouldn't matter because we can just read the config out when we need to show it to the user. But making the integration the source of truth . Would be great if we could mark add-ons as system-managed and so can only be removed via config entry. But that's for future. Should we show a show progress step here? Also what if the add-on is already running ? We check for running add-on above in the previous step. Yeah, this part does take longer time now compared to the OpenZWave add-on. I can add a progress step here as well. Why store this on the instance ? I don't think we need to. Looks like legacy. We should prefer to import the hassio component and avoid using hass.components.X . The latter can't be typed and so typechecking would miss it if we change method signatures or remove them. Downside is that new helpers can't be tested in custom integrations without this. That's how I test on a real Supervisor host. This helper is already released so it's ok here. Why wouldn't that work? hass.components.hassio just does a from hass.components import hassio under the hood and wraps methods decorated with bind hass . If we add a new method in the hassio integration and copy that as a custom integration, the zwave js integration will look in the wrong directory if we're using normal top level imports. I got hit by this when developing the hassio add-on helpers for ozw. I think it's the loader module that populates the hass bound components and regular imports don't have the custom integration lookup logic that the loader has. Ah yes, that is correct. You can also connect your dev machine to a supervisor on another machine: integration-development
Not intended for this commit
How can this be such a big change? Oh I see that it is because of how we map speed values.
We can now select medium high Since Lutron seems to work with presets, should we implement preset mode ? All the values are actually speeds (no auto or smart) so preset mode isn't needed in this case. If self.percentage is 0 the first check will already be falsy. I'd do:
How does this validate uniqueness and the ability to connect? no, because i don't want to make people go turn on their cooker. All they need here is to copy-paste from the android app. I would expect different sensor types for my anova, like remaining time, current temperature, etc. so setting a device class would be my advice, even if it is just one at this time. Since anova can run for a long time and be offline for long stretches I would implement the RestoreEntity for this one so that the state is kept across HA reboots and it is not completely empty when you reboot HA while the anova is offline. we're talking to the firebase service in the cloud, not the device itself, so we should get an answer every time, even if the answer is that the device is offline. Indeed needs to move to the top of this file. this should run during setup, with a flow that if it is marked as offline it tries to reconnect with a long timeout, and when it if offline refresh more frequently. (and maybe also provide a service to connect if a user wants to do that now) We'll still get a response even it it's offline - because we're talking to anova's cloud service, not the device. at the very least, use except Exception as e and then log the e so that users have some idea of why it is going wrong, ideally catch different types of errors and give detailed info about what went wrong. alas the python module return only an Exception, not different except classes. as said, I would split out some of these across multiple sensors, for me at least current temp and remaining time. Probably adding a climate component in a next PR so that you can control the temp with all the existing visuals for that. And don't use set in the name of the function, becuase that would imply a setter which takes at least a value in the function call. something like update attr would make more sense. These aren't actually thrown in the config flow. Delete this file, it will be filled based on strings.json and translations can be added. I don't see this in the config flow, I presume it will come into that? This wil probably have to move to a different class that implements the dataupdatecoordinator! i can't see dataupdatecoordinator mentioned anywhere in the examples. Can you find it? ![image](
Please open an issue in our architecture repo for discussion and approval. changing-the-entity-model Thanks, filed with more context on why I added both force and mass . Hi MartinHjelmare, is there any process for getting the issue above reviewed? Please sort .
Pass dev reg and ent reg to this function and get area above. That way we only fetch those once. I think we should avoid the entity and device lookup twice too. That is why I thought it might be better to do as a refactor. Done.
We shouldn't interact with the platform details directly in the tests. Please use the core interfaces to set up and start the test. We need a fixture without supported sensor mapping and then assert that it results in a disabled entity. MartinHjelmare i was trying to think through a test like that but I couldn t think of a way of doing it because then would need to add a ZWaveDiscoverySchema in discovery that doesn t have a corisponding sensor mapping in binary sensor. And since I couldn t think of a real world example to add a ZWaveDiscoverySchema for I did this. I thought about removing the lines in question, but then you have indeterminate behavior when if there ever is a discovery scheme that doesn t have a coriaponding sensor mapping. This isn t a problem for the notification binary sensor due to the multiplicity of the command class notification values amd how those mappings are mapped. But for the property binary sensor, the property name either matches or it doesn t. Or maybe I m missing something obvious. If you have some idea how to test the case differently suggestions please cuz I racked my brain for a while MartinHjelmare actuallly....i may have thought of a way to change the code to make the test not necessary since the code path should be imposible anyway MartinHjelmare that should do it. refactor makes it so there is no untested code paths and we dont need to invent a scenario where there is a ZWaveDiscoverySchema in discovery.py with platform of binary sensor and hint of property without a corresponding PropertySensorMapping in binary sensory.py What does this result in? An empty dict? yeah. it was the only way i could get all the linting tests to pass and get code coverage and not invent some bogus ZWaveDiscoverySchema without a corresponding PropertySensorMapping. Ok.
You can remove async setup since It seems that all communication happens over HTTP, are you sure you need to disable SSL verify? L28-L30 I thought I have to disable SSL verify on http only request but indeed, it's nonsense In the future, it would be good to implement a reauth flow, where you throw ConfigEntryAuthFailed on EcoDevicesInvalidAuthError . Example: See remark above. If a user needs to configure this, it should be part of the OptionsFlow imo. options-support Are there use cases where a user needs wants to configure this? I don't think that you need to pass the DOMAIN as well, I assumed that Config Flows always had the domain context. Would be good if someone else could verify this. L999 You don't need to store and save this in entry, just self. abort if unique id configured() is enough. This function will do the same check. L977 For what are you using the update listener? You could remove the dependencies as well, since it is empty. If you set a device class (power), you are not allowed to set an icon. from homeassistant.const For what are these values required? Shouldn't they be separate sensor entities if this is important. They are plenty values available, and each person are not interested by all of them, so I choosed to only create one sensor on the main value and put all others in attributes, to avoid getting a lot of sensor, but maybe it's not the good solution ? Please remove this translation, initial PR's should only have strings.json and en.json for testing. Other languages will be added later via Lokalize :). Why can people set the name? This is something that they can override in the entity registry of HA as well. I am not familiar enough with this device, but is the unit of measurement not standardized? Or is this to support edge cases? They should be able to override this as well via customize . Yes it depends on what you connect on the inputs. As it's "standard" to have to customize the input, isn't it better to customize at the installation than go to advanced customize section ? For the Name, it's easily customizable, but not for device class or unit
Out of scope for this PR, but we can make self. state a boolean. It is compared to STATE ON inside is on property.
Please don't access integration details in the test. We don't seem to need the device. We have the config entry available and can check the entry data if needed. I improved the tests
async get entry may return None . We may need to assert the entry for typing reasons. We already check it exists on the line above. Yes, I was thinking that mypy might complain about it since it can't follow that. Should we use an f-string instead of string concatenation? No. That looks really bad. Then maybe break up the expression? Nevermind. Let's keep this. This is just testing the websocket api. Right. The function itself is tested in the library. Too late
We should add lock to the service name. Now it's registered under zwave js domain but it's not clear it's lock specific. MartinHjelmare do you agree? maybe set lock usercode and clear lock usercode then? Yes. What's the type error we ignore here? homeassistant components zwave js lock.py:78: error: Call to untyped function "async register entity service" of "EntityPlatform" in typed context [no-untyped-call] Found 1 error in 1 file (checked 1 source file)
Remove the subscription in async unload entry . Something like this: L394-L395 Call async scan update instead What's the now parameter for? If intentionally unused, maybe name it or now . Parameter appears to be require by async track time interval for the callback. I'll rename it to How come this is not covered by tests? Fixed. This code is duplicated in async unload entry , do the cleanup in a common helper. Actually, it's not really necessary to do a thorough shutdown, unless it's somehow important mandatory for Gree. The idea is to make sure that the discovery process isn't left around if there is any case where shutdown can be called, and HomeAssistant keeps running. But I am unsure if this is possible, given than do you think it should still be removed? Do you mean you want to ensure the async track time interval stops? Or does the gree discovery have some thread or process in the background which needs to be killed? Neither, discovery does not require a thread, and the event is unsubscribed in the async unload entry which I think covers the needed cases. The only thing this cleans up are the following lines: There are no side effects of not cleaning it up, other than having the object persist in memory. Actually I don't think this should be here at all, cleanup is handled in async unload entry anyway async unload entry is not called at shutdown, but you don't really need to worry about cleaning up at shutdown unless it: - Is somehow required by the library to do a clean exit - Not cleaning up prevents Home Assistant from shutting down, for example running threads Ok, I removed the event, it is unnecessary What's this for? Relic from an older refactor that removed wrappers in this bridge, this will be removed as it is unused. How come you need to del the object, is it not enough to pop it from the dict? Pop would be fine, habits from other languages kicking in. Move this to async setup entry in init .py Same needed in switch.py, done.
Raise a ValueError with the message as exception argument, instead. Stale comment. Stale service data. Ah geez, I'm blind lol
Doesn't need timeout if it doesn't make any connection. Removed Why even try connecting? The odds of it being online are so small and it halts setup of Home Assistant for AIOSHELLY DEVICE TIMEOUT SEC seconds. When first adding a device we reach here from config flow after the user was asked to wake up the device This part is refactored, based on sleep period : 0, regular device setup None or device not in registry, wait for device and finish setup. else sleeping device setup This name should be device wrapper , it doesn't wrap the coap context but a device? we have a rest wrapper also, do you think it makes more sense to call this device wrapper ? Changed to device wrapper to be aligned with the name of the class. We shouldn't do this with a migration. We can just do this in async setup entry if we see that the key is not there. But I think that we should just skip migration and only say that battery devices are supported after this PR and let people repair their old ones ? Since the user needs to wake up the device anyhow first time after this PR, I think your approach is better, we should update the docs that sleeping devices which added before HA with this PR should be removed and added again, what do you think? Migration removed, will only add data if it is missing If this is for initialization, do it in the constructor? Seems weird to do it inside the generic updatae handler. Removed from here will restore inside entity This seems weird. Why wouldn't we do it the other way around - when a sensor entity is first initialized, it will calculate this info. That way we don't have to pre-calculate it for everything. There is now a really weird reliance: Entity relies on Device Wrapper Device Wrapper needs entity storage in hass.data Move this all to async added to hass lifecycle callback for the entity in case the entity belongs to a sleepy device. Removed, not using anymore, restoring inside entity and not needing the sensors list Why would attribute value be STATE ON and not just a boolean ? When this is restored from async get last state the restored state is on or off Migrations are really tough, as it prevents users from downgrading and should be avoided as much as possible. Try to just do it inside async setup entry . async setup entry attribute entities should be split in two. This if-statement already makes it have two different implementations anyway. Isn't this always a restored device because this is the SleepingBlockAttributeEntity? Revised the logic here, removed restored device , logic based on block is None Don't do this. This should already be done inside async update entry. This can't work. We should translate the last state.state to True False. This needs to be a boolean value, which it's not with current set last state implementation. I wonder if we can change this around to allow faster comparison:
Im planning on flattening the data structure so please look for the domain instead :), or you skip one level of evaluation here for speeds sake? Will change it to if not entry.data as it was there to make sure we don't lookup keys that don't exist for ignored flows Shouldnt we make sure its the correct domain? This could fail if it looks at anything other than unifi? Look at using self.async entries(UNIFI DOMAIN) async current entries should only return entries for the unifi domain if I'm ready in it right? You're right! Since the unifi cloud key is now also on UniFi OS can that also be discovered? It doesn't seem to be available via SSDP If UniFi cloud key or controller later also can be discovered using SSDP we take the decision to only discover once is the logical thing here The goal here was to prevent discovery for existing entries since they won't have a unique id Ok! I've been thinking about creating a way to set the unique id; each site has a unique ID which would be applicable and I think is a good value. But its still relevant to offer a way to disable discovery. Worst case we always need to derive the MAC the controller runs on Discussed on discord to keep it mac for now This is not used Removed If voluptuous and gui doesn't care it is fine to leave it as is default None should be fine here for vol
Should we empty the password field? Will need to fix the tests as well

Does it make sense to make this a new integration and potentially load it in default config instead? That was my initial thought as well, but then I leaned towards putting it into the core directly, since it felt quite integral. Any good name ideas for the integration? alert is already taken. We should not use persistent notifications for this purpose. Instead, we should implement this with WebSockets that the frontend can use like it was done in this attempt
This file should not be here. Please remove this file. Done Limit the addition of a new integration to a single platform. Either add climate or sensor, not both. Sorry for my lack of knowledge.. Does that mean one PR per platform even if they belong to the same component? Currently, this integration provides 2 platforms: climate and sensor . It should only provide 1 of those in the initial PR. More platforms can be added in subsequently PRs. The reason is that we try to keep PRs as small as possible, in order to be able to move forward quicker. Translations are handled via Lokalise. Additional languages should not be provided. Please remove this file. This used to be a custom component but I decided to work a bit more and make it available to the core. Thank you for your help! frenck Let me ask you a question... I would like to notify the user that the integration might need to be reloaded if the bluetooth adapter fails. Until now, in my custom component I used a logging message. What would be the correct approach here? Is it enough to use the logs? Apart from that, do logging messages have to be lokalised? I am not sure as all the logs seem written in English even if my instance is configured in Spanish. Don't skip files for Pylint There are available in the Home Assistant core constants. Use those instead I am not sure if this is allowed, since you don't specify all properties yourselves. Are you sure it only contains [valid device properties]( device-properties)? Best would be to do it as the example below, where you can always pull the info from self.dev info . See device-properties No, the properties may no be fully aligned. When I reviewed what was being done with them I just thought it would do no harm to let HA list only those that match. I will change it to the supported properties as suggested. By default, the log severity level is warning. (see [logger]( Do you only want this message to show up for users that change the logger settings? And how often does this happen? Is this just for debugging rare cases, or is this something that happens often? You are right, this message should be in the default severity level. This is a new integration and thus YAML flow can't be used, see [ADR-0010]( for more context. I see you already marked it a deprecated, what is the reason? Why do you import config flow? (and why do you disable F401) Does this mean that the integration couldn't be setup? Is this temporary or do you need to reconfigure the integration? You might want to raise PlatformNotReady here, to retry setting up the integration. Seems unused? Is it always set? Why set it to MIN TEMP instead of None, when no target temperature is set? Why set it to MIN TEMP when no temperature is known? Why not set it to None? Same remark as above about severity level. nit: but would be nice to remove some of the extra whitespace enters here Not required This is not the documentation for the correct domain I don't have experience with bluetooth and HA, bu
There should not be a README file here. Please remove this file. We no longer accept YAML configuration for integrations that connect to devices or services. Instead, a configuration flow via the UI should be used. For more information about this decision see: - ADR-0007: decision - ADR-0010: decision To get started on the integration configuration, see our developer documentation:
This moved to the manifest Use the self. attr unique id instance attribute. entity-class-or-instance-attributes You can convert the other properties in a future PR. I think this is not used. You can call hass.config entries.flow.async init in async setup platform (in binary sensor.py) so you don't need to search the config of every HA installations even the ones without workday. Add this to binary sensor.py: PR shouldn't have commented out code.
We don't need to inherit TestCase. I get a 'cannot collect class because it has a init constructor' warning when I remove the test class. Is that acceptable? Rename the class and don't prefix it with Test . Please rename this test module to test init.py .
You are YashYKhatri ? Also does ThomasBLarsen consent to also being a code owner? Yes, My github name is YashYKhatri and ThomasBLarsen is also the code owner. Same as above. Should be your GitHub handle. I don't believe this is needed as we are using a config flow with no extra config here. Take a look at the-minimum Two units of measurement? Can the lib API return the correct value for this? timmo001 "DKK kWh" is the unit of measurement which is static for now and therefore I hardcoded it. Why is the unique id hardcoded? Thanks for pointing it out. I am making it dynamic based on the user's meter selection. Is this call not blocking io? Should this be async or using the hass executor? See calling-sync-functions-from-async. Currently, we are not using async calls in the initial release and planning to use them in the future release. Best would be to catch all errors, and eventually have a broad exception returning an unknown error . Thanks for the suggestion. Will replace InvalidToken exception with Exception to cover all the errors and return unknown error . You don't need to replace this exception, best would to catch InvalidToken and add a broad except all for other expections. Have a look at other ConfigFlows. I tried to add Broad exception, but the pipeline is failing due to that broad exception. Can you please help me out here? Have a look at the Shelly integration for example; L93. You need to disable pylint for this line, since it is allowed for this usecase. Afer login, is there no emailaddress or other userid which can be used to identify this entity? Currently, we don't have any other identity of a user except the metering point and price code. It looks like you are setting priceCode yourselves, why not use price code ? Python mainly uses snake case for variables. Are you sure you match all items of this list? silver- F0 9F A5 88. Not at moment. I changed the scale to "internal" and will improve the quality in the next version. Integrations which are part of Home Assistant are not rated but marked as internal. You can not use internal for this integration. Best would be to remove the quality scale from this PR for now. What if users want to use more metering id's? Is that (currently) not supported, since they also can only add one single Barry integration. Thanks for the concern but In the initial release of our brand in Home Assistant, we are supporting one metering point per customer. And most of our customers have a single metering point at the moment. However, We are planning to support multiple meters per customer in the next version. I don't think you are allowed to change this, especially not without an approved [architecture]( issue. I will remove this line because it is not required to be present in this file in the next commit. Thanks. After removing this line from the file, hassfest is throwing an error from the pipeline. However, when I keep above line in the file, It works. Can you please help to fix this issue? This is a 
Can we include the expected call arguments in the parameters so we can avoid the logic in the test? Why do we compare with ? Checks if the content of expected client args is a subset of mock client.call args.kwargs , as the latter includes also arguments unrelated to the SSL behaviour being tested
create exposures after await hass.data[DOMAIN].start() so on failed connections the callbacks don't try to send telegrams to a non existing KNXIPInterface The iteration of self.config[DOMAIN][CONF KNX EXPOSE] is now done in async setup() like all other platforms. The rest moved to expose.py module. I have removed the callback decorator there as I'm not sure why this is needed. If the function is every called from from async run job or async run hass job or async track state change event etc, and isn't marked with callback it will run in the executor instead of the event loop. this moved to expose.py also moved to expose.py the shutdown method is new now. It removes callbacks. Same for KNXExposeTime. It's called when using remove from the new service. If the function is every called from from async run job or async run hass job or async track state change event etc, and isn't marked with callback it will run in the executor instead of the event loop. Would be slightly cleaner if you reverse the condition, return and then outdent Can we raise an exception that will be visible in the UI instead ? How is this done best? The service itself is intended for blueprint use. Should it be visible in UI nevertheless? Wrap it in HomeAssistantError with a human readable error Thanks! Done. Duplicate code The yaml schema has recently received an update. Please check core platforms eg fan , light , etc for the new options. Do you mean this? Or the yaml style guide? I guess this would be an extra PR to homeassistant.io then? Its for the services.yaml file Ah now I see. I have tried to stick to these examples, but on my test instance no different view is rendered, except that I deleted "Optional" in the description thinking the "required" key would be shown. Is this still work in progress? As this now uses selectors, only fields with a selector are shown. Payload does not have a selector now, thus hidden. What that on purpose? Why not add an object selector instead? There is also an option to mark it advanced this will hide it by default, unless in advanced mode. It expects int, string or a list of ints ( 256) so I guess object would be the way to go. Advanced would not make sense as it is a required field. Right, well in that case, if required, this schema is now problematic, so that needs fixing. required: false is the default. There is no need to specify defaults. It's a risk to use a config schema as base for a service schema. The constants are different and may change independently. The intention was that if it was changed in one place (the config schema) the change is automatically applied to the service - as the service calls the exact same functions as the config create knx exposure(self.hass, self.xknx, call.data) from service and create knx exposure(hass, hass.data[DOMAIN].xknx, expose config) from config Yes, but that only works safely if the constants are the same, which they aren't. I don't understand. Which constants differ? If the address is require
async get device can return None . Probably add a check here first. We should set the return value of the client async send command method which we've already patched. L139-L145 What's the proper way to do that? I tried a couple times to patch the return value of async send command but never could get it to work. Try: The solution always ends up being easier than I expected Looks like the copy paste went a bit sideways.
We can remove the config schema here since there's no yaml config now at this level. We don't need this function at the moment but we'll need it to be able to load the notify platform since the notify integration doesn't support config entry forwarding. We don't need this pylint disable anymore. It's been fixed upstream. We don't end logging messages with period. Please merge the logs so we don't log more than needed. Invert this check and raise if true. Then we can outdent below. Please only wrap the line that can raise in the try...except block. Use an else: block if needed. This nesting doesn't seem needed. Add further except cases as needed instead in the same try context. This isn't used. Please type functions completely or not at all. We're not returning False anywhere. We also don't seem to check this return value in the caller. We don't need to prefix with anything integration domain specific. The config entries are aware of the config entry domain Please remove the empty items. Please inherit from SensorEntity imported from the sensor integration instead. This sounds like it should be a binary sensor instead. We don't need to prefix with the integration domain or the platform domain. The entity registry is aware of both. Is the user id less unique or stable than the email? Maybe we should use the user id as unique id instead of the email? We're missing error strings. This file is the source of truth. The default English translation will be generated based on this file. Is it a device or account? Please add a link to a changelog or GitHub commit compare view for the version bump in the PR description. Please patch the library code and not our code in the config flow. Don't test this separately. Test it as part of the flow.

We no longer accept YAML configuration for integrations that connect to devices or services. Instead, a configuration flow via the UI should be used. For more information about this decision see: - ADR-0007: decision - ADR-0010: decision To get started on the integration configuration, see our developer documentation: Yes I know... may we have an exception for this? I mean it is just 1 missing parameter (which should have been a parameter from the start, I don't know why it's the only one hard-coded). Developing a UI would be a much greater effort. Please don't make me use a patch for this tiny thing Thank you ADR-0010 for the UI might be much for TTS at this point indeed in general. MartinHjelmare Pointed out that TTS and config entries don't work together yet. This means ADR-0010 does not apply to this PR. However, ADR-0007 does, which does need to be implemented first. However, ADR-0007 does, which does need to be implemented first. I'm sorry I don't think I can put effort into that at the moment :-( I guess I'll use my patch on my istance for now. Alright, I guess in that case we close this PR until a later moment. Nevertheless, thanks for willing to contribute
small copy paste leftover... replace with: return self.info.primary value.value 3 replace with: return self.info.primary value.value 1 replace with: return self.info.primary value.value 0 We should try to name the fixture after the device name and not the type of device. Then we know more specifically what device it is. That's the plan, unfortunately the dump wasn't complete. Is leaving the fixture name generic ok? "window cover" or should I adjust that as well? Please use my suggestion and rename the file. There's no other case, so we can remove this. We can simplify: I don't think it's correct to type the kwargs as int. Stale docstring. This should return a boolean. If mypy complains we can copy the expression to that explicitly with bool . Yup mypy gives me: Returning Any from function declared to return "bool" Please reset the mock in between service calls. That makes it easier to reason about the calls. MartinHjelmare should I adjust the name here to chain actuator zws12 state ? Yes, please. and chain actuator zws12 here? Yes, please.
Is the mac address formatting going to be the same between sources? from homeassistant.helpers.device registry import format mac .. but that doesn't cover existing ones I will verify this between all sources Standardised MAC according to format mac in separate PR
This almost worked with no changes, but device tracker has standardized on host name and unifi uses hostname We're in sync context. We should make the context async if we need to call an async api. Good catch. Will make a stop and async stop and call the right way based on which one exists. Currently the only job we have is a task. Not sure if there are other plans for the future. This could block. Its happening in the executor now We should make these attributes device tracker entity properties if they become interfaces to other integrations. done
If we don't specify the dict item types we can use dict as type. Can we use asdict ? dataclasses.asdict We're overwriting the client parameter. Maybe choose a different variable name? Remove before merge. Put require admin after async response. This is exposing the raw Z-Wave JS data. This means that we don't really know what data the frontend is using. Maybe better to just include the controller properties we think we might need? Actually, this is not async. There is no await This one is so small, we could embed the fixture just here in the file.
Is this check even needed? I realize it was there before this PR, but is it required for setting up the entities? If a failed update only leads to unavailable data, then it can be removed. Probably not. I'd leave it as is for this PR. Consider placing the separate api calls into separate methods and then create separate UpdateCoordinators. This way a failed update in one api call will not prevent data getting unavailable for the other api call. Done Since we lost the comments on the previous review, and so I can remember, the currently existing entity is the 3hourly one? It's written right in the description above, ignore this then. Looks like you may also be to cover this line in the tests to fulfill the coverage requirement. Didn't you add a test for this in the previous iteration? I think it got lost when you amended the last commit. Do you think it's worth using asyncio.gather() to run them in parallel? Done Pretty sure you only need one coordinator here. You can use use 3hourly to pick the correct one. The same applies to weather.py Done
We have a device class for binary battery sensors: L25-L26 done Is this case possible? We don't seem to have this case in the discovery items added. No, it was there for testing discovery scenarios. I'll remove it. done Please name the fixture file after the device name and not after what we want to test. done What do we want to do here? leftover logging, is now removed Is this case just when we haven't added this sensor type yet to the mapping? yeah, it's impossible to predict all possible mappings. I did my best to map the most common used. btw: I'll add a quick adjustment to disable sensors for which we do not have a mapping as those are considered to be advanced. checked in that fix Should these be defined in the library instead of the integration? Not sure, these are only the values I used to create the mappings, not a full complete list. It doesn't hurt though to create an enum in the lib. I think we can merge this as-is and if we get a more complete list move them to the lib
Is this needed? is it not possible to let the entry start and just let them end up being unavailable based on coordinator being unavailable? This is actually taken from OpenWeatherMap, but I ll look into it: L59 elupus This should be solved with Sort of yes. But now you will keep on logging an error on each failed request. Filling the log (also you can remove some checks for the return value of town None). You should either catch your new exception and rethrow a UpdateFailed exception. Or base the exception on UpdateFailed. That way the update coordinator will only log once on failure. See: L172 elupus done in You might as well make this a weather coordinator since you have your own baseclass. This is also based on OpenWeatherMap, but I'll look into it: L18 Just let the timeout error propagate here. The standard handling is to log an error and set last update success False. This is a minor nit. I would pass in the timestamp to avoid fetching it more than once. Makes it a bit more deterministic. As above Do you need to add senor.py here. You do seem to have tests for it. If I remember correctly there were code coverage errors when I didn't add it. Is there a reason that the forecast mode should be selected in configuration rather than to setup up both kinds of data and allowing the user to disable enable entities? It is my understanding that the latter is preferred unless there is a need due to api call limits, etc. See [ADR0003]( If you expose all data in one config entry, you can have one update coordinator for each api call type. I think for latitude and longitude should always have values even if the user does not supply since there is a default supplied? If so, you should not use .get method. Here there is a default supplied for the comment above. Similar to comment above, is there a reason to allow selecting the data during configuration? This mode is also an option below, I think it should be one or the other if it is needed at all. I think you don't supply the translations, but only the strings.json . Same as above, only supply strings.json . This is already done above. Please use a list comprehension instead of filter lambda. Can you inherit from CoordinatorEntity, which might clean up this code a bit? See L233 Why aren't we inheriting CoordinatorEntity ? Mode should only be part of the options flow. Optional items not related specifically with the connection go there. None is the default value returned if the key is missing in the dict. Always start with hass in the signature if hass is present in the signature. Please only wrap the line that can raise in the try... except block. This class is large with a lot of repetition. Does it make sense to have a single get value or maybe have a few cases like get numeric value ? Why is the upstream library not supplying numeric values for numeric data? This seems more ideal, and would eliminate the majority need to separate the numeric data from non-numeric data entirely. We wouldn't need to chec
Is it OK to set unique id here? Not in that manner i think. You need to update the entry. Also this should be set during the normal config flow. No just remove this, the entry.unique id will automattically be set by the config flow. (When you use self.async set unique id) Here is where I get this error every time I use options flow to add or remove a zone and in the async unload unit test: Even worse, adding and removing zones leaves behind "ghost" entities like "avr", "avr1", "avr2" etc that will show as "unavailable" but don't seem to go away until HA restart. The code is copied from DenonAVR but I must have misunderstood something. The twice is because you remove the "main" zone on line 115 with entity registry.async remove(zone.entity id) and again when you call return await hass.config entries.async forward entry unload on line 119. Just remove CONF ZONE1 from the list on line 111. Besides I would first do the await hass.config entries.async forward entry unload , and then remove the left over aditional zones. So move lines 119-121 to 108 If it then still leaves "ghost" entities, there is probably something wrong with the unique id matching. easiest way is to add a LOGGER.error() with the zone.unique id on line 113 and then just look in the log how the unique id's look like and if they match with your f"{entry.unique id}-{name}" Is this a good way to set unique id for the config flow? Yes, but see previous comment, unique id schould be the same for user and ssdp. Why do you use the raise on progress False ? I'd like to make this dynamic to the number of the zones that the receiver actually supports - so it doesn't show Zone3 and Zone4 for my receiver that only has Main and Zone2, for example. Not sure how that could be done. I will probably redo this in the dependency. Just have a list of valid zones in the dependency so I don't have to do this fiddly stuff in init and here Set defaults in dependency to avoid these magic numbers add const Better naming - add to options flow? The name can automatically be changed by the user when a unique id is provided. So no option needed. Not needed since a user can change the name when a unique id is set (which is done) Can this be dynamic along with the options flow? I would not know how I would just skip this for a new integration. I agree, config import is not needed since YAML is depricated anyway I would split this out by making a new function async step connect in which the connection is made. And then go from the async step user and async step ssdp to the async step connect. That makes it a bit easier to follow I don't think config entries.HANDLERS.register(DOMAIN) is actually needed Schould this state "Heos"? Why do we save this in the hass.data? We can use class variables of the AVReceiverFlowHandler class for this right? I think the self.async set unique id already takes care of this, so this is not needed I think It is important to make sure the unique id is always the same for the same device.
We no longer accept YAML configuration for integrations that connect to devices or services. Instead, a configuration flow via the UI should be used. For more information about this decision see: - ADR-0007: decision - ADR-0010: decision To get started on the integration configuration, see our developer documentation:
you might want to change this one to snake case ;-) .value can be None in some conditions. The light platform caches this value in the init function. Should that be done for this as well? Is there guidance on when to cache or not-cache? It doesn't really matter. I did that because light platform has a bunch of values to watch Please name the fixture file after the device so we keep track of what fixtures we have. Remember to remove print before merge. We should exercise the state update also by emitting an event after the initial entity set up. The fixture should return the node instance. Should probably say "test the Z-Wave JS switch platform" Good catch! Opened a PR to fix 45076
that's a lot of Roomba's I don't think there's any backwards compatibility needed here. The user step is enough. Urls should be put in description placeholders so the translation doesn't translate those.
The weather entity only requires condition and temperature according to the dev docs [here]( Is there a reason that Humidity is required here? just legacy from my belly button configuration (fixed) Looks like it's not clear: This would have to be changed to config.get if humidity is made optional fixed Currently humidity is required. We can swap it back if that changes.
I'd rename this to sensor type . Name is most often user configurable so it's easy to misunderstand it. That's not what this is. Can we inherit from CoordinatorEntity? I think so, should I do the same to the weather platform in a separate PR? Yes, please. Makes sense. There may be room to simplify the duplication across platforms at the same time. Please collect all entities first and then make a single call to async add entities .
No longer needed
Debug level please. Ahh good spot, updated Please set the state attribute keys explicitly. We want to see what they are and their formatting. We can use a constant dict to map between state attribute keys and device data keys. MartinHjelmare thank you Sorry just to check I follow... You mean instead of looping through the dict received to set whatever is in there, actually map each attribute? so: offset celsius self. tado.data["device"][self. device id]["TEMP OFFSET"]["celsius"] but with stick them in a dict map const to loop through? Assuming I got that right, will add Just trying to update the tests as the offset mock obviously isn't there, so will do that at the same time. Ahh yeah nice.. need to check the device id exists too, for the tests, as I think they are failing when no mock response exists so the entity ends up not existing So will update with your suggestion This shouldn't be needed as the template will be rendered before reaching the service schema. Ahh ok I'll revert that commit (googles 'how to revert a commit' ), apologies... still learning the process Its not, template doesn't work.. It passes the whole template as a string.. This code I wrote works to render that as a value, no ideas why it doesn't work I expected, like you said, HA would render it before passing to the service.... Ok I reverted that commit, seems to have worked. Back on commit b54baf7f31 now How are you testing the template and service? I used Developer Tools to call the service with a template. When it didn't work I increased output to the logs to see what was happening. I didn't need a template, hence not writing it in the first place, one of the guys on the feature request pointed out it didn't work so I tested it then and found that to be true, it didn't. I kinda felt like it should so looked into it. Happy for this PR to go in without now I reverted the code. Maybe one for the future? Feel free to point me at any docs or example code etc if you agree we should have it.. Template rendering doesn't work in the developer tools services section. You need to add an automation with a template in the action part and then trigger the automation. Templates are a feature of automations and scripts, not of services. Hey, sorry for delay, finally got round to testing that. Yeah it works, you were right (I know you know that ) Is there anything else to do? The tests failed for some reason when I reverted the commit, looked like a timeout. Is there a way to kick them off again? I've restarted CI. Let's see if it passes this time. Looks like we don't need this method. We only call it from a single place. We can inline the offset update inside async update zone data . Yeah fair point, can 't remember why I thought a dedicated method was needed, updated changed
Please open an architecture issue first for discussion and approval. changing-the-entity-model
Shouldn't this be the very first guard in this method? Yes it should. It doesn't appear that set humidifier mode is set to deal with the mode being optional. Should this be required? yes, changed. The humidifier features should be exposed as a humidifier entity instead. Let me know if this looks OK. Please sort . Would be good to use the list of modes when specifying valid modes. The humidity is already validated by the service schema. Please start all tests with the core interfaces and don't interact with integration details. writing-tests-for-integrations Set up the integration and let it load the humidifier platform and let it add an entity. Then assert the state of the entity via the core state machine. Test the services via the service registry. We don't need to change this.
This will also put sensitive data in the logs (if provided on the command line) which we should not. So don't log the message basically? Well, we should not log the actually executed command in this case I would say. Oh, hm. So I basically just borrowed what shell command and command line sensor were already doing. I can change it to just log stdout and stderr? I suppose the command isn't really necessary it just seemed helpful to the person trying to debug to link the command to the output right in the message. Also its not like this is logged always, only when debugging is specifically turned on. Anyway I can guess I can just drop this line and log out the ID with stdout and stderr, the developer will then have to remember or look up the command. Should it also be removed from shell command and command line sensor then? You can still log messages? The command seems less important and part of the risk involved. For reference: L179 L100 Those should not happen, imho, should not log either. But that is out of scope for this PR. Ok understood. Yea fixing them would be a separate pr I just wanted to confirm that they were bugs. Will adjust the pr to not log the command or message The command is also logged on error by this component (and pretty much every component in this integration). Is that also a problem? [See here]( L59): Ok updated to no longer log the actual command or message in debug logs. Let me know if the error level messages are a problem (although they are pre-existing so that might be a separate bug). Name is optional, thus doesn't have to be set. Hm right. And I guess if its not set then there's no way for me to know the name. The documentation says it defaults to notify but its really just set by hass right? If there are multiple nameless notifiers then they'll probably be notify , notify1 , notify2 , etc. and I can't predict that, right? I think the best I can do here is change it to use config.get(CONF NAME) and default to '' if that doesn't exist. That means the debug log won't have a name in it but if they didn't give me one then that's really all I can do.
That message, that will be above the embedded content. I wonder if it makes sense to use the "description" key of the embed object for that instead. Edit: that will just be confusing, and the docs already have both keys With the line directly above it, you know that it's there.
Typo: unconfigured thanks, fixed. The per-entity config is stored in the config entry options based on the "entity id" (which is the name reported from the API), which presumably could change and break the option storage. Given that unique id is based upon targetID would it be more stable to use targetID for that config entry storage? I think that makes sense to do after YAML support is dropped in the future. Since we want to import the existing configuration, I think it makes sense to keep it as-is for now. We don't need to use dict.get the first time since we've already checked for the error key. If the user changes entity id, this list isn't updated, it seems. Will fix this when I migrate to using the unique id for the options.
Configuration parameters are not standardized and can specific to individual devices, so parameter 81 is only valid in this context for a couple of light switches. This should really be part of the "quirks" you've talked about. I don't think the core integration should ever be looking at config parameters for decision logic. You are absolutely right. I basically copied this from the ozw integration, not realizing this is device specific. We need a proper way to handle this. Thinking about this the min mired and max mired values are light dependent and should either be retrieved from the actual lights specs or be user configurable. These values will be what the light actually emits at full brightness, e.g. 2700K for the warm light. For now I removed the device specific code from the light implementation. This doesn't look correct. If cw val.value is None this will error. should be fixed now. I used round in the other places. duration and transition are already integers. If we make a change in the library, users will only get that change after a restart and then the node.values dict will be rebuilt. So changing the library shouldn't matter here. perhaps we can remove the whole lookup by iterating now that it uses the get value id from the lib ? Yeah, I can't think of a case where the direct look up would fail. This check means we require the service call to contain both white value and color temp. Is that how it should work? Service calls from the GUI with the white value slider won't work then. No, it's either color temp or white value, not both. A light which does not support color temp will only have white value Ok, so then we need to change the logic here. Should we really return here? What if the service call contains more parameters, eg brightness? yeah, otherwise it will set the white light. alternative is extra if statement for white value We need to handle multiple parameters. that is not possible, is it ? a light can't send both white value and color temp. At least, that's how I understand it. We need to handle all possible combinations. Brightness can be combined with other parameters, right? oh now I get what you mean. stupid mistake. Will fix it fixed We can remove this definition now.
I don't think user agent should be an option for the user. If that is needed something isn't right with how the integration is working against the API. Hey Martin, The problem has been that the user agent has been getting blocked resulting in authentication errors. We then change the user agent again to something that then works for a while before it is then blocked again. Last time a random user agent was implemented and then just this past week it was being blocked. Each time it is blocked, the integration stops working until the integration is fixed and then the change released in a new Home Assistant version. And we just keep on doing this. The underlying integration has now been updated to also accept a custom user agent and thus this PR to able to leverage that so that folks can provide a new user agent that then works when current one is blocked instead of having to wait. Also see for example: The current issue with myQ intermittent connectivity is apparently not related to specific user agent headers being blocked. Connections to the legacy myQ V5 infrastructure do work for a short time, get dropped due to "500-server" errors, then reconnect repeatedly in short intervals. The original agent blocking issue was successfully addressed with the update to generate a random agent. 44348 should have been closed as no longer needed. In the latest pymyq 2.0.13 update in 2021.1.1, this random agent was removed and "pymq" is now the default user agent with no non-hacking way to change it unless this PR is approved. IMO the random agent should have been retained. The focus now needs to be on rewriting the myQ integration to be compatible with the new myQ v6 architecture as described in Simply changing the user-agent in the config flow is unlikely to solve anything (unless the now default "pymq" is being blocked). Please provide evidence connections are in fact stable with a custom agent for as long as myQ v5 remains operational. bdraco - do you concur? I was getting Error 400 with the random agent. Changing to pymyq resulted in it being able to authenticate again. Error 500 is still sometimes showing up. I am not the only one who had Error 400 with the random user agent and then ended up being resolved with going to pymyq. Also see: Even with the 500 error the integration is still operational but clearly once the new API has been reverse engineered the integration would need to be updated. Thanks for pointing out issue 59. That should have been a key info link in this PR as to what it fixes. I didn't know that the random agent was causing auth failures. I had not seen that occur for my two separate myQ garage openers. I had assumed this update was in response to the 500-server errors. It's pretty bad - in the past 24 hours, my logs show 180 myQ 500-server connection drops reconnects - on average every 8 minutes. The custom agent won't solve this, but at least it should help those who have auth failures to at least connect and then complain about the 
We no longer accept YAML configuration for integrations that connect to devices or services. Instead, a configuration flow via the UI should be used. For more information about this decision see: - ADR-0007: decision - ADR-0010: decision To get started on the integration configuration, see our developer documentation: Okay thanks! I'll have a look at refactoring the integration
Any reason why this is not a binary sensor with the connection class? Because I hadn't thought of that :smile: Pulled from the PR and will open a new one with it as a binary sensor. This should be device state attributes . This isn't needed. The state attributes will be merged with the device state attributes in the Entity base class. We can remove .keys() . The keys are used by default in dict membership tests. py def timestamp ms to date(epoch ms: int) - Optional[datetime]: Please return None explicitly in the other case.
The sound mode raw attribute is only added if the power is on, maybe we want the same for dynamic eq? Probably best to just bail out with an empty dict if power is not ON . Good catch. Yes I will change that. This is the new state right? It sounds a bit weird that this is passive voice. How about set dynamic eq or just dynamic eq ? Yes true. I also had the impression that it sounds weird I just took volume mute as an example. I will change it to dynamic eq Looks unused Property has been removed
For logging we don't do f-strings, usually. Thanks, I think I actually knew that but I must've been in auto-pilot when I wrote that line. Please remove the YAML configuration possibility. It is not something we want to add to new integrations. Ah, sorry, I removed the references to YAML configuration in the docs but didn't realise we were removing the YAML configuration totally from new integrations. I'll fix now. Spelling Not sure if this was an intentional meat pun or not . Aha, unfortunately not an intentional pun. It's quite embarrassing, I thought I'd caught all the spelling mistakes. I'm mildly dyslexic, which makes programming hard; I once came back to a project two years after I'd completed it to do some upgrades and found a misspelled variable that I'd used throughout the codebase, just didn't spot it at the time. Thanks again for catching those, I'm committing the changes now. No problem! I've been playing around with this and noticed one other small error in meater-python as it relates to the cook aspect of it. I know that doesn't impact this PR but it would if cook sensors were added at some point, so I threw in a PR on that repo. Hopefully that's alright. Thanks for your work on this! Using self.name results in the device being called Meater Probe Ambient . I'm not entirely sure if just calling it Meater Probe would be an issue if multiple probes are added, I don't think so but I also only have 1 probe to test with. Since there are two sensors, isn't it useful to keep the "Ambient" label so that it is known which is measuring the ambient air temperature? There are 2 sensor entities, one for ambient and one for internal temperature, but only 1 device that the 2 entities belong to. This only changes the name of the device to Meater Probe , and the 2 entities would still be named appropriately. Hope that makes sense. Yes, the Meater Probe Ambient was incorrectly being used for the device name in this case that does make sense. thanks for the clarification Use built-in const Since we are using DataUpdateCoordinator , I believe you could inherit from CoordinatorEntity here, which provides some built-in methods that you could use. You should be able to remove the should poll , async added to hass , and async update methods as those are included in CoordinatorEntity . coordinated-single-api-poll-for-data-for-all-entities You are once again correct! Totally missed that in my initial look through the docs. I'll hopefully have some time to update this tonight. Given that a change and it all seems to be working as expected. Good job on spotting that! This can also be removed. Yep, missed that! I'm wondering if you don't want to overwrite this still. CoordinatorEntity only provides whether or not the update was successful, but you also have logic in there to see if the probe is still online. Taking this out will change the way the probes are treated when they're offline. That's totally up to you, just pointing out that this is different than the
I've always thought this was weird that udp means everything but tcp here, but I guess that is just evolution of the spec.
We no longer accept YAML configuration for integrations that connect to devices or services. Instead, a configuration flow via the UI should be used. For more information about this decision see: - ADR-0007: decision - ADR-0010: decision To get started on the integration configuration, see our developer documentation: So then it would be better to convert the caldav integration to the new configuration flow and then add this new feature? Yes, please do the refactor first. Then do another PR with the new feature.
Please use a target key instead. service-descriptions target-selector
None is the default. Would it be possible to fetch the room ID and update the config entry during setup ? When discovery works properly - host isn't set - and the roon integration uses roon id to keep track of which server it is connected to (and authorised by). The discovery packet returned by roon devices includes this id - and so the library can be efficient in reconnecting. So we do need to store it. Please do both sync calls (discovery.all and discovery.stop) in the same function and thread context. It's expensive to switch context. Don't exclude this from coverage. Don't patch the code in the config flow. Patch the library. If we need to test timeouts it's ok to patch the timeout constant only. Please make a function that iterates the APIs and stops them. Then schedule that function once on the executor. The persistent notification integration doesn't need to be set up inside the patch context manager. Side note: We usually set up the persistent notification integration in the beginning of the config flow tests to avoid a log error about missing service. It won't affect the tests of the config flow, it just cleans up the log, making it easier to troubleshoot. Understood - shall I drop this into the PR? (just aware you've already approved). Yeah, please do that. Then we'll trigger another build to hopefully get it passed the unrelated flaky test.
Can we replace this option with the system level option? config-entry-system-options-setting-default-value-of-disabled by-for-new-entity-registry-entries You are suggesting to remove this and use system option or something different? I think it could work, just it is not very intuitive for the users. Yes, it's what we've built the system level option for. Test preparation is failing, is because this is a old branch? I can rebase the target branch and then you can rebase this PR. I've rebased the target branch asuswrt-config-entries so you can rebase this PR on top of that branch.
Any reason to use the f-string rather than just reference self.home id directly? Fixed on latest commit, thanks. Shouldn't the super constructor be called first? Yes, should be fixed now. Just let core handle the conversion. Just return the current unit and value elupus both units are provided, so I was just trying to avoid any conversions. Anyway, I will change it in order to always return celsius. As above. Return current unit a d let core handle conversion. Does this need to update on add? Looks left over? bdraco no, it's not. I'm using this to transform the condition reported by Tado to a home assistant standard value. See: diff-851f046c721e3d1e7fa5b0f9948981858b92bf6e623f23d923b7b6c7add24a98R51-R56 diff-851f046c721e3d1e7fa5b0f9948981858b92bf6e623f23d923b7b6c7add24a98R185-R191 While it does work, and I'm not specifically opposed to this, I'm not sure we should be partially implementing the weather platform on the sensor platform. I'll ask for a second opinion on this. No we shouldn't use weather constants for the sensor platform. Same?
Change to: from unittest.mock import patch Thanks for the input. I've changed it to the native input. I assume hat the tests.async mock dispatcher will be obsolete in the future. I've committed the change ... lets see if it will pass I think this can all fit on a single line. This might fix the error with black. LOGGER.debug("[wizlight s] update requested", entry.data.get(CONF HOST)) Changed .... Thank you. I missed that line test form bulb time out, test form bulb offline test form bulb exception look pretty similar. Could you create a single parameterized test that covers those three cases plus ConnectionRefusedError? Something like: That would pick up coverage for the line related to ConnectionRefusedError. If the source is changed to SOURCE IMPORT, it would test both async step user and async step import, picking up another line of coverage for the test. I've received feedback in the past to not mock out methods related to the integration and instead mock out the device library. If you were to patch homeassistant.components.wiz light.wizlight would that avoid needing to patch the rest? This was also my first idea but it seems to be difficult to mock the lib because of the return value of the UDP connection. But in the future this will be the final step to prevent the big "patch stacking". I'm probably missing a key detail about the UDP connection. Could you point out which return value? Would something like this work? Great, this can work. I have to dig in deeper into that topic because a test for the light.py should also be created. But thank you for the feedback. I'm not a expert in writing tests ... but the create autospec should be the key. Async setup is no longer required and can be removed. Make this into a constant? And then use it here YAML configuration is no longer allowed for new integrations that communicate with devices ( decision) As YAML configuration is no longer allowed, this can be removed Move these to .const? Again, this should probably be removed. You should probably surround this call to wizlight with a try-except block as well just as you do in the config flow. The device may have gone offline since the config entry was created or may be unreachable for some other reason. Checking it here and returning false notifies home assistant that the entryfailed to setup. Constants would be nice for these as well Add your iot class You already implemented async update . You can use the homeassistant.update entity service ( service-homeassistantupdate entity) to force an update Put these in a dict and then you can fetch the mapping Then you can do a dict get Only update these once since they aren't expected to change Avoid a broad except handler, and only catch expected exceptions You can likely save many lines of code with entity-class-or-instance-attributes
This is not necessary (it does nothing!) That's right, but if I omit this the code does not pass, because the const NONE is never used. When NONE is selected, there is no need to create an async track time change , but not using this value at all is a no-pass don't worry, just delete this as it is unnecessary unused... So what do you suggest then? I think there should always be a cycle specified by the user so we need a new constant "NONE". Making the cycle optional is not a good idea in my opinion. But the UM does not need to do anything with it, that's why I added the "pass" in the previous version of the code (also to make sure the tests don't throw a "not used" error. In the previous revieuw you stated that I should not worry about the tests not passing and so I removed the pass section in the code. Seems like we're running in circles here. in this file you are just importing the variable which is not used... Do you program in python :) ? I'm by far not a python expert - I have a few degrees in C and Java, but the discussion is not relevant to the coding language. I think that adding an option to UM that enables the user to have a UM that does not reset automatically has significant value. There are 3 options: 1. Make cycle an optional parameter in the integration 2. Import the parameter and when async added to hass runs, make sure no async track time change is created (what I did in the previous version by adding pass ) 3. Import the parameter and do not use it If you have any better suggestion(s), please let me know - but now I've switched from 2 to 3 based on your feedback, and now 3 is not ok. We are probably getting lost in translation I'm not discussing the need for the "none" cycle, it has come up in the past in user forums the suggestion to add it and I agree with it. You only need NONE to be defined in the consts.py in order for the configuration validation to pass. BTW: we are very short of implementing option 1. (just a matter of defining none as the default cycle) and doing the proper checks
Please extract the device specific interface code and data parsing to a standalone library published on PyPI. 4-communication-with-devicesservices MartinHjelmare, done in 32b2f2d thanks - this move simplified the code a lot :) Please create the web service instance in async setup entry . Store the instance in hass.data . done in new commit asystentka-jolka improvements after first review 6214ef8 A service is only needed if we want to allow users direct access to the web service. Please don't add the service in this first PR. ok, done in commit asystentka-jolka improvements after first review 6214ef8 Please run our scaffold script to generate best practice code including config flow tests. Here it will suggest to use asyncio.gather . ok, done in commit asystentka-jolka improvements after first review 6214ef8 Please use f-strings instead string concatenation. Please only use dict.get when we don't know if the key is in the dict or not. When we know that the key is in the dict we use dict[key] . ok, done in commit asystentka-jolka improvements after first review 6214ef8 Please remove empty items. ok, done in commit asystentka-jolka improvements after first review 6214ef8 Please start with a single platform in the first PR. Just keep the sensor platform here for now. Further platforms are welcome in later PRs. ok, done in commit asystentka-jolka improvements after first review 6214ef8 Get the web service instance from hass.data here and pass it to the entity when creating that. ok, done in commit asystentka-jolka improvements after first review 6214ef8 Platforms don't support an entry unload function. The platform entity helper takes care of entry unloading and entity removal. good to know :) done 26a7843 Don't pass in hass . It will be set on the entity when the entity has been added to home assistant. This means you can access hass with self.hass , after the entity has been added to home assistant. We don't need to store the URL or the web session. What kind of measurement is this? Please set the state attribute keys explicitly in a new dict. We want to see what the keys are and their formatting. Markdown isn't supported in translation strings. Please remove all translation files except the default English translation. If we just need to ask for the host address we can do that in a single step, the user step. Please simplify the config flow. Please use the template that the scaffold script creates as a base. We can remove the config schema. It's not used. We're only raising InvalidAuth .
The MQTT integration doesn't support the number platform. What does the change here do? Sorry forgot to commit the most important bit Can this be covered by tests as well? It's covered in test run number setup with "10" and "20.5" Stale comment Unless polling is really needed, override should poll :
constants belong in const.py Thanks for tips, I moved on const.py file and upload the new code This is change to the old configuration style, I believe this is not allowed. Yes, that's correct. See: thanks for the link. We are working on changing the whole modbus configuration, but it takes some time, especially since the test harness needs to be partly rewritten.
Maybe just put this in setup since its a singleton registration. I realize there is only possibly one ConfigEntry however, so it doesn't really matter, but then again I also saw there is the same call inside of the ConfigFlow async step user , so if you move it to setup it won't be needed in both places I think. As far as I can tell, when using the config flow, async setup or async setup entry are not called before the call to async step user, so I need that call in async step user. Then, when restarting hass, I also need to register the OAuthImplementation so I need to make sure it's declared either in async setup or in async setup entry. As I don't support the yaml declaration, I chose to put that call in async setup entry. Defining it only in async setup is not enough. Am I wrong here? Yeah, that makes sense. I see what I was missing. I got this from L42 The difference may just be that in that example a configuration.yaml is needed for configuring oauth client id and client secret, and that would invoke async setup . Not the case here since its hard coded. Do you know if you actually need to call async register implementation or async get config entry implentation here? It may be sufficient to just pass OndiloOauth2Implementaiton into OndiloClient since the config flow will register itself. I think you can omit this and it will get automatically created. It was created using python3 -m script.translations develop . Should I remove it? Worst case, I guess, it will just be recreated afterwards? I believe the best practice is to subclass CoordinatorEntity when using DataUpdateCoordinator as it handles a bunch of the implementations for many methods around updating state already. Thanks, I can see this was indeed updated in the doc (it wasn't there when I first did that in August). I'll update accordingly. Optional: Consider if its worth being defensive about ensuring "data type" is found in SENSOR TYPES Alternatively: iterate over every supported SENSOR TYPE and check for it as a measure that exists in the set of measures, then create the entities just for those. (This would only work if you did the "id lookup" pattern below and made the sensor data indexed by measure type) Done, thanks. I see this is following the pattern in the docs, however I was curious what would happen if the API started returning devices in a different order if a new device was created and added to the front of the list. Is this a non-issue? I realize this is beyond your component. I was imagining some kind of "id lookup" would be more resilient to problems than an index lookup, but not sure how real of a problem that is. Interesting point thanks. As a JSON object is unordered, this could indeed happen, although I doubt Ondilo would change that order. Anyway, I've taken that into account and changed the behavior to look for the "data type" field. And I did the same for the pools and relied on the Ondilo pool Id. Consider if it makes sense to have a single method blocking m
